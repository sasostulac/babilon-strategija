{"version":3,"file":"babylonjs.loaders.min.js","mappings":"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","sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/webpack/runtime/create fake namespace object","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/flowGraphGLTFDataProvider.ts","webpack://LOADERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/pbrMaterialLoadingAdapter.ts","webpack://LOADERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/openPbrMaterialLoadingAdapter.ts","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/webpack/runtime/compat get default export","webpack://LOADERS/webpack/runtime/define property getters","webpack://LOADERS/webpack/runtime/global","webpack://LOADERS/webpack/runtime/hasOwnProperty shorthand","webpack://LOADERS/webpack/runtime/make namespace object","webpack://LOADERS/../../../dev/loaders/src/BVH/bvhLoader.ts","webpack://LOADERS/../../../dev/loaders/src/BVH/bvhFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/BVH/bvhFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFValidation.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/glTFFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoaderInterfaces.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoaderUtils.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFBinaryExtension.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/1.0/glTFMaterialsCommonExtension.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/glTFLoaderExtensionRegistry.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/glTFLoader.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_area.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_image_based.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_meshopt_compression.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_webp.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_texture_avif.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/EXT_lights_ies.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_ior.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_volume.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_materials_diffuse_roughness.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_mesh_quantization.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_basisu.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_xmp_json_ld.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.data.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_animation_pointer.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_lod.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_minecraftMesh.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/MSFT_sRGBFactors.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_visibility.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_selectability.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/KHR_node_hoverability.ts","webpack://LOADERS/../../../dev/loaders/src/glTF/2.0/Extensions/ExtrasAsMetadata.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/mtlFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/solidParser.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/STL/stlFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/STL/stlFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/SPLAT/splatFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/SPLAT/sog.ts","webpack://LOADERS/../../../dev/loaders/src/SPLAT/splatFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/SPLAT/spz.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-bvhFileLoader.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-glTF.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-glTF1.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-glTF2.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-objFileLoader.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-stlFileLoader.ts","webpack://LOADERS/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","import type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { FlowGraphBlock } from \"core/FlowGraph/flowGraphBlock\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\n\n/**\n * a configuration interface for this block\n */\nexport interface IFlowGraphGLTFDataProviderBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * the glTF object to provide data from\n     */\n    glTF: IGLTF;\n}\n\n/**\n * a glTF-based FlowGraph block that provides arrays with babylon object, based on the glTF tree\n * Can be used, for example, to get animation index from a glTF animation\n */\nexport class FlowGraphGLTFDataProvider extends FlowGraphBlock {\n    /**\n     * Output: an array of animation groups\n     * Corresponds directly to the glTF animations array\n     */\n    public readonly animationGroups: FlowGraphDataConnection<AnimationGroup[]>;\n\n    /**\n     * Output an array of (Transform) nodes\n     * Corresponds directly to the glTF nodes array\n     */\n    public readonly nodes: FlowGraphDataConnection<TransformNode[]>;\n\n    constructor(config: IFlowGraphGLTFDataProviderBlockConfiguration) {\n        super();\n        const glTF = config.glTF;\n        const animationGroups = glTF.animations?.map((a) => a._babylonAnimationGroup) || [];\n        this.animationGroups = this.registerDataOutput(\"animationGroups\", RichTypeAny, animationGroups);\n        const nodes = glTF.nodes?.map((n) => n._babylonTransformNode) || [];\n        this.nodes = this.registerDataOutput(\"nodes\", RichTypeAny, nodes);\n    }\n\n    public override getClassName(): string {\n        return \"FlowGraphGLTFDataProvider\";\n    }\n}\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","import type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { IMaterialLoadingAdapter } from \"./materialLoadingAdapter\";\r\n\r\n/**\r\n * Material Loading Adapter for PBR materials that provides a unified OpenPBR-like interface.\r\n */\r\nexport class PBRMaterialLoadingAdapter implements IMaterialLoadingAdapter {\r\n    private _material: PBRMaterial;\r\n\r\n    /**\r\n     * Creates a new instance of the PBRMaterialLoadingAdapter.\r\n     * @param material - The PBR material to adapt.\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material as PBRMaterial;\r\n        this._material.enableSpecularAntiAliasing = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying material\r\n     */\r\n    public get material(): PBRMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Whether the material should be treated as unlit\r\n     */\r\n    public get isUnlit(): boolean {\r\n        return this._material.unlit;\r\n    }\r\n\r\n    /**\r\n     * Sets whether the material should be treated as unlit\r\n     */\r\n    public set isUnlit(value: boolean) {\r\n        this._material.unlit = value;\r\n    }\r\n\r\n    // ========================================\r\n    // CULLING PROPERTIES\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets whether back face culling is enabled.\r\n     * @param value True to enable back face culling\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        this._material.backFaceCulling = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether back face culling is enabled.\r\n     * @returns True if back face culling is enabled\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._material.backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Sets whether two-sided lighting is enabled.\r\n     * @param value True to enable two-sided lighting\r\n     */\r\n    public set twoSidedLighting(value: boolean) {\r\n        this._material.twoSidedLighting = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether two-sided lighting is enabled.\r\n     * @returns True if two-sided lighting is enabled\r\n     */\r\n    public get twoSidedLighting(): boolean {\r\n        return this._material.twoSidedLighting;\r\n    }\r\n\r\n    // ========================================\r\n    // ALPHA PROPERTIES\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the alpha cutoff value for alpha testing.\r\n     * @param value The alpha cutoff threshold (0-1)\r\n     */\r\n    public set alphaCutOff(value: number) {\r\n        this._material.alphaCutOff = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha cutoff value.\r\n     * @returns The alpha cutoff threshold (0-1)\r\n     */\r\n    public get alphaCutOff(): number {\r\n        return this._material.alphaCutOff;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use alpha from the albedo texture.\r\n     * @param value True to use alpha from albedo texture\r\n     */\r\n    public set useAlphaFromBaseColorTexture(value: boolean) {\r\n        this._material.useAlphaFromAlbedoTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether alpha is used from the albedo texture.\r\n     * @returns True if using alpha from albedo texture\r\n     */\r\n    public get useAlphaFromBaseColorTexture(): boolean {\r\n        return this._material.useAlphaFromAlbedoTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the transparency is treated as alpha coverage.\r\n     */\r\n    public get transparencyAsAlphaCoverage(): boolean {\r\n        return this._material.useRadianceOverAlpha || this._material.useSpecularOverAlpha;\r\n    }\r\n\r\n    /**\r\n     * Sets/Gets whether the transparency is treated as alpha coverage\r\n     */\r\n    public set transparencyAsAlphaCoverage(value: boolean) {\r\n        this._material.useRadianceOverAlpha = !value;\r\n        this._material.useSpecularOverAlpha = !value;\r\n    }\r\n\r\n    // ========================================\r\n    // BASE PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the base color of the material (mapped to PBR albedoColor).\r\n     * @param value The base color as a Color3\r\n     */\r\n    public set baseColor(value: Color3) {\r\n        this._material.albedoColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base color of the material.\r\n     * @returns The base color as a Color3\r\n     */\r\n    public get baseColor(): Color3 {\r\n        return this._material.albedoColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the base color texture of the material (mapped to PBR albedoTexture).\r\n     * @param value The base color texture or null\r\n     */\r\n    public set baseColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.albedoTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base color texture of the material.\r\n     * @returns The base color texture or null\r\n     */\r\n    public get baseColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.albedoTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the base diffuse roughness of the material.\r\n     * @param value The diffuse roughness value (0-1)\r\n     */\r\n    public set baseDiffuseRoughness(value: number) {\r\n        this._material.baseDiffuseRoughness = value;\r\n        if (value > 0) {\r\n            this._material.brdf.baseDiffuseModel = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the base diffuse roughness of the material.\r\n     * @returns The diffuse roughness value (0-1), defaults to 0 if not set\r\n     */\r\n    public get baseDiffuseRoughness(): number {\r\n        return this._material.baseDiffuseRoughness ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the base diffuse roughness texture of the material.\r\n     * @param value The diffuse roughness texture or null\r\n     */\r\n    public set baseDiffuseRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.baseDiffuseRoughnessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base diffuse roughness texture of the material.\r\n     * @returns The diffuse roughness texture or null\r\n     */\r\n    public get baseDiffuseRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.baseDiffuseRoughnessTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the base metalness value of the material (mapped to PBR metallic).\r\n     * @param value The metalness value (0-1)\r\n     */\r\n    public set baseMetalness(value: number) {\r\n        this._material.metallic = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base metalness value of the material.\r\n     * @returns The metalness value (0-1), defaults to 1 if not set\r\n     */\r\n    public get baseMetalness(): number {\r\n        return this._material.metallic ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the base metalness texture of the material (mapped to PBR metallicTexture).\r\n     * @param value The metalness texture or null\r\n     */\r\n    public set baseMetalnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.metallicTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base metalness texture of the material.\r\n     * @returns The metalness texture or null\r\n     */\r\n    public get baseMetalnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.metallicTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use roughness from the metallic texture's green channel.\r\n     * Also disables using roughness from the alpha channel when enabled.\r\n     * @param value True to use green channel for roughness\r\n     */\r\n    public set useRoughnessFromMetallicTextureGreen(value: boolean) {\r\n        this._material.useRoughnessFromMetallicTextureGreen = value;\r\n        this._material.useRoughnessFromMetallicTextureAlpha = !value;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use metalness from the metallic texture's blue channel.\r\n     * @param value True to use blue channel for metalness\r\n     */\r\n    public set useMetallicFromMetallicTextureBlue(value: boolean) {\r\n        this._material.useMetallnessFromMetallicTextureBlue = value;\r\n    }\r\n\r\n    // ========================================\r\n    // SPECULAR PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures specular properties and optionally enables OpenPBR BRDF model for edge color support.\r\n     * @param enableEdgeColor Whether to enable OpenPBR BRDF models for edge color support\r\n     */\r\n    public enableSpecularEdgeColor(enableEdgeColor: boolean = false): void {\r\n        if (enableEdgeColor) {\r\n            this._material.brdf.dielectricSpecularModel = Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR;\r\n            this._material.brdf.conductorSpecularModel = Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the specular weight (mapped to PBR metallicF0Factor).\r\n     * @param value The specular weight value\r\n     */\r\n    public set specularWeight(value: number) {\r\n        this._material.metallicF0Factor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular weight.\r\n     * @returns The specular weight value, defaults to 1 if not set\r\n     */\r\n    public get specularWeight(): number {\r\n        return this._material.metallicF0Factor ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular weight texture (mapped to PBR metallicReflectanceTexture).\r\n     * Configures the material to use only metalness from this texture when set.\r\n     * @param value The specular weight texture or null\r\n     */\r\n    public set specularWeightTexture(value: Nullable<BaseTexture>) {\r\n        if (value) {\r\n            this._material.metallicReflectanceTexture = value;\r\n            this._material.useOnlyMetallicFromMetallicReflectanceTexture = true;\r\n        } else {\r\n            this._material.metallicReflectanceTexture = null;\r\n            this._material.useOnlyMetallicFromMetallicReflectanceTexture = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the specular weight texture.\r\n     * @returns The specular weight texture or null\r\n     */\r\n    public get specularWeightTexture(): Nullable<BaseTexture> {\r\n        return this._material.metallicReflectanceTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular color (mapped to PBR metallicReflectanceColor).\r\n     * @param value The specular color as a Color3\r\n     */\r\n    public set specularColor(value: Color3) {\r\n        this._material.metallicReflectanceColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color.\r\n     * @returns The specular color as a Color3\r\n     */\r\n    public get specularColor(): Color3 {\r\n        return this._material.metallicReflectanceColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular color texture (mapped to PBR reflectanceTexture).\r\n     * @param value The specular color texture or null\r\n     */\r\n    public set specularColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.reflectanceTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color texture.\r\n     * @returns The specular color texture or null\r\n     */\r\n    public get specularColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.reflectanceTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular roughness (mapped to PBR roughness).\r\n     * @param value The roughness value (0-1)\r\n     */\r\n    public set specularRoughness(value: number) {\r\n        this._material.roughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness.\r\n     * @returns The roughness value (0-1), defaults to 1 if not set\r\n     */\r\n    public get specularRoughness(): number {\r\n        return this._material.roughness ?? 1;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular roughness texture.\r\n     * Note: PBR uses the same texture for both metallic and roughness,\r\n     * so this only sets the texture if no base metalness texture exists.\r\n     * @param value The roughness texture or null\r\n     */\r\n    public set specularRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        // PBR uses the same texture for both metallic and roughness\r\n        if (!this.baseMetalnessTexture) {\r\n            this._material.metallicTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness texture.\r\n     * @returns The roughness texture (same as metallic texture for PBR) or null\r\n     */\r\n    public get specularRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.metallicTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular index of refraction (mapped to PBR indexOfRefraction).\r\n     * @param value The IOR value\r\n     */\r\n    public set specularIor(value: number) {\r\n        this._material.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular index of refraction.\r\n     * @returns The IOR value\r\n     */\r\n    public get specularIor(): number {\r\n        return this._material.indexOfRefraction;\r\n    }\r\n\r\n    // ========================================\r\n    // EMISSION PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the emission color (mapped to PBR emissiveColor).\r\n     * @param value The emission color as a Color3\r\n     */\r\n    public set emissionColor(value: Color3) {\r\n        this._material.emissiveColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission color.\r\n     * @returns The emission color as a Color3\r\n     */\r\n    public get emissionColor(): Color3 {\r\n        return this._material.emissiveColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the emission luminance/intensity (mapped to PBR emissiveIntensity).\r\n     * @param value The emission intensity value\r\n     */\r\n    public set emissionLuminance(value: number) {\r\n        this._material.emissiveIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission luminance/intensity.\r\n     * @returns The emission intensity value\r\n     */\r\n    public get emissionLuminance(): number {\r\n        return this._material.emissiveIntensity;\r\n    }\r\n\r\n    /**\r\n     * Sets the emission color texture (mapped to PBR emissiveTexture).\r\n     * @param value The emission texture or null\r\n     */\r\n    public set emissionColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.emissiveTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission color texture.\r\n     * @returns The emission texture or null\r\n     */\r\n    public get emissionColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.emissiveTexture;\r\n    }\r\n\r\n    // ========================================\r\n    // AMBIENT OCCLUSION\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the ambient occlusion texture (mapped to PBR ambientTexture).\r\n     * Automatically enables grayscale mode when set.\r\n     * @param value The ambient occlusion texture or null\r\n     */\r\n    public set ambientOcclusionTexture(value: Nullable<BaseTexture>) {\r\n        this._material.ambientTexture = value;\r\n        if (value) {\r\n            this._material.useAmbientInGrayScale = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient occlusion texture.\r\n     * @returns The ambient occlusion texture or null\r\n     */\r\n    public get ambientOcclusionTexture(): Nullable<BaseTexture> {\r\n        return this._material.ambientTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the ambient occlusion texture strength.\r\n     * @param value The strength value (typically 0-1)\r\n     */\r\n    public set ambientOcclusionTextureStrength(value: number) {\r\n        this._material.ambientTextureStrength = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient occlusion texture strength.\r\n     * @returns The strength value, defaults to 1.0 if not set\r\n     */\r\n    public get ambientOcclusionTextureStrength(): number {\r\n        return this._material.ambientTextureStrength ?? 1.0;\r\n    }\r\n\r\n    // ========================================\r\n    // COAT PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures clear coat for PBR material.\r\n     * Enables clear coat and sets up proper configuration.\r\n     */\r\n    public configureCoat(): void {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.useRoughnessFromMainTexture = false;\r\n        this._material.clearCoat.remapF0OnInterfaceChange = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat weight (mapped to PBR clearCoat.intensity).\r\n     * Automatically enables clear coat.\r\n     * @param value The coat weight value (0-1)\r\n     */\r\n    public set coatWeight(value: number) {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat weight.\r\n     * @returns The coat weight value\r\n     */\r\n    public get coatWeight(): number {\r\n        return this._material.clearCoat.intensity;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat weight texture (mapped to PBR clearCoat.texture).\r\n     * Automatically enables clear coat.\r\n     * @param value The coat weight texture or null\r\n     */\r\n    public set coatWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.texture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat weight texture.\r\n     * @returns The coat weight texture or null\r\n     */\r\n    public get coatWeightTexture(): Nullable<BaseTexture> {\r\n        return this._material.clearCoat.texture;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat color (mapped to PBR clearCoat.tintColor).\r\n     * @param value The coat tint color as a Color3\r\n     */\r\n    public set coatColor(value: Color3) {\r\n        this._material.clearCoat.isTintEnabled = value != Color3.White();\r\n        this._material.clearCoat.tintColor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat color texture (mapped to PBR clearCoat.tintTexture).\r\n     * @param value The coat color texture or null\r\n     */\r\n    public set coatColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.clearCoat.tintTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness (mapped to PBR clearCoat.roughness).\r\n     * Automatically enables clear coat.\r\n     * @param value The coat roughness value (0-1)\r\n     */\r\n    public set coatRoughness(value: number) {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.roughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness.\r\n     * @returns The coat roughness value, defaults to 0 if not set\r\n     */\r\n    public get coatRoughness(): number {\r\n        return this._material.clearCoat.roughness ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness texture (mapped to PBR clearCoat.textureRoughness).\r\n     * Automatically enables clear coat and disables using roughness from main texture.\r\n     * @param value The coat roughness texture or null\r\n     */\r\n    public set coatRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.useRoughnessFromMainTexture = false;\r\n        this._material.clearCoat.textureRoughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness texture.\r\n     * @returns The coat roughness texture or null\r\n     */\r\n    public get coatRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.clearCoat.textureRoughness;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat index of refraction (IOR).\r\n     */\r\n    public set coatIor(value: number) {\r\n        this._material.clearCoat.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat darkening value.\r\n     * Note: PBR doesn't have a direct coat darkening property, so this is a no-op.\r\n     * @param value The coat darkening value (ignored for PBR)\r\n     */\r\n    public set coatDarkening(value: number) {\r\n        // PBR doesn't have a coat darkening property\r\n    }\r\n\r\n    /**\r\n     * Sets the coat darkening texture\r\n     * @param value The coat darkening texture or null\r\n     */\r\n    public set coatDarkeningTexture(value: Nullable<BaseTexture>) {\r\n        // PBR doesn't have a coat darkening property\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness anisotropy.\r\n     * Note: PBR clearCoat doesn't support anisotropy yet, so this is a placeholder.\r\n     * @param value The coat anisotropy intensity value (currently ignored)\r\n     */\r\n    public set coatRoughnessAnisotropy(value: number) {\r\n        // TODO: Implement when PBR clearCoat anisotropy becomes available\r\n        // this._material.clearCoat.anisotropy = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness anisotropy.\r\n     * Note: PBR clearCoat doesn't support anisotropy yet, so this returns 0.\r\n     * @returns Currently returns 0 as clearCoat anisotropy is not yet available\r\n     */\r\n    public get coatRoughnessAnisotropy(): number {\r\n        // TODO: Implement when PBR clearCoat anisotropy becomes available\r\n        // return this._material.clearCoat.anisotropy ?? 0;\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat tangent angle for anisotropy.\r\n     * Note: PBR clearCoat doesn't support anisotropy yet, so this is a placeholder.\r\n     * @param value The coat anisotropy rotation angle in radians (currently ignored)\r\n     */\r\n    public set geometryCoatTangentAngle(value: number) {\r\n        // TODO: Implement when PBR clearCoat anisotropy becomes available\r\n        // this._material.clearCoat.anisotropyAngle = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat tangent texture for anisotropy.\r\n     * Note: PBR clearCoat doesn't support anisotropy textures yet, so this is a placeholder.\r\n     * @param value The coat anisotropy texture (currently ignored)\r\n     */\r\n    public set geometryCoatTangentTexture(value: Nullable<BaseTexture>) {\r\n        // TODO: Implement when PBR clearCoat anisotropy becomes available\r\n        // this._material.clearCoat.anisotropyTangentTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat tangent texture for anisotropy.\r\n     * Note: PBR clearCoat doesn't support anisotropy textures yet, so this returns null.\r\n     * @returns Currently returns null as clearCoat anisotropy is not yet available\r\n     */\r\n    public get geometryCoatTangentTexture(): Nullable<BaseTexture> {\r\n        // TODO: Implement when PBR clearCoat anisotropy becomes available\r\n        // return this._material.clearCoat.anisotropyTangentTexture;\r\n        return null;\r\n    }\r\n\r\n    // ========================================\r\n    // TRANSMISSION LAYER\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the transmission weight (mapped to PBR subSurface.refractionIntensity).\r\n     * Enables refraction when value \\> 0.\r\n     * @param value The transmission weight value (0-1)\r\n     */\r\n    public set transmissionWeight(value: number) {\r\n        this._material.subSurface.isRefractionEnabled = value > 0;\r\n        this._material.subSurface.refractionIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the transmission weight.\r\n     * @returns The transmission weight value\r\n     */\r\n    public get transmissionWeight(): number {\r\n        return this._material.subSurface.refractionIntensity;\r\n    }\r\n\r\n    /**\r\n     * Sets the transmission weight texture (mapped to PBR subSurface.refractionIntensityTexture).\r\n     * Automatically enables refraction and glTF-style textures.\r\n     * @param value The transmission weight texture or null\r\n     */\r\n    public set transmissionWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.subSurface.isRefractionEnabled = true;\r\n        this._material.subSurface.refractionIntensityTexture = value;\r\n        this._material.subSurface.useGltfStyleTextures = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the attenuation distance for volume scattering.\r\n     * @param value The attenuation distance value\r\n     */\r\n    public set transmissionDepth(value: number) {\r\n        this._material.subSurface.tintColorAtDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the attenuation color (mapped to PBR subSurface.tintColor).\r\n     * @param value The attenuation color as a Color3\r\n     */\r\n    public set transmissionColor(value: Color3) {\r\n        this._material.subSurface.tintColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the transmission dispersion Abbe number.\r\n     * @param value The Abbe number value\r\n     */\r\n    public set transmissionDispersionAbbeNumber(value: number) {\r\n        if (value > 0) {\r\n            this._material.subSurface.isDispersionEnabled = true;\r\n            this._material.subSurface.dispersion = 20.0 / value;\r\n        } else {\r\n            this._material.subSurface.isDispersionEnabled = false;\r\n            this._material.subSurface.dispersion = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Configures transmission for thin-surface transmission (KHR_materials_transmission).\r\n     * Sets up the material for proper thin-surface transmission behavior.\r\n     */\r\n    public configureTransmission(): void {\r\n        // Since this extension models thin-surface transmission only, we must make IOR = 1.0\r\n        this._material.subSurface.volumeIndexOfRefraction = 1.0;\r\n        // Albedo colour will tint transmission.\r\n        this._material.subSurface.useAlbedoToTintRefraction = true;\r\n        this._material.subSurface.minimumThickness = 0.0;\r\n        this._material.subSurface.maximumThickness = 0.0;\r\n    }\r\n\r\n    // ========================================\r\n    // VOLUME PROPERTIES\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the thickness texture (mapped to PBR subSurface.thicknessTexture).\r\n     * Automatically enables refraction.\r\n     * @param value The thickness texture or null\r\n     */\r\n    public set volumeThicknessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.subSurface.thicknessTexture = value;\r\n        this._material.subSurface.useGltfStyleTextures = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness factor (mapped to PBR subSurface.maximumThickness).\r\n     * Automatically enables refraction.\r\n     * @param value The thickness value\r\n     */\r\n    public set volumeThickness(value: number) {\r\n        this._material.subSurface.minimumThickness = 0.0;\r\n        this._material.subSurface.maximumThickness = value;\r\n        this._material.subSurface.useThicknessAsDepth = true;\r\n        if (value > 0) {\r\n            this._material.subSurface.volumeIndexOfRefraction = this._material.indexOfRefraction;\r\n        }\r\n    }\r\n\r\n    // ========================================\r\n    // SUBSURFACE PROPERTIES (Subsurface Scattering)\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures subsurface properties for PBR material\r\n     */\r\n    public configureSubsurface(): void {\r\n        this._material.subSurface.useGltfStyleTextures = true;\r\n\r\n        // Since this extension models thin-surface transmission only, we must make the\r\n        // internal IOR == 1.0 and set the thickness to 0.\r\n        this._material.subSurface.volumeIndexOfRefraction = 1.0;\r\n        this._material.subSurface.minimumThickness = 0.0;\r\n        this._material.subSurface.maximumThickness = 0.0;\r\n\r\n        // Tint color will be used for transmission.\r\n        this._material.subSurface.useAlbedoToTintTranslucency = false;\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface weight\r\n     */\r\n    public set subsurfaceWeight(value: number) {\r\n        this._material.subSurface.isTranslucencyEnabled = value > 0;\r\n        this._material.subSurface.translucencyIntensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the subsurface weight\r\n     * @returns The subsurface weight value\r\n     */\r\n    public get subsurfaceWeight(): number {\r\n        return this._material.subSurface.isTranslucencyEnabled ? this._material.subSurface.translucencyIntensity : 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface weight texture\r\n     */\r\n    public set subsurfaceWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.subSurface.translucencyIntensityTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface color.\r\n     * @param value The subsurface tint color as a Color3\r\n     */\r\n    public set subsurfaceColor(value: Color3) {\r\n        this._material.subSurface.tintColor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface color texture.\r\n     * @param value The subsurface tint texture or null\r\n     */\r\n    public set subsurfaceColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.subSurface.translucencyColorTexture = value;\r\n    }\r\n\r\n    // ========================================\r\n    // FUZZ LAYER (Sheen)\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures sheen for PBR material.\r\n     * Enables sheen and sets up proper configuration.\r\n     */\r\n    public configureFuzz(): void {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.useRoughnessFromMainTexture = false;\r\n        this._material.sheen.albedoScaling = true;\r\n    }\r\n\r\n    /**\r\n     * Sets the sheen weight (mapped to PBR sheen.intensity).\r\n     * Automatically enables sheen.\r\n     * @param value The sheen weight value\r\n     */\r\n    public set fuzzWeight(value: number) {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the sheen color (mapped to PBR sheen.color).\r\n     * Automatically enables sheen.\r\n     * @param value The sheen color as a Color3\r\n     */\r\n    public set fuzzColor(value: Color3) {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.color = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the sheen color texture (mapped to PBR sheen.texture).\r\n     * Automatically enables sheen.\r\n     * @param value The sheen color texture or null\r\n     */\r\n    public set fuzzColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.texture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the sheen roughness (mapped to PBR sheen.roughness).\r\n     * Automatically enables sheen.\r\n     * @param value The sheen roughness value (0-1)\r\n     */\r\n    public set fuzzRoughness(value: number) {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.roughness = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the sheen roughness texture (mapped to PBR sheen.textureRoughness).\r\n     * Automatically enables sheen.\r\n     * @param value The sheen roughness texture or null\r\n     */\r\n    public set fuzzRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.sheen.isEnabled = true;\r\n        this._material.sheen.textureRoughness = value;\r\n    }\r\n\r\n    // ========================================\r\n    // ANISOTROPY\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the specular roughness anisotropy (mapped to PBR anisotropy.intensity).\r\n     * Automatically enables anisotropy.\r\n     * @param value The anisotropy intensity value\r\n     */\r\n    public set specularRoughnessAnisotropy(value: number) {\r\n        this._material.anisotropy.isEnabled = true;\r\n        this._material.anisotropy.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness anisotropy.\r\n     * @returns The anisotropy intensity value\r\n     */\r\n    public get specularRoughnessAnisotropy(): number {\r\n        return this._material.anisotropy.intensity;\r\n    }\r\n\r\n    /**\r\n     * Sets the anisotropy rotation (mapped to PBR anisotropy.angle).\r\n     * Automatically enables anisotropy.\r\n     * @param value The anisotropy rotation angle in radians\r\n     */\r\n    public set geometryTangentAngle(value: number) {\r\n        this._material.anisotropy.isEnabled = true;\r\n        this._material.anisotropy.angle = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry tangent texture (mapped to PBR anisotropy.texture).\r\n     * Automatically enables anisotropy.\r\n     * @param value The anisotropy texture or null\r\n     */\r\n    public set geometryTangentTexture(value: Nullable<BaseTexture>) {\r\n        this._material.anisotropy.isEnabled = true;\r\n        this._material.anisotropy.texture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry tangent texture.\r\n     * @returns The anisotropy texture or null\r\n     */\r\n    public get geometryTangentTexture(): Nullable<BaseTexture> {\r\n        return this._material.anisotropy.texture;\r\n    }\r\n\r\n    /**\r\n     * Configures glTF-style anisotropy for the material.\r\n     * Note: PBR materials don't need this configuration, so this is a no-op.\r\n     * @param useGltfStyle Whether to use glTF-style anisotropy (ignored for PBR)\r\n     */\r\n    public configureGltfStyleAnisotropy(useGltfStyle: boolean = true): void {\r\n        // PBR materials don't need this configuration\r\n    }\r\n\r\n    // ========================================\r\n    // THIN FILM IRIDESCENCE\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the iridescence weight (mapped to PBR iridescence.intensity).\r\n     * Automatically enables iridescence.\r\n     * @param value The iridescence intensity value\r\n     */\r\n    public set thinFilmWeight(value: number) {\r\n        this._material.iridescence.isEnabled = value > 0;\r\n        this._material.iridescence.intensity = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the iridescence IOR (mapped to PBR iridescence.indexOfRefraction).\r\n     * @param value The iridescence IOR value\r\n     */\r\n    public set thinFilmIor(value: number) {\r\n        this._material.iridescence.indexOfRefraction = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the iridescence thickness minimum (mapped to PBR iridescence.minimumThickness).\r\n     * @param value The minimum thickness value in nanometers\r\n     */\r\n    public set thinFilmThicknessMinimum(value: number) {\r\n        this._material.iridescence.minimumThickness = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the iridescence thickness maximum (mapped to PBR iridescence.maximumThickness).\r\n     * @param value The maximum thickness value in nanometers\r\n     */\r\n    public set thinFilmThicknessMaximum(value: number) {\r\n        this._material.iridescence.maximumThickness = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film weight texture (mapped to PBR iridescence.texture).\r\n     * @param value The thin film weight texture or null\r\n     */\r\n    public set thinFilmWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.iridescence.texture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the iridescence thickness texture (mapped to PBR iridescence.thicknessTexture).\r\n     * @param value The iridescence thickness texture or null\r\n     */\r\n    public set thinFilmThicknessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.iridescence.thicknessTexture = value;\r\n    }\r\n\r\n    // ========================================\r\n    // DISPERSION\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the transmission dispersion value.\r\n     * Note: PBR doesn't have direct dispersion support, so this stores it as metadata.\r\n     * @param value The dispersion value (stored as metadata)\r\n     */\r\n    public set transmissionDispersion(value: number) {\r\n        // PBR doesn't have a direct dispersion property, this would need custom shader modification\r\n        // For now, we'll store it as metadata\r\n        (this._material as any)._dispersion = value;\r\n    }\r\n\r\n    // ========================================\r\n    // UNLIT MATERIALS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets whether the material is unlit.\r\n     * @param value True to make the material unlit\r\n     */\r\n    public set unlit(value: boolean) {\r\n        this._material.unlit = value;\r\n    }\r\n\r\n    // ========================================\r\n    // GEOMETRY PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the geometry opacity (mapped to PBR alpha).\r\n     * @param value The opacity value (0-1)\r\n     */\r\n    public set geometryOpacity(value: number) {\r\n        this._material.alpha = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry opacity.\r\n     * @returns The opacity value (0-1)\r\n     */\r\n    public get geometryOpacity(): number {\r\n        return this._material.alpha;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry normal texture (mapped to PBR bumpTexture).\r\n     * Also forces irradiance computation in fragment shader for better lighting.\r\n     * @param value The normal texture or null\r\n     */\r\n    public set geometryNormalTexture(value: Nullable<BaseTexture>) {\r\n        this._material.bumpTexture = value;\r\n        this._material.forceIrradianceInFragment = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry normal texture.\r\n     * @returns The normal texture or null\r\n     */\r\n    public get geometryNormalTexture(): Nullable<BaseTexture> {\r\n        return this._material.bumpTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the normal map inversions for the material.\r\n     * @param invertX Whether to invert the normal map on the X axis\r\n     * @param invertY Whether to invert the normal map on the Y axis\r\n     */\r\n    public setNormalMapInversions(invertX: boolean, invertY: boolean): void {\r\n        this._material.invertNormalMapX = invertX;\r\n        this._material.invertNormalMapY = invertY;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry coat normal texture (mapped to PBR clearCoat.bumpTexture).\r\n     * Automatically enables clear coat.\r\n     * @param value The coat normal texture or null\r\n     */\r\n    public set geometryCoatNormalTexture(value: Nullable<BaseTexture>) {\r\n        this._material.clearCoat.isEnabled = true;\r\n        this._material.clearCoat.bumpTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry coat normal texture.\r\n     * @returns The coat normal texture or null\r\n     */\r\n    public get geometryCoatNormalTexture(): Nullable<BaseTexture> {\r\n        return this._material.clearCoat.bumpTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry coat normal texture scale.\r\n     * @param value The scale value for the coat normal texture\r\n     */\r\n    public set geometryCoatNormalTextureScale(value: number) {\r\n        if (this._material.clearCoat.bumpTexture) {\r\n            this._material.clearCoat.bumpTexture.level = value;\r\n        }\r\n    }\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","import type { IObjectInfo, IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\r\n\r\n/**\r\n * Adding an exception here will break traversing through the glTF object tree.\r\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\r\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\r\n */\r\nexport const OptionalPathExceptionsList: {\r\n    regex: RegExp;\r\n}[] = [\r\n    {\r\n        // get the node as object when reading an extension\r\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\r\n    },\r\n];\r\n\r\n/**\r\n * A converter that takes a glTF Object Model JSON Pointer\r\n * and transforms it into an ObjectAccessorContainer, allowing\r\n * objects referenced in the glTF to be associated with their\r\n * respective Babylon.js objects.\r\n */\r\nexport class GLTFPathToObjectConverter<T, BabylonType, BabylonValue> implements IPathToObjectConverter<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n    public constructor(\r\n        private _gltf: IGLTF,\r\n        private _infoTree: any\r\n    ) {}\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     * - \"/nodes.length\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     *\r\n     * @param path The path to convert\r\n     * @returns The object and info associated with the path\r\n     */\r\n    public convert(path: string): IObjectInfo<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n        let objectTree: any = this._gltf;\r\n        let infoTree: any = this._infoTree;\r\n        let target: any = undefined;\r\n\r\n        if (!path.startsWith(\"/\")) {\r\n            throw new Error(\"Path must start with a /\");\r\n        }\r\n        const parts = path.split(\"/\");\r\n        parts.shift();\r\n\r\n        //if the last part has \".length\" in it, separate that as an extra part\r\n        if (parts[parts.length - 1].includes(\".length\")) {\r\n            const lastPart = parts[parts.length - 1];\r\n            const split = lastPart.split(\".\");\r\n            parts.pop();\r\n            parts.push(...split);\r\n        }\r\n\r\n        let ignoreObjectTree = false;\r\n\r\n        for (const part of parts) {\r\n            const isLength = part === \"length\";\r\n            if (isLength && !infoTree.__array__) {\r\n                throw new Error(`Path ${path} is invalid`);\r\n            }\r\n            if (infoTree.__ignoreObjectTree__) {\r\n                ignoreObjectTree = true;\r\n            }\r\n            if (infoTree.__array__ && !isLength) {\r\n                infoTree = infoTree.__array__;\r\n            } else {\r\n                infoTree = infoTree[part];\r\n                if (!infoTree) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n            }\r\n            if (!ignoreObjectTree) {\r\n                if (objectTree === undefined) {\r\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\r\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\r\n                    if (!exception) {\r\n                        throw new Error(`Path ${path} is invalid`);\r\n                    }\r\n                } else if (!isLength) {\r\n                    objectTree = objectTree?.[part];\r\n                }\r\n            }\r\n\r\n            if (infoTree.__target__ || isLength) {\r\n                target = objectTree;\r\n            }\r\n        }\r\n\r\n        return {\r\n            object: target,\r\n            info: infoTree,\r\n        };\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { IAnimation, ICamera, IGLTF, IKHRLightsPunctual_Light, IMaterial, IMesh, INode } from \"../glTFLoaderInterfaces\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport type { Color3 } from \"core/Maths/math.color\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport type { Light } from \"core/Lights/light\";\nimport type { Nullable } from \"core/types\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport type { IEXTLightsImageBased_LightImageBased } from \"babylonjs-gltf2interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IInterpolationPropertyInfo, IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Mesh } from \"core/Meshes/mesh\";\n\nexport interface IGLTFObjectModelTree {\n    cameras: IGLTFObjectModelTreeCamerasObject;\n    nodes: IGLTFObjectModelTreeNodesObject;\n    materials: IGLTFObjectModelTreeMaterialsObject;\n    extensions: IGLTFObjectModelTreeExtensionsObject;\n    animations: {\n        length: IObjectAccessor<IAnimation[], AnimationGroup[], number>;\n        __array__: {};\n    };\n    meshes: {\n        length: IObjectAccessor<IMesh[], (Mesh | undefined)[], number>;\n        __array__: {};\n    };\n}\n\nexport interface IGLTFObjectModelTreeNodesObject<GLTFTargetType = INode, BabylonTargetType = TransformNode> {\n    length: IObjectAccessor<GLTFTargetType[], BabylonTargetType[], number>;\n    __array__: {\n        __target__: boolean;\n        translation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        rotation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Quaternion>;\n        scale: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        matrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        globalMatrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        weights: {\n            length: IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n            __array__: { __target__: boolean } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n        } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number[]>;\n        extensions: {\n            EXT_lights_ies?: {\n                multiplier: IObjectAccessor<INode, Light, number>;\n                color: IObjectAccessor<INode, Light, Color3>;\n            };\n            KHR_node_visibility?: {\n                visible: IObjectAccessor<INode, Mesh, boolean>;\n            };\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeCamerasObject {\n    __array__: {\n        __target__: boolean;\n        orthographic: {\n            xmag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            ymag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n        };\n        perspective: {\n            yfov: IObjectAccessor<ICamera, ICamera, number>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n            aspectRatio: IObjectAccessor<ICamera, ICamera, Nullable<number>>;\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeMaterialsObject {\n    __array__: {\n        __target__: boolean;\n        pbrMetallicRoughness: {\n            baseColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color4>;\n            metallicFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            roughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n        };\n        emissiveFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n        normalTexture: {\n            scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        occlusionTexture: {\n            strength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyRotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_clearcoat: {\n                clearcoatFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatNormalTexture: {\n                    scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_dispersion: {\n                dispersion: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_emissive_strength: {\n                emissiveStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_ior: {\n                ior: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_iridescence: {\n                iridescenceFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceIor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMinimum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMaximum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_sheen: {\n                sheenColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                sheenRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_specular: {\n                specularFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                specularColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_transmission: {\n                transmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                diffuseTransmissionColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<Color3>>;\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_volume: {\n                thicknessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                attenuationColor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                attenuationDistance: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n        };\n    };\n}\n\ninterface ITextureDefinition {\n    offset: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n    rotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n    scale: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n}\n\nexport interface IGLTFObjectModelTreeMeshesObject {}\n\nexport interface IGLTFObjectModelTreeExtensionsObject {\n    KHR_lights_punctual: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IKHRLightsPunctual_Light, Light, Color3>;\n                intensity: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                range: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                spot: {\n                    innerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                    outerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_ies: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n        };\n    };\n    EXT_lights_image_based: {\n        lights: {\n            __array__: {\n                __target__: boolean;\n                intensity: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, number>;\n                rotation: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, Quaternion>;\n            };\n            length: IObjectAccessor<IEXTLightsImageBased_LightImageBased[], BaseTexture[], number>;\n        };\n    };\n}\n\nconst nodesTree: IGLTFObjectModelTreeNodesObject = {\n    length: {\n        type: \"number\",\n        get: (nodes: INode[]) => nodes.length,\n        getTarget: (nodes: INode[]) => nodes.map((node) => node._babylonTransformNode!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.position,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node: INode) => node._babylonTransformNode?.rotationQuaternion!,\n            set: (value: Quaternion, node: INode) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.scaling,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node: INode) => node._numMorphTargets,\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node: INode, index?: number) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node: INode, index?: number) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node: INode) => Matrix.Compose(node._babylonTransformNode?.scaling!, node._babylonTransformNode?.rotationQuaternion!, node._babylonTransformNode?.position!),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node: INode) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate =\n                    node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                } else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node: INode) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n            KHR_node_visibility: {\n                visible: {\n                    type: \"boolean\",\n                    get: (node: INode) => {\n                        return node._primitiveBabylonMeshes ? node._primitiveBabylonMeshes[0].isVisible : false;\n                    },\n                    getTarget: () => undefined, // TODO: what should this return?\n                    set: (value: boolean, node: INode) => {\n                        if (node._primitiveBabylonMeshes) {\n                            node._primitiveBabylonMeshes.forEach((mesh) => (mesh.isVisible = value));\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations: IAnimation[]) => animations.length,\n        getTarget: (animations: IAnimation[]) => animations.map((animation) => animation._babylonAnimationGroup!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes: IMesh[]) => meshes.length,\n        getTarget: (meshes: IMesh[]) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst camerasTree: IGLTFObjectModelTreeCamerasObject = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera: ICamera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value: Vector2, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.fov,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\n\nconst materialsTree: IGLTFObjectModelTreeMaterialsObject = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value: Color3, material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value: number, material, index?, payload?) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value: number, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value: Color4, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture!.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst extensionsTree: IGLTFObjectModelTreeExtensionsObject = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.range,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.innerAngle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).innerAngle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.angle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).angle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture!),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\n\nfunction GetTexture(material: IMaterial, payload: any, textureType: keyof PBRMaterial, textureInObject?: string) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material: IMaterial, _index?: number, payload?: any) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial as PBRMaterial;\n}\nfunction GenerateTextureMap(textureType: keyof PBRMaterial, textureInObject?: string): ITextureDefinition {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index?, payload?) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\n\nconst objectModelMapping: IGLTFObjectModelTree = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf: IGLTF) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key: string): IObjectAccessor | undefined {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key: string, interpolation?: IInterpolationPropertyInfo[]): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        (current as IObjectAccessor).interpolation = interpolation;\n    }\n}\n\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any>(\n    key: string,\n    accessor: IObjectAccessor<GLTFTargetType, BabylonTargetType, BabylonValueType>\n): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n","import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { SetInterpolationForKey } from \"./Extensions/objectModelMapping\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(\r\n        public readonly type: number,\r\n        public readonly name: string,\r\n        public readonly getValue: GetValueFn,\r\n        public readonly getStride: (target: any) => number\r\n    ) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode!, babylonAnimation: this._buildAnimation(name, fps, keys) });\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/nodes/{}/translation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/rotation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)]);\r\nSetInterpolationForKey(\"/nodes/{}/scale\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/weights\", [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)]);\r\n","import type { OpenPBRMaterial } from \"core/Materials/PBR/openPbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Color3 } from \"core/Maths/math.color\";\r\nimport type { IMaterialLoadingAdapter } from \"./materialLoadingAdapter\";\r\n\r\n/**\r\n * Material Loading Adapter for OpenPBR materials that provides a unified OpenPBR-like interface.\r\n */\r\nexport class OpenPBRMaterialLoadingAdapter implements IMaterialLoadingAdapter {\r\n    private _material: OpenPBRMaterial;\r\n\r\n    /**\r\n     * Creates a new instance of the OpenPBRMaterialLoadingAdapter.\r\n     * @param material - The OpenPBR material to adapt.\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material as OpenPBRMaterial;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying material\r\n     */\r\n    public get material(): OpenPBRMaterial {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Whether the material should be treated as unlit\r\n     */\r\n    public get isUnlit(): boolean {\r\n        return this._material.unlit;\r\n    }\r\n\r\n    /**\r\n     * Sets whether the material should be treated as unlit\r\n     */\r\n    public set isUnlit(value: boolean) {\r\n        this._material.unlit = value;\r\n    }\r\n\r\n    // ========================================\r\n    // CULLING PROPERTIES\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets whether back face culling is enabled.\r\n     * @param value True to enable back face culling\r\n     */\r\n    public set backFaceCulling(value: boolean) {\r\n        this._material.backFaceCulling = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether back face culling is enabled.\r\n     * @returns True if back face culling is enabled\r\n     */\r\n    public get backFaceCulling(): boolean {\r\n        return this._material.backFaceCulling;\r\n    }\r\n\r\n    /**\r\n     * Sets whether two-sided lighting is enabled.\r\n     * @param value True to enable two-sided lighting\r\n     */\r\n    public set twoSidedLighting(value: boolean) {\r\n        this._material.twoSidedLighting = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether two-sided lighting is enabled.\r\n     * @returns True if two-sided lighting is enabled\r\n     */\r\n    public get twoSidedLighting(): boolean {\r\n        return this._material.twoSidedLighting;\r\n    }\r\n\r\n    // ========================================\r\n    // ALPHA PROPERTIES\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the alpha cutoff value for alpha testing.\r\n     * Note: OpenPBR doesn't have a direct equivalent, so this is a no-op.\r\n     * @param value The alpha cutoff threshold (ignored for OpenPBR)\r\n     */\r\n    public set alphaCutOff(value: number) {\r\n        // OpenPBR doesn't have a direct equivalent, but could be implemented if needed\r\n    }\r\n\r\n    /**\r\n     * Gets the alpha cutoff value.\r\n     * @returns Default value of 0.5 (OpenPBR doesn't support this directly)\r\n     */\r\n    public get alphaCutOff(): number {\r\n        return 0.5; // Default value\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use alpha from the base color texture.\r\n     * Note: OpenPBR handles this differently through the baseColorTexture alpha channel.\r\n     * @param value True to use alpha from base color texture (handled automatically in OpenPBR)\r\n     */\r\n    public set useAlphaFromBaseColorTexture(value: boolean) {\r\n        this._material._useAlphaFromBaseColorTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets whether alpha is used from the base color texture.\r\n     * @returns Always false for OpenPBR as it's handled automatically\r\n     */\r\n    public get useAlphaFromBaseColorTexture(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets whether the transparency is treated as alpha coverage.\r\n     */\r\n    public get transparencyAsAlphaCoverage(): boolean {\r\n        // OpenPBR doesn't support treating transparency as alpha coverage.\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets/Gets whether the transparency is treated as alpha coverage\r\n     */\r\n    public set transparencyAsAlphaCoverage(value: boolean) {\r\n        // OpenPBR doesn't support treating transparency as alpha coverage.\r\n    }\r\n\r\n    // ========================================\r\n    // BASE PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the base color of the OpenPBR material.\r\n     * @param value The base color as a Color3\r\n     */\r\n    public set baseColor(value: Color3) {\r\n        this._material.baseColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base color of the OpenPBR material.\r\n     * @returns The base color as a Color3\r\n     */\r\n    public get baseColor(): Color3 {\r\n        return this._material.baseColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the base color texture of the OpenPBR material.\r\n     * @param value The base color texture or null\r\n     */\r\n    public set baseColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.baseColorTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base color texture of the OpenPBR material.\r\n     * @returns The base color texture or null\r\n     */\r\n    public get baseColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.baseColorTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the base diffuse roughness of the OpenPBR material.\r\n     * @param value The diffuse roughness value (0-1)\r\n     */\r\n    public set baseDiffuseRoughness(value: number) {\r\n        this._material.baseDiffuseRoughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base diffuse roughness of the OpenPBR material.\r\n     * @returns The diffuse roughness value (0-1)\r\n     */\r\n    public get baseDiffuseRoughness(): number {\r\n        return this._material.baseDiffuseRoughness;\r\n    }\r\n\r\n    /**\r\n     * Sets the base diffuse roughness texture of the OpenPBR material.\r\n     * @param value The diffuse roughness texture or null\r\n     */\r\n    public set baseDiffuseRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.baseDiffuseRoughnessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base diffuse roughness texture of the OpenPBR material.\r\n     * @returns The diffuse roughness texture or null\r\n     */\r\n    public get baseDiffuseRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.baseDiffuseRoughnessTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the base metalness value of the OpenPBR material.\r\n     * @param value The metalness value (0-1)\r\n     */\r\n    public set baseMetalness(value: number) {\r\n        this._material.baseMetalness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base metalness value of the OpenPBR material.\r\n     * @returns The metalness value (0-1)\r\n     */\r\n    public get baseMetalness(): number {\r\n        return this._material.baseMetalness;\r\n    }\r\n\r\n    /**\r\n     * Sets the base metalness texture of the OpenPBR material.\r\n     * @param value The metalness texture or null\r\n     */\r\n    public set baseMetalnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.baseMetalnessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the base metalness texture of the OpenPBR material.\r\n     * @returns The metalness texture or null\r\n     */\r\n    public get baseMetalnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.baseMetalnessTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use roughness from the metallic texture's green channel.\r\n     * @param value True to use green channel for roughness\r\n     */\r\n    public set useRoughnessFromMetallicTextureGreen(value: boolean) {\r\n        this._material._useRoughnessFromMetallicTextureGreen = value;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use metalness from the metallic texture's blue channel.\r\n     * @param value True to use blue channel for metalness\r\n     */\r\n    public set useMetallicFromMetallicTextureBlue(value: boolean) {\r\n        this._material._useMetallicFromMetallicTextureBlue = value;\r\n    }\r\n\r\n    // ========================================\r\n    // SPECULAR PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures specular properties for OpenPBR material.\r\n     * @param _enableEdgeColor Whether to enable edge color support (ignored for OpenPBR)\r\n     */\r\n    public enableSpecularEdgeColor(_enableEdgeColor: boolean = false): void {\r\n        // OpenPBR already supports edge color natively, no configuration needed\r\n    }\r\n\r\n    /**\r\n     * Sets the specular weight of the OpenPBR material.\r\n     * @param value The specular weight value (0-1)\r\n     */\r\n    public set specularWeight(value: number) {\r\n        this._material.specularWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular weight of the OpenPBR material.\r\n     * @returns The specular weight value (0-1)\r\n     */\r\n    public get specularWeight(): number {\r\n        return this._material.specularWeight;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular weight texture of the OpenPBR material.\r\n     * If the same texture is used for specular color, optimizes by using alpha channel for weight.\r\n     * @param value The specular weight texture or null\r\n     */\r\n    public set specularWeightTexture(value: Nullable<BaseTexture>) {\r\n        if (this._material.specularColorTexture === value) {\r\n            this._material.specularWeightTexture = null;\r\n            this._material._useSpecularWeightFromSpecularColorTexture = true;\r\n            this._material._useSpecularWeightFromAlpha = true;\r\n        } else {\r\n            this._material.specularWeightTexture = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the specular weight texture of the OpenPBR material.\r\n     * @returns The specular weight texture or null\r\n     */\r\n    public get specularWeightTexture(): Nullable<BaseTexture> {\r\n        return this._material.specularWeightTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular color of the OpenPBR material.\r\n     * @param value The specular color as a Color3\r\n     */\r\n    public set specularColor(value: Color3) {\r\n        this._material.specularColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color of the OpenPBR material.\r\n     * @returns The specular color as a Color3\r\n     */\r\n    public get specularColor(): Color3 {\r\n        return this._material.specularColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular color texture of the OpenPBR material.\r\n     * If the same texture is used for specular weight, optimizes by using alpha channel for weight.\r\n     * @param value The specular color texture or null\r\n     */\r\n    public set specularColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.specularColorTexture = value;\r\n        if (this._material.specularWeightTexture === this._material.specularColorTexture) {\r\n            this._material.specularWeightTexture = null;\r\n            this._material._useSpecularWeightFromSpecularColorTexture = true;\r\n            this._material._useSpecularWeightFromAlpha = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the specular color texture of the OpenPBR material.\r\n     * @returns The specular color texture or null\r\n     */\r\n    public get specularColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.specularColorTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular roughness of the OpenPBR material.\r\n     * @param value The roughness value (0-1)\r\n     */\r\n    public set specularRoughness(value: number) {\r\n        this._material.specularRoughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness of the OpenPBR material.\r\n     * @returns The roughness value (0-1)\r\n     */\r\n    public get specularRoughness(): number {\r\n        return this._material.specularRoughness;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular roughness texture of the OpenPBR material.\r\n     * @param value The roughness texture or null\r\n     */\r\n    public set specularRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.specularRoughnessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness texture of the OpenPBR material.\r\n     * @returns The roughness texture or null\r\n     */\r\n    public get specularRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.specularRoughnessTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the specular index of refraction (IOR) of the OpenPBR material.\r\n     * @param value The IOR value\r\n     */\r\n    public set specularIor(value: number) {\r\n        this._material.specularIor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular index of refraction (IOR) of the OpenPBR material.\r\n     * @returns The IOR value\r\n     */\r\n    public get specularIor(): number {\r\n        return this._material.specularIor;\r\n    }\r\n\r\n    // ========================================\r\n    // EMISSION PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the emission color of the OpenPBR material.\r\n     * @param value The emission color as a Color3\r\n     */\r\n    public set emissionColor(value: Color3) {\r\n        this._material.emissionColor = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission color of the OpenPBR material.\r\n     * @returns The emission color as a Color3\r\n     */\r\n    public get emissionColor(): Color3 {\r\n        return this._material.emissionColor;\r\n    }\r\n\r\n    /**\r\n     * Sets the emission luminance of the OpenPBR material.\r\n     * @param value The emission luminance value\r\n     */\r\n    public set emissionLuminance(value: number) {\r\n        this._material.emissionLuminance = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission luminance of the OpenPBR material.\r\n     * @returns The emission luminance value\r\n     */\r\n    public get emissionLuminance(): number {\r\n        return this._material.emissionLuminance;\r\n    }\r\n\r\n    /**\r\n     * Sets the emission color texture of the OpenPBR material.\r\n     * @param value The emission texture or null\r\n     */\r\n    public set emissionColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.emissionColorTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the emission color texture of the OpenPBR material.\r\n     * @returns The emission texture or null\r\n     */\r\n    public get emissionColorTexture(): Nullable<BaseTexture> {\r\n        return this._material.emissionColorTexture;\r\n    }\r\n\r\n    // ========================================\r\n    // AMBIENT OCCLUSION\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the ambient occlusion texture of the OpenPBR material.\r\n     * @param value The ambient occlusion texture or null\r\n     */\r\n    public set ambientOcclusionTexture(value: Nullable<BaseTexture>) {\r\n        this._material.ambientOcclusionTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient occlusion texture of the OpenPBR material.\r\n     * @returns The ambient occlusion texture or null\r\n     */\r\n    public get ambientOcclusionTexture(): Nullable<BaseTexture> {\r\n        return this._material.ambientOcclusionTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the ambient occlusion texture strength by modifying the texture's level.\r\n     * @param value The strength value (typically 0-1)\r\n     */\r\n    public set ambientOcclusionTextureStrength(value: number) {\r\n        const texture = this._material.ambientOcclusionTexture;\r\n        if (texture) {\r\n            texture.level = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the ambient occlusion texture strength from the texture's level property.\r\n     * @returns The strength value, defaults to 1.0 if no texture or level is set\r\n     */\r\n    public get ambientOcclusionTextureStrength(): number {\r\n        const texture = this._material.ambientOcclusionTexture;\r\n        return texture?.level ?? 1.0;\r\n    }\r\n\r\n    // ========================================\r\n    // COAT PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures coat parameters for OpenPBR material.\r\n     * OpenPBR coat is already built-in, so no configuration is needed.\r\n     */\r\n    public configureCoat(): void {\r\n        // OpenPBR coat is already built-in, no configuration needed\r\n    }\r\n\r\n    /**\r\n     * Sets the coat weight of the OpenPBR material.\r\n     * @param value The coat weight value (0-1)\r\n     */\r\n    public set coatWeight(value: number) {\r\n        this._material.coatWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat weight of the OpenPBR material.\r\n     * @returns The coat weight value (0-1)\r\n     */\r\n    public get coatWeight(): number {\r\n        return this._material.coatWeight;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat weight texture of the OpenPBR material.\r\n     * @param value The coat weight texture or null\r\n     */\r\n    public set coatWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.coatWeightTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat weight texture of the OpenPBR material.\r\n     * @returns The coat weight texture or null\r\n     */\r\n    public get coatWeightTexture(): Nullable<BaseTexture> {\r\n        return this._material.coatWeightTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat color of the OpenPBR material.\r\n     * @param value The coat color as a Color3\r\n     */\r\n    public set coatColor(value: Color3) {\r\n        this._material.coatColor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat color texture of the OpenPBR material.\r\n     * @param value The coat color texture or null\r\n     */\r\n    public set coatColorTexture(value: Nullable<BaseTexture>) {\r\n        this._material.coatColorTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness of the OpenPBR material.\r\n     * @param value The coat roughness value (0-1)\r\n     */\r\n    public set coatRoughness(value: number) {\r\n        this._material.coatRoughness = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness of the OpenPBR material.\r\n     * @returns The coat roughness value (0-1)\r\n     */\r\n    public get coatRoughness(): number {\r\n        return this._material.coatRoughness;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness texture of the OpenPBR material.\r\n     * @param value The coat roughness texture or null\r\n     */\r\n    public set coatRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.coatRoughnessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness texture of the OpenPBR material.\r\n     * @returns The coat roughness texture or null\r\n     */\r\n    public get coatRoughnessTexture(): Nullable<BaseTexture> {\r\n        return this._material.coatRoughnessTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat index of refraction (IOR) of the OpenPBR material.\r\n     */\r\n    public set coatIor(value: number) {\r\n        this._material.coatIor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat darkening value of the OpenPBR material.\r\n     * @param value The coat darkening value\r\n     */\r\n    public set coatDarkening(value: number) {\r\n        this._material.coatDarkening = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat darkening texture (OpenPBR: coatDarkeningTexture, no PBR equivalent)\r\n     */\r\n    public set coatDarkeningTexture(value: Nullable<BaseTexture>) {\r\n        this._material.coatDarkeningTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat roughness anisotropy.\r\n     * TODO: Implementation pending OpenPBR coat anisotropy feature availability.\r\n     * @param value The coat anisotropy intensity value\r\n     */\r\n    public set coatRoughnessAnisotropy(value: number) {\r\n        this._material.coatRoughnessAnisotropy = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the coat roughness anisotropy.\r\n     * TODO: Implementation pending OpenPBR coat anisotropy feature availability.\r\n     * @returns Currently returns 0 as coat anisotropy is not yet available\r\n     */\r\n    public get coatRoughnessAnisotropy(): number {\r\n        return this._material.coatRoughnessAnisotropy;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat tangent angle for anisotropy.\r\n     * TODO: Implementation pending OpenPBR coat anisotropy feature availability.\r\n     * @param value The coat anisotropy rotation angle in radians\r\n     */\r\n    public set geometryCoatTangentAngle(value: number) {\r\n        this._material.geometryCoatTangentAngle = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the coat tangent texture for anisotropy.\r\n     * TODO: Implementation pending OpenPBR coat anisotropy feature availability.\r\n     * @param value The coat anisotropy texture or null\r\n     */\r\n    public set geometryCoatTangentTexture(value: Nullable<BaseTexture>) {\r\n        this._material.geometryCoatTangentTexture = value;\r\n        if (value) {\r\n            this._material._useCoatRoughnessAnisotropyFromTangentTexture = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the coat tangent texture for anisotropy.\r\n     * TODO: Implementation pending OpenPBR coat anisotropy feature availability.\r\n     * @returns Currently returns null as coat anisotropy is not yet available\r\n     */\r\n    public get geometryCoatTangentTexture(): Nullable<BaseTexture> {\r\n        return this._material.geometryCoatTangentTexture;\r\n    }\r\n\r\n    // ========================================\r\n    // TRANSMISSION LAYER\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the transmission weight.\r\n     * TODO: Implementation pending OpenPBR transmission feature availability.\r\n     * @param value The transmission weight value (0-1)\r\n     */\r\n    public set transmissionWeight(value: number) {\r\n        // TODO: Implement when OpenPBR transmission is available\r\n        // this._material.transmissionWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the transmission weight texture.\r\n     * TODO: Implementation pending OpenPBR transmission feature availability.\r\n     * @param value The transmission weight texture or null\r\n     */\r\n    public set transmissionWeightTexture(value: Nullable<BaseTexture>) {\r\n        // TODO: Implement when OpenPBR transmission is available\r\n        // this._material.transmissionWeightTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the transmission weight.\r\n     * TODO: Implementation pending OpenPBR transmission feature availability.\r\n     * @returns Currently returns 0 as transmission is not yet available\r\n     */\r\n    public get transmissionWeight(): number {\r\n        // TODO: Implement when OpenPBR transmission is available\r\n        // return this._material.transmissionWeight;\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the transmission dispersion Abbe number.\r\n     * @param value The Abbe number value\r\n     */\r\n    public set transmissionDispersionAbbeNumber(value: number) {\r\n        // TODO: Implement when OpenPBR transmission dispersion is available\r\n    }\r\n\r\n    /**\r\n     * Configures transmission for OpenPBR material.\r\n     * TODO: Implementation pending OpenPBR transmission feature availability.\r\n     */\r\n    public configureTransmission(): void {\r\n        // OpenPBR transmission will be configured differently when available\r\n    }\r\n\r\n    // ========================================\r\n    // VOLUME PROPERTIES (Subsurface Scattering)\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the attenuation distance for volume scattering.\r\n     * TODO: Implementation pending OpenPBR volume feature availability.\r\n     * @param value The attenuation distance value\r\n     */\r\n    public set transmissionDepth(value: number) {\r\n        // TODO: Implement when OpenPBR volume properties are available\r\n        // this._material.attenuationDistance = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the attenuation color for volume scattering.\r\n     * TODO: Implementation pending OpenPBR volume feature availability.\r\n     * @param value The attenuation color as a Color3\r\n     */\r\n    public set transmissionColor(value: Color3) {\r\n        // TODO: Implement when OpenPBR volume properties are available\r\n        // this._material.attenuationColor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness texture for volume scattering.\r\n     * TODO: Implementation pending OpenPBR volume feature availability.\r\n     * @param value The thickness texture or null\r\n     */\r\n    public set volumeThicknessTexture(value: Nullable<BaseTexture>) {\r\n        // TODO: Implement when OpenPBR volume properties are available\r\n        // this._material.thicknessTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thickness factor for volume scattering.\r\n     * TODO: Implementation pending OpenPBR volume feature availability.\r\n     * @param value The thickness value\r\n     */\r\n    public set volumeThickness(value: number) {\r\n        // TODO: Implement when OpenPBR volume properties are available\r\n        // this._material.thickness = value;\r\n    }\r\n\r\n    // ========================================\r\n    // SUBSURFACE PROPERTIES (Subsurface Scattering)\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures subsurface properties for PBR material\r\n     */\r\n    public configureSubsurface(): void {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface weight\r\n     */\r\n    public set subsurfaceWeight(value: number) {\r\n        // TODO\r\n    }\r\n\r\n    public get subsurfaceWeight(): number {\r\n        // TODO\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface weight texture\r\n     */\r\n    public set subsurfaceWeightTexture(value: Nullable<BaseTexture>) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface color.\r\n     * @param value The subsurface tint color as a Color3\r\n     */\r\n    public set subsurfaceColor(value: Color3) {\r\n        // TODO\r\n    }\r\n\r\n    /**\r\n     * Sets the subsurface color texture.\r\n     * @param value The subsurface tint texture or null\r\n     */\r\n    public set subsurfaceColorTexture(value: Nullable<BaseTexture>) {\r\n        // TODO\r\n    }\r\n\r\n    // ========================================\r\n    // FUZZ LAYER (Sheen)\r\n    // ========================================\r\n\r\n    /**\r\n     * Configures fuzz for OpenPBR.\r\n     * Enables fuzz and sets up proper configuration.\r\n     */\r\n    public configureFuzz(): void {\r\n        // Currently no setup to do for OpenPBR\r\n    }\r\n\r\n    /**\r\n     * Sets the fuzz weight.\r\n     * TODO: Implementation pending OpenPBR fuzz feature availability.\r\n     * @param value The fuzz weight value\r\n     */\r\n    public set fuzzWeight(value: number) {\r\n        // TODO: Implement when OpenPBR fuzz is available\r\n        // this._material.fuzzWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the fuzz color.\r\n     * TODO: Implementation pending OpenPBR fuzz feature availability.\r\n     * @param value The fuzz color as a Color3\r\n     */\r\n    public set fuzzColor(value: Color3) {\r\n        // TODO: Implement when OpenPBR fuzz is available\r\n        // this._material.fuzzColor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the fuzz color texture.\r\n     * TODO: Implementation pending OpenPBR fuzz feature availability.\r\n     * @param value The fuzz color texture or null\r\n     */\r\n    public set fuzzColorTexture(value: Nullable<BaseTexture>) {\r\n        // TODO: Implement when OpenPBR fuzz is available\r\n        // this._material.fuzzColorTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the fuzz roughness.\r\n     * TODO: Implementation pending OpenPBR fuzz feature availability.\r\n     * @param value The fuzz roughness value (0-1)\r\n     */\r\n    public set fuzzRoughness(value: number) {\r\n        // TODO: Implement when OpenPBR fuzz is available\r\n        // this._material.fuzzRoughness = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the fuzz roughness texture.\r\n     * TODO: Implementation pending OpenPBR fuzz feature availability.\r\n     * @param value The fuzz roughness texture or null\r\n     */\r\n    public set fuzzRoughnessTexture(value: Nullable<BaseTexture>) {\r\n        // TODO: Implement when OpenPBR fuzz is available\r\n        // this._material.fuzzRoughnessTexture = value;\r\n    }\r\n\r\n    // ========================================\r\n    // ANISOTROPY\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the specular roughness anisotropy of the OpenPBR material.\r\n     * @param value The anisotropy intensity value\r\n     */\r\n    public set specularRoughnessAnisotropy(value: number) {\r\n        this._material.specularRoughnessAnisotropy = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the specular roughness anisotropy of the OpenPBR material.\r\n     * @returns The anisotropy intensity value\r\n     */\r\n    public get specularRoughnessAnisotropy(): number {\r\n        return this._material.specularRoughnessAnisotropy;\r\n    }\r\n\r\n    /**\r\n     * Sets the anisotropy rotation angle.\r\n     * @param value The anisotropy rotation angle in radians\r\n     */\r\n    public set geometryTangentAngle(value: number) {\r\n        this._material.geometryTangentAngle = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry tangent texture for anisotropy.\r\n     * Automatically enables using anisotropy from the tangent texture.\r\n     * @param value The anisotropy texture or null\r\n     */\r\n    public set geometryTangentTexture(value: Nullable<BaseTexture>) {\r\n        this._material.geometryTangentTexture = value;\r\n        this._material._useSpecularRoughnessAnisotropyFromTangentTexture = true;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry tangent texture for anisotropy.\r\n     * @returns The anisotropy texture or null\r\n     */\r\n    public get geometryTangentTexture(): Nullable<BaseTexture> {\r\n        return this._material.geometryTangentTexture;\r\n    }\r\n\r\n    /**\r\n     * Configures glTF-style anisotropy for the OpenPBR material.\r\n     * @param useGltfStyle Whether to use glTF-style anisotropy\r\n     */\r\n    public configureGltfStyleAnisotropy(useGltfStyle: boolean = true): void {\r\n        this._material._useGltfStyleAnisotropy = useGltfStyle;\r\n    }\r\n\r\n    // ========================================\r\n    // THIN FILM IRIDESCENCE\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the thin film weight.\r\n     * @param value The thin film weight value\r\n     */\r\n    public set thinFilmWeight(value: number) {\r\n        this._material.thinFilmWeight = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film IOR.\r\n     * @param value The thin film IOR value\r\n     */\r\n    public set thinFilmIor(value: number) {\r\n        this._material.thinFilmIor = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film thickness minimum.\r\n     * @param value The minimum thickness value in nanometers\r\n     */\r\n    public set thinFilmThicknessMinimum(value: number) {\r\n        this._material.thinFilmThicknessMin = value / 1000.0; // Convert to micrometers for OpenPBR\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film thickness maximum.\r\n     * @param value The maximum thickness value in nanometers\r\n     */\r\n    public set thinFilmThicknessMaximum(value: number) {\r\n        this._material.thinFilmThickness = value / 1000.0; // Convert to micrometers for OpenPBR\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film weight texture.\r\n     * @param value The thin film weight texture or null\r\n     */\r\n    public set thinFilmWeightTexture(value: Nullable<BaseTexture>) {\r\n        this._material.thinFilmWeightTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Sets the thin film thickness texture.\r\n     * @param value The thin film thickness texture or null\r\n     */\r\n    public set thinFilmThicknessTexture(value: Nullable<BaseTexture>) {\r\n        this._material.thinFilmThicknessTexture = value;\r\n        this._material._useThinFilmThicknessFromTextureGreen = true;\r\n    }\r\n\r\n    // ========================================\r\n    // UNLIT MATERIALS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets whether the OpenPBR material is unlit.\r\n     * @param value True to make the material unlit\r\n     */\r\n    public set unlit(value: boolean) {\r\n        this._material.unlit = value;\r\n    }\r\n\r\n    // ========================================\r\n    // GEOMETRY PARAMETERS\r\n    // ========================================\r\n\r\n    /**\r\n     * Sets the geometry opacity of the OpenPBR material.\r\n     * @param value The opacity value (0-1)\r\n     */\r\n    public set geometryOpacity(value: number) {\r\n        this._material.geometryOpacity = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry opacity of the OpenPBR material.\r\n     * @returns The opacity value (0-1)\r\n     */\r\n    public get geometryOpacity(): number {\r\n        return this._material.geometryOpacity;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry normal texture of the OpenPBR material.\r\n     * @param value The normal texture or null\r\n     */\r\n    public set geometryNormalTexture(value: Nullable<BaseTexture>) {\r\n        this._material.geometryNormalTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry normal texture of the OpenPBR material.\r\n     * @returns The normal texture or null\r\n     */\r\n    public get geometryNormalTexture(): Nullable<BaseTexture> {\r\n        return this._material.geometryNormalTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the normal map inversions for the OpenPBR material.\r\n     * Note: OpenPBR may handle normal map inversions differently or may not need them.\r\n     * @param invertX Whether to invert the normal map on the X axis (may be ignored)\r\n     * @param invertY Whether to invert the normal map on the Y axis (may be ignored)\r\n     */\r\n    public setNormalMapInversions(invertX: boolean, invertY: boolean): void {\r\n        // OpenPBR handles normal map inversions differently or may not need them\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry coat normal texture of the OpenPBR material.\r\n     * @param value The coat normal texture or null\r\n     */\r\n    public set geometryCoatNormalTexture(value: Nullable<BaseTexture>) {\r\n        this._material.geometryCoatNormalTexture = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry coat normal texture of the OpenPBR material.\r\n     * @returns The coat normal texture or null\r\n     */\r\n    public get geometryCoatNormalTexture(): Nullable<BaseTexture> {\r\n        return this._material.geometryCoatNormalTexture;\r\n    }\r\n\r\n    /**\r\n     * Sets the geometry coat normal texture scale.\r\n     * @param value The scale value for the coat normal texture\r\n     */\r\n    public set geometryCoatNormalTextureScale(value: number) {\r\n        if (this._material.geometryCoatNormalTexture) {\r\n            this._material.geometryCoatNormalTexture.level = value;\r\n        }\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { IAnimationKey } from \"core/Animations\";\nimport { Animation } from \"core/Animations/animation\";\nimport { Bone } from \"core/Bones/bone\";\nimport { Skeleton } from \"core/Bones/skeleton\";\nimport { Matrix, Quaternion, Vector3 } from \"core/Maths/math.vector\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport type { BVHLoadingOptions } from \"./bvhLoadingOptions\";\nimport { Tools } from \"core/Misc/tools\";\nimport type { AssetContainer } from \"core/assetContainer\";\n\nconst _XPosition = \"Xposition\";\nconst _YPosition = \"Yposition\";\nconst _ZPosition = \"Zposition\";\nconst _XRotation = \"Xrotation\";\nconst _YRotation = \"Yrotation\";\nconst _ZRotation = \"Zrotation\";\n\nconst _HierarchyNode = \"HIERARCHY\";\nconst _MotionNode = \"MOTION\";\n\nclass LoaderContext {\n    loopMode: number = Animation.ANIMATIONLOOPMODE_CYCLE;\n    list: IBVHNode[] = [];\n    root: IBVHNode = CreateBVHNode();\n    numFrames: number = 0;\n    frameRate: number = 0;\n    skeleton: Skeleton;\n\n    constructor(skeleton: Skeleton) {\n        this.skeleton = skeleton;\n    }\n}\n\ninterface IBVHNode {\n    name: string;\n    type: string;\n    offset: Vector3;\n    channels: string[];\n    children: IBVHNode[];\n    frames: IBVHKeyFrame[];\n    parent: Nullable<IBVHNode>;\n}\n\ninterface IBVHKeyFrame {\n    frame: number;\n    position: Vector3;\n    rotation: Quaternion;\n}\n\nfunction CreateBVHNode(): IBVHNode {\n    return {\n        name: \"\",\n        type: \"\",\n        offset: new Vector3(),\n        channels: [],\n        children: [],\n        frames: [],\n        parent: null,\n    };\n}\n\nfunction CreateBVHKeyFrame(): IBVHKeyFrame {\n    return {\n        frame: 0,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n    };\n}\n\n/**\n * Converts the BVH node's offset to a Babylon matrix\n * @param node - The BVH node to convert\n * @returns The converted matrix\n */\nfunction BoneOffset(node: IBVHNode): Matrix {\n    const x = node.offset.x;\n    const y = node.offset.y;\n    const z = node.offset.z;\n    return Matrix.Translation(x, y, z);\n}\n\n/**\n * Creates animations for the BVH node\n * @param node - The BVH node to create animations for\n * @param context - The loader context\n * @returns The created animations\n */\nfunction CreateAnimations(node: IBVHNode, context: LoaderContext): Animation[] {\n    if (node.frames.length === 0) {\n        return [];\n    }\n\n    const animations: Animation[] = [];\n\n    // Create position animation if there are position channels\n    const hasPosition = node.channels.some((c) => c === _XPosition || c === _YPosition || c === _ZPosition);\n\n    // Create rotation animation if there are rotation channels\n    const hasRotation = node.channels.some((c) => c === _XRotation || c === _YRotation || c === _ZRotation);\n\n    const posAnim = new Animation(`${node.name}_pos`, \"position\", context.frameRate, Animation.ANIMATIONTYPE_VECTOR3, context.loopMode);\n\n    const rotAnim = new Animation(`${node.name}_rot`, \"rotationQuaternion\", context.frameRate, Animation.ANIMATIONTYPE_QUATERNION, context.loopMode);\n\n    const posKeys: IAnimationKey[] = [];\n    const rotKeys: IAnimationKey[] = [];\n\n    for (let i = 0; i < node.frames.length; i++) {\n        const frame = node.frames[i];\n\n        if (hasPosition && frame.position) {\n            posKeys.push({\n                frame: frame.frame,\n                value: frame.position.clone(),\n            });\n        }\n\n        if (hasRotation) {\n            rotKeys.push({\n                frame: frame.frame,\n                value: frame.rotation.clone(),\n            });\n        }\n    }\n\n    if (posKeys.length > 0) {\n        posAnim.setKeys(posKeys);\n        animations.push(posAnim);\n    }\n\n    if (rotKeys.length > 0) {\n        rotAnim.setKeys(rotKeys);\n        animations.push(rotAnim);\n    }\n\n    return animations;\n}\n\n/**\n * Converts a BVH node to a Babylon bone\n * @param node - The BVH node to convert\n * @param parent - The parent bone\n * @param context - The loader context\n */\nfunction ConvertNode(node: IBVHNode, parent: Nullable<Bone>, context: LoaderContext) {\n    const matrix = BoneOffset(node);\n    const bone = new Bone(node.name, context.skeleton, parent, matrix);\n\n    // Create animation for this bone\n    const animations = CreateAnimations(node, context);\n    for (const animation of animations) {\n        if (animation.getKeys() && animation.getKeys().length > 0) {\n            bone.animations.push(animation);\n        }\n    }\n\n    for (const child of node.children) {\n        ConvertNode(child, bone, context);\n    }\n}\n\n/**\n * Recursively reads data from a single frame into the bone hierarchy.\n * The bone hierarchy has to be structured in the same order as the BVH file.\n * keyframe data is stored in bone.frames.\n * @param data - splitted string array (frame values), values are shift()ed\n * @param frameNumber - playback time for this keyframe\n * @param bone - the bone to read frame data from\n * @param tokenIndex - the index of the token to read\n */\nfunction ReadFrameData(data: string[], frameNumber: number, bone: IBVHNode, tokenIndex: { i: number }) {\n    if (bone.type === \"ENDSITE\") {\n        // end sites have no motion data\n        return;\n    }\n\n    // add keyframe\n    const keyframe = CreateBVHKeyFrame();\n    keyframe.frame = frameNumber;\n    keyframe.position = new Vector3();\n    keyframe.rotation = new Quaternion();\n\n    bone.frames.push(keyframe);\n\n    let combinedRotation = Matrix.Identity();\n\n    // parse values for each channel in node\n    for (let i = 0; i < bone.channels.length; ++i) {\n        const channel = bone.channels[i];\n        const value = data[tokenIndex.i++];\n        if (!value) {\n            continue;\n        }\n        const parsedValue = parseFloat(value.trim());\n        if (channel.endsWith(\"position\")) {\n            switch (channel) {\n                case _XPosition:\n                    keyframe.position.x = parsedValue;\n                    break;\n                case _YPosition:\n                    keyframe.position.y = parsedValue;\n                    break;\n                case _ZPosition:\n                    keyframe.position.z = parsedValue;\n                    break;\n            }\n        } else if (channel.endsWith(\"rotation\")) {\n            const angle = Tools.ToRadians(parsedValue);\n            let rotationMatrix: Matrix;\n            switch (channel) {\n                case _XRotation:\n                    rotationMatrix = Matrix.RotationX(angle);\n                    break;\n                case _YRotation:\n                    rotationMatrix = Matrix.RotationY(angle);\n                    break;\n                case _ZRotation:\n                    rotationMatrix = Matrix.RotationZ(angle);\n                    break;\n            }\n            combinedRotation = rotationMatrix!.multiply(combinedRotation);\n        }\n    }\n\n    Quaternion.FromRotationMatrixToRef(combinedRotation, keyframe.rotation);\n\n    // parse child nodes\n    for (const child of bone.children) {\n        ReadFrameData(data, frameNumber, child, tokenIndex);\n    }\n}\n\n/**\n * Recursively parses the HIERARCHY section of the BVH file\n * @param lines - all lines of the file. lines are consumed as we go along\n * @param firstLine - line containing the node type and name e.g. \"JOINT hip\"\n * @param parent - the parent node for hierarchy\n * @param context - the loader context containing the list of nodes and other data\n * @returns a BVH node including children\n */\nfunction ReadNode(lines: string[], firstLine: string, parent: Nullable<IBVHNode>, context: LoaderContext): IBVHNode {\n    const node = CreateBVHNode();\n    node.parent = parent;\n    context.list.push(node);\n\n    // parse node type and name.\n    let tokens: string[] | undefined = firstLine.trim().split(/\\s+/);\n\n    if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n        node.type = \"ENDSITE\";\n        node.name = \"ENDSITE\"; // bvh end sites have no name\n    } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n    }\n\n    // opening bracket\n    if (lines.shift()?.trim() != \"{\") {\n        throw new Error(\"Expected opening { after type & name\");\n    }\n\n    // parse OFFSET\n    const tokensSplit = lines.shift()?.trim().split(/\\s+/);\n    if (!tokensSplit) {\n        throw new Error(\"Unexpected end of file: missing OFFSET\");\n    }\n    tokens = tokensSplit;\n\n    if (tokens[0].toUpperCase() != \"OFFSET\") {\n        throw new Error(\"Expected OFFSET, but got: \" + tokens[0]);\n    }\n    if (tokens.length != 4) {\n        throw new Error(\"OFFSET: Invalid number of values\");\n    }\n\n    const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n    if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        throw new Error(\"OFFSET: Invalid values\");\n    }\n\n    node.offset = offset;\n\n    // parse CHANNELS definitions\n    if (node.type != \"ENDSITE\") {\n        tokens = lines.shift()?.trim().split(/\\s+/);\n        if (!tokens) {\n            throw new Error(\"Unexpected end of file: missing CHANNELS\");\n        }\n\n        if (tokens[0].toUpperCase() != \"CHANNELS\") {\n            throw new Error(\"Expected CHANNELS definition\");\n        }\n\n        const numChannels = parseInt(tokens[1]);\n        // Skip CHANNELS and the number of channels\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n    }\n\n    // read children\n    while (lines.length > 0) {\n        const line = lines.shift()?.trim();\n\n        if (line === \"}\") {\n            // Finish reading the node\n            return node;\n        } else if (line) {\n            node.children.push(ReadNode(lines, line, node, context));\n        }\n    }\n\n    throw new Error(\"Unexpected end of file: missing closing brace\");\n}\n\n/**\n * Reads a BVH file, returns a skeleton\n * @param text - The BVH file content\n * @param scene - The scene to add the skeleton to\n * @param assetContainer - The asset container to add the skeleton to\n * @param loadingOptions - The loading options\n * @returns The skeleton\n */\nexport function ReadBvh(text: string, scene: Scene, assetContainer: Nullable<AssetContainer>, loadingOptions: BVHLoadingOptions): Skeleton {\n    const lines = text.split(\"\\n\");\n\n    const { loopMode } = loadingOptions;\n\n    scene._blockEntityCollection = !!assetContainer;\n    const skeleton = new Skeleton(\"\", \"\", scene);\n    skeleton._parentContainer = assetContainer;\n    scene._blockEntityCollection = false;\n\n    const context = new LoaderContext(skeleton);\n    context.loopMode = loopMode;\n\n    // read model structure\n    const firstLine = lines.shift();\n    if (!firstLine || firstLine.trim().toUpperCase() !== _HierarchyNode) {\n        throw new Error(\"HIERARCHY expected\");\n    }\n\n    const nodeLine = lines.shift();\n    if (!nodeLine) {\n        throw new Error(\"Unexpected end of file after HIERARCHY\");\n    }\n    const root = ReadNode(lines, nodeLine.trim(), null, context);\n\n    // read motion data\n    const motionLine = lines.shift();\n    if (!motionLine || motionLine.trim().toUpperCase() !== _MotionNode) {\n        throw new Error(\"MOTION expected\");\n    }\n\n    const framesLine = lines.shift();\n    if (!framesLine) {\n        throw new Error(\"Unexpected end of file before frame count\");\n    }\n    const framesTokens = framesLine.trim().split(/[\\s]+/);\n    if (framesTokens.length < 2) {\n        throw new Error(\"Invalid frame count line\");\n    }\n\n    // number of frames\n    const numFrames = parseInt(framesTokens[1]);\n    if (isNaN(numFrames)) {\n        throw new Error(\"Failed to read number of frames.\");\n    }\n    context.numFrames = numFrames;\n\n    // frame time\n    const frameTimeLine = lines.shift();\n    if (!frameTimeLine) {\n        throw new Error(\"Unexpected end of file before frame time\");\n    }\n    const frameTimeTokens = frameTimeLine.trim().split(/[\\s]+/);\n    if (frameTimeTokens.length < 3) {\n        throw new Error(\"Invalid frame time line\");\n    }\n    const frameTime = parseFloat(frameTimeTokens[2]);\n    if (isNaN(frameTime)) {\n        throw new Error(\"Failed to read frame time.\");\n    }\n    if (frameTime <= 0) {\n        throw new Error(\"Failed to read frame time. Invalid value \" + frameTime);\n    }\n\n    context.frameRate = 1 / frameTime;\n\n    // read frame data line by line\n    for (let i = 0; i < numFrames; ++i) {\n        const frameLine = lines.shift();\n        if (!frameLine) {\n            continue;\n        }\n        const tokens = frameLine.trim().split(/[\\s]+/) || [];\n        ReadFrameData(tokens, i, root, { i: 0 });\n    }\n\n    context.root = root;\n\n    ConvertNode(context.root, null, context);\n\n    context.skeleton.returnToRest();\n    return context.skeleton;\n}\n","import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const BVHFileLoaderMetadata = {\r\n    name: \"bvh\",\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".bvh\": { isBinary: false },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","import type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { Animation } from \"core/Animations/animation\";\nimport type { Scene } from \"core/scene\";\nimport type { BVHLoadingOptions } from \"./bvhLoadingOptions\";\nimport { BVHFileLoaderMetadata } from \"./bvhFileLoader.metadata\";\nimport { ReadBvh } from \"./bvhLoader\";\n\ndeclare module \"core/Loading/sceneLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface SceneLoaderPluginOptions {\n        /**\n         * Defines options for the bvh loader.\n         */\n        [BVHFileLoaderMetadata.name]: Partial<BVHLoadingOptions>;\n    }\n}\n\n/**\n * @experimental\n * BVH file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class BVHFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\n    /**\n     * Name of the loader (\"bvh\")\n     */\n    public readonly name = BVHFileLoaderMetadata.name;\n\n    /** @internal */\n    public readonly extensions = BVHFileLoaderMetadata.extensions;\n\n    private readonly _loadingOptions: BVHLoadingOptions;\n\n    /**\n     * Creates loader for bvh motion files\n     * @param loadingOptions - Options for the bvh loader\n     */\n    constructor(loadingOptions?: Partial<Readonly<BVHLoadingOptions>>) {\n        this._loadingOptions = { ...BVHFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n\n    private static get _DefaultLoadingOptions(): BVHLoadingOptions {\n        return {\n            loopMode: Animation.ANIMATIONLOOPMODE_CYCLE,\n        };\n    }\n\n    /** @internal */\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\n        return new BVHFileLoader(options[BVHFileLoaderMetadata.name]);\n    }\n\n    /**\n     * If the data string can be loaded directly.\n     * @param data - direct load data\n     * @returns if the data can be loaded directly\n     */\n    public canDirectLoad(data: string): boolean {\n        return this.isBvhHeader(data);\n    }\n\n    public isBvhHeader(text: string): boolean {\n        return text.split(\"\\n\")[0] == \"HIERARCHY\";\n    }\n\n    public isNotBvhHeader(text: string): boolean {\n        return !this.isBvhHeader(text);\n    }\n\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param _meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the bvh data to load\n     * @returns a promise containing the loaded skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public importMeshAsync(_meshesNames: string | readonly string[] | null | undefined, scene: Scene, data: unknown): Promise<ISceneLoaderAsyncResult> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        try {\n            const skeleton = ReadBvh(data, scene, null, this._loadingOptions);\n            return Promise.resolve({\n                meshes: [],\n                particleSystems: [],\n                skeletons: [skeleton],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            } as ISceneLoaderAsyncResult);\n        } catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Imports all objects from the loaded bvh data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the bvh data to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    public loadAsync(scene: Scene, data: unknown): Promise<void> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public loadAssetContainerAsync(scene: Scene, data: unknown): Promise<AssetContainer> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        const assetContainer = new AssetContainer(scene);\n        try {\n            const skeleton = ReadBvh(data, scene, assetContainer, this._loadingOptions);\n            assetContainer.skeletons.push(skeleton);\n            return Promise.resolve(assetContainer);\n        } catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n}\n\nRegisterSceneLoaderPlugin(new BVHFileLoader());\n","/* eslint-disable github/no-then */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction ValidateAsync(\r\n    data: string | Uint8Array,\r\n    rootUrl: string,\r\n    fileName: string,\r\n    getExternalResource: (uri: string) => Promise<Uint8Array>\r\n): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: getExternalResource,\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction WorkerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void; reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                ValidateAsync(\r\n                    data.data,\r\n                    data.rootUrl,\r\n                    data.fileName,\r\n                    (uri) =>\r\n                        new Promise((resolve, reject) => {\r\n                            const index = pendingExternalResources.length;\r\n                            pendingExternalResources.push({ resolve, reject });\r\n                            postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                        })\r\n                ).then(\r\n                    (value) => {\r\n                        postMessage({ id: \"validate.resolve\", value: value });\r\n                    },\r\n                    (reason) => {\r\n                        postMessage({ id: \"validate.reject\", reason: reason });\r\n                    }\r\n                );\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://cdn.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: `${Tools._DefaultCdnUrl}/gltf_validator.js`,\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(\r\n        data: string | Uint8Array,\r\n        rootUrl: string,\r\n        fileName: string,\r\n        getExternalResource: (uri: string) => Promise<Uint8Array>\r\n    ): Promise<GLTF2.IGLTFValidationResults> {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${ValidateAsync}(${WorkerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then(\r\n                                (value) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value.buffer]);\r\n                                },\r\n                                (reason) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                                }\r\n                            );\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            worker.terminate();\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(data.reason);\r\n                            worker.terminate();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: Tools.GetBabylonScriptURL(this.Configuration.url) });\r\n\r\n                if (ArrayBuffer.isView(data)) {\r\n                    // Slice the data to avoid copying the whole array buffer.\r\n                    const slicedData = data.slice();\r\n                    worker.postMessage({ id: \"validate\", data: slicedData, rootUrl: rootUrl, fileName: fileName }, [slicedData.buffer]);\r\n                } else {\r\n                    worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n                }\r\n            });\r\n        } else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadBabylonScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return ValidateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable github/no-then */\r\n/* eslint-disable @typescript-eslint/no-floating-promises */\r\n/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginFactory, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport { GLTFFileLoaderMetadata, GLTFMagicBase64Encoded } from \"./glTFFileLoader.metadata\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n/**\r\n * Defines options for glTF loader extensions. This interface is extended by specific extensions.\r\n */\r\nexport interface GLTFLoaderExtensionOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the glTF loader.\r\n         */\r\n        [GLTFFileLoaderMetadata.name]: Partial<GLTFLoaderOptions>;\r\n    }\r\n}\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\nfunction readViewAsync(arrayBufferView: ArrayBufferView, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Offset is out of range.\");\r\n        }\r\n\r\n        if (byteOffset + byteLength > arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Length is out of range.\");\r\n        }\r\n\r\n        return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Adds default/implicit options to extension specific options.\r\n */\r\ntype DefaultExtensionOptions<BaseExtensionOptions> = {\r\n    /**\r\n     * Defines if the extension is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BaseExtensionOptions;\r\n\r\n/**\r\n * This class contains all the concrete (not abstract) glTF options, excluding callbacks.\r\n * The purpose of this class is to make it easy to provide a way to mutate the default\r\n * loader options (see the GLTFLoaderDefaultOptions instance below) without duplicating\r\n * all the options in yet another object. Since this class is instantiated for the default\r\n * options object, abstract properties and callbacks are not included, it's more just\r\n * flag-type options.\r\n */\r\nclass GLTFLoaderBaseOptions {\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load morph targets. Defaults to true.\r\n     */\r\n    public loadMorphTargets = true;\r\n\r\n    /**\r\n     * Defines if the loader should load node animations. Defaults to true.\r\n     * NOTE: The animation of this node will still load if the node is also a joint of a skin and `loadSkins` is true.\r\n     */\r\n    public loadNodeAnimations = true;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load skins. Defaults to true.\r\n     */\r\n    public loadSkins = true;\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * If true, the loader will derive the name for Babylon textures from the glTF texture name, image name, or image url. Defaults to false.\r\n     * Note that it is possible for multiple Babylon textures to share the same name when the Babylon textures load from the same glTF texture or image.\r\n     */\r\n    public useGltfTextureNames = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Load the glTF files using the OpenPBR material.\r\n     * @experimental\r\n     */\r\n    public useOpenPBR = false;\r\n}\r\n\r\n/**\r\n * The default GLTF loader options.\r\n * Override the properties of this object to globally change the default loader options.\r\n * To specify options for a specific load call, pass those options into the associated load function.\r\n */\r\nexport const GLTFLoaderDefaultOptions = new GLTFLoaderBaseOptions();\r\n\r\nabstract class GLTFLoaderOptions extends GLTFLoaderBaseOptions {\r\n    // eslint-disable-next-line babylonjs/available\r\n    protected copyFrom(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        if (options) {\r\n            this.alwaysComputeBoundingBox = options.alwaysComputeBoundingBox ?? this.alwaysComputeBoundingBox;\r\n            this.alwaysComputeSkeletonRootNode = options.alwaysComputeSkeletonRootNode ?? this.alwaysComputeSkeletonRootNode;\r\n            this.animationStartMode = options.animationStartMode ?? this.animationStartMode;\r\n            this.capturePerformanceCounters = options.capturePerformanceCounters ?? this.capturePerformanceCounters;\r\n            this.compileMaterials = options.compileMaterials ?? this.compileMaterials;\r\n            this.compileShadowGenerators = options.compileShadowGenerators ?? this.compileShadowGenerators;\r\n            this.coordinateSystemMode = options.coordinateSystemMode ?? this.coordinateSystemMode;\r\n            this.createInstances = options.createInstances ?? this.createInstances;\r\n            this.customRootNode = options.customRootNode;\r\n            this.extensionOptions = options.extensionOptions ?? this.extensionOptions;\r\n            this.loadAllMaterials = options.loadAllMaterials ?? this.loadAllMaterials;\r\n            this.loadMorphTargets = options.loadMorphTargets ?? this.loadMorphTargets;\r\n            this.loadNodeAnimations = options.loadNodeAnimations ?? this.loadNodeAnimations;\r\n            this.loadOnlyMaterials = options.loadOnlyMaterials ?? this.loadOnlyMaterials;\r\n            this.loadSkins = options.loadSkins ?? this.loadSkins;\r\n            this.loggingEnabled = options.loggingEnabled ?? this.loggingEnabled;\r\n            this.onCameraLoaded = options.onCameraLoaded;\r\n            this.onMaterialLoaded = options.onMaterialLoaded;\r\n            this.onMeshLoaded = options.onMeshLoaded;\r\n            this.onParsed = options.onParsed;\r\n            this.onSkinLoaded = options.onSkinLoaded;\r\n            this.onTextureLoaded = options.onTextureLoaded;\r\n            this.onValidated = options.onValidated;\r\n            this.preprocessUrlAsync = options.preprocessUrlAsync ?? this.preprocessUrlAsync;\r\n            this.skipMaterials = options.skipMaterials ?? this.skipMaterials;\r\n            this.targetFps = options.targetFps ?? this.targetFps;\r\n            this.transparencyAsCoverage = options.transparencyAsCoverage ?? this.transparencyAsCoverage;\r\n            this.useClipPlane = options.useClipPlane ?? this.useClipPlane;\r\n            this.useGltfTextureNames = options.useGltfTextureNames ?? this.useGltfTextureNames;\r\n            this.useOpenPBR = options.useOpenPBR ?? this.useOpenPBR;\r\n            this.useRangeRequests = options.useRangeRequests ?? this.useRangeRequests;\r\n            this.useSRGBBuffers = options.useSRGBBuffers ?? this.useSRGBBuffers;\r\n            this.validate = options.validate ?? this.validate;\r\n        }\r\n    }\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public abstract onParsed?: ((loaderData: IGLTFLoaderData) => void) | undefined;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public abstract capturePerformanceCounters: boolean;\r\n\r\n    /**\r\n     * Defines the node to use as the root of the hierarchy when loading the scene (default: undefined). If not defined, a root node will be automatically created.\r\n     * You can also pass null if you don't want a root node to be created.\r\n     */\r\n    public customRootNode?: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines options for glTF extensions.\r\n     */\r\n    public extensionOptions: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each extension.\r\n        // 2. Creating a mapped type of all the options of all the extensions to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Extension in keyof GLTFLoaderExtensionOptions]?: {\r\n            [Option in keyof DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>]: DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>[Option];\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * If true, enable logging for the loader. Defaults to false.\r\n     */\r\n    public abstract loggingEnabled: boolean;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public abstract onCameraLoaded?: (camera: Camera) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public abstract onMaterialLoaded?: (material: Material) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public abstract onMeshLoaded?: (mesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public abstract onSkinLoaded?: (node: TransformNode, skinnedNode: TransformNode) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public abstract onTextureLoaded?: (texture: BaseTexture) => void;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public abstract onValidated?: (results: GLTF2.IGLTFValidationResults) => void;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url url referenced by the asset\r\n     * @returns Async url to load\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader extends GLTFLoaderOptions implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @internal */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @internal */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /**\r\n     * Creates a new glTF file loader.\r\n     * @param options The options for the loader\r\n     */\r\n    public constructor(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        super();\r\n        this.copyFrom(Object.assign({ ...GLTFLoaderDefaultOptions }, options));\r\n    }\r\n\r\n    // --------------------\r\n    // Begin Common options\r\n    // --------------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: ((loaderData: IGLTFLoaderData) => void) | undefined) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onParsedObserver = this.onParsedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    // ------------------\r\n    // End Common options\r\n    // ------------------\r\n\r\n    // ----------------\r\n    // Begin V1 options\r\n    // ----------------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @internal\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @internal\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // --------------\r\n    // End V1 options\r\n    // --------------\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: ((mesh: AbstractMesh) => void) | undefined) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     * @param node - the transform node that corresponds to the original glTF skin node used for animations\r\n     * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\r\n     */\r\n    public readonly onSkinLoadedObservable = new Observable<{ node: TransformNode; skinnedNode: TransformNode }>();\r\n\r\n    private _onSkinLoadedObserver: Nullable<Observer<{ node: TransformNode; skinnedNode: TransformNode }>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public set onSkinLoaded(callback: ((node: TransformNode, skinnedNode: TransformNode) => void) | undefined) {\r\n        if (this._onSkinLoadedObserver) {\r\n            this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((data) => callback(data.node, data.skinnedNode));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: ((texture: BaseTexture) => void) | undefined) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: ((material: Material) => void) | undefined) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: ((camera: Camera) => void) | undefined) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public readonly name = GLTFFileLoaderMetadata.name;\r\n\r\n    /** @internal */\r\n    public readonly extensions = GLTFFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onSkinLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest> {\r\n        if (ArrayBuffer.isView(fileOrUrl)) {\r\n            this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);\r\n            return null;\r\n        }\r\n\r\n        this._progressCallback = onProgress;\r\n\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, new Uint8Array(data as ArrayBuffer, 0, (data as ArrayBuffer).byteLength), rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        } else {\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    try {\r\n                        this._validate(scene, data as string, rootUrl, fileName);\r\n                        onSuccess({ json: this._parseJson(data as string) });\r\n                    } catch {\r\n                        if (onError) {\r\n                            onError();\r\n                        }\r\n                    }\r\n                },\r\n                false,\r\n                onError\r\n            );\r\n        }\r\n    }\r\n\r\n    private _loadBinary(\r\n        scene: Scene,\r\n        data: ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        fileName?: string\r\n    ): void {\r\n        this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);\r\n        this._unpackBinaryAsync(\r\n            new DataReader({\r\n                readAsync: (byteOffset, byteLength) => readViewAsync(data, byteOffset, byteLength),\r\n                byteLength: data.byteLength,\r\n            })\r\n        ).then(\r\n            (loaderData) => {\r\n                onSuccess(loaderData);\r\n            },\r\n            onError ? (error) => onError(undefined, error) : undefined\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAssetContainerAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            const morphTargetManagers: Array<MorphTargetManager> = [];\r\n            this.onMeshLoadedObservable.add((mesh) => {\r\n                if (mesh.morphTargetManager) {\r\n                    morphTargetManagers.push(mesh.morphTargetManager);\r\n                }\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return GLTFFileLoaderMetadata.canDirectLoad(data);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<object> {\r\n        if (\r\n            data.startsWith(\"base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\";base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @internal */\r\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader(options[GLTFFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add(() => {\r\n            // Force the length computable to be true since we can guarantee the data is loaded.\r\n            request._lengthComputable = true;\r\n            request._total = request._loaded;\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | Uint8Array, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => {\r\n                return scene._loadFileAsync(url, undefined, true, true).then((data) => {\r\n                    return new Uint8Array(data, 0, data.byteLength);\r\n                });\r\n            });\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\r\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @internal */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @internal */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @internal */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @internal */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new GLTFFileLoader());\r\n","import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const GLTFMagicBase64Encoded = \"Z2xURg\"; // \"glTF\" base64 encoded (without the quotes!)\r\n\r\nexport const GLTFFileLoaderMetadata = {\r\n    name: \"gltf\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".gltf\": { isBinary: false, mimeType: \"model/gltf+json\" },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".glb\": { isBinary: true, mimeType: \"model/gltf-binary\" },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n\r\n    canDirectLoad(data: string): boolean {\r\n        return (\r\n            (data.indexOf(\"asset\") !== -1 && data.indexOf(\"version\") !== -1) ||\r\n            data.startsWith(\"data:base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\"data:;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"data:model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        );\r\n    },\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Skeleton } from \"core/Bones/skeleton\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Enums\r\n * @internal\r\n */\r\nexport enum EComponentType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    FLOAT = 5126,\r\n}\r\n\r\n/** @internal */\r\nexport enum EShaderType {\r\n    FRAGMENT = 35632,\r\n    VERTEX = 35633,\r\n}\r\n\r\n/** @internal */\r\nexport enum EParameterType {\r\n    BYTE = 5120,\r\n    UNSIGNED_BYTE = 5121,\r\n    SHORT = 5122,\r\n    UNSIGNED_SHORT = 5123,\r\n    INT = 5124,\r\n    UNSIGNED_INT = 5125,\r\n    FLOAT = 5126,\r\n    FLOAT_VEC2 = 35664,\r\n    FLOAT_VEC3 = 35665,\r\n    FLOAT_VEC4 = 35666,\r\n    INT_VEC2 = 35667,\r\n    INT_VEC3 = 35668,\r\n    INT_VEC4 = 35669,\r\n    BOOL = 35670,\r\n    BOOL_VEC2 = 35671,\r\n    BOOL_VEC3 = 35672,\r\n    BOOL_VEC4 = 35673,\r\n    FLOAT_MAT2 = 35674,\r\n    FLOAT_MAT3 = 35675,\r\n    FLOAT_MAT4 = 35676,\r\n    SAMPLER_2D = 35678,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureWrapMode {\r\n    CLAMP_TO_EDGE = 33071,\r\n    MIRRORED_REPEAT = 33648,\r\n    REPEAT = 10497,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFilterType {\r\n    NEAREST = 9728,\r\n    LINEAR = 9728,\r\n    NEAREST_MIPMAP_NEAREST = 9984,\r\n    LINEAR_MIPMAP_NEAREST = 9985,\r\n    NEAREST_MIPMAP_LINEAR = 9986,\r\n    LINEAR_MIPMAP_LINEAR = 9987,\r\n}\r\n\r\n/** @internal */\r\nexport enum ETextureFormat {\r\n    ALPHA = 6406,\r\n    RGB = 6407,\r\n    RGBA = 6408,\r\n    LUMINANCE = 6409,\r\n    LUMINANCE_ALPHA = 6410,\r\n}\r\n\r\n/** @internal */\r\nexport enum ECullingType {\r\n    FRONT = 1028,\r\n    BACK = 1029,\r\n    FRONT_AND_BACK = 1032,\r\n}\r\n\r\n/** @internal */\r\nexport enum EBlendingFunction {\r\n    ZERO = 0,\r\n    ONE = 1,\r\n    SRC_COLOR = 768,\r\n    ONE_MINUS_SRC_COLOR = 769,\r\n    DST_COLOR = 774,\r\n    ONE_MINUS_DST_COLOR = 775,\r\n    SRC_ALPHA = 770,\r\n    ONE_MINUS_SRC_ALPHA = 771,\r\n    DST_ALPHA = 772,\r\n    ONE_MINUS_DST_ALPHA = 773,\r\n    CONSTANT_COLOR = 32769,\r\n    ONE_MINUS_CONSTANT_COLOR = 32770,\r\n    CONSTANT_ALPHA = 32771,\r\n    ONE_MINUS_CONSTANT_ALPHA = 32772,\r\n    SRC_ALPHA_SATURATE = 776,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProperty {\r\n    extensions?: { [key: string]: any };\r\n    extras?: object;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFChildRootProperty extends IGLTFProperty {\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAccessor extends IGLTFChildRootProperty {\r\n    bufferView: string;\r\n    byteOffset: number;\r\n    byteStride: number;\r\n    count: number;\r\n    type: string;\r\n    componentType: EComponentType;\r\n\r\n    max?: number[];\r\n    min?: number[];\r\n    name?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBufferView extends IGLTFChildRootProperty {\r\n    buffer: string;\r\n    byteOffset: number;\r\n    byteLength: number;\r\n    byteStride: number;\r\n\r\n    target?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFBuffer extends IGLTFChildRootProperty {\r\n    uri: string;\r\n\r\n    byteLength?: number;\r\n    type?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFShader extends IGLTFChildRootProperty {\r\n    uri: string;\r\n    type: EShaderType;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFProgram extends IGLTFChildRootProperty {\r\n    attributes: string[];\r\n    fragmentShader: string;\r\n    vertexShader: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueParameter {\r\n    type: number;\r\n\r\n    count?: number;\r\n    semantic?: string;\r\n    node?: string;\r\n    value?: number | boolean | string | Array<any>;\r\n    source?: string;\r\n\r\n    babylonValue?: any;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueCommonProfile {\r\n    lightingModel: string;\r\n    texcoordBindings: object;\r\n\r\n    parameters?: Array<any>;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStatesFunctions {\r\n    blendColor?: number[];\r\n    blendEquationSeparate?: number[];\r\n    blendFuncSeparate?: number[];\r\n    colorMask: boolean[];\r\n    cullFace: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechniqueStates {\r\n    enable: number[];\r\n    functions: IGLTFTechniqueStatesFunctions;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTechnique extends IGLTFChildRootProperty {\r\n    parameters: { [key: string]: IGLTFTechniqueParameter };\r\n    program: string;\r\n\r\n    attributes: { [key: string]: string };\r\n    uniforms: { [key: string]: string };\r\n    states: IGLTFTechniqueStates;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMaterial extends IGLTFChildRootProperty {\r\n    technique?: string;\r\n    values: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMeshPrimitive extends IGLTFProperty {\r\n    attributes: { [key: string]: string };\r\n    indices: string;\r\n    material: string;\r\n\r\n    mode?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFMesh extends IGLTFChildRootProperty {\r\n    primitives: IGLTFMeshPrimitive[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFImage extends IGLTFChildRootProperty {\r\n    uri: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSampler extends IGLTFChildRootProperty {\r\n    magFilter?: number;\r\n    minFilter?: number;\r\n    wrapS?: number;\r\n    wrapT?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFTexture extends IGLTFChildRootProperty {\r\n    sampler: string;\r\n    source: string;\r\n\r\n    format?: ETextureFormat;\r\n    internalFormat?: ETextureFormat;\r\n    target?: number;\r\n    type?: number;\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonTexture?: Texture;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAmbienLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFDirectionalLight {\r\n    color?: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFPointLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSpotLight {\r\n    color?: number[];\r\n    constantAttenuation?: number;\r\n    fallOfAngle?: number;\r\n    fallOffExponent?: number;\r\n    linearAttenuation?: number;\r\n    quadraticAttenuation?: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLight extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraOrthographic {\r\n    xmag: number;\r\n    ymag: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCameraPerspective {\r\n    aspectRatio: number;\r\n    yfov: number;\r\n    zfar: number;\r\n    znear: number;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFCamera extends IGLTFChildRootProperty {\r\n    type: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannelTarget {\r\n    id: string;\r\n    path: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationChannel {\r\n    sampler: string;\r\n    target: IGLTFAnimationChannelTarget;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimationSampler {\r\n    input: string;\r\n    output: string;\r\n\r\n    interpolation?: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFAnimation extends IGLTFChildRootProperty {\r\n    channels?: IGLTFAnimationChannel[];\r\n    parameters?: { [key: string]: string };\r\n    samplers?: { [key: string]: IGLTFAnimationSampler };\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNodeInstanceSkin {\r\n    skeletons: string[];\r\n    skin: string;\r\n    meshes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFSkins extends IGLTFChildRootProperty {\r\n    bindShapeMatrix: number[];\r\n    inverseBindMatrices: string;\r\n    jointNames: string[];\r\n\r\n    babylonSkeleton?: Skeleton;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFNode extends IGLTFChildRootProperty {\r\n    camera?: string;\r\n    children: string[];\r\n    skin?: string;\r\n    jointName?: string;\r\n    light?: string;\r\n    matrix: number[];\r\n    mesh?: string;\r\n    meshes?: string[];\r\n    rotation?: number[];\r\n    scale?: number[];\r\n    translation?: number[];\r\n\r\n    // Babylon.js values (optimize)\r\n    babylonNode?: Node;\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFScene extends IGLTFChildRootProperty {\r\n    nodes: string[];\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFRuntime {\r\n    extensions: { [key: string]: any };\r\n    accessors: { [key: string]: IGLTFAccessor };\r\n    buffers: { [key: string]: IGLTFBuffer };\r\n    bufferViews: { [key: string]: IGLTFBufferView };\r\n    meshes: { [key: string]: IGLTFMesh };\r\n    lights: { [key: string]: IGLTFLight };\r\n    cameras: { [key: string]: IGLTFCamera };\r\n    nodes: { [key: string]: IGLTFNode };\r\n    images: { [key: string]: IGLTFImage };\r\n    textures: { [key: string]: IGLTFTexture };\r\n    shaders: { [key: string]: IGLTFShader };\r\n    programs: { [key: string]: IGLTFProgram };\r\n    samplers: { [key: string]: IGLTFSampler };\r\n    techniques: { [key: string]: IGLTFTechnique };\r\n    materials: { [key: string]: IGLTFMaterial };\r\n    animations: { [key: string]: IGLTFAnimation };\r\n    skins: { [key: string]: IGLTFSkins };\r\n\r\n    currentScene?: object;\r\n    scenes: { [key: string]: IGLTFScene }; // v1.1\r\n\r\n    extensionsUsed: string[];\r\n    extensionsRequired?: string[]; // v1.1\r\n\r\n    buffersCount: number;\r\n    shaderscount: number;\r\n\r\n    scene: Scene;\r\n    rootUrl: string;\r\n\r\n    loadedBufferCount: number;\r\n    loadedBufferViews: { [name: string]: ArrayBufferView };\r\n\r\n    loadedShaderCount: number;\r\n\r\n    importOnlyMeshes: boolean;\r\n    importMeshesNames?: string[];\r\n\r\n    dummyNodes: Node[];\r\n\r\n    assetContainer: Nullable<AssetContainer>;\r\n}\r\n\r\n/** @internal */\r\nexport interface INodeToRoot {\r\n    bone: Bone;\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface IJointNode {\r\n    node: IGLTFNode;\r\n    id: string;\r\n}\r\n","import type { IGLTFTechniqueParameter, IGLTFAccessor, IGLTFRuntime, IGLTFBufferView } from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureWrapMode, ETextureFilterType, EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2, Vector3, Vector4, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\n/**\r\n * Utils functions for GLTF\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFUtils {\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param scene the Scene object\r\n     * @param source the source node where to pick the matrix\r\n     * @param parameter the GLTF technique parameter\r\n     * @param uniformName the name of the shader's uniform\r\n     * @param shaderMaterial the shader material\r\n     */\r\n    public static SetMatrix(scene: Scene, source: Node, parameter: IGLTFTechniqueParameter, uniformName: string, shaderMaterial: ShaderMaterial | Effect): void {\r\n        let mat: Nullable<Matrix> = null;\r\n\r\n        if (parameter.semantic === \"MODEL\") {\r\n            mat = source.getWorldMatrix();\r\n        } else if (parameter.semantic === \"PROJECTION\") {\r\n            mat = scene.getProjectionMatrix();\r\n        } else if (parameter.semantic === \"VIEW\") {\r\n            mat = scene.getViewMatrix();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());\r\n        } else if (parameter.semantic === \"MODELVIEW\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix());\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTION\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());\r\n        } else if (parameter.semantic === \"MODELINVERSE\") {\r\n            mat = source.getWorldMatrix().invert();\r\n        } else if (parameter.semantic === \"VIEWINVERSE\") {\r\n            mat = scene.getViewMatrix().invert();\r\n        } else if (parameter.semantic === \"PROJECTIONINVERSE\") {\r\n            mat = scene.getProjectionMatrix().invert();\r\n        } else if (parameter.semantic === \"MODELVIEWINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELVIEWPROJECTIONINVERSE\") {\r\n            mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();\r\n        } else if (parameter.semantic === \"MODELINVERSETRANSPOSE\") {\r\n            mat = Matrix.Transpose(source.getWorldMatrix().invert());\r\n        }\r\n\r\n        if (mat) {\r\n            switch (parameter.type) {\r\n                case EParameterType.FLOAT_MAT2:\r\n                    shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT3:\r\n                    shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));\r\n                    break;\r\n                case EParameterType.FLOAT_MAT4:\r\n                    shaderMaterial.setMatrix(uniformName, mat);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the given \"parameter\" matrix\r\n     * @param shaderMaterial the shader material\r\n     * @param uniform the name of the shader's uniform\r\n     * @param value the value of the uniform\r\n     * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)\r\n     * @returns true if set, else false\r\n     */\r\n    public static SetUniform(shaderMaterial: ShaderMaterial | Effect, uniform: string, value: any, type: number): boolean {\r\n        switch (type) {\r\n            case EParameterType.FLOAT:\r\n                shaderMaterial.setFloat(uniform, value);\r\n                return true;\r\n            case EParameterType.FLOAT_VEC2:\r\n                shaderMaterial.setVector2(uniform, Vector2.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC3:\r\n                shaderMaterial.setVector3(uniform, Vector3.FromArray(value));\r\n                return true;\r\n            case EParameterType.FLOAT_VEC4:\r\n                shaderMaterial.setVector4(uniform, Vector4.FromArray(value));\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the wrap mode of the texture\r\n     * @param mode the mode value\r\n     * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)\r\n     */\r\n    public static GetWrapMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case ETextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case ETextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the byte stride giving an accessor\r\n     * @param accessor the GLTF accessor objet\r\n     * @returns the byte stride\r\n     */\r\n    public static GetByteStrideFromType(accessor: IGLTFAccessor): number {\r\n        // Needs this function since \"byteStride\" isn't requiered in glTF format\r\n        const type = accessor.type;\r\n\r\n        switch (type) {\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n            default:\r\n                return 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the texture filter mode giving a mode value\r\n     * @param mode the filter mode value\r\n     * @returns the filter mode (TODO - needs to be a type?)\r\n     */\r\n    public static GetTextureFilterMode(mode: number): number {\r\n        switch (mode) {\r\n            case ETextureFilterType.LINEAR:\r\n            case ETextureFilterType.LINEAR_MIPMAP_NEAREST:\r\n            case ETextureFilterType.LINEAR_MIPMAP_LINEAR:\r\n                return Texture.TRILINEAR_SAMPLINGMODE;\r\n            case ETextureFilterType.NEAREST:\r\n            case ETextureFilterType.NEAREST_MIPMAP_NEAREST:\r\n                return Texture.NEAREST_SAMPLINGMODE;\r\n            default:\r\n                return Texture.BILINEAR_SAMPLINGMODE;\r\n        }\r\n    }\r\n\r\n    public static GetBufferFromBufferView(\r\n        gltfRuntime: IGLTFRuntime,\r\n        bufferView: IGLTFBufferView,\r\n        byteOffset: number,\r\n        byteLength: number,\r\n        componentType: EComponentType\r\n    ): ArrayBufferView {\r\n        byteOffset = bufferView.byteOffset + byteOffset;\r\n\r\n        const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];\r\n        if (byteOffset + byteLength > loadedBufferView.byteLength) {\r\n            throw new Error(\"Buffer access is out of range\");\r\n        }\r\n\r\n        const buffer = loadedBufferView.buffer;\r\n        byteOffset += loadedBufferView.byteOffset;\r\n\r\n        switch (componentType) {\r\n            case EComponentType.BYTE:\r\n                return new Int8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_BYTE:\r\n                return new Uint8Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.SHORT:\r\n                return new Int16Array(buffer, byteOffset, byteLength);\r\n            case EComponentType.UNSIGNED_SHORT:\r\n                return new Uint16Array(buffer, byteOffset, byteLength);\r\n            default:\r\n                return new Float32Array(buffer, byteOffset, byteLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a buffer from its accessor\r\n     * @param gltfRuntime the GLTF runtime\r\n     * @param accessor the GLTF accessor\r\n     * @returns an array buffer view\r\n     */\r\n    public static GetBufferFromAccessor(gltfRuntime: IGLTFRuntime, accessor: IGLTFAccessor): any {\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[accessor.bufferView];\r\n        const byteLength = accessor.count * GLTFUtils.GetByteStrideFromType(accessor);\r\n        return GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);\r\n    }\r\n\r\n    /**\r\n     * Decodes a buffer view into a string\r\n     * @param view the buffer view\r\n     * @returns a string\r\n     */\r\n    public static DecodeBufferToText(view: ArrayBufferView): string {\r\n        let result = \"\";\r\n        const length = view.byteLength;\r\n\r\n        for (let i = 0; i < length; ++i) {\r\n            result += String.fromCharCode((<any>view)[i]);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the default material of gltf. Related to\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material\r\n     * @param scene the Babylon.js scene\r\n     * @returns the default Babylon material\r\n     */\r\n    public static GetDefaultMaterial(scene: Scene): ShaderMaterial {\r\n        if (!GLTFUtils._DefaultMaterial) {\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialVertexShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform mat4 worldView;\",\r\n                \"uniform mat4 projection;\",\r\n                \"\",\r\n                \"attribute vec3 position;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_Position = projection * worldView * vec4(position, 1.0);\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            Effect.ShadersStore[\"GLTFDefaultMaterialPixelShader\"] = [\r\n                \"precision highp float;\",\r\n                \"\",\r\n                \"uniform vec4 u_emission;\",\r\n                \"\",\r\n                \"void main(void)\",\r\n                \"{\",\r\n                \"    gl_FragColor = u_emission;\",\r\n                \"}\",\r\n            ].join(\"\\n\");\r\n\r\n            const shaderPath = {\r\n                vertex: \"GLTFDefaultMaterial\",\r\n                fragment: \"GLTFDefaultMaterial\",\r\n            };\r\n\r\n            const options = {\r\n                attributes: [\"position\"],\r\n                uniforms: [\"worldView\", \"projection\", \"u_emission\"],\r\n                samplers: new Array<string>(),\r\n                needAlphaBlending: false,\r\n            };\r\n\r\n            GLTFUtils._DefaultMaterial = new ShaderMaterial(\"GLTFDefaultMaterial\", scene, shaderPath, options);\r\n            GLTFUtils._DefaultMaterial.setColor4(\"u_emission\", new Color4(0.5, 0.5, 0.5, 1.0));\r\n        }\r\n\r\n        return GLTFUtils._DefaultMaterial;\r\n    }\r\n\r\n    // The GLTF default material\r\n    private static _DefaultMaterial: Nullable<ShaderMaterial> = null;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport type {\r\n    IGLTFRuntime,\r\n    IGLTFTechniqueParameter,\r\n    IGLTFAnimation,\r\n    IGLTFAnimationSampler,\r\n    IGLTFNode,\r\n    IGLTFSkins,\r\n    INodeToRoot,\r\n    IJointNode,\r\n    IGLTFMesh,\r\n    IGLTFAccessor,\r\n    IGLTFLight,\r\n    IGLTFAmbienLight,\r\n    IGLTFDirectionalLight,\r\n    IGLTFPointLight,\r\n    IGLTFSpotLight,\r\n    IGLTFCamera,\r\n    IGLTFCameraPerspective,\r\n    IGLTFScene,\r\n    IGLTFTechnique,\r\n    IGLTFMaterial,\r\n    IGLTFProgram,\r\n    IGLTFBuffer,\r\n    IGLTFTexture,\r\n    IGLTFImage,\r\n    IGLTFSampler,\r\n    IGLTFShader,\r\n    IGLTFTechniqueStates,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport { EParameterType, ETextureFilterType, ECullingType, EBlendingFunction, EShaderType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { FloatArray, Nullable } from \"core/types\";\r\nimport { Quaternion, Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { ShaderMaterial } from \"core/Materials/shaderMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { Node } from \"core/node\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { SubMesh } from \"core/Meshes/subMesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader } from \"../glTFFileLoader\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n\r\n/**\r\n * Tokenizer. Used for shaders compatibility\r\n * Automatically map world, view, projection, worldViewProjection, attributes and so on\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum ETokenType {\r\n    IDENTIFIER = 1,\r\n\r\n    UNKNOWN = 2,\r\n    END_OF_INPUT = 3,\r\n}\r\n\r\nclass Tokenizer {\r\n    private _toParse: string;\r\n    private _pos: number = 0;\r\n    private _maxPos: number;\r\n\r\n    public currentToken: ETokenType = ETokenType.UNKNOWN;\r\n    public currentIdentifier: string = \"\";\r\n    public currentString: string = \"\";\r\n    public isLetterOrDigitPattern: RegExp = /^[a-zA-Z0-9]+$/;\r\n\r\n    constructor(toParse: string) {\r\n        this._toParse = toParse;\r\n        this._maxPos = toParse.length;\r\n    }\r\n\r\n    public getNextToken(): ETokenType {\r\n        if (this.isEnd()) {\r\n            return ETokenType.END_OF_INPUT;\r\n        }\r\n\r\n        this.currentString = this.read();\r\n        this.currentToken = ETokenType.UNKNOWN;\r\n\r\n        if (this.currentString === \"_\" || this.isLetterOrDigitPattern.test(this.currentString)) {\r\n            this.currentToken = ETokenType.IDENTIFIER;\r\n            this.currentIdentifier = this.currentString;\r\n            while (!this.isEnd() && (this.isLetterOrDigitPattern.test((this.currentString = this.peek())) || this.currentString === \"_\")) {\r\n                this.currentIdentifier += this.currentString;\r\n                this.forward();\r\n            }\r\n        }\r\n\r\n        return this.currentToken;\r\n    }\r\n\r\n    public peek(): string {\r\n        return this._toParse[this._pos];\r\n    }\r\n\r\n    public read(): string {\r\n        return this._toParse[this._pos++];\r\n    }\r\n\r\n    public forward(): void {\r\n        this._pos++;\r\n    }\r\n\r\n    public isEnd(): boolean {\r\n        return this._pos >= this._maxPos;\r\n    }\r\n}\r\n\r\n/**\r\n * Values\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFTransforms = [\"MODEL\", \"VIEW\", \"PROJECTION\", \"MODELVIEW\", \"MODELVIEWPROJECTION\", \"JOINTMATRIX\"];\r\nconst BabylonTransforms = [\"world\", \"view\", \"projection\", \"worldView\", \"worldViewProjection\", \"mBones\"];\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nconst glTFAnimationPaths = [\"translation\", \"rotation\", \"scale\"];\r\nconst BabylonAnimationPaths = [\"position\", \"rotationQuaternion\", \"scaling\"];\r\n\r\n/**\r\n * Parse\r\n * @param parsedBuffers\r\n * @param gltfRuntime\r\n */\r\nconst ParseBuffers = (parsedBuffers: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const buf in parsedBuffers) {\r\n        const parsedBuffer = parsedBuffers[buf];\r\n        gltfRuntime.buffers[buf] = parsedBuffer;\r\n        gltfRuntime.buffersCount++;\r\n    }\r\n};\r\n\r\nconst ParseShaders = (parsedShaders: any, gltfRuntime: IGLTFRuntime) => {\r\n    for (const sha in parsedShaders) {\r\n        const parsedShader = parsedShaders[sha];\r\n        gltfRuntime.shaders[sha] = parsedShader;\r\n        gltfRuntime.shaderscount++;\r\n    }\r\n};\r\n\r\nconst ParseObject = (parsedObjects: any, runtimeProperty: string, gltfRuntime: IGLTFRuntime) => {\r\n    for (const object in parsedObjects) {\r\n        const parsedObject = parsedObjects[object];\r\n        (<any>gltfRuntime)[runtimeProperty][object] = parsedObject;\r\n    }\r\n};\r\n\r\n/**\r\n * Utils\r\n * @param buffer\r\n */\r\nconst NormalizeUVs = (buffer: any) => {\r\n    if (!buffer) {\r\n        return;\r\n    }\r\n\r\n    for (let i = 0; i < buffer.length / 2; i++) {\r\n        buffer[i * 2 + 1] = 1.0 - buffer[i * 2 + 1];\r\n    }\r\n};\r\n\r\nconst GetAttribute = (attributeParameter: IGLTFTechniqueParameter): Nullable<string> => {\r\n    if (attributeParameter.semantic === \"NORMAL\") {\r\n        return \"normal\";\r\n    } else if (attributeParameter.semantic === \"POSITION\") {\r\n        return \"position\";\r\n    } else if (attributeParameter.semantic === \"JOINT\") {\r\n        return \"matricesIndices\";\r\n    } else if (attributeParameter.semantic === \"WEIGHT\") {\r\n        return \"matricesWeights\";\r\n    } else if (attributeParameter.semantic === \"COLOR\") {\r\n        return \"color\";\r\n    } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n        const channel = Number(attributeParameter.semantic.split(\"_\")[1]);\r\n        return \"uv\" + (channel === 0 ? \"\" : channel + 1);\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Loads and creates animations\r\n * @param gltfRuntime\r\n */\r\nconst LoadAnimations = (gltfRuntime: IGLTFRuntime) => {\r\n    for (const anim in gltfRuntime.animations) {\r\n        const animation: IGLTFAnimation = gltfRuntime.animations[anim];\r\n\r\n        if (!animation.channels || !animation.samplers) {\r\n            continue;\r\n        }\r\n\r\n        let lastAnimation: Nullable<Animation> = null;\r\n\r\n        for (let i = 0; i < animation.channels.length; i++) {\r\n            // Get parameters and load buffers\r\n            const channel = animation.channels[i];\r\n            const sampler: IGLTFAnimationSampler = animation.samplers[channel.sampler];\r\n\r\n            if (!sampler) {\r\n                continue;\r\n            }\r\n\r\n            let inputData: Nullable<string> = null;\r\n            let outputData: Nullable<string> = null;\r\n\r\n            if (animation.parameters) {\r\n                inputData = animation.parameters[sampler.input];\r\n                outputData = animation.parameters[sampler.output];\r\n            } else {\r\n                inputData = sampler.input;\r\n                outputData = sampler.output;\r\n            }\r\n\r\n            const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);\r\n            const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);\r\n\r\n            const targetId = channel.target.id;\r\n            let targetNode: any = gltfRuntime.scene.getNodeById(targetId);\r\n\r\n            if (targetNode === null) {\r\n                targetNode = gltfRuntime.scene.getNodeByName(targetId);\r\n            }\r\n\r\n            if (targetNode === null) {\r\n                Tools.Warn(\"Creating animation named \" + anim + \". But cannot find node named \" + targetId + \" to attach to\");\r\n                continue;\r\n            }\r\n\r\n            const isBone = targetNode instanceof Bone;\r\n\r\n            // Get target path (position, rotation or scaling)\r\n            let targetPath = channel.target.path;\r\n            const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);\r\n\r\n            if (targetPathIndex !== -1) {\r\n                targetPath = BabylonAnimationPaths[targetPathIndex];\r\n            }\r\n\r\n            // Determine animation type\r\n            let animationType = Animation.ANIMATIONTYPE_MATRIX;\r\n\r\n            if (!isBone) {\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    animationType = Animation.ANIMATIONTYPE_QUATERNION;\r\n                    targetNode.rotationQuaternion = new Quaternion();\r\n                } else {\r\n                    animationType = Animation.ANIMATIONTYPE_VECTOR3;\r\n                }\r\n            }\r\n\r\n            // Create animation and key frames\r\n            let babylonAnimation: Nullable<Animation> = null;\r\n            const keys = [];\r\n            let arrayOffset = 0;\r\n            let modifyKey = false;\r\n\r\n            if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {\r\n                babylonAnimation = lastAnimation;\r\n                modifyKey = true;\r\n            }\r\n\r\n            if (!modifyKey) {\r\n                gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n                babylonAnimation = new Animation(anim, isBone ? \"_matrix\" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);\r\n                gltfRuntime.scene._blockEntityCollection = false;\r\n            }\r\n\r\n            // For each frame\r\n            for (let j = 0; j < bufferInput.length; j++) {\r\n                let value: any = null;\r\n\r\n                if (targetPath === \"rotationQuaternion\") {\r\n                    // VEC4\r\n                    value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);\r\n                    arrayOffset += 4;\r\n                } else {\r\n                    // Position and scaling are VEC3\r\n                    value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);\r\n                    arrayOffset += 3;\r\n                }\r\n\r\n                if (isBone) {\r\n                    const bone = <Bone>targetNode;\r\n                    let translation = Vector3.Zero();\r\n                    let rotationQuaternion = new Quaternion();\r\n                    let scaling = Vector3.Zero();\r\n\r\n                    // Warning on decompose\r\n                    let mat = bone.getBaseMatrix();\r\n\r\n                    if (modifyKey && lastAnimation) {\r\n                        mat = lastAnimation.getKeys()[j].value;\r\n                    }\r\n\r\n                    mat.decompose(scaling, rotationQuaternion, translation);\r\n\r\n                    if (targetPath === \"position\") {\r\n                        translation = value;\r\n                    } else if (targetPath === \"rotationQuaternion\") {\r\n                        rotationQuaternion = value;\r\n                    } else {\r\n                        scaling = value;\r\n                    }\r\n\r\n                    value = Matrix.Compose(scaling, rotationQuaternion, translation);\r\n                }\r\n\r\n                if (!modifyKey) {\r\n                    keys.push({\r\n                        frame: bufferInput[j],\r\n                        value: value,\r\n                    });\r\n                } else if (lastAnimation) {\r\n                    lastAnimation.getKeys()[j].value = value;\r\n                }\r\n            }\r\n\r\n            // Finish\r\n            if (!modifyKey && babylonAnimation) {\r\n                babylonAnimation.setKeys(keys);\r\n                targetNode.animations.push(babylonAnimation);\r\n            }\r\n\r\n            lastAnimation = babylonAnimation;\r\n\r\n            gltfRuntime.scene.stopAnimation(targetNode);\r\n            gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1.0);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * @returns the bones transformation matrix\r\n * @param node\r\n */\r\nconst ConfigureBoneTransformation = (node: IGLTFNode): Matrix => {\r\n    let mat: Nullable<Matrix> = null;\r\n\r\n    if (node.translation || node.rotation || node.scale) {\r\n        const scale = Vector3.FromArray(node.scale || [1, 1, 1]);\r\n        const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);\r\n        const position = Vector3.FromArray(node.translation || [0, 0, 0]);\r\n\r\n        mat = Matrix.Compose(scale, rotation, position);\r\n    } else {\r\n        mat = Matrix.FromArray(node.matrix);\r\n    }\r\n\r\n    return mat;\r\n};\r\n\r\n/**\r\n * Returns the parent bone\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param jointName\r\n * @param newSkeleton\r\n * @returns the parent bone\r\n */\r\nconst GetParentBone = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, jointName: string, newSkeleton: Skeleton): Nullable<Bone> => {\r\n    // Try to find\r\n    for (let i = 0; i < newSkeleton.bones.length; i++) {\r\n        if (newSkeleton.bones[i].name === jointName) {\r\n            return newSkeleton.bones[i];\r\n        }\r\n    }\r\n\r\n    // Not found, search in gltf nodes\r\n    const nodes = gltfRuntime.nodes;\r\n    for (const nde in nodes) {\r\n        const node: IGLTFNode = nodes[nde];\r\n\r\n        if (!node.jointName) {\r\n            continue;\r\n        }\r\n\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child: IGLTFNode = gltfRuntime.nodes[children[i]];\r\n            if (!child.jointName) {\r\n                continue;\r\n            }\r\n\r\n            if (child.jointName === jointName) {\r\n                const mat = ConfigureBoneTransformation(node);\r\n                const bone = new Bone(node.name || \"\", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);\r\n                bone.id = nde;\r\n                return bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the appropriate root node\r\n * @param nodesToRoot\r\n * @param id\r\n * @returns the root node\r\n */\r\nconst GetNodeToRoot = (nodesToRoot: INodeToRoot[], id: string): Nullable<Bone> => {\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n\r\n        for (let j = 0; j < nodeToRoot.node.children.length; j++) {\r\n            const child = nodeToRoot.node.children[j];\r\n            if (child === id) {\r\n                return nodeToRoot.bone;\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Returns the node with the joint name\r\n * @param gltfRuntime\r\n * @param jointName\r\n * @returns the node with the joint name\r\n */\r\nconst GetJointNode = (gltfRuntime: IGLTFRuntime, jointName: string): Nullable<IJointNode> => {\r\n    const nodes = gltfRuntime.nodes;\r\n    let node: IGLTFNode = nodes[jointName];\r\n    if (node) {\r\n        return {\r\n            node: node,\r\n            id: jointName,\r\n        };\r\n    }\r\n\r\n    for (const nde in nodes) {\r\n        node = nodes[nde];\r\n        if (node.jointName === jointName) {\r\n            return {\r\n                node: node,\r\n                id: nde,\r\n            };\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Checks if a nodes is in joints\r\n * @param skins\r\n * @param id\r\n * @returns true if the node is in joints, else false\r\n */\r\nconst NodeIsInJoints = (skins: IGLTFSkins, id: string): boolean => {\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        if (skins.jointNames[i] === id) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\n/**\r\n * Fills the nodes to root for bones and builds hierarchy\r\n * @param gltfRuntime\r\n * @param newSkeleton\r\n * @param skins\r\n * @param nodesToRoot\r\n */\r\nconst GetNodesToRoot = (gltfRuntime: IGLTFRuntime, newSkeleton: Skeleton, skins: IGLTFSkins, nodesToRoot: INodeToRoot[]) => {\r\n    // Creates nodes for root\r\n    for (const nde in gltfRuntime.nodes) {\r\n        const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n        const id = nde;\r\n\r\n        if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {\r\n            continue;\r\n        }\r\n\r\n        // Create node to root bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n        const bone = new Bone(node.name || \"\", newSkeleton, null, mat);\r\n        bone.id = id;\r\n        nodesToRoot.push({ bone: bone, node: node, id: id });\r\n    }\r\n\r\n    // Parenting\r\n    for (let i = 0; i < nodesToRoot.length; i++) {\r\n        const nodeToRoot = nodesToRoot[i];\r\n        const children = nodeToRoot.node.children;\r\n\r\n        for (let j = 0; j < children.length; j++) {\r\n            let child: Nullable<INodeToRoot> = null;\r\n\r\n            for (let k = 0; k < nodesToRoot.length; k++) {\r\n                if (nodesToRoot[k].id === children[j]) {\r\n                    child = nodesToRoot[k];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (child) {\r\n                (<any>child.bone)._parent = nodeToRoot.bone;\r\n                nodeToRoot.bone.children.push(child.bone);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Imports a skeleton\r\n * @param gltfRuntime\r\n * @param skins\r\n * @param mesh\r\n * @param newSkeleton\r\n * @returns the bone name\r\n */\r\nconst ImportSkeleton = (gltfRuntime: IGLTFRuntime, skins: IGLTFSkins, mesh: Mesh, newSkeleton: Skeleton | undefined): Skeleton => {\r\n    if (!newSkeleton) {\r\n        newSkeleton = new Skeleton(skins.name || \"\", \"\", gltfRuntime.scene);\r\n    }\r\n\r\n    if (!skins.babylonSkeleton) {\r\n        return newSkeleton;\r\n    }\r\n\r\n    // Find the root bones\r\n    const nodesToRoot: INodeToRoot[] = [];\r\n    const nodesToRootToAdd: Bone[] = [];\r\n\r\n    GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);\r\n    newSkeleton.bones = [];\r\n\r\n    // Joints\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        const node = jointNode.node;\r\n\r\n        if (!node) {\r\n            Tools.Warn(\"Joint named \" + skins.jointNames[i] + \" does not exist\");\r\n            continue;\r\n        }\r\n\r\n        const id = jointNode.id;\r\n\r\n        // Optimize, if the bone already exists...\r\n        const existingBone = gltfRuntime.scene.getBoneById(id);\r\n        if (existingBone) {\r\n            newSkeleton.bones.push(existingBone);\r\n            continue;\r\n        }\r\n\r\n        // Search for parent bone\r\n        let foundBone = false;\r\n        let parentBone: Nullable<Bone> = null;\r\n\r\n        for (let j = 0; j < i; j++) {\r\n            const jointNode = GetJointNode(gltfRuntime, skins.jointNames[j]);\r\n\r\n            if (!jointNode) {\r\n                continue;\r\n            }\r\n\r\n            const joint: IGLTFNode = jointNode.node;\r\n\r\n            if (!joint) {\r\n                Tools.Warn(\"Joint named \" + skins.jointNames[j] + \" does not exist when looking for parent\");\r\n                continue;\r\n            }\r\n\r\n            const children = joint.children;\r\n            if (!children) {\r\n                continue;\r\n            }\r\n            foundBone = false;\r\n\r\n            for (let k = 0; k < children.length; k++) {\r\n                if (children[k] === id) {\r\n                    parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);\r\n                    foundBone = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundBone) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Create bone\r\n        const mat = ConfigureBoneTransformation(node);\r\n\r\n        if (!parentBone && nodesToRoot.length > 0) {\r\n            parentBone = GetNodeToRoot(nodesToRoot, id);\r\n\r\n            if (parentBone) {\r\n                if (nodesToRootToAdd.indexOf(parentBone) === -1) {\r\n                    nodesToRootToAdd.push(parentBone);\r\n                }\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(node.jointName || \"\", newSkeleton, parentBone, mat);\r\n        bone.id = id;\r\n    }\r\n\r\n    // Polish\r\n    const bones = newSkeleton.bones;\r\n    newSkeleton.bones = [];\r\n\r\n    for (let i = 0; i < skins.jointNames.length; i++) {\r\n        const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);\r\n\r\n        if (!jointNode) {\r\n            continue;\r\n        }\r\n\r\n        for (let j = 0; j < bones.length; j++) {\r\n            if (bones[j].id === jointNode.id) {\r\n                newSkeleton.bones.push(bones[j]);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    newSkeleton.prepare();\r\n\r\n    // Finish\r\n    for (let i = 0; i < nodesToRootToAdd.length; i++) {\r\n        newSkeleton.bones.push(nodesToRootToAdd[i]);\r\n    }\r\n\r\n    return newSkeleton;\r\n};\r\n\r\n/**\r\n * Imports a mesh and its geometries\r\n * @param gltfRuntime\r\n * @param node\r\n * @param meshes\r\n * @param id\r\n * @param newMesh\r\n * @returns the new mesh\r\n */\r\nconst ImportMesh = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, meshes: string[], id: string, newMesh: Mesh): Mesh => {\r\n    if (!newMesh) {\r\n        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n        newMesh = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n        newMesh._parentContainer = gltfRuntime.assetContainer;\r\n        gltfRuntime.scene._blockEntityCollection = false;\r\n        newMesh.id = id;\r\n    }\r\n\r\n    if (!node.babylonNode) {\r\n        return newMesh;\r\n    }\r\n\r\n    const subMaterials: Material[] = [];\r\n\r\n    let vertexData: Nullable<VertexData> = null;\r\n    const verticesStarts: number[] = [];\r\n    const verticesCounts: number[] = [];\r\n    const indexStarts: number[] = [];\r\n    const indexCounts: number[] = [];\r\n\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        // Positions, normals and UVs\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            // Temporary vertex data\r\n            const tempVertexData = new VertexData();\r\n\r\n            const primitive = mesh.primitives[i];\r\n            if (primitive.mode !== 4) {\r\n                // continue;\r\n            }\r\n\r\n            const attributes = primitive.attributes;\r\n            let accessor: Nullable<IGLTFAccessor> = null;\r\n            let buffer: any = null;\r\n\r\n            // Set positions, normal and uvs\r\n            for (const semantic in attributes) {\r\n                // Link accessor and buffer view\r\n                accessor = gltfRuntime.accessors[attributes[semantic]];\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                if (semantic === \"NORMAL\") {\r\n                    tempVertexData.normals = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.normals).set(buffer);\r\n                } else if (semantic === \"POSITION\") {\r\n                    if (GLTFFileLoader.HomogeneousCoordinates) {\r\n                        tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);\r\n\r\n                        for (let j = 0; j < buffer.length; j += 4) {\r\n                            tempVertexData.positions[j] = buffer[j];\r\n                            tempVertexData.positions[j + 1] = buffer[j + 1];\r\n                            tempVertexData.positions[j + 2] = buffer[j + 2];\r\n                        }\r\n                    } else {\r\n                        tempVertexData.positions = new Float32Array(buffer.length);\r\n                        (<Float32Array>tempVertexData.positions).set(buffer);\r\n                    }\r\n\r\n                    verticesCounts.push(tempVertexData.positions.length);\r\n                } else if (semantic.indexOf(\"TEXCOORD_\") !== -1) {\r\n                    const channel = Number(semantic.split(\"_\")[1]);\r\n                    const uvKind = VertexBuffer.UVKind + (channel === 0 ? \"\" : channel + 1);\r\n                    const uvs = new Float32Array(buffer.length);\r\n                    (<Float32Array>uvs).set(buffer);\r\n                    NormalizeUVs(uvs);\r\n                    tempVertexData.set(uvs, uvKind);\r\n                } else if (semantic === \"JOINT\") {\r\n                    tempVertexData.matricesIndices = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesIndices).set(buffer);\r\n                } else if (semantic === \"WEIGHT\") {\r\n                    tempVertexData.matricesWeights = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.matricesWeights).set(buffer);\r\n                } else if (semantic === \"COLOR\") {\r\n                    tempVertexData.colors = new Float32Array(buffer.length);\r\n                    (<Float32Array>tempVertexData.colors).set(buffer);\r\n                }\r\n            }\r\n\r\n            // Indices\r\n            accessor = gltfRuntime.accessors[primitive.indices];\r\n            if (accessor) {\r\n                buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);\r\n\r\n                tempVertexData.indices = new Int32Array(buffer.length);\r\n                tempVertexData.indices.set(buffer);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            } else {\r\n                // Set indices on the fly\r\n                const indices: number[] = [];\r\n                for (let j = 0; j < (<FloatArray>tempVertexData.positions).length / 3; j++) {\r\n                    indices.push(j);\r\n                }\r\n\r\n                tempVertexData.indices = new Int32Array(indices);\r\n                indexCounts.push(tempVertexData.indices.length);\r\n            }\r\n\r\n            if (!vertexData) {\r\n                vertexData = tempVertexData;\r\n            } else {\r\n                vertexData.merge(tempVertexData);\r\n            }\r\n\r\n            // Sub material\r\n            const material = gltfRuntime.scene.getMaterialById(primitive.material);\r\n\r\n            subMaterials.push(material === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material);\r\n\r\n            // Update vertices start and index start\r\n            verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);\r\n            indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);\r\n        }\r\n    }\r\n    let material: StandardMaterial | MultiMaterial;\r\n    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n    if (subMaterials.length > 1) {\r\n        material = new MultiMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n        material.subMaterials = subMaterials;\r\n    } else {\r\n        material = new StandardMaterial(\"multimat\" + id, gltfRuntime.scene);\r\n    }\r\n\r\n    if (subMaterials.length === 1) {\r\n        material = subMaterials[0] as StandardMaterial;\r\n    }\r\n\r\n    material._parentContainer = gltfRuntime.assetContainer;\r\n\r\n    if (!newMesh.material) {\r\n        newMesh.material = material;\r\n    }\r\n\r\n    // Apply geometry\r\n    new Geometry(id, gltfRuntime.scene, vertexData!, false, newMesh);\r\n    newMesh.computeWorldMatrix(true);\r\n\r\n    gltfRuntime.scene._blockEntityCollection = false;\r\n\r\n    // Apply submeshes\r\n    newMesh.subMeshes = [];\r\n    let index = 0;\r\n    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n        const meshId = meshes[meshIndex];\r\n        const mesh: IGLTFMesh = gltfRuntime.meshes[meshId];\r\n\r\n        if (!mesh) {\r\n            continue;\r\n        }\r\n\r\n        for (let i = 0; i < mesh.primitives.length; i++) {\r\n            if (mesh.primitives[i].mode !== 4) {\r\n                //continue;\r\n            }\r\n\r\n            SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Finish\r\n    return newMesh;\r\n};\r\n\r\n/**\r\n * Configure node transformation from position, rotation and scaling\r\n * @param newNode\r\n * @param position\r\n * @param rotation\r\n * @param scaling\r\n */\r\nconst ConfigureNode = (newNode: any, position: Vector3, rotation: Quaternion, scaling: Vector3) => {\r\n    if (newNode.position) {\r\n        newNode.position = position;\r\n    }\r\n\r\n    if (newNode.rotationQuaternion || newNode.rotation) {\r\n        newNode.rotationQuaternion = rotation;\r\n    }\r\n\r\n    if (newNode.scaling) {\r\n        newNode.scaling = scaling;\r\n    }\r\n};\r\n\r\n/**\r\n * Configures node from transformation matrix\r\n * @param newNode\r\n * @param node\r\n */\r\nconst ConfigureNodeFromMatrix = (newNode: Mesh, node: IGLTFNode) => {\r\n    if (node.matrix) {\r\n        const position = new Vector3(0, 0, 0);\r\n        const rotation = new Quaternion();\r\n        const scaling = new Vector3(0, 0, 0);\r\n        const mat = Matrix.FromArray(node.matrix);\r\n        mat.decompose(scaling, rotation, position);\r\n\r\n        ConfigureNode(newNode, position, rotation, scaling);\r\n    } else if (node.translation && node.rotation && node.scale) {\r\n        ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));\r\n    }\r\n\r\n    newNode.computeWorldMatrix(true);\r\n};\r\n\r\n/**\r\n * Imports a node\r\n * @param gltfRuntime\r\n * @param node\r\n * @param id\r\n * @returns the newly imported node\r\n */\r\nconst ImportNode = (gltfRuntime: IGLTFRuntime, node: IGLTFNode, id: string): Nullable<Node> => {\r\n    let lastNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {\r\n        if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || \"\") === -1) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Meshes\r\n    if (node.skin) {\r\n        if (node.meshes) {\r\n            const skin: IGLTFSkins = gltfRuntime.skins[node.skin];\r\n\r\n            const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, <Mesh>node.babylonNode);\r\n            newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);\r\n\r\n            if (newMesh.skeleton === null) {\r\n                newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);\r\n\r\n                if (!skin.babylonSkeleton) {\r\n                    skin.babylonSkeleton = newMesh.skeleton;\r\n                }\r\n            }\r\n\r\n            lastNode = newMesh;\r\n        }\r\n    } else if (node.meshes) {\r\n        /**\r\n         * Improve meshes property\r\n         */\r\n        const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, <Mesh>node.babylonNode);\r\n        lastNode = newMesh;\r\n    }\r\n    // Lights\r\n    else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const light: IGLTFLight = gltfRuntime.lights[node.light];\r\n\r\n        if (light) {\r\n            if (light.type === \"ambient\") {\r\n                const ambienLight: IGLTFAmbienLight = (<any>light)[light.type];\r\n                const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                hemiLight.name = node.name || \"\";\r\n\r\n                if (ambienLight.color) {\r\n                    hemiLight.diffuse = Color3.FromArray(ambienLight.color);\r\n                }\r\n\r\n                lastNode = hemiLight;\r\n            } else if (light.type === \"directional\") {\r\n                const directionalLight: IGLTFDirectionalLight = (<any>light)[light.type];\r\n                const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                dirLight.name = node.name || \"\";\r\n\r\n                if (directionalLight.color) {\r\n                    dirLight.diffuse = Color3.FromArray(directionalLight.color);\r\n                }\r\n\r\n                lastNode = dirLight;\r\n            } else if (light.type === \"point\") {\r\n                const pointLight: IGLTFPointLight = (<any>light)[light.type];\r\n                const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);\r\n                ptLight.name = node.name || \"\";\r\n\r\n                if (pointLight.color) {\r\n                    ptLight.diffuse = Color3.FromArray(pointLight.color);\r\n                }\r\n\r\n                lastNode = ptLight;\r\n            } else if (light.type === \"spot\") {\r\n                const spotLight: IGLTFSpotLight = (<any>light)[light.type];\r\n                const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);\r\n                spLight.name = node.name || \"\";\r\n\r\n                if (spotLight.color) {\r\n                    spLight.diffuse = Color3.FromArray(spotLight.color);\r\n                }\r\n\r\n                if (spotLight.fallOfAngle) {\r\n                    spLight.angle = spotLight.fallOfAngle;\r\n                }\r\n\r\n                if (spotLight.fallOffExponent) {\r\n                    spLight.exponent = spotLight.fallOffExponent;\r\n                }\r\n\r\n                lastNode = spLight;\r\n            }\r\n        }\r\n    }\r\n    // Cameras\r\n    else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {\r\n        const camera: IGLTFCamera = gltfRuntime.cameras[node.camera];\r\n\r\n        if (camera) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            if (camera.type === \"orthographic\") {\r\n                const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                orthoCamera.name = node.name || \"\";\r\n                orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                orthoCamera.attachControl();\r\n\r\n                lastNode = orthoCamera;\r\n\r\n                orthoCamera._parentContainer = gltfRuntime.assetContainer;\r\n            } else if (camera.type === \"perspective\") {\r\n                const perspectiveCamera: IGLTFCameraPerspective = (<any>camera)[camera.type];\r\n                const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);\r\n\r\n                persCamera.name = node.name || \"\";\r\n                persCamera.attachControl();\r\n\r\n                if (!perspectiveCamera.aspectRatio) {\r\n                    perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();\r\n                }\r\n\r\n                if (perspectiveCamera.znear && perspectiveCamera.zfar) {\r\n                    persCamera.maxZ = perspectiveCamera.zfar;\r\n                    persCamera.minZ = perspectiveCamera.znear;\r\n                }\r\n\r\n                lastNode = persCamera;\r\n                persCamera._parentContainer = gltfRuntime.assetContainer;\r\n            }\r\n\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n        }\r\n    }\r\n\r\n    // Empty node\r\n    if (!node.jointName) {\r\n        if (node.babylonNode) {\r\n            return node.babylonNode;\r\n        } else if (lastNode === null) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const dummy = new Mesh(node.name || \"\", gltfRuntime.scene);\r\n            dummy._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            node.babylonNode = dummy;\r\n            lastNode = dummy;\r\n        }\r\n    }\r\n\r\n    if (lastNode !== null) {\r\n        if (node.matrix && lastNode instanceof Mesh) {\r\n            ConfigureNodeFromMatrix(lastNode, node);\r\n        } else {\r\n            const translation = node.translation || [0, 0, 0];\r\n            const rotation = node.rotation || [0, 0, 0, 1];\r\n            const scale = node.scale || [1, 1, 1];\r\n            ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));\r\n        }\r\n\r\n        lastNode.updateCache(true);\r\n        node.babylonNode = lastNode;\r\n    }\r\n\r\n    return lastNode;\r\n};\r\n\r\n/**\r\n * Traverses nodes and creates them\r\n * @param gltfRuntime\r\n * @param id\r\n * @param parent\r\n * @param meshIncluded\r\n */\r\nconst TraverseNodes = (gltfRuntime: IGLTFRuntime, id: string, parent: Nullable<Node>, meshIncluded: boolean = false) => {\r\n    const node: IGLTFNode = gltfRuntime.nodes[id];\r\n    let newNode: Nullable<Node> = null;\r\n\r\n    if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {\r\n        if (gltfRuntime.importMeshesNames.indexOf(node.name || \"\") !== -1 || gltfRuntime.importMeshesNames.length === 0) {\r\n            meshIncluded = true;\r\n        } else {\r\n            meshIncluded = false;\r\n        }\r\n    } else {\r\n        meshIncluded = true;\r\n    }\r\n\r\n    if (!node.jointName && meshIncluded) {\r\n        newNode = ImportNode(gltfRuntime, node, id);\r\n\r\n        if (newNode !== null) {\r\n            newNode.id = id;\r\n            newNode.parent = parent;\r\n        }\r\n    }\r\n\r\n    if (node.children) {\r\n        for (let i = 0; i < node.children.length; i++) {\r\n            TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * do stuff after buffers, shaders are loaded (e.g. hook up materials, load animations, etc.)\r\n * @param gltfRuntime\r\n */\r\nconst PostLoad = (gltfRuntime: IGLTFRuntime) => {\r\n    // Nodes\r\n    let currentScene: IGLTFScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n    if (currentScene) {\r\n        for (let i = 0; i < currentScene.nodes.length; i++) {\r\n            TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n        }\r\n    } else {\r\n        for (const thing in gltfRuntime.scenes) {\r\n            currentScene = gltfRuntime.scenes[thing];\r\n\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Set animations\r\n    LoadAnimations(gltfRuntime);\r\n\r\n    for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {\r\n        const skeleton = gltfRuntime.scene.skeletons[i];\r\n        gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1.0);\r\n    }\r\n};\r\n\r\n/**\r\n * onBind shaderrs callback to set uniforms and matrices\r\n * @param mesh\r\n * @param gltfRuntime\r\n * @param unTreatedUniforms\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param onSuccess\r\n */\r\nconst OnBindShaderMaterial = (\r\n    mesh: AbstractMesh,\r\n    gltfRuntime: IGLTFRuntime,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n\r\n        if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {\r\n            if (uniform.semantic && !uniform.source && !uniform.node) {\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());\r\n            } else if (uniform.semantic && (uniform.source || uniform.node)) {\r\n                let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || \"\");\r\n                if (source === null) {\r\n                    source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || \"\");\r\n                }\r\n                if (source === null) {\r\n                    continue;\r\n                }\r\n\r\n                GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());\r\n            }\r\n        } else {\r\n            const value = (<any>materialValues)[technique.uniforms[unif]];\r\n            if (!value) {\r\n                continue;\r\n            }\r\n\r\n            if (type === EParameterType.SAMPLER_2D) {\r\n                const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;\r\n\r\n                if (texture === null || texture === undefined) {\r\n                    continue;\r\n                }\r\n\r\n                shaderMaterial.getEffect().setTexture(unif, texture);\r\n            } else {\r\n                GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);\r\n            }\r\n        }\r\n    }\r\n\r\n    onSuccess(shaderMaterial);\r\n};\r\n\r\n/**\r\n * Prepare uniforms to send the only one time\r\n * Loads the appropriate textures\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n */\r\nconst PrepareShaderMaterialUniforms = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }\r\n) => {\r\n    const materialValues = material.values || technique.parameters;\r\n    const techniqueUniforms = technique.uniforms;\r\n\r\n    /**\r\n     * Prepare values here (not matrices)\r\n     */\r\n    for (const unif in unTreatedUniforms) {\r\n        const uniform: IGLTFTechniqueParameter = unTreatedUniforms[unif];\r\n        const type = uniform.type;\r\n        let value = (<any>materialValues)[techniqueUniforms[unif]];\r\n\r\n        if (value === undefined) {\r\n            // In case the value is the same for all materials\r\n            value = <any>uniform.value;\r\n        }\r\n\r\n        if (!value) {\r\n            continue;\r\n        }\r\n\r\n        const onLoadTexture = (uniformName: Nullable<string>) => {\r\n            return (texture: Texture) => {\r\n                if (uniform.value && uniformName) {\r\n                    // Static uniform\r\n                    shaderMaterial.setTexture(uniformName, texture);\r\n                    delete unTreatedUniforms[uniformName];\r\n                }\r\n            };\r\n        };\r\n\r\n        // Texture (sampler2D)\r\n        if (type === EParameterType.SAMPLER_2D) {\r\n            GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));\r\n        }\r\n        // Others\r\n        else {\r\n            if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {\r\n                // Static uniform\r\n                delete unTreatedUniforms[unif];\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Shader compilation failed\r\n * @param program\r\n * @param shaderMaterial\r\n * @param onError\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileError = (program: IGLTFProgram, shaderMaterial: ShaderMaterial, onError: (message: string) => void) => {\r\n    return (effect: Effect, error: string) => {\r\n        shaderMaterial.dispose(true);\r\n        onError(\"Cannot compile program named \" + program.name + \". Error: \" + error + \". Default material will be applied\");\r\n    };\r\n};\r\n\r\n/**\r\n * Shader compilation success\r\n * @param gltfRuntime\r\n * @param shaderMaterial\r\n * @param technique\r\n * @param material\r\n * @param unTreatedUniforms\r\n * @param onSuccess\r\n * @returns callback when shader is compiled\r\n */\r\nconst OnShaderCompileSuccess = (\r\n    gltfRuntime: IGLTFRuntime,\r\n    shaderMaterial: ShaderMaterial,\r\n    technique: IGLTFTechnique,\r\n    material: IGLTFMaterial,\r\n    unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter },\r\n    onSuccess: (shaderMaterial: ShaderMaterial) => void\r\n) => {\r\n    return (_: Effect) => {\r\n        PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);\r\n\r\n        shaderMaterial.onBind = (mesh: AbstractMesh) => {\r\n            OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);\r\n        };\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the appropriate uniform if already handled by babylon\r\n * @param tokenizer\r\n * @param technique\r\n * @param unTreatedUniforms\r\n * @returns the name of the uniform handled by babylon\r\n */\r\nconst ParseShaderUniforms = (tokenizer: Tokenizer, technique: IGLTFTechnique, unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter }): string => {\r\n    for (const unif in technique.uniforms) {\r\n        const uniform = technique.uniforms[unif];\r\n        const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n        if (tokenizer.currentIdentifier === unif) {\r\n            if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n\r\n                if (transformIndex !== -1) {\r\n                    delete unTreatedUniforms[unif];\r\n                    return BabylonTransforms[transformIndex];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return tokenizer.currentIdentifier;\r\n};\r\n\r\n/**\r\n * All shaders loaded. Create materials one by one\r\n * @param gltfRuntime\r\n */\r\nconst ImportMaterials = (gltfRuntime: IGLTFRuntime) => {\r\n    // Create materials\r\n    for (const mat in gltfRuntime.materials) {\r\n        GLTFLoaderExtension.LoadMaterialAsync(\r\n            gltfRuntime,\r\n            mat,\r\n            () => {},\r\n            () => {}\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Implementation of the base glTF spec\r\n * @internal\r\n */\r\nexport class GLTFLoaderBase {\r\n    public static CreateRuntime(parsedData: any, scene: Scene, rootUrl: string): IGLTFRuntime {\r\n        const gltfRuntime: IGLTFRuntime = {\r\n            extensions: {},\r\n            accessors: {},\r\n            buffers: {},\r\n            bufferViews: {},\r\n            meshes: {},\r\n            lights: {},\r\n            cameras: {},\r\n            nodes: {},\r\n            images: {},\r\n            textures: {},\r\n            shaders: {},\r\n            programs: {},\r\n            samplers: {},\r\n            techniques: {},\r\n            materials: {},\r\n            animations: {},\r\n            skins: {},\r\n            extensionsUsed: [],\r\n\r\n            scenes: {},\r\n\r\n            buffersCount: 0,\r\n            shaderscount: 0,\r\n\r\n            scene: scene,\r\n            rootUrl: rootUrl,\r\n\r\n            loadedBufferCount: 0,\r\n            loadedBufferViews: {},\r\n\r\n            loadedShaderCount: 0,\r\n\r\n            importOnlyMeshes: false,\r\n\r\n            dummyNodes: [],\r\n\r\n            assetContainer: null,\r\n        };\r\n\r\n        // Parse\r\n        if (parsedData.extensions) {\r\n            ParseObject(parsedData.extensions, \"extensions\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.extensionsUsed) {\r\n            ParseObject(parsedData.extensionsUsed, \"extensionsUsed\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.buffers) {\r\n            ParseBuffers(parsedData.buffers, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.bufferViews) {\r\n            ParseObject(parsedData.bufferViews, \"bufferViews\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.accessors) {\r\n            ParseObject(parsedData.accessors, \"accessors\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.meshes) {\r\n            ParseObject(parsedData.meshes, \"meshes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.lights) {\r\n            ParseObject(parsedData.lights, \"lights\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.cameras) {\r\n            ParseObject(parsedData.cameras, \"cameras\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.nodes) {\r\n            ParseObject(parsedData.nodes, \"nodes\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.images) {\r\n            ParseObject(parsedData.images, \"images\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.textures) {\r\n            ParseObject(parsedData.textures, \"textures\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.shaders) {\r\n            ParseShaders(parsedData.shaders, gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.programs) {\r\n            ParseObject(parsedData.programs, \"programs\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.samplers) {\r\n            ParseObject(parsedData.samplers, \"samplers\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.techniques) {\r\n            ParseObject(parsedData.techniques, \"techniques\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.materials) {\r\n            ParseObject(parsedData.materials, \"materials\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.animations) {\r\n            ParseObject(parsedData.animations, \"animations\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.skins) {\r\n            ParseObject(parsedData.skins, \"skins\", gltfRuntime);\r\n        }\r\n\r\n        if (parsedData.scenes) {\r\n            gltfRuntime.scenes = parsedData.scenes;\r\n        }\r\n\r\n        if (parsedData.scene && parsedData.scenes) {\r\n            gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];\r\n        }\r\n\r\n        return gltfRuntime;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        const buffer: IGLTFBuffer = gltfRuntime.buffers[id];\r\n\r\n        if (Tools.IsBase64(buffer.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + buffer.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                onProgress,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: Nullable<ArrayBufferView>) => void, onError: (message: string) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (!texture || !texture.source) {\r\n            onError(\"\");\r\n            return;\r\n        }\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(null);\r\n            return;\r\n        }\r\n\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n\r\n        if (Tools.IsBase64(source.uri)) {\r\n            setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));\r\n        } else {\r\n            Tools.LoadFile(\r\n                gltfRuntime.rootUrl + source.uri,\r\n                (data) => onSuccess(new Uint8Array(data as ArrayBuffer)),\r\n                undefined,\r\n                undefined,\r\n                true,\r\n                (request) => {\r\n                    if (request) {\r\n                        onError(request.status + \" \" + request.statusText);\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static CreateTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: Nullable<ArrayBufferView>, onSuccess: (texture: Texture) => void): void {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n\r\n        if (texture.babylonTexture) {\r\n            onSuccess(texture.babylonTexture);\r\n            return;\r\n        }\r\n\r\n        const sampler: IGLTFSampler = gltfRuntime.samplers[texture.sampler];\r\n\r\n        const createMipMaps =\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST ||\r\n            sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;\r\n\r\n        const samplingMode = Texture.BILINEAR_SAMPLINGMODE;\r\n\r\n        const blob = buffer == null ? new Blob() : new Blob([buffer]);\r\n        const blobURL = URL.createObjectURL(blob);\r\n        const revokeBlobURL = () => URL.revokeObjectURL(blobURL);\r\n        const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);\r\n        if (sampler.wrapS !== undefined) {\r\n            newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);\r\n        }\r\n        if (sampler.wrapT !== undefined) {\r\n            newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);\r\n        }\r\n        newTexture.name = id;\r\n\r\n        texture.babylonTexture = newTexture;\r\n        onSuccess(newTexture);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string | ArrayBuffer) => void, onError?: (message: string) => void): void {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n\r\n        if (Tools.IsBase64(shader.uri)) {\r\n            const shaderString = atob(shader.uri.split(\",\")[1]);\r\n            if (onSuccess) {\r\n                onSuccess(shaderString);\r\n            }\r\n        } else {\r\n            Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, undefined, undefined, false, (request) => {\r\n                if (request && onError) {\r\n                    onError(request.status + \" \" + request.statusText);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material.technique) {\r\n            if (onError) {\r\n                onError(\"No technique found.\");\r\n            }\r\n            return;\r\n        }\r\n\r\n        const technique: IGLTFTechnique = gltfRuntime.techniques[material.technique];\r\n        if (!technique) {\r\n            gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;\r\n            const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n            defaultMaterial._parentContainer = gltfRuntime.assetContainer;\r\n            gltfRuntime.scene._blockEntityCollection = false;\r\n            defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);\r\n            defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n            onSuccess(defaultMaterial);\r\n            return;\r\n        }\r\n\r\n        const program: IGLTFProgram = gltfRuntime.programs[technique.program];\r\n        const states: IGLTFTechniqueStates = technique.states;\r\n\r\n        const vertexShader: string = Effect.ShadersStore[program.vertexShader + \"VertexShader\"];\r\n        const pixelShader: string = Effect.ShadersStore[program.fragmentShader + \"PixelShader\"];\r\n        let newVertexShader = \"\";\r\n        let newPixelShader = \"\";\r\n\r\n        const vertexTokenizer = new Tokenizer(vertexShader);\r\n        const pixelTokenizer = new Tokenizer(pixelShader);\r\n\r\n        const unTreatedUniforms: { [key: string]: IGLTFTechniqueParameter } = {};\r\n        const uniforms: string[] = [];\r\n        const attributes: string[] = [];\r\n        const samplers: string[] = [];\r\n\r\n        // Fill uniform, sampler2D and attributes\r\n        for (const unif in technique.uniforms) {\r\n            const uniform = technique.uniforms[unif];\r\n            const uniformParameter: IGLTFTechniqueParameter = technique.parameters[uniform];\r\n\r\n            unTreatedUniforms[unif] = uniformParameter;\r\n\r\n            if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {\r\n                const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);\r\n                if (transformIndex !== -1) {\r\n                    uniforms.push(BabylonTransforms[transformIndex]);\r\n                    delete unTreatedUniforms[unif];\r\n                } else {\r\n                    uniforms.push(unif);\r\n                }\r\n            } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {\r\n                samplers.push(unif);\r\n            } else {\r\n                uniforms.push(unif);\r\n            }\r\n        }\r\n\r\n        for (const attr in technique.attributes) {\r\n            const attribute = technique.attributes[attr];\r\n            const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n            if (attributeParameter.semantic) {\r\n                const name = GetAttribute(attributeParameter);\r\n                if (name) {\r\n                    attributes.push(name);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Configure vertex shader\r\n        while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {\r\n            const tokenType = vertexTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newVertexShader += vertexTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            let foundAttribute = false;\r\n\r\n            for (const attr in technique.attributes) {\r\n                const attribute = technique.attributes[attr];\r\n                const attributeParameter: IGLTFTechniqueParameter = technique.parameters[attribute];\r\n\r\n                if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {\r\n                    newVertexShader += GetAttribute(attributeParameter);\r\n                    foundAttribute = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (foundAttribute) {\r\n                continue;\r\n            }\r\n\r\n            newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Configure pixel shader\r\n        while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {\r\n            const tokenType = pixelTokenizer.currentToken;\r\n\r\n            if (tokenType !== ETokenType.IDENTIFIER) {\r\n                newPixelShader += pixelTokenizer.currentString;\r\n                continue;\r\n            }\r\n\r\n            newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);\r\n        }\r\n\r\n        // Create shader material\r\n        const shaderPath = {\r\n            vertex: program.vertexShader + id,\r\n            fragment: program.fragmentShader + id,\r\n        };\r\n\r\n        const options = {\r\n            attributes: attributes,\r\n            uniforms: uniforms,\r\n            samplers: samplers,\r\n            needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1,\r\n        };\r\n\r\n        Effect.ShadersStore[program.vertexShader + id + \"VertexShader\"] = newVertexShader;\r\n        Effect.ShadersStore[program.fragmentShader + id + \"PixelShader\"] = newPixelShader;\r\n\r\n        const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);\r\n        shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);\r\n        shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);\r\n        shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (states && states.functions) {\r\n            const functions = states.functions;\r\n            if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {\r\n                shaderMaterial.backFaceCulling = false;\r\n            }\r\n\r\n            const blendFunc = functions.blendFuncSeparate;\r\n            if (blendFunc) {\r\n                if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ONE &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE &&\r\n                    blendFunc[2] === EBlendingFunction.ZERO &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_ADD;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.ZERO &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.DST_COLOR &&\r\n                    blendFunc[1] === EBlendingFunction.ZERO &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;\r\n                } else if (\r\n                    blendFunc[0] === EBlendingFunction.SRC_ALPHA &&\r\n                    blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR &&\r\n                    blendFunc[2] === EBlendingFunction.ONE &&\r\n                    blendFunc[3] === EBlendingFunction.ONE\r\n                ) {\r\n                    shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * glTF V1 Loader\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    public static Extensions: { [name: string]: GLTFLoaderExtension } = {};\r\n\r\n    public static RegisterExtension(extension: GLTFLoaderExtension): void {\r\n        if (GLTFLoader.Extensions[extension.name]) {\r\n            Tools.Error('Tool with the same name \"' + extension.name + '\" already exists');\r\n            return;\r\n        }\r\n\r\n        GLTFLoader.Extensions[extension.name] = extension;\r\n    }\r\n\r\n    public dispose(): void {\r\n        // do nothing\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        onSuccess: (meshes: AbstractMesh[], skeletons: Skeleton[]) => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): boolean {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                gltfRuntime.assetContainer = assetContainer;\r\n                gltfRuntime.importOnlyMeshes = true;\r\n\r\n                if (meshesNames === \"\") {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                } else if (typeof meshesNames === \"string\") {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else if (meshesNames && !(meshesNames instanceof Array)) {\r\n                    gltfRuntime.importMeshesNames = [meshesNames];\r\n                } else {\r\n                    gltfRuntime.importMeshesNames = [];\r\n                    Tools.Warn(\"Argument meshesNames must be of type string or string[]\");\r\n                }\r\n\r\n                // Create nodes\r\n                this._createNodes(gltfRuntime);\r\n\r\n                const meshes: AbstractMesh[] = [];\r\n                const skeletons: Skeleton[] = [];\r\n\r\n                // Fill arrays of meshes and skeletons\r\n                for (const nde in gltfRuntime.nodes) {\r\n                    const node: IGLTFNode = gltfRuntime.nodes[nde];\r\n\r\n                    if (node.babylonNode instanceof AbstractMesh) {\r\n                        meshes.push(node.babylonNode);\r\n                    }\r\n                }\r\n\r\n                for (const skl in gltfRuntime.skins) {\r\n                    const skin: IGLTFSkins = gltfRuntime.skins[skl];\r\n\r\n                    if (skin.babylonSkeleton instanceof Skeleton) {\r\n                        skeletons.push(skin.babylonSkeleton);\r\n                    }\r\n                }\r\n\r\n                // Load buffers, shaders, materials, etc.\r\n                this._loadBuffersAsync(gltfRuntime, () => {\r\n                    this._loadShadersAsync(gltfRuntime, () => {\r\n                        ImportMaterials(gltfRuntime);\r\n                        PostLoad(gltfRuntime);\r\n\r\n                        if (!GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                            onSuccess(meshes, skeletons);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                if (GLTFFileLoader.IncrementalLoading && onSuccess) {\r\n                    onSuccess(meshes, skeletons);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from a loaded gltf file and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param assetContainer defines the asset container to use (can be null)\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise containg the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        assetContainer: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return new Promise((resolve, reject) => {\r\n            this._importMeshAsync(\r\n                meshesNames,\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                assetContainer,\r\n                (meshes, skeletons) => {\r\n                    resolve({\r\n                        meshes: meshes,\r\n                        particleSystems: [],\r\n                        skeletons: skeletons,\r\n                        animationGroups: [],\r\n                        lights: [],\r\n                        transformNodes: [],\r\n                        geometries: [],\r\n                        spriteManagers: [],\r\n                    });\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess: () => void,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        scene.useRightHandedSystem = true;\r\n\r\n        GLTFLoaderExtension.LoadRuntimeAsync(\r\n            scene,\r\n            data,\r\n            rootUrl,\r\n            (gltfRuntime) => {\r\n                // Load runtime extensios\r\n                GLTFLoaderExtension.LoadRuntimeExtensionsAsync(\r\n                    gltfRuntime,\r\n                    () => {\r\n                        // Create nodes\r\n                        this._createNodes(gltfRuntime);\r\n\r\n                        // Load buffers, shaders, materials, etc.\r\n                        this._loadBuffersAsync(gltfRuntime, () => {\r\n                            this._loadShadersAsync(gltfRuntime, () => {\r\n                                ImportMaterials(gltfRuntime);\r\n                                PostLoad(gltfRuntime);\r\n\r\n                                if (!GLTFFileLoader.IncrementalLoading) {\r\n                                    onSuccess();\r\n                                }\r\n                            });\r\n                        });\r\n\r\n                        if (GLTFFileLoader.IncrementalLoading) {\r\n                            onSuccess();\r\n                        }\r\n                    },\r\n                    onError\r\n                );\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from a loaded gltf file and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data gltf data containing information of the meshes in a loaded file\r\n     * @param rootUrl root url to load from\r\n     * @param onProgress event that fires when loading progress has occured\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void): Promise<void> {\r\n        return await new Promise((resolve, reject) => {\r\n            this._loadAsync(\r\n                scene,\r\n                data,\r\n                rootUrl,\r\n                () => {\r\n                    resolve();\r\n                },\r\n                onProgress,\r\n                (message) => {\r\n                    reject(new Error(message));\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadShadersAsync(gltfRuntime: IGLTFRuntime, onload: () => void): void {\r\n        let hasShaders = false;\r\n\r\n        const processShader = (sha: string, shader: IGLTFShader) => {\r\n            GLTFLoaderExtension.LoadShaderStringAsync(\r\n                gltfRuntime,\r\n                sha,\r\n                (shaderString) => {\r\n                    if (shaderString instanceof ArrayBuffer) {\r\n                        return;\r\n                    }\r\n\r\n                    gltfRuntime.loadedShaderCount++;\r\n\r\n                    if (shaderString) {\r\n                        Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? \"VertexShader\" : \"PixelShader\")] = shaderString;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {\r\n                        onload();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading shader program named \" + sha + \" located at \" + shader.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const sha in gltfRuntime.shaders) {\r\n            hasShaders = true;\r\n\r\n            const shader: IGLTFShader = gltfRuntime.shaders[sha];\r\n            if (shader) {\r\n                processShader.bind(this, sha, shader)();\r\n            } else {\r\n                Tools.Error(\"No shader named: \" + sha);\r\n            }\r\n        }\r\n\r\n        if (!hasShaders) {\r\n            onload();\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _loadBuffersAsync(gltfRuntime: IGLTFRuntime, onLoad: () => void): void {\r\n        let hasBuffers = false;\r\n\r\n        const processBuffer = (buf: string, buffer: IGLTFBuffer) => {\r\n            GLTFLoaderExtension.LoadBufferAsync(\r\n                gltfRuntime,\r\n                buf,\r\n                (bufferView) => {\r\n                    gltfRuntime.loadedBufferCount++;\r\n\r\n                    if (bufferView) {\r\n                        if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {\r\n                            Tools.Error(\"Buffer named \" + buf + \" is length \" + bufferView.byteLength + \". Expected: \" + buffer.byteLength); // Improve error message\r\n                        }\r\n\r\n                        gltfRuntime.loadedBufferViews[buf] = bufferView;\r\n                    }\r\n\r\n                    if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {\r\n                        onLoad();\r\n                    }\r\n                },\r\n                () => {\r\n                    Tools.Error(\"Error when loading buffer named \" + buf + \" located at \" + buffer.uri);\r\n                }\r\n            );\r\n        };\r\n\r\n        for (const buf in gltfRuntime.buffers) {\r\n            hasBuffers = true;\r\n\r\n            const buffer: IGLTFBuffer = gltfRuntime.buffers[buf];\r\n            if (buffer) {\r\n                processBuffer.bind(this, buf, buffer)();\r\n            } else {\r\n                Tools.Error(\"No buffer named: \" + buf);\r\n            }\r\n        }\r\n\r\n        if (!hasBuffers) {\r\n            onLoad();\r\n        }\r\n    }\r\n\r\n    private _createNodes(gltfRuntime: IGLTFRuntime): void {\r\n        let currentScene = <IGLTFScene>gltfRuntime.currentScene;\r\n\r\n        if (currentScene) {\r\n            // Only one scene even if multiple scenes are defined\r\n            for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n            }\r\n        } else {\r\n            // Load all scenes\r\n            for (const thing in gltfRuntime.scenes) {\r\n                currentScene = gltfRuntime.scenes[thing];\r\n\r\n                for (let i = 0; i < currentScene.nodes.length; i++) {\r\n                    TraverseNodes(gltfRuntime, currentScene.nodes[i], null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport abstract class GLTFLoaderExtension {\r\n    private _name: string;\r\n\r\n    public constructor(name: string) {\r\n        this._name = name;\r\n    }\r\n\r\n    public get name(): string {\r\n        return this._name;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading the runtime\r\n     * Return true to stop further extensions from loading the runtime\r\n     * @param scene\r\n     * @param data\r\n     * @param rootUrl\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess?: (gltfRuntime: IGLTFRuntime) => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an onverride for creating gltf runtime\r\n     * Return true to stop further extensions from creating the runtime\r\n     * @param gltfRuntime\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from creating the runtime\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading buffers\r\n     * Return true to stop further extensions from loading this buffer\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @param onProgress\r\n     * @returns true to stop further extensions from loading this buffer\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading texture buffers\r\n     * Return true to stop further extensions from loading this texture data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for creating textures\r\n     * Return true to stop further extensions from loading this texture\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param buffer\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this texture\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public createTextureAsync(gltfRuntime: IGLTFRuntime, id: string, buffer: ArrayBufferView, onSuccess: (texture: Texture) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading shader strings\r\n     * Return true to stop further extensions from loading this shader data\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this shader data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Defines an override for loading materials\r\n     * Return true to stop further extensions from loading this material\r\n     * @param gltfRuntime\r\n     * @param id\r\n     * @param onSuccess\r\n     * @param onError\r\n     * @returns true to stop further extensions from loading this material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        return false;\r\n    }\r\n\r\n    // ---------\r\n    // Utilities\r\n    // ---------\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onSuccess?: (gltfRuntime: IGLTFRuntime) => void,\r\n        onError?: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    if (!onSuccess) {\r\n                        return;\r\n                    }\r\n                    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime, onSuccess: () => void, onError?: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);\r\n            },\r\n            () => {\r\n                setTimeout(() => {\r\n                    onSuccess();\r\n                });\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (bufferView: ArrayBufferView) => void,\r\n        onError: (message: string) => void,\r\n        onProgress?: () => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadTextureAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (texture: Texture) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                if (buffer) {\r\n                    GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n                }\r\n            },\r\n            onError\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderData: string | ArrayBuffer) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public static LoadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _LoadTextureBufferAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        onSuccess: (buffer: Nullable<ArrayBufferView>) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private static _CreateTextureAsync(\r\n        gltfRuntime: IGLTFRuntime,\r\n        id: string,\r\n        buffer: ArrayBufferView,\r\n        onSuccess: (texture: Texture) => void,\r\n        onError: (message: string) => void\r\n    ): void {\r\n        GLTFLoaderExtension._ApplyExtensions(\r\n            (loaderExtension) => {\r\n                return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);\r\n            },\r\n            () => {\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);\r\n            }\r\n        );\r\n    }\r\n\r\n    private static _ApplyExtensions(func: (loaderExtension: GLTFLoaderExtension) => boolean, defaultFunc: () => void): void {\r\n        for (const extensionName in GLTFLoader.Extensions) {\r\n            const loaderExtension = GLTFLoader.Extensions[extensionName];\r\n            if (func(loaderExtension)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        defaultFunc();\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();\r\n","import { GLTFLoaderExtension, GLTFLoader, GLTFLoaderBase } from \"./glTFLoader\";\r\nimport { GLTFUtils } from \"./glTFLoaderUtils\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport type { IGLTFRuntime, IGLTFTexture, IGLTFImage, IGLTFBufferView, IGLTFShader } from \"./glTFLoaderInterfaces\";\r\nimport { EComponentType } from \"./glTFLoaderInterfaces\";\r\n\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\n\r\nconst BinaryExtensionBufferName = \"binary_glTF\";\r\n\r\ninterface IGLTFBinaryExtensionShader {\r\n    bufferView: string;\r\n}\r\n\r\ninterface IGLTFBinaryExtensionImage {\r\n    bufferView: string;\r\n    mimeType: string;\r\n    height: number;\r\n    width: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFBinaryExtension extends GLTFLoaderExtension {\r\n    private _bin: IDataBuffer;\r\n\r\n    public constructor() {\r\n        super(\"KHR_binary_glTF\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onSuccess: (gltfRuntime: IGLTFRuntime) => void): boolean {\r\n        const extensionsUsed = (<any>data.json).extensionsUsed;\r\n        if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {\r\n            return false;\r\n        }\r\n\r\n        this._bin = data.bin;\r\n        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void, onError: (message: string) => void): boolean {\r\n        if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {\r\n            return false;\r\n        }\r\n\r\n        if (id !== BinaryExtensionBufferName) {\r\n            return false;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadTextureBufferAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (buffer: ArrayBufferView) => void): boolean {\r\n        const texture: IGLTFTexture = gltfRuntime.textures[id];\r\n        const source: IGLTFImage = gltfRuntime.images[texture.source];\r\n        if (!source.extensions || !(this.name in source.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const sourceExt: IGLTFBinaryExtensionImage = source.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[sourceExt.bufferView];\r\n        const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n        onSuccess(buffer);\r\n        return true;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadShaderStringAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (shaderString: string) => void): boolean {\r\n        const shader: IGLTFShader = gltfRuntime.shaders[id];\r\n        if (!shader.extensions || !(this.name in shader.extensions)) {\r\n            return false;\r\n        }\r\n\r\n        const binaryExtensionShader: IGLTFBinaryExtensionShader = shader.extensions[this.name];\r\n        const bufferView: IGLTFBufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];\r\n        const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);\r\n\r\n        setTimeout(() => {\r\n            const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);\r\n            onSuccess(shaderString);\r\n        });\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFBinaryExtension());\r\n","import { GLTFLoaderExtension, GLTFLoaderBase, GLTFLoader } from \"./glTFLoader\";\r\n\r\nimport type { IGLTFRuntime, IGLTFMaterial } from \"./glTFLoaderInterfaces\";\r\n\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { HemisphericLight } from \"core/Lights/hemisphericLight\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\n\r\ninterface IGLTFMaterialsCommonExtensionValues {\r\n    ambient?: number[] | string;\r\n    diffuse?: number[] | string;\r\n    emission?: number[] | string;\r\n    specular?: number[] | string;\r\n    shininess?: number;\r\n    transparency?: number;\r\n}\r\n\r\ninterface IGLTFMaterialsCommonExtension {\r\n    technique: string;\r\n    transparent?: number;\r\n    doubleSided?: boolean;\r\n    values: IGLTFMaterialsCommonExtensionValues;\r\n}\r\n\r\ninterface IGLTFRuntimeCommonExtension {\r\n    lights: { [key: string]: IGLTFLightCommonExtension };\r\n}\r\n\r\ninterface IGLTFLightCommonExtension {\r\n    name: string;\r\n    type: string;\r\n\r\n    ambient?: IGLTFAmbientLightCommonExtension;\r\n    point?: IGLTFPointLightCommonExtension;\r\n    directional?: IGLTFDirectionalLightCommonExtension;\r\n    spot?: IGLTFSpotLightCommonExtension;\r\n}\r\n\r\ninterface IGLTFPointLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\ninterface IGLTFAmbientLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFDirectionalLightCommonExtension {\r\n    color: number[];\r\n}\r\n\r\ninterface IGLTFSpotLightCommonExtension {\r\n    color: number[];\r\n    constantAttenuation: number;\r\n    fallOffAngle: number;\r\n    fallOffExponent: number;\r\n    linearAttenuation: number;\r\n    quadraticAttenuation: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @deprecated\r\n */\r\nexport class GLTFMaterialsCommonExtension extends GLTFLoaderExtension {\r\n    constructor() {\r\n        super(\"KHR_materials_common\");\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadRuntimeExtensionsAsync(gltfRuntime: IGLTFRuntime): boolean {\r\n        if (!gltfRuntime.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFRuntimeCommonExtension = gltfRuntime.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        // Create lights\r\n        const lights = extension.lights;\r\n        if (lights) {\r\n            for (const thing in lights) {\r\n                const light: IGLTFLightCommonExtension = lights[thing];\r\n\r\n                switch (light.type) {\r\n                    case \"ambient\": {\r\n                        const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);\r\n                        const ambient = light.ambient;\r\n                        if (ambient) {\r\n                            ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"point\": {\r\n                        const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);\r\n                        const point = light.point;\r\n                        if (point) {\r\n                            pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"directional\": {\r\n                        const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);\r\n                        const directional = light.directional;\r\n                        if (directional) {\r\n                            dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    case \"spot\": {\r\n                        const spot = light.spot;\r\n                        if (spot) {\r\n                            const spotLight = new SpotLight(\r\n                                light.name,\r\n                                new Vector3(0, 10, 0),\r\n                                new Vector3(0, -1, 0),\r\n                                spot.fallOffAngle || Math.PI,\r\n                                spot.fallOffExponent || 0.0,\r\n                                gltfRuntime.scene\r\n                            );\r\n                            spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);\r\n                        }\r\n                        break;\r\n                    }\r\n                    default:\r\n                        Tools.Warn('GLTF Material Common extension: light type \"' + light.type + \"” not supported\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public override loadMaterialAsync(gltfRuntime: IGLTFRuntime, id: string, onSuccess: (material: Material) => void, onError: (message: string) => void): boolean {\r\n        const material: IGLTFMaterial = gltfRuntime.materials[id];\r\n        if (!material || !material.extensions) {\r\n            return false;\r\n        }\r\n\r\n        const extension: IGLTFMaterialsCommonExtension = material.extensions[this.name];\r\n        if (!extension) {\r\n            return false;\r\n        }\r\n\r\n        const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);\r\n        standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;\r\n\r\n        if (extension.technique === \"CONSTANT\") {\r\n            standardMaterial.disableLighting = true;\r\n        }\r\n\r\n        standardMaterial.backFaceCulling = extension.doubleSided === undefined ? false : !extension.doubleSided;\r\n        standardMaterial.alpha = extension.values.transparency === undefined ? 1.0 : extension.values.transparency;\r\n        standardMaterial.specularPower = extension.values.shininess === undefined ? 0.0 : extension.values.shininess;\r\n\r\n        // Ambient\r\n        if (typeof extension.values.ambient === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, \"ambientTexture\", onError);\r\n        } else {\r\n            standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);\r\n        }\r\n\r\n        // Diffuse\r\n        if (typeof extension.values.diffuse === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, \"diffuseTexture\", onError);\r\n        } else {\r\n            standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);\r\n        }\r\n\r\n        // Emission\r\n        if (typeof extension.values.emission === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, \"emissiveTexture\", onError);\r\n        } else {\r\n            standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);\r\n        }\r\n\r\n        // Specular\r\n        if (typeof extension.values.specular === \"string\") {\r\n            this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, \"specularTexture\", onError);\r\n        } else {\r\n            standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _loadTexture(gltfRuntime: IGLTFRuntime, id: string, material: StandardMaterial, propertyPath: string, onError: (message: string) => void): void {\r\n        // Create buffer from texture url\r\n        GLTFLoaderBase.LoadTextureBufferAsync(\r\n            gltfRuntime,\r\n            id,\r\n            (buffer) => {\r\n                // Create texture from buffer\r\n                GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => ((<any>material)[propertyPath] = texture));\r\n            },\r\n            onError\r\n        );\r\n    }\r\n}\r\n\r\nGLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());\r\n","import type { GLTFLoader } from \"./glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\n\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ninterface IRegisteredGLTFExtension {\r\n    isGLTFExtension: boolean;\r\n    factory: GLTFExtensionFactory;\r\n}\r\n\r\nexport type GLTFExtensionFactory = (loader: GLTFLoader) => IGLTFLoaderExtension | Promise<IGLTFLoaderExtension>;\r\n\r\nconst RegisteredGLTFExtensions = new Map<string, IRegisteredGLTFExtension>();\r\n\r\n/**\r\n * All currently registered glTF 2.0 loader extensions.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport const registeredGLTFExtensions: ReadonlyMap<string, Readonly<IRegisteredGLTFExtension>> = RegisteredGLTFExtensions;\r\n\r\n/**\r\n * Registers a loader extension.\r\n * @param name The name of the loader extension.\r\n * @param isGLTFExtension If the loader extension is a glTF extension, then it will only be used for glTF files that use the corresponding glTF extension. Otherwise, it will be used for all loaded glTF files.\r\n * @param factory The factory function that creates the loader extension.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function registerGLTFExtension(name: string, isGLTFExtension: boolean, factory: GLTFExtensionFactory): void {\r\n    if (unregisterGLTFExtension(name)) {\r\n        Logger.Warn(`Extension with the name '${name}' already exists`);\r\n    }\r\n\r\n    RegisteredGLTFExtensions.set(name, {\r\n        isGLTFExtension,\r\n        factory,\r\n    });\r\n}\r\n\r\n/**\r\n * Unregisters a loader extension.\r\n * @param name The name of the loader extension.\r\n * @returns A boolean indicating whether the extension has been unregistered\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function unregisterGLTFExtension(name: string): boolean {\r\n    return RegisteredGLTFExtensions.delete(name);\r\n}\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable github/no-then */\r\nimport type { IndicesArray, Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorType,\r\n    CameraType,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem,\r\n    _ISamplerData,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    _IAnimationSamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, GetMimeType, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { AnimationPropertyInfo } from \"./glTFLoaderAnimation\";\r\nimport type { IObjectInfo } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport { registeredGLTFExtensions, registerGLTFExtension, unregisterGLTFExtension } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { GLTFExtensionFactory } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { IInterpolationPropertyInfo } from \"core/FlowGraph/typeDefinitions\";\r\nimport { GetMappingForKey } from \"./Extensions/objectModelMapping\";\r\nimport { deepMerge } from \"core/Misc/deepMerger\";\r\nimport { GetTypedArrayConstructor } from \"core/Buffers/bufferUtils\";\r\nimport { Lazy } from \"core/Misc/lazy\";\r\nimport type { IMaterialLoadingAdapter } from \"./materialLoadingAdapter\";\r\n\r\n// Caching these dynamic imports gives a surprising perf boost (compared to importing them directly each time).\r\nconst LazyAnimationGroupModulePromise = new Lazy(() => import(\"core/Animations/animationGroup\"));\r\nconst LazyLoaderAnimationModulePromise = new Lazy(() => import(\"./glTFLoaderAnimation\"));\r\n\r\nexport { GLTFFileLoader };\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IWithMetadata {\r\n    metadata: any;\r\n    _internalMetadata: any;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Gets an item from the given array or returns null if not available.\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item or null\r\n     */\r\n    public static TryGet<T>(array: ArrayLike<T> | undefined, index: number | undefined): Nullable<T> {\r\n        if (!array || index == undefined || !array[index]) {\r\n            return null;\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport interface IAnimationTargetInfo {\r\n    /** @internal */\r\n    target: unknown;\r\n\r\n    /** @internal */\r\n    properties: Array<AnimationPropertyInfo>;\r\n}\r\n\r\n/** @internal */\r\nexport function LoadBoundingInfoFromPositionAccessor(accessor: IAccessor): Nullable<BoundingInfo> {\r\n    if (accessor.min && accessor.max) {\r\n        const minArray = accessor.min as [number, number, number];\r\n        const maxArray = accessor.max as [number, number, number];\r\n        const minVector = TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);\r\n        const maxVector = TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);\r\n        if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n            let divider = 1;\r\n            switch (accessor.componentType) {\r\n                case AccessorComponentType.BYTE:\r\n                    divider = 127.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_BYTE:\r\n                    divider = 255.0;\r\n                    break;\r\n                case AccessorComponentType.SHORT:\r\n                    divider = 32767.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_SHORT:\r\n                    divider = 65535.0;\r\n                    break;\r\n            }\r\n            const oneOverDivider = 1 / divider;\r\n            minVector.scaleInPlace(oneOverDivider);\r\n            maxVector.scaleInPlace(oneOverDivider);\r\n        }\r\n        return new BoundingInfo(minVector, maxVector);\r\n    }\r\n    return null;\r\n}\r\n\r\ntype PBRMaterialImplementation = {\r\n    materialClass: typeof Material;\r\n    adapterClass: new (material: Material) => IMaterialLoadingAdapter;\r\n};\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @internal */\r\n    public readonly _completePromises = new Array<Promise<unknown>>();\r\n\r\n    /** @internal */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @internal */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    /** @internal */\r\n    public _allMaterialsDirtyRequired = false;\r\n\r\n    /** @internal */\r\n    public _skipStartAnimationStep = false;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<TransformNode> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private readonly _postSceneLoadActions = new Array<() => void>();\r\n    private readonly _materialAdapterCache = new WeakMap<Material, IMaterialLoadingAdapter>();\r\n\r\n    /** @internal */\r\n    public _pbrMaterialImpl: Nullable<Readonly<PBRMaterialImplementation>> | false = null;\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     * @deprecated Please use registerGLTFExtension instead.\r\n     */\r\n    public static RegisterExtension(name: string, factory: GLTFExtensionFactory): void {\r\n        registerGLTFExtension(name, false, factory);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     * @deprecated Please use unregisterGLTFExtension instead.\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        return unregisterGLTFExtension(name);\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon node when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<TransformNode> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * The root url when loading the asset.\r\n     */\r\n    public get rootUrl(): Nullable<string> {\r\n        return this._rootUrl;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /**\r\n     * Creates or gets a cached material loading adapter with dynamic imports\r\n     * @param material The material to adapt\r\n     * @returns Promise that resolves to the appropriate adapter\r\n     * @internal\r\n     */\r\n    public _getOrCreateMaterialAdapter(material: Material): IMaterialLoadingAdapter {\r\n        let adapter = this._materialAdapterCache.get(material);\r\n        if (!adapter) {\r\n            if (this._pbrMaterialImpl) {\r\n                adapter = new this._pbrMaterialImpl.adapterClass(material);\r\n            } else {\r\n                throw new Error(`Appropriate material adapter class not found`);\r\n            }\r\n            this._materialAdapterCache.set(material, adapter);\r\n        }\r\n        return adapter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await Promise.resolve().then(async () => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return await this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                    spriteManagers: [],\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        this._babylonScene = scene;\r\n        this._loadData(data);\r\n        return await this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n    }\r\n\r\n    private async _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return await Promise.resolve()\r\n            .then(async () => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n                this._allMaterialsDirtyRequired = false;\r\n\r\n                await this._loadExtensionsAsync();\r\n\r\n                // NOTE: Explicitly check _pbrMaterialImpl for null as a value of false means don't use PBR materials at all.\r\n                if (!this.parent.skipMaterials && this._pbrMaterialImpl == null) {\r\n                    if (this.parent.useOpenPBR || this.isExtensionUsed(\"KHR_materials_openpbr\")) {\r\n                        this._pbrMaterialImpl = {\r\n                            materialClass: (await import(\"core/Materials/PBR/openPbrMaterial\")).OpenPBRMaterial,\r\n                            adapterClass: (await import(\"./openPbrMaterialLoadingAdapter\")).OpenPBRMaterialLoadingAdapter,\r\n                        };\r\n                    } else {\r\n                        this._pbrMaterialImpl = {\r\n                            materialClass: (await import(\"core/Materials/PBR/pbrMaterial\")).PBRMaterial,\r\n                            adapterClass: (await import(\"./pbrMaterialLoadingAdapter\")).PBRMaterialLoadingAdapter,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<unknown>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                if (this._allMaterialsDirtyRequired) {\r\n                    // This can happen if we add a light for instance as it will impact the whole scene.\r\n                    // This automatically resets everything if needed.\r\n                    this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n                } else {\r\n                    // By default a newly created material is dirty so there is no need to flag the full scene as dirty.\r\n                    // For perf reasons, we then bypass blockMaterialDirtyMechanism as this would \"dirty\" the entire scene.\r\n                    this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);\r\n                }\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh && this._rootBabylonMesh !== this._parent.customRootNode) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    // Making sure we enable enough lights to have all lights together\r\n                    for (const material of this._babylonScene.materials) {\r\n                        const mat = material as any;\r\n\r\n                        if (mat.maxSimultaneousLights !== undefined) {\r\n                            mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, this._babylonScene.lights.length);\r\n                        }\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n                    if (!this._skipStartAnimationStep) {\r\n                        this._startAnimations();\r\n                    }\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return await resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _loadExtensionsAsync() {\r\n        const extensionPromises: Promise<IGLTFLoaderExtension>[] = [];\r\n\r\n        registeredGLTFExtensions.forEach((registeredExtension, name) => {\r\n            // Don't load explicitly disabled extensions.\r\n            if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                // But warn if the disabled extension is used by the model.\r\n                if (registeredExtension.isGLTFExtension && this.isExtensionUsed(name)) {\r\n                    Logger.Warn(`Extension ${name} is used but has been explicitly disabled.`);\r\n                }\r\n            }\r\n            // Load loader extensions that are not a glTF extension, as well as extensions that are glTF extensions and are used by the model.\r\n            else if (!registeredExtension.isGLTFExtension || this.isExtensionUsed(name)) {\r\n                extensionPromises.push(\r\n                    (async () => {\r\n                        const extension = await registeredExtension.factory(this);\r\n                        if (extension.name !== name) {\r\n                            Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n                        }\r\n\r\n                        this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n                        return extension;\r\n                    })()\r\n                );\r\n            }\r\n        });\r\n\r\n        this._extensions.push(...(await Promise.all(extensionPromises)));\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                        throw new Error(`Required extension ${name} is disabled`);\r\n                    }\r\n                    throw new Error(`Required extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        if (this._parent.customRootNode !== undefined) {\r\n            this._rootBabylonMesh = this._parent.customRootNode;\r\n            return {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                _babylonTransformNode: this._rootBabylonMesh === null ? undefined : this._rootBabylonMesh,\r\n                index: -1,\r\n            };\r\n        }\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const rootMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh = rootMesh;\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries: Geometry[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes: AbstractMesh[] = [];\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh instanceof AbstractMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes: TransformNode[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons: Skeleton[] = [];\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups: AnimationGroup[] = [];\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                        if (!this._babylonScene.useRightHandedSystem) {\r\n                            babylonTransformNode.scaling.x = -1; // Cancelling root node scaling for handedness so the view matrix does not end up flipped.\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        const hasMesh = node.mesh != undefined;\r\n        const hasSkin = this._parent.loadSkins && node.skin != undefined;\r\n\r\n        if (!hasMesh || hasSkin) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (hasMesh) {\r\n            if (hasSkin) {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin!;\r\n\r\n                        // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\r\n                        babylonTransformNode.metadata = deepMerge(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until all the nodes are parented before parenting the skinned mesh.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        // Handle special case when the parent of the skeleton root is the skinned mesh.\r\n                                        const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent!;\r\n                                        if (node.index === parentNode.index) {\r\n                                            babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\r\n                                        } else {\r\n                                            babylonTransformNode.parent = parentNode._babylonTransformNode!;\r\n                                        }\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n\r\n                                    this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            } else {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                const asMesh = babylonMesh as Mesh;\r\n                if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true, true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<unknown>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then(async (babylonGeometry) => {\r\n                    return await this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        if (this._disposed) {\r\n                            return;\r\n                        }\r\n\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            if (!this.parent.skipMaterials) {\r\n                const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n                if (primitive.material == undefined) {\r\n                    let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                    if (!babylonMaterial) {\r\n                        babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                        this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                        this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                    }\r\n                    babylonMesh.material = babylonMaterial;\r\n                } else {\r\n                    const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                    promises.push(\r\n                        this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                            babylonMesh.material = babylonMaterial;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (name: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[name] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._gltf.accessors, attributes[name]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor);\r\n                        if (babylonBoundingInfo) {\r\n                            babylonGeometry._boundingInfo = babylonBoundingInfo;\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(this._babylonScene);\r\n        babylonMesh.morphTargetManager._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private async _loadMorphTargetVertexDataAsync(\r\n        context: string,\r\n        babylonGeometry: Geometry,\r\n        attributes: { [name: string]: number },\r\n        babylonMorphTarget: MorphTarget\r\n    ): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUVs(uvs);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUV2s(uvs);\r\n        });\r\n\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (babylonVertexBuffer, data) => {\r\n            let colors = null;\r\n            const componentSize = babylonVertexBuffer.getSize();\r\n            if (componentSize === 3) {\r\n                colors = new Float32Array((data.length / 3) * 4);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    const pixid = Math.floor(index / 3);\r\n                    const channel = index % 3;\r\n                    colors[4 * pixid + channel] = data[3 * pixid + channel] + value;\r\n                });\r\n                for (let i = 0; i < data.length / 3; ++i) {\r\n                    colors[4 * i + 3] = 1;\r\n                }\r\n            } else if (componentSize === 4) {\r\n                colors = new Float32Array(data.length);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    colors[index] = data[index] + value;\r\n                });\r\n            } else {\r\n                throw new Error(`${context}: Invalid number of components (${componentSize}) for COLOR_0 attribute`);\r\n            }\r\n            babylonMorphTarget.setColors(colors);\r\n        });\r\n\r\n        return await Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        if (!this._parent.loadSkins) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path: INode[] = [];\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        node._isJoint = true;\r\n\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateAbsoluteBindMatrices(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        camera._babylonCamera = babylonCamera;\r\n\r\n        // glTF cameras look towards the local -Z axis.\r\n        babylonCamera.setTarget(new Vector3(0, 0, -1));\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Load animations\");\r\n\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Load animations\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        this._parent._startPerformanceCounter(\"Load animation\");\r\n\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        return LazyAnimationGroupModulePromise.value.then(({ AnimationGroup }) => {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n            babylonAnimationGroup._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            ArrayItem.Assign(animation.channels);\r\n            ArrayItem.Assign(animation.samplers);\r\n\r\n            for (const channel of animation.channels) {\r\n                promises.push(\r\n                    this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\r\n                        babylonTarget.animations = babylonTarget.animations || [];\r\n                        babylonTarget.animations.push(babylonAnimation);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\r\n                    })\r\n                );\r\n            }\r\n\r\n            this._parent._endPerformanceCounter(\"Load animation\");\r\n\r\n            return Promise.all(promises).then(() => {\r\n                babylonAnimationGroup.normalize(0);\r\n                return babylonAnimationGroup;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n        const channelTargetPath = channel.target.path;\r\n        const pathIsWeights = channelTargetPath === AnimationChannelTargetPath.WEIGHTS;\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if ((pathIsWeights && !targetNode._numMorphTargets) || (!pathIsWeights && !targetNode._babylonTransformNode)) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Don't load node animations if disabled.\r\n        if (!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // async-load the animation sampler to provide the interpolation of the channelTargetPath\r\n        return LazyLoaderAnimationModulePromise.value.then(() => {\r\n            let properties: IInterpolationPropertyInfo[];\r\n            switch (channelTargetPath) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/translation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/rotation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/scale\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/weights\")?.interpolation!;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n            // stay safe\r\n            if (!properties) {\r\n                throw new Error(`${context}/target/path: Could not find interpolation properties for target path (${channel.target.path})`);\r\n            }\r\n\r\n            const targetInfo: IObjectInfo<IInterpolationPropertyInfo[]> = {\r\n                object: targetNode,\r\n                info: properties,\r\n            };\r\n\r\n            return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param targetInfo The glTF target and properties\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelFromTargetInfoAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        targetInfo: IObjectInfo<IInterpolationPropertyInfo[]>,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const fps = this.parent.targetFps;\r\n        const invfps = 1 / fps;\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let numAnimations = 0;\r\n\r\n            const target = targetInfo.object;\r\n            const propertyInfos = targetInfo.info;\r\n            // Extract the corresponding values from the read value.\r\n            // GLTF values may be dispatched to several Babylon properties.\r\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\r\n            // - albedoColor as Color3(`r`, `g`, `b`)\r\n            // - alpha as `a`\r\n            for (const propertyInfo of propertyInfos) {\r\n                const stride = propertyInfo.getStride(target);\r\n                const input = data.input;\r\n                const output = data.output;\r\n                const keys = new Array<IAnimationKey>(input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n                            const outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                inTangent: inTangent,\r\n                                value: value,\r\n                                outTangent: outTangent,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (outputOffset > 0) {\r\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\r\n                    const babylonAnimations = propertyInfo.buildAnimations(target, name, fps, keys);\r\n                    for (const babylonAnimation of babylonAnimations) {\r\n                        numAnimations++;\r\n                        onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArray;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArray;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(engine, data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n\r\n        if (accessor.sparse || accessor.bufferView == undefined) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    engine,\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    undefined,\r\n                    bufferView.byteStride,\r\n                    undefined,\r\n                    accessor.byteOffset,\r\n                    numComponents,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    undefined,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        if (properties) {\r\n            // Set base color and alpha using adapter\r\n            if (properties.baseColorFactor) {\r\n                adapter.baseColor = Color3.FromArray(properties.baseColorFactor);\r\n                adapter.geometryOpacity = properties.baseColorFactor[3];\r\n            } else {\r\n                adapter.baseColor = Color3.White();\r\n            }\r\n\r\n            // Set metallic and roughness using adapter\r\n            adapter.baseMetalness = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            adapter.specularRoughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        adapter.baseColorTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        adapter.baseMetalnessTexture = texture;\r\n                        adapter.specularRoughnessTexture = texture;\r\n                    })\r\n                );\r\n\r\n                // Configure texture channel usage using adapter\r\n                adapter.useRoughnessFromMetallicTextureGreen = true;\r\n                adapter.useMetallicFromMetallicTextureBlue = true;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        if (!this._pbrMaterialImpl) {\r\n            throw new Error(\"PBR Material class not loaded\");\r\n        }\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new this._pbrMaterialImpl.materialClass(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;\r\n        // Create the material adapter and set some default properties.\r\n        // We don't need to wait for the promise to resolve here.\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n        adapter.transparencyAsAlphaCoverage = this._parent.transparencyAsCoverage;\r\n\r\n        // Set default metallic and roughness values\r\n        adapter.baseMetalness = 1.0;\r\n        adapter.specularRoughness = 1.0;\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionMaterial = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionMaterial) {\r\n            return extensionMaterial;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        // Set emission color using adapter\r\n        adapter.emissionColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n\r\n        // Set double-sided properties using adapter\r\n        if (material.doubleSided) {\r\n            adapter.backFaceCulling = false;\r\n            adapter.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    adapter.geometryNormalTexture = texture;\r\n                    if (material.normalTexture?.scale != undefined) {\r\n                        texture.level = material.normalTexture.scale;\r\n                    }\r\n                })\r\n            );\r\n\r\n            // Set normal map inversions using adapter\r\n            adapter.setNormalMapInversions(!this._babylonScene.useRightHandedSystem, this._babylonScene.useRightHandedSystem);\r\n        }\r\n\r\n        let aoTexture: BaseTexture;\r\n        let aoStrength: number = 1.0;\r\n        let emissionTexture: BaseTexture;\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    aoTexture = texture;\r\n                })\r\n            );\r\n\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                aoStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    emissionTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            // Set ambient occlusion and emissive textures using adapter\r\n            if (aoTexture) {\r\n                adapter.ambientOcclusionTexture = aoTexture;\r\n                adapter.ambientOcclusionTextureStrength = aoStrength;\r\n            }\r\n\r\n            if (emissionTexture) {\r\n                adapter.emissionColorTexture = emissionTexture;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!this._pbrMaterialImpl) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const baseColorTexture = adapter.baseColorTexture;\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;\r\n                babylonMaterial.alpha = 1.0; // Force alpha to 1.0 for opaque mode.\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHATEST;\r\n                adapter.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (baseColorTexture) {\r\n                    baseColorTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHABLEND;\r\n                if (baseColorTexture) {\r\n                    baseColorTexture.hasAlpha = true;\r\n                    adapter.useAlphaFromBaseColorTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: unknown,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType ?? GetMimeType(image.uri ?? \"\"),\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n\r\n                // Set the internal texture label.\r\n                const internalTexture = babylonTexture.getInternalTexture();\r\n                if (internalTexture) {\r\n                    internalTexture.label = image.name;\r\n                }\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        if (this._parent.useGltfTextureNames) {\r\n            babylonTexture.name = image.name || image.uri || `image${image.index}`;\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substring(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with _internalMetadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void {\r\n        babylonObject.metadata = babylonObject.metadata || {};\r\n        const metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        try {\r\n            return GetTypedArrayConstructor(componentType);\r\n        } catch (e) {\r\n            throw new Error(`${context}: ${e.message}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): TypedArray {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            animation,\r\n            \"loadAnimationChannel\",\r\n            (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtensionAsync<TExtension = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtraAsync<TExtra = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport { RectAreaLight } from \"core/Lights/rectAreaLight\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { TransformNode as BabylonTransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IEXTLightsArea_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { EXTLightsArea_LightShape } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IEXTLightsArea_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_lights_area\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_lights_area extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_lights_area\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_area/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_area implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsArea_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsArea_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.shape) {\r\n                    case EXTLightsArea_LightShape.RECT: {\r\n                        const width = light.width !== undefined ? light.width : 1.0;\r\n                        const height = light.height !== undefined ? light.height : 1.0;\r\n                        const babylonRectAreaLight = new RectAreaLight(name, Vector3.Zero(), width, height, this._loader.babylonScene);\r\n                        babylonLight = babylonRectAreaLight;\r\n                        break;\r\n                    }\r\n                    case EXTLightsArea_LightShape.DISK: {\r\n                        // For disk lights, we'll use RectAreaLight with equal width and height to approximate a square area\r\n                        // In the future, this could be extended to support actual disk area lights\r\n                        const radius = light.radius !== undefined ? light.radius : 0.5;\r\n                        const size = radius * 2; // Convert radius to square size\r\n                        const babylonRectAreaLight = new RectAreaLight(name, Vector3.Zero(), size, size, this._loader.babylonScene);\r\n                        babylonLight = babylonRectAreaLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid area light shape (${light.shape})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n\r\n                // glTF EXT_lights_area specifies lights face down -Z, but Babylon.js area lights face down +Z\r\n                // Create a parent transform node with 180-degree rotation around Y axis to flip the direction\r\n                const lightParentNode = new BabylonTransformNode(`${name}_orientation`, this._loader.babylonScene);\r\n                lightParentNode.rotationQuaternion = Quaternion.RotationAxis(Vector3.Up(), Math.PI);\r\n                lightParentNode.parent = babylonMesh;\r\n                babylonLight.parent = lightParentNode;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_area(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { SphericalHarmonics, SphericalPolynomial } from \"core/Maths/sphericalPolynomial\";\r\nimport { Quaternion, Matrix } from \"core/Maths/math.vector\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { RawCubeTexture } from \"core/Materials/Textures/rawCubeTexture\";\r\n\r\nimport type { IEXTLightsImageBased_LightReferenceImageBased, IEXTLightsImageBased_LightImageBased, IEXTLightsImageBased } from \"babylonjs-gltf2interface\";\r\nimport type { IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_lights_image_based\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_lights_image_based extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_lights_image_based\"]: {};\r\n    }\r\n}\r\n\r\ndeclare module \"babylonjs-gltf2interface\" {\r\n    /** @internal */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    interface IEXTLightsImageBased_LightImageBased {\r\n        _babylonTexture?: BaseTexture;\r\n        _loaded?: Promise<void>;\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_image_based/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_image_based implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsImageBased_LightImageBased[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IEXTLightsImageBased;\r\n            this._lights = extension.lights;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsImageBased_LightReferenceImageBased>(context, scene, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);\r\n            promises.push(\r\n                // eslint-disable-next-line github/no-then\r\n                this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {\r\n                    this._loader.babylonScene.environmentTexture = texture;\r\n                })\r\n            );\r\n\r\n            this._loader.logClose();\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadLightAsync(context: string, light: IEXTLightsImageBased_LightImageBased): Promise<BaseTexture> {\r\n        if (!light._loaded) {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            this._loader.logOpen(`${context}`);\r\n\r\n            const imageData = new Array<Array<ArrayBufferView>>(light.specularImages.length);\r\n            for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {\r\n                const faces = light.specularImages[mipmap];\r\n                imageData[mipmap] = new Array<ArrayBufferView>(faces.length);\r\n                for (let face = 0; face < faces.length; face++) {\r\n                    const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;\r\n                    this._loader.logOpen(`${specularImageContext}`);\r\n\r\n                    const index = faces[face];\r\n                    const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {\r\n                            imageData[mipmap][face] = data;\r\n                        })\r\n                    );\r\n\r\n                    this._loader.logClose();\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            light._loaded = Promise.all(promises).then(async () => {\r\n                const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);\r\n                babylonTexture.name = light.name || \"environment\";\r\n                light._babylonTexture = babylonTexture;\r\n\r\n                if (light.intensity != undefined) {\r\n                    babylonTexture.level = light.intensity;\r\n                }\r\n\r\n                if (light.rotation) {\r\n                    let rotation = Quaternion.FromArray(light.rotation);\r\n\r\n                    // Invert the rotation so that positive rotation is counter-clockwise.\r\n                    if (!this._loader.babylonScene.useRightHandedSystem) {\r\n                        rotation = Quaternion.Inverse(rotation);\r\n                    }\r\n\r\n                    Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());\r\n                }\r\n\r\n                if (!light.irradianceCoefficients) {\r\n                    throw new Error(`${context}: Irradiance coefficients are missing`);\r\n                }\r\n\r\n                const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);\r\n                sphericalHarmonics.scaleInPlace(light.intensity);\r\n\r\n                sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n                const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n\r\n                // Compute the lod generation scale to fit exactly to the number of levels available.\r\n                const lodGenerationScale = (imageData.length - 1) / Math.log2(light.specularImageSize);\r\n                return await babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);\r\n            });\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return light._loaded.then(() => {\r\n            return light._babylonTexture!;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_image_based(loader));\r\n","import { Vector3, Quaternion, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Meshes/thinInstanceMesh\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_mesh_gpu_instancing extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_mesh_gpu_instancing\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n * [Playground Sample](https://playground.babylonjs.com/#QFIGLW#9)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshGpuInstancing, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._disableInstancedMesh++;\r\n\r\n            const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);\r\n\r\n            this._loader._disableInstancedMesh--;\r\n\r\n            if (!node._primitiveBabylonMeshes) {\r\n                return await promise;\r\n            }\r\n\r\n            const promises = new Array<Promise<Nullable<Float32Array>>>();\r\n            let instanceCount = 0;\r\n\r\n            const loadAttribute = (attribute: string) => {\r\n                if (extension.attributes[attribute] == undefined) {\r\n                    promises.push(Promise.resolve(null));\r\n                    return;\r\n                }\r\n\r\n                const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);\r\n                promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));\r\n\r\n                if (instanceCount === 0) {\r\n                    instanceCount = accessor.count;\r\n                } else if (instanceCount !== accessor.count) {\r\n                    throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"TRANSLATION\");\r\n            loadAttribute(\"ROTATION\");\r\n            loadAttribute(\"SCALE\");\r\n            loadAttribute(\"_COLOR_0\");\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            return await promise.then(async (babylonTransformNode) => {\r\n                const [translationBuffer, rotationBuffer, scaleBuffer, colorBuffer] = await Promise.all(promises);\r\n                const matrices = new Float32Array(instanceCount * 16);\r\n                TmpVectors.Vector3[0].copyFromFloats(0, 0, 0); // translation\r\n                TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1); // rotation\r\n                TmpVectors.Vector3[1].copyFromFloats(1, 1, 1); // scale\r\n                for (let i = 0; i < instanceCount; ++i) {\r\n                    translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);\r\n                    rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);\r\n                    scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);\r\n\r\n                    Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);\r\n\r\n                    TmpVectors.Matrix[0].copyToArray(matrices, i * 16);\r\n                }\r\n                for (const babylonMesh of node._primitiveBabylonMeshes!) {\r\n                    (babylonMesh as Mesh).thinInstanceSetBuffer(\"matrix\", matrices, 16, true);\r\n                    if (colorBuffer) {\r\n                        if (colorBuffer.length === instanceCount * 3) {\r\n                            (babylonMesh as Mesh).thinInstanceSetBuffer(\"color\", colorBuffer, 3, true);\r\n                        } else if (colorBuffer.length === instanceCount * 4) {\r\n                            (babylonMesh as Mesh).thinInstanceSetBuffer(\"color\", colorBuffer, 4, true);\r\n                        } else {\r\n                            Logger.Warn(\"Unexpected size of _COLOR_0 attribute for mesh \" + babylonMesh.name);\r\n                        }\r\n                    }\r\n                }\r\n                return babylonTransformNode;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_mesh_gpu_instancing(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { ArrayItem, GLTFLoader } from \"../glTFLoader\";\r\nimport type { IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IEXTMeshoptCompression } from \"babylonjs-gltf2interface\";\r\nimport { MeshoptCompression } from \"core/Meshes/Compression/meshoptCompression\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_meshopt_compression\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_meshopt_compression extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_meshopt_compression\"]: {};\r\n    }\r\n}\r\n\r\ninterface IBufferViewMeshopt extends IBufferView {\r\n    _meshOptData?: Promise<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md)\r\n *\r\n * This extension uses a WebAssembly decoder module from https://github.com/zeux/meshoptimizer/tree/master/js\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_meshopt_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTMeshoptCompression, ArrayBufferView>(context, bufferView, this.name, async (extensionContext, extension) => {\r\n            const bufferViewMeshopt = bufferView as IBufferViewMeshopt;\r\n            if (bufferViewMeshopt._meshOptData) {\r\n                return await bufferViewMeshopt._meshOptData;\r\n            }\r\n\r\n            const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);\r\n            bufferViewMeshopt._meshOptData = this._loader\r\n                .loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength)\r\n                // eslint-disable-next-line github/no-then\r\n                .then(async (buffer) => {\r\n                    return await MeshoptCompression.Default.decodeGltfBufferAsync(buffer as Uint8Array, extension.count, extension.byteStride, extension.mode, extension.filter);\r\n                });\r\n\r\n            return await bufferViewMeshopt._meshOptData;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_meshopt_compression(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IEXTTextureWebP } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_texture_webp\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_texture_webp extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_texture_webp\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_texture_webp implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTTextureWebP, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_texture_webp(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IEXTTextureAVIF } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"EXT_texture_avif\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_texture_avif extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_texture_avif\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [glTF PR](https://github.com/KhronosGroup/glTF/pull/2235)\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_avif/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_texture_avif implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTTextureAVIF, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_texture_avif(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IEXTLightsIES_LightReference } from \"babylonjs-gltf2interface\";\r\nimport type { IEXTLightsIES_Light, INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nconst NAME = \"EXT_lights_ies\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the EXT_lights_ies extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"EXT_lights_ies\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_lights_ies)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_lights_ies implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IEXTLightsIES_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IEXTLightsIES_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            let babylonSpotLight: SpotLight;\r\n            let light: IEXTLightsIES_Light;\r\n\r\n            const transformNode = await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                babylonSpotLight.angle = Math.PI / 2;\r\n                babylonSpotLight.innerAngle = 0;\r\n\r\n                babylonSpotLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonSpotLight;\r\n\r\n                babylonSpotLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonSpotLight.diffuse = extension.color ? Color3.FromArray(extension.color) : Color3.White();\r\n                babylonSpotLight.intensity = extension.multiplier || 1;\r\n                babylonSpotLight.range = Number.MAX_VALUE;\r\n                babylonSpotLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonSpotLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonSpotLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n\r\n            // Load the profile\r\n            let bufferData: ArrayBufferView;\r\n            if (light!.uri) {\r\n                bufferData = await this._loader.loadUriAsync(context, light!, light!.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, light!.bufferView);\r\n                bufferData = await this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n            babylonSpotLight!.iesProfileTexture = new Texture(\r\n                name + \"_iesProfile\",\r\n                this._loader.babylonScene,\r\n                true,\r\n                false,\r\n                undefined,\r\n                null,\r\n                null,\r\n                bufferData,\r\n                true,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                undefined,\r\n                \".ies\"\r\n            );\r\n\r\n            return transformNode;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_ies(loader));\r\n","/* eslint-disable github/no-then */\r\nimport { DracoDecoder } from \"core/Meshes/Compression/dracoDecoder\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Geometry } from \"core/Meshes/geometry\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport type { IKHRDracoMeshCompression } from \"babylonjs-gltf2interface\";\r\nimport type { IMeshPrimitive, IBufferView } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem, LoadBoundingInfoFromPositionAccessor } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_draco_mesh_compression\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_draco_mesh_compression extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_draco_mesh_compression\"]: {};\r\n    }\r\n}\r\n\r\ninterface IBufferViewDraco extends IBufferView {\r\n    _dracoBabylonGeometry?: Promise<Geometry>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_draco_mesh_compression implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * The draco decoder used to decode vertex data or DracoDecoder.Default if not defined\r\n     */\r\n    public dracoDecoder?: DracoDecoder;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether to use the normalized flag from the glTF accessor instead of the Draco data. Defaults to true.\r\n     */\r\n    public useNormalizedFlagFromAccessor = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        delete this.dracoDecoder;\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRDracoMeshCompression, Geometry>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            if (primitive.mode != undefined) {\r\n                if (primitive.mode !== MeshPrimitiveMode.TRIANGLES && primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP) {\r\n                    throw new Error(`${context}: Unsupported mode ${primitive.mode}`);\r\n                }\r\n            }\r\n\r\n            const attributes: { [kind: string]: number } = {};\r\n            const normalized: { [kind: string]: boolean } = {};\r\n            const loadAttribute = (name: string, kind: string) => {\r\n                const uniqueId = extension.attributes[name];\r\n                if (uniqueId == undefined) {\r\n                    return;\r\n                }\r\n\r\n                babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n                if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                    babylonMesh._delayInfo.push(kind);\r\n                }\r\n\r\n                attributes[kind] = uniqueId;\r\n\r\n                if (this.useNormalizedFlagFromAccessor) {\r\n                    const accessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[name]);\r\n                    if (accessor) {\r\n                        normalized[kind] = accessor.normalized || false;\r\n                    }\r\n                }\r\n            };\r\n\r\n            loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n            loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n            loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n            loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n            loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n            loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n            loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n            loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n            loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n            loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n            loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n            loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind);\r\n\r\n            const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView) as IBufferViewDraco;\r\n            if (!bufferView._dracoBabylonGeometry) {\r\n                bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(async (data) => {\r\n                    const dracoDecoder = this.dracoDecoder || DracoDecoder.Default;\r\n                    const positionAccessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[\"POSITION\"]);\r\n                    const babylonBoundingInfo =\r\n                        !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? LoadBoundingInfoFromPositionAccessor(positionAccessor) : null;\r\n                    return await dracoDecoder\r\n                        ._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo)\r\n                        .catch((error) => {\r\n                            throw new Error(`${context}: ${error.message}`);\r\n                        });\r\n                });\r\n            }\r\n\r\n            return await bufferView._dracoBabylonGeometry;\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_draco_mesh_compression(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { DirectionalLight } from \"core/Lights/directionalLight\";\r\nimport { PointLight } from \"core/Lights/pointLight\";\r\nimport { SpotLight } from \"core/Lights/spotLight\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\n\r\nimport type { IKHRLightsPunctual_LightReference } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { INode, IKHRLightsPunctual_Light } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_lights_punctual extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_lights_punctual\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /** hidden */\r\n    private _loader: GLTFLoader;\r\n    private _lights?: IKHRLightsPunctual_Light[];\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name];\r\n            this._lights = extension.lights;\r\n            ArrayItem.Assign(this._lights);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRLightsPunctual_LightReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            this._loader._allMaterialsDirtyRequired = true;\r\n\r\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\r\n                let babylonLight: Light;\r\n\r\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\r\n                const name = light.name || babylonMesh.name;\r\n\r\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\r\n\r\n                switch (light.type) {\r\n                    case KHRLightsPunctual_LightType.DIRECTIONAL: {\r\n                        const babylonDirectionalLight = new DirectionalLight(name, Vector3.Backward(), this._loader.babylonScene);\r\n                        babylonDirectionalLight.position.setAll(0);\r\n                        babylonLight = babylonDirectionalLight;\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.POINT: {\r\n                        babylonLight = new PointLight(name, Vector3.Zero(), this._loader.babylonScene);\r\n                        break;\r\n                    }\r\n                    case KHRLightsPunctual_LightType.SPOT: {\r\n                        const babylonSpotLight = new SpotLight(name, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);\r\n                        babylonSpotLight.angle = ((light.spot && light.spot.outerConeAngle) || Math.PI / 4) * 2;\r\n                        babylonSpotLight.innerAngle = ((light.spot && light.spot.innerConeAngle) || 0) * 2;\r\n                        babylonLight = babylonSpotLight;\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        this._loader.babylonScene._blockEntityCollection = false;\r\n                        throw new Error(`${extensionContext}: Invalid light type (${light.type})`);\r\n                    }\r\n                }\r\n\r\n                babylonLight._parentContainer = this._loader._assetContainer;\r\n                this._loader.babylonScene._blockEntityCollection = false;\r\n                light._babylonLight = babylonLight;\r\n\r\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\r\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\r\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\r\n                babylonLight.range = light.range == undefined ? Number.MAX_VALUE : light.range;\r\n                babylonLight.parent = babylonMesh;\r\n\r\n                this._loader._babylonLights.push(babylonLight);\r\n\r\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\r\n\r\n                assign(babylonMesh);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_lights(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsPbrSpecularGlossiness } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_pbrSpecularGlossiness\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_pbrSpecularGlossiness extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_pbrSpecularGlossiness\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_pbrSpecularGlossiness implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 200;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsPbrSpecularGlossiness>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSpecularGlossinessPropertiesAsync(context: string, properties: IKHRMaterialsPbrSpecularGlossiness, babylonMaterial: Material): Promise<void> {\r\n        if (!(babylonMaterial instanceof PBRMaterial)) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        babylonMaterial.metallic = null;\r\n        babylonMaterial.roughness = null;\r\n\r\n        if (properties.diffuseFactor) {\r\n            babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);\r\n            babylonMaterial.alpha = properties.diffuseFactor[3];\r\n        } else {\r\n            babylonMaterial.albedoColor = Color3.White();\r\n        }\r\n\r\n        babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();\r\n        babylonMaterial.microSurface = properties.glossinessFactor == undefined ? 1 : properties.glossinessFactor;\r\n\r\n        if (properties.diffuseTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse)`;\r\n                    babylonMaterial.albedoTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularGlossinessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular Glossiness)`;\r\n                    babylonMaterial.reflectivityTexture = texture;\r\n                    babylonMaterial.reflectivityTexture.hasAlpha = true;\r\n                })\r\n            );\r\n\r\n            babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_unlit extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_unlit\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 210;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, async () => {\r\n            return await this._loadUnlitPropertiesAsync(context, material, babylonMaterial);\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadUnlitPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        const properties = material.pbrMetallicRoughness;\r\n        if (properties) {\r\n            if (properties.baseColorFactor) {\r\n                adapter.baseColor = Color3.FromArray(properties.baseColorFactor);\r\n                adapter.geometryOpacity = properties.baseColorFactor[3];\r\n            }\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        adapter.baseColorTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n        adapter.isUnlit = true;\r\n        if (material.doubleSided) {\r\n            adapter.backFaceCulling = false;\r\n            adapter.twoSidedLighting = true;\r\n        }\r\n\r\n        this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_unlit(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type {\r\n    IKHRMaterialsClearcoat,\r\n    IKHRMaterialsClearcoatDarkening,\r\n    IKHRMaterialsClearcoatIor,\r\n    IKHRMaterialsClearcoatColor,\r\n    IKHRMaterialsClearcoatAnisotropy,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_clearcoat extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_clearcoat\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#7F7PN6#8)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsClearcoat>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n\r\n            const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n            if (extension.extensions && extension.extensions.KHR_materials_clearcoat_darkening) {\r\n                const darkeningExtension = extension.extensions.KHR_materials_clearcoat_darkening as IKHRMaterialsClearcoatDarkening;\r\n                promises.push(this._loadClearCoatDarkeningPropertiesAsync(extensionContext, darkeningExtension, babylonMaterial));\r\n            }\r\n            if (extension.extensions && extension.extensions.KHR_materials_clearcoat_ior) {\r\n                const iorExtension = extension.extensions.KHR_materials_clearcoat_ior as IKHRMaterialsClearcoatIor;\r\n                let ior = 1.5;\r\n                if (iorExtension.clearcoatIor !== undefined) {\r\n                    ior = iorExtension.clearcoatIor;\r\n                }\r\n                adapter.coatIor = ior;\r\n            }\r\n            if (extension.extensions && extension.extensions.KHR_materials_clearcoat_anisotropy) {\r\n                const anisotropyExtension = extension.extensions.KHR_materials_clearcoat_anisotropy as IKHRMaterialsClearcoatAnisotropy;\r\n                promises.push(this._loadClearCoatAnisotropyPropertiesAsync(extensionContext, anisotropyExtension, babylonMaterial));\r\n            }\r\n            if (extension.extensions && extension.extensions.KHR_materials_clearcoat_color) {\r\n                const colorExtension = extension.extensions.KHR_materials_clearcoat_color as IKHRMaterialsClearcoatColor;\r\n                promises.push(this._loadClearCoatColorPropertiesAsync(extensionContext, colorExtension, babylonMaterial));\r\n            }\r\n\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClearCoatPropertiesAsync(context: string, properties: IKHRMaterialsClearcoat, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        // Set non-texture properties immediately\r\n        adapter.configureCoat();\r\n        adapter.coatWeight = properties.clearcoatFactor !== undefined ? properties.clearcoatFactor : 0;\r\n        adapter.coatRoughness = properties.clearcoatRoughnessFactor !== undefined ? properties.clearcoatRoughnessFactor : 0;\r\n\r\n        // Load textures\r\n        if (properties.clearcoatTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat)`;\r\n                    adapter.coatWeightTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatRoughnessTexture) {\r\n            (properties.clearcoatRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;\r\n                    adapter.coatRoughnessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.clearcoatNormalTexture) {\r\n            (properties.clearcoatNormalTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;\r\n                    adapter.geometryCoatNormalTexture = texture;\r\n                    if (properties.clearcoatNormalTexture?.scale != undefined) {\r\n                        adapter.geometryCoatNormalTextureScale = properties.clearcoatNormalTexture.scale;\r\n                    }\r\n                })\r\n            );\r\n            adapter.setNormalMapInversions(!babylonMaterial.getScene().useRightHandedSystem, babylonMaterial.getScene().useRightHandedSystem);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClearCoatDarkeningPropertiesAsync(context: string, properties: IKHRMaterialsClearcoatDarkening, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        adapter.coatDarkening = properties.clearcoatDarkeningFactor !== undefined ? properties.clearcoatDarkeningFactor : 1;\r\n\r\n        if (properties.clearcoatDarkeningTexture) {\r\n            (properties.clearcoatDarkeningTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatDarkeningTexture`, properties.clearcoatDarkeningTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Darkening)`;\r\n                    adapter.coatDarkeningTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClearCoatColorPropertiesAsync(context: string, properties: IKHRMaterialsClearcoatColor, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n        const colorFactor = Color3.White();\r\n        if (properties.clearcoatColorFactor !== undefined) {\r\n            colorFactor.fromArray(properties.clearcoatColorFactor);\r\n        }\r\n\r\n        adapter.coatColor = colorFactor;\r\n\r\n        if (properties.clearcoatColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatColorTexture`, properties.clearcoatColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (ClearCoat Color)`;\r\n                    adapter.coatColorTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClearCoatAnisotropyPropertiesAsync(context: string, properties: IKHRMaterialsClearcoatAnisotropy, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        // Set non-texture properties immediately\r\n        const clearcoatAnisotropyWeight = properties.clearcoatAnisotropyStrength ?? 0;\r\n        const clearcoatAnisotropyAngle = properties.clearcoatAnisotropyRotation ?? 0;\r\n\r\n        adapter.coatRoughnessAnisotropy = clearcoatAnisotropyWeight;\r\n        adapter.geometryCoatTangentAngle = clearcoatAnisotropyAngle;\r\n\r\n        // Check if this is glTF-style anisotropy\r\n        const extensions = properties.extensions ?? {};\r\n        if (!extensions.EXT_materials_anisotropy_openpbr || !extensions.EXT_materials_anisotropy_openpbr.openPbrAnisotropyEnabled) {\r\n            adapter.configureGltfStyleAnisotropy(true);\r\n        }\r\n\r\n        // Load texture if present\r\n        if (properties.clearcoatAnisotropyTexture) {\r\n            (properties.clearcoatAnisotropyTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/clearcoatAnisotropyTexture`, properties.clearcoatAnisotropyTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Clearcoat Anisotropy)`;\r\n                    adapter.geometryCoatTangentTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_clearcoat(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_iridescence extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_iridescence\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 195;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIridescence>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadIridescencePropertiesAsync(context: string, properties: IKHRMaterialsIridescence, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        // Set non-texture properties immediately\r\n        adapter.thinFilmWeight = properties.iridescenceFactor ?? 0;\r\n        adapter.thinFilmIor = properties.iridescenceIor ?? (properties as any).iridescenceIOR ?? 1.3;\r\n        adapter.thinFilmThicknessMinimum = properties.iridescenceThicknessMinimum ?? 100;\r\n        adapter.thinFilmThicknessMaximum = properties.iridescenceThicknessMaximum ?? 400;\r\n\r\n        // Load textures\r\n        if (properties.iridescenceTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence)`;\r\n                    adapter.thinFilmWeightTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.iridescenceThicknessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;\r\n                    adapter.thinFilmThicknessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_iridescence(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_anisotropy extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_anisotropy\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 195;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsAnisotropy>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadAnisotropyPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    private async _loadAnisotropyPropertiesAsync(context: string, properties: IKHRMaterialsAnisotropy, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        // Set non-texture properties immediately\r\n        const anisotropyWeight = properties.anisotropyStrength ?? 0;\r\n        const anisotropyAngle = properties.anisotropyRotation ?? 0;\r\n\r\n        adapter.specularRoughnessAnisotropy = anisotropyWeight;\r\n        adapter.geometryTangentAngle = anisotropyAngle;\r\n\r\n        // Check if this is glTF-style anisotropy\r\n        const extensions = properties.extensions ?? {};\r\n        if (!extensions.EXT_materials_anisotropy_openpbr || !extensions.EXT_materials_anisotropy_openpbr.openPbrAnisotropyEnabled) {\r\n            adapter.configureGltfStyleAnisotropy(true);\r\n        }\r\n\r\n        // Load texture if present\r\n        if (properties.anisotropyTexture) {\r\n            (properties.anisotropyTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/anisotropyTexture`, properties.anisotropyTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Anisotropy Intensity)`;\r\n                    adapter.geometryTangentTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        await Promise.all(promises);\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_anisotropy(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_emissive_strength extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_emissive_strength\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 170;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsEmissiveStrength>(context, material, this.name, async (extensionContext, extension) => {\r\n            await this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n            this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);\r\n            return await Promise.resolve();\r\n        });\r\n    }\r\n\r\n    private _loadEmissiveProperties(context: string, properties: IKHRMaterialsEmissiveStrength, babylonMaterial: Material): void {\r\n        if (properties.emissiveStrength !== undefined) {\r\n            const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n            adapter.emissionLuminance = properties.emissiveStrength;\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_emissive_strength(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_sheen extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_sheen\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_sheen/README.md)\r\n * [Playground Sample](https://www.babylonjs-playground.com/frame.html#BNIZX6#4)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSheen>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSheenPropertiesAsync(context: string, properties: IKHRMaterialsSheen, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        adapter.configureFuzz();\r\n\r\n        // Set non-texture properties immediately\r\n        const sheenColor = properties.sheenColorFactor !== undefined ? Color3.FromArray(properties.sheenColorFactor) : Color3.Black();\r\n        const sheenRoughness = properties.sheenRoughnessFactor !== undefined ? properties.sheenRoughnessFactor : 0.0;\r\n\r\n        adapter.fuzzWeight = 1; // KHR_materials_sheen assumes intensity of 1\r\n        adapter.fuzzColor = sheenColor;\r\n        adapter.fuzzRoughness = sheenRoughness;\r\n\r\n        // Load textures\r\n        if (properties.sheenColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Color)`;\r\n                    adapter.fuzzColorTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.sheenRoughnessTexture) {\r\n            (properties.sheenRoughnessTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Sheen Roughness)`;\r\n                    adapter.fuzzRoughnessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_sheen(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { IEXTMaterialsSpecularEdgeColor, IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_specular extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_specular\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsSpecular>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // Handle the EXT_materials_specular_edge_color sub-extension\r\n            // https://github.com/KhronosGroup/glTF/blob/2a1111b88f052cbd3e2d82abb9faee56e7494904/extensions/2.0/Vendor/EXT_materials_specular_edge_color/README.md\r\n            const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n            if (extension.extensions && extension.extensions.EXT_materials_specular_edge_color) {\r\n                const specularEdgeColorExtension = extension.extensions.EXT_materials_specular_edge_color as IEXTMaterialsSpecularEdgeColor;\r\n                if (specularEdgeColorExtension.specularEdgeColorEnabled) {\r\n                    adapter.enableSpecularEdgeColor(true);\r\n                }\r\n            }\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSpecularPropertiesAsync(context: string, properties: IKHRMaterialsSpecular, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        // Set non-texture properties immediately\r\n        adapter.specularWeight = properties.specularFactor ?? 1.0;\r\n        adapter.specularColor = properties.specularColorFactor !== undefined ? Color3.FromArray(properties.specularColorFactor) : new Color3(1, 1, 1);\r\n\r\n        if (properties.specularTexture) {\r\n            (properties.specularTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular)`;\r\n                    adapter.specularWeightTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (properties.specularColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Specular Color)`;\r\n                    adapter.specularColorTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_specular(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_ior extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_ior\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFLoaderExtension {\r\n    /**\r\n     * Default ior Value from the spec.\r\n     */\r\n    private static readonly _DEFAULT_IOR = 1.5;\r\n\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 180;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsIor>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadIorPropertiesAsync(context: string, properties: IKHRMaterialsIor, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const indexOfRefraction = properties.ior !== undefined ? properties.ior : KHR_materials_ior._DEFAULT_IOR;\r\n        adapter.specularIor = indexOfRefraction;\r\n\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_ior(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { MaterialVariantsController } from \"../../glTFFileLoader\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\nexport { MaterialVariantsController };\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // Define options related types here so they can be referenced in the options,\r\n    // but export the types at the module level. This ensures the types are in the\r\n    // correct namespace for UMD.\r\n    type MaterialVariantsController = {\r\n        /**\r\n         * The list of available variant names for this asset.\r\n         */\r\n        readonly variants: readonly string[];\r\n\r\n        /**\r\n         * Gets or sets the selected variant.\r\n         */\r\n        selectedVariant: string;\r\n    };\r\n\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_variants extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_variants\"]: Partial<{\r\n            /**\r\n             * Specifies the name of the variant that should be selected by default.\r\n             */\r\n            defaultVariant: string;\r\n\r\n            /**\r\n             * Defines a callback that will be called if material variants are loaded.\r\n             * @experimental\r\n             */\r\n            onLoaded: (controller: MaterialVariantsController) => void;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME) && !this._loader.parent.skipMaterials;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootNode: TransformNode): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootNode: TransformNode): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public static Reset(rootNode: TransformNode): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public reset(rootNode: TransformNode): void {\r\n        KHR_materials_variants.Reset(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootNode: Nullable<TransformNode>): Nullable<IExtensionMetadata> {\r\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        const rootNode = this._loader.rootBabylonMesh;\r\n        if (rootNode) {\r\n            const options = this._loader.parent.extensionOptions[NAME];\r\n            if (options?.defaultVariant) {\r\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\r\n            }\r\n\r\n            options?.onLoaded?.({\r\n                get variants() {\r\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n                },\r\n                get selectedVariant(): string {\r\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n                    if (!lastSelectedVariant) {\r\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\r\n                    }\r\n                    if (Array.isArray(lastSelectedVariant)) {\r\n                        return lastSelectedVariant[0];\r\n                    }\r\n                    return lastSelectedVariant;\r\n                },\r\n                set selectedVariant(variantName) {\r\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot._internalMetadata = {};\r\n                                                for (const key in root._internalMetadata) {\r\n                                                    newRoot._internalMetadata[key] = root._internalMetadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot._internalMetadata.gltf = [];\r\n                                                for (const key in root._internalMetadata.gltf) {\r\n                                                    newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot._internalMetadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot._internalMetadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     * @returns the default options\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        return (material as any)?.subSurface?.isRefractionEnabled ? true : false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                if (this._transparentMeshesCache.indexOf(mesh) === -1) {\r\n                    this._transparentMeshesCache.push(mesh);\r\n                }\r\n            } else {\r\n                if (this._opaqueMeshesCache.indexOf(mesh) === -1) {\r\n                    this._opaqueMeshesCache.push(mesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material) {\r\n                const subSurface = (mesh.material as PBRMaterial).subSurface;\r\n                if (subSurface) {\r\n                    subSurface.refractionTexture = this._opaqueRenderTarget;\r\n                }\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Check if the opaque render target has not been disposed and can still be used.\r\n     * @returns\r\n     */\r\n    public _isRenderTargetValid() {\r\n        return this._opaqueRenderTarget?.getInternalTexture() !== null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    public _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n        this._opaqueRenderTarget.renderSprites = true;\r\n        this._opaqueRenderTarget.renderParticles = true;\r\n        this._opaqueRenderTarget.disableImageProcessing = true;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n        });\r\n\r\n        for (const mesh of this._transparentMeshesCache) {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const transmissionWeight = extension.transmissionFactor !== undefined ? extension.transmissionFactor : 0.0;\r\n\r\n        if (transmissionWeight === 0) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Set transmission properties immediately via adapter\r\n        adapter.configureTransmission();\r\n        adapter.transmissionWeight = transmissionWeight;\r\n\r\n        // Handle transmission helper setup (only needed for PBR materials)\r\n        if (transmissionWeight > 0) {\r\n            const scene = babylonMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (!scene._transmissionHelper) {\r\n                new TransmissionHelper({}, babylonMaterial.getScene());\r\n            } else if (!scene._transmissionHelper?._isRenderTargetValid()) {\r\n                // If the render target is not valid, recreate it.\r\n                scene._transmissionHelper?._setupRenderTargets();\r\n            }\r\n        }\r\n\r\n        // Load texture if present\r\n        let texturePromise: Promise<Nullable<BaseTexture>> = Promise.resolve(null);\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            texturePromise = this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, (texture: BaseTexture) => {\r\n                texture.name = `${babylonMaterial.name} (Transmission)`;\r\n                adapter.transmissionWeightTexture = texture;\r\n            });\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return texturePromise.then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_transmission(loader));\r\n","/* eslint-disable github/no-then */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsDiffuseTransmission } from \"babylonjs-gltf2interface\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_diffuse_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_diffuse_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsDiffuseTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTranslucentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsDiffuseTransmission): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        adapter.configureSubsurface();\r\n        adapter.subsurfaceWeight = extension.diffuseTransmissionFactor ?? 0;\r\n        adapter.subsurfaceColor = extension.diffuseTransmissionColorFactor !== undefined ? Color3.FromArray(extension.diffuseTransmissionColorFactor) : Color3.White();\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (extension.diffuseTransmissionTexture) {\r\n            (extension.diffuseTransmissionTexture as ITextureInfo).nonColorData = true;\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionTexture`, extension.diffuseTransmissionTexture).then((texture: BaseTexture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Transmission)`;\r\n                    adapter.subsurfaceWeightTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        if (extension.diffuseTransmissionColorTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionColorTexture`, extension.diffuseTransmissionColorTexture).then((texture: BaseTexture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Transmission Color)`;\r\n                    adapter.subsurfaceColorTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_diffuse_transmission(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_volume extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_volume\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 173;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            // We need to disable instance usage because the attenuation factor depends on the node scale of each individual mesh\r\n            this._loader._disableInstancedMesh++;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        if (this.enabled) {\r\n            this._loader._disableInstancedMesh--;\r\n        }\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsVolume>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadVolumePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsVolume): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if ((adapter.transmissionWeight === 0 && adapter.subsurfaceWeight === 0) || !extension.thicknessFactor) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        adapter.transmissionDepth = extension.attenuationDistance !== undefined ? extension.attenuationDistance : Number.MAX_VALUE;\r\n        adapter.transmissionColor =\r\n            extension.attenuationColor !== undefined && extension.attenuationColor.length == 3 ? Color3.FromArray(extension.attenuationColor) : Color3.White();\r\n        adapter.volumeThickness = extension.thicknessFactor ?? 0;\r\n\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        if (extension.thicknessTexture) {\r\n            (extension.thicknessTexture as ITextureInfo).nonColorData = true;\r\n            // eslint-disable-next-line github/no-then\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture, (texture: BaseTexture) => {\r\n                    texture.name = `${babylonMaterial.name} (Thickness)`;\r\n                    adapter.volumeThicknessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_volume(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsDispersion } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_dispersion\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_dispersion extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_dispersion\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_dispersion implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 174;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsDispersion>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadDispersionPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadDispersionPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsDispersion): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        // If transparency isn't enabled already, this extension shouldn't do anything.\r\n        // i.e. it requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if (adapter.transmissionWeight > 0 || !extension.dispersion) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        adapter.transmissionDispersionAbbeNumber = 20.0 / extension.dispersion;\r\n\r\n        return Promise.resolve();\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_dispersion(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\n\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsDiffuseRoughness } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_roughness\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_diffuse_roughness extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_diffuse_roughness\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/fdee35425ae560ea378092e38977216d63a094ec/extensions/2.0/Khronos/KHR_materials_diffuse_roughness/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_roughness implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 190;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsDiffuseRoughness>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadDiffuseRoughnessPropertiesAsync(extensionContext, extension, babylonMaterial));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadDiffuseRoughnessPropertiesAsync(context: string, properties: IKHRMaterialsDiffuseRoughness, babylonMaterial: Material): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const promises = new Array<Promise<any>>();\r\n\r\n        adapter.baseDiffuseRoughness = properties.diffuseRoughnessFactor ?? 0;\r\n\r\n        if (properties.diffuseRoughnessTexture) {\r\n            promises.push(\r\n                this._loader.loadTextureInfoAsync(`${context}/diffuseRoughnessTexture`, properties.diffuseRoughnessTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Diffuse Roughness)`;\r\n                    adapter.baseDiffuseRoughnessTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_diffuse_roughness(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_mesh_quantization\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_mesh_quantization extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_mesh_quantization\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_mesh_quantization implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {}\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_mesh_quantization(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { ITexture } from \"../glTFLoaderInterfaces\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { IKHRTextureBasisU } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_texture_basisu\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_texture_basisu extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_texture_basisu\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_basisu implements IGLTFLoaderExtension {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureBasisU, BaseTexture>(context, texture, this.name, async (extensionContext, extension) => {\r\n            const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);\r\n            const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);\r\n            return await this._loader._createTextureAsync(\r\n                context,\r\n                sampler,\r\n                image,\r\n                (babylonTexture) => {\r\n                    assign(babylonTexture);\r\n                },\r\n                texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : undefined,\r\n                !texture._textureInfo.nonColorData\r\n            );\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_texture_basisu(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\n\r\nimport type { ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_texture_transform extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_texture_transform\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRTextureTransform, BaseTexture>(context, textureInfo, this.name, async (extensionContext, extension) => {\r\n            return await this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {\r\n                if (!(babylonTexture instanceof Texture)) {\r\n                    throw new Error(`${extensionContext}: Texture type not supported`);\r\n                }\r\n\r\n                if (extension.offset) {\r\n                    babylonTexture.uOffset = extension.offset[0];\r\n                    babylonTexture.vOffset = extension.offset[1];\r\n                }\r\n\r\n                // Always rotate around the origin.\r\n                babylonTexture.uRotationCenter = 0;\r\n                babylonTexture.vRotationCenter = 0;\r\n\r\n                if (extension.rotation) {\r\n                    babylonTexture.wAng = -extension.rotation;\r\n                }\r\n\r\n                if (extension.scale) {\r\n                    babylonTexture.uScale = extension.scale[0];\r\n                    babylonTexture.vScale = extension.scale[1];\r\n                }\r\n\r\n                if (extension.texCoord != undefined) {\r\n                    babylonTexture.coordinatesIndex = extension.texCoord;\r\n                }\r\n\r\n                assign(babylonTexture);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_texture_transform(loader));\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRXmpJsonLd_Gltf, IKHRXmpJsonLd_Node } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"KHR_xmp_json_ld\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_xmp_json_ld extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_xmp_json_ld\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/README.md)\r\n * @since 5.0.0\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_xmp_json_ld implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Called after the loader state changes to LOADING.\r\n     */\r\n    public onLoading(): void {\r\n        if (this._loader.rootBabylonMesh === null) {\r\n            return;\r\n        }\r\n\r\n        const xmpGltf = this._loader.gltf.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Gltf;\r\n        const xmpNode = this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld as IKHRXmpJsonLd_Node;\r\n        if (xmpGltf && xmpNode) {\r\n            const packet = +xmpNode.packet;\r\n            if (xmpGltf.packets && packet < xmpGltf.packets.length) {\r\n                this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};\r\n                this._loader.rootBabylonMesh.metadata.xmp = xmpGltf.packets[packet];\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_xmp_json_ld(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport type { ICamera, IKHRLightsPunctual_Light, IMaterial, INode } from \"../glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { AnimationPropertyInfo } from \"../glTFLoaderAnimation\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { SetInterpolationForKey } from \"./objectModelMapping\";\r\n\r\nfunction getColor3(_target: any, source: Float32Array, offset: number, scale: number): Color3 {\r\n    return Color3.FromArray(source, offset).scale(scale);\r\n}\r\n\r\nfunction getAlpha(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 3] * scale;\r\n}\r\n\r\nfunction getFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale;\r\n}\r\n\r\nfunction getMinusFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return -source[offset] * scale;\r\n}\r\n\r\nfunction getNextFloat(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset + 1] * scale;\r\n}\r\n\r\nfunction getFloatBy2(_target: any, source: Float32Array, offset: number, scale: number): number {\r\n    return source[offset] * scale * 2;\r\n}\r\n\r\nfunction getTextureTransformTree(textureName: string) {\r\n    return {\r\n        scale: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2),\r\n        ],\r\n        offset: [\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),\r\n            new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2),\r\n        ],\r\n        rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)],\r\n    };\r\n}\r\n\r\nclass CameraAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: ICamera, name: string, fps: number, keys: any[]) {\r\n        return [{ babylonAnimatable: target._babylonCamera!, babylonAnimation: this._buildAnimation(name, fps, keys) }];\r\n    }\r\n}\r\n\r\nclass MaterialAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: IMaterial, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        for (const fillMode in target._data!) {\r\n            babylonAnimations.push({\r\n                babylonAnimatable: target._data[fillMode].babylonMaterial,\r\n                babylonAnimation: this._buildAnimation(name, fps, keys),\r\n            });\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nclass LightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: IKHRLightsPunctual_Light, name: string, fps: number, keys: any[]) {\r\n        return [{ babylonAnimatable: target._babylonLight!, babylonAnimation: this._buildAnimation(name, fps, keys) }];\r\n    }\r\n}\r\n\r\nclass MeshAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        return target._primitiveBabylonMeshes\r\n            ? target._primitiveBabylonMeshes.map((mesh) => ({ babylonAnimatable: mesh, babylonAnimation: this._buildAnimation(name, fps, keys) }))\r\n            : [];\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/xmag\", [\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoLeft\", getMinusFloat, () => 1),\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoRight\", getNextFloat, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/ymag\", [\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoBottom\", getMinusFloat, () => 1),\r\n    new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"orthoTop\", getNextFloat, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/zfar\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/orthographic/znear\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)]);\r\n\r\nSetInterpolationForKey(\"/cameras/{}/perspective/yfov\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"fov\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/perspective/zfar\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"maxZ\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/cameras/{}/perspective/znear\", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"minZ\", getFloat, () => 1)]);\r\n\r\n// add interpolation to the materials mapping\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"albedoColor\", getColor3, () => 4),\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"alpha\", getAlpha, () => 4),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/metallicFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallic\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/metallicFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"roughness\", getFloat, () => 1)]);\r\nconst baseColorTextureInterpolation = getTextureTransformTree(\"albedoTexture\");\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale\", baseColorTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset\", baseColorTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/rotation\", baseColorTextureInterpolation.rotation);\r\n\r\nconst metallicRoughnessTextureInterpolation = getTextureTransformTree(\"metallicTexture\");\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/scale\", metallicRoughnessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/offset\", metallicRoughnessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/rotation\", metallicRoughnessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/emissiveFactor\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"emissiveColor\", getColor3, () => 3)]);\r\nconst normalTextureInterpolation = getTextureTransformTree(\"bumpTexture\");\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/scale\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"bumpTexture.level\", getFloat, () => 1)]);\r\n\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/scale\", normalTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/offset\", normalTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/normalTexture/extensions/KHR_texture_transform/rotation\", normalTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/strength\", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"ambientTextureStrength\", getFloat, () => 1)]);\r\n\r\nconst occlusionTextureInterpolation = getTextureTransformTree(\"ambientTexture\");\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/scale\", occlusionTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/offset\", occlusionTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/occlusionTexture/extensions/KHR_texture_transform/rotation\", occlusionTextureInterpolation.rotation);\r\nconst emissiveTextureInterpolation = getTextureTransformTree(\"emissiveTexture\");\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/scale\", emissiveTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/offset\", emissiveTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/emissiveTexture/extensions/KHR_texture_transform/rotation\", emissiveTextureInterpolation.rotation);\r\n\r\n// materials extensions\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyStrength\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"anisotropy.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyRotation\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"anisotropy.angle\", getFloat, () => 1),\r\n]);\r\nconst anisotropyTextureInterpolation = getTextureTransformTree(\"anisotropy.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/scale\", anisotropyTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/offset\", anisotropyTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/rotation\", anisotropyTextureInterpolation.rotation);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.roughness\", getFloat, () => 1),\r\n]);\r\nconst clearcoatTextureInterpolation = getTextureTransformTree(\"clearCoat.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/scale\", clearcoatTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/offset\", clearcoatTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/rotation\", clearcoatTextureInterpolation.rotation);\r\nconst clearcoatNormalTextureInterpolation = getTextureTransformTree(\"clearCoat.bumpTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/scale\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"clearCoat.bumpTexture.level\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/scale\", clearcoatNormalTextureInterpolation.scale);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/offset\",\r\n    clearcoatNormalTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/rotation\",\r\n    clearcoatNormalTextureInterpolation.rotation\r\n);\r\nconst clearcoatRoughnessTextureInterpolation = getTextureTransformTree(\"clearCoat.textureRoughness\");\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/scale\",\r\n    clearcoatRoughnessTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/offset\",\r\n    clearcoatRoughnessTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/rotation\",\r\n    clearcoatRoughnessTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_dispersion/dispersionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.dispersion\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_emissive_strength/emissiveStrength\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"emissiveIntensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_ior/ior\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"indexOfRefraction\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.intensity\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceIor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.indexOfRefraction\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMinimum\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.minimumThickness\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMaximum\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"iridescence.maximumThickness\", getFloat, () => 1),\r\n]);\r\n\r\nconst iridescenceTextureInterpolation = getTextureTransformTree(\"iridescence.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/scale\", iridescenceTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/offset\", iridescenceTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/rotation\", iridescenceTextureInterpolation.rotation);\r\n\r\nconst iridescenceThicknessTextureInterpolation = getTextureTransformTree(\"iridescence.thicknessTexture\");\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/scale\",\r\n    iridescenceThicknessTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/offset\",\r\n    iridescenceThicknessTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/rotation\",\r\n    iridescenceThicknessTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"sheen.color\", getColor3, () => 3),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"sheen.roughness\", getFloat, () => 1),\r\n]);\r\n\r\nconst sheenTextureInterpolation = getTextureTransformTree(\"sheen.texture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/scale\", sheenTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/offset\", sheenTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/rotation\", sheenTextureInterpolation.rotation);\r\n\r\nconst sheenRoughnessTextureInterpolation = getTextureTransformTree(\"sheen.textureRoughness\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/scale\", sheenRoughnessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/offset\", sheenRoughnessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/rotation\", sheenRoughnessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"metallicF0Factor\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"metallicReflectanceColor\", getColor3, () => 3),\r\n]);\r\n\r\nconst specularTextureInterpolation = getTextureTransformTree(\"metallicReflectanceTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/scale\", specularTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/offset\", specularTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/rotation\", specularTextureInterpolation.rotation);\r\nconst specularColorTextureInterpolation = getTextureTransformTree(\"reflectanceTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/scale\", specularColorTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/offset\", specularColorTextureInterpolation.offset);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/rotation\",\r\n    specularColorTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.refractionIntensity\", getFloat, () => 1),\r\n]);\r\nconst transmissionTextureInterpolation = getTextureTransformTree(\"subSurface.refractionIntensityTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/scale\", transmissionTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/offset\", transmissionTextureInterpolation.offset);\r\nSetInterpolationForKey(\r\n    \"/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/rotation\",\r\n    transmissionTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/attenuationColor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.tintColor\", getColor3, () => 3),\r\n]);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/attenuationDistance\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.tintColorAtDistance\", getFloat, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.maximumThickness\", getFloat, () => 1),\r\n]);\r\n\r\nconst thicknessTextureInterpolation = getTextureTransformTree(\"subSurface.thicknessTexture\");\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/scale\", thicknessTextureInterpolation.scale);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/offset\", thicknessTextureInterpolation.offset);\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/rotation\", thicknessTextureInterpolation.rotation);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"subSurface.translucencyIntensity\", getFloat, () => 1),\r\n]);\r\n\r\nconst diffuseTransmissionTextureInterpolation = getTextureTransformTree(\"subSurface.translucencyIntensityTexture\");\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/scale\",\r\n    diffuseTransmissionTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/offset\",\r\n    diffuseTransmissionTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/rotation\",\r\n    diffuseTransmissionTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorFactor\", [\r\n    new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"subSurface.translucencyColor\", getColor3, () => 3),\r\n]);\r\n\r\nconst diffuseTransmissionColorTextureInterpolation = getTextureTransformTree(\"subSurface.translucencyColorTexture\");\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/scale\",\r\n    diffuseTransmissionColorTextureInterpolation.scale\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/offset\",\r\n    diffuseTransmissionColorTextureInterpolation.offset\r\n);\r\nSetInterpolationForKey(\r\n    \"materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/rotation\",\r\n    diffuseTransmissionColorTextureInterpolation.rotation\r\n);\r\n\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/color\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/intensity\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/range\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"range\", getFloat, () => 1)]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/spot/innerConeAngle\", [\r\n    new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"innerAngle\", getFloatBy2, () => 1),\r\n]);\r\nSetInterpolationForKey(\"/extensions/KHR_lights_punctual/lights/{}/spot/outerConeAngle\", [\r\n    new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"angle\", getFloatBy2, () => 1),\r\n]);\r\n\r\nSetInterpolationForKey(\"/nodes/{}/extensions/EXT_lights_ies/color\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, \"diffuse\", getColor3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/extensions/EXT_lights_ies/multiplier\", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"intensity\", getFloat, () => 1)]);\r\n\r\nSetInterpolationForKey(\"/nodes/{}/extensions/KHR_node_visibility/visible\", [new MeshAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"isVisible\", getFloat, () => 1)]);\r\n","import type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimation, IAnimationChannel } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRAnimationPointer } from \"babylonjs-gltf2interface\";\r\nimport { AnimationChannelTargetPath } from \"babylonjs-gltf2interface\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport { GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport \"./KHR_animation_pointer.data\";\r\n\r\nconst NAME = \"KHR_animation_pointer\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_animation_pointer extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_animation_pointer\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification PR](https://github.com/KhronosGroup/glTF/pull/2147)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_animation_pointer implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _pathToObjectConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this._pathToObjectConverter = GetPathToObjectConverter(this._loader.gltf);\r\n    }\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public get enabled(): boolean {\r\n        return this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathToObjectConverter; // GC\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete or null if not handled\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        const extension = channel.target.extensions?.KHR_animation_pointer as IKHRAnimationPointer;\r\n        if (!extension || !this._pathToObjectConverter) {\r\n            return null;\r\n        }\r\n\r\n        if (channel.target.path !== AnimationChannelTargetPath.POINTER) {\r\n            Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${AnimationChannelTargetPath.POINTER}) when using the ${this.name} extension`);\r\n        }\r\n\r\n        if (channel.target.node != undefined) {\r\n            Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);\r\n        }\r\n\r\n        const extensionContext = `${context}/extensions/${this.name}`;\r\n\r\n        const pointer = extension.pointer;\r\n        if (!pointer) {\r\n            throw new Error(`${extensionContext}: Pointer is missing`);\r\n        }\r\n\r\n        try {\r\n            const obj = this._pathToObjectConverter.convert(pointer);\r\n            if (!obj.info.interpolation) {\r\n                throw new Error(`${extensionContext}/pointer: Interpolation is missing`);\r\n            }\r\n            return this._loader._loadAnimationChannelFromTargetInfoAsync(\r\n                context,\r\n                animationContext,\r\n                animation,\r\n                channel,\r\n                {\r\n                    object: obj.object,\r\n                    info: obj.info.interpolation,\r\n                },\r\n                onLoad\r\n            );\r\n        } catch (e) {\r\n            Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_animation_pointer(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Audio/audioSceneComponent\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_audio_emitter extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_audio_emitter\"]: {};\r\n    }\r\n}\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                for (const emitterIndex of extension.emitters) {\r\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                            for (const sound of emitter._babylonSounds) {\r\n                                sound.attachToMesh(babylonMesh);\r\n                                if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                    sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                    sound.setDirectionalCone(\r\n                                        2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                        2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                        0\r\n                                    );\r\n                                }\r\n                            }\r\n                        })\r\n                    );\r\n                }\r\n\r\n                assign(babylonMesh);\r\n            });\r\n            await Promise.all(promises);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, async (extensionContext, extension) => {\r\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\r\n            const promises = new Array<Promise<any>>();\r\n            ArrayItem.Assign(extension.events);\r\n            for (const event of extension.events) {\r\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n            }\r\n            await Promise.all(promises);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    // eslint-disable-next-line github/no-then\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        // eslint-disable-next-line github/no-then\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\r\n","/* eslint-disable github/no-then */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_lod extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_lod\"]: Partial<{\r\n            /**\r\n             * Maximum number of LODs to load, starting from the lowest LOD.\r\n             */\r\n            maxLODsToLoad: number;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.\r\n        // For new extensions, they should only use options.\r\n        this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME]?.maxLODsToLoad ?? this.maxLODsToLoad;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = async (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return await bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties: T[] = [];\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials: Material[] = [];\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_lod(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_minecraftMesh\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_minecraftMesh extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_minecraftMesh\"]: {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_minecraftMesh implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, async (extraContext, extra) => {\r\n            if (extra) {\r\n                if (!this._loader._pbrMaterialImpl) {\r\n                    throw new Error(`${extraContext}: Material type not supported`);\r\n                }\r\n\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                if (babylonMaterial.needAlphaBlending()) {\r\n                    babylonMaterial.forceDepthWrite = true;\r\n                    babylonMaterial.separateCullingPass = true;\r\n                }\r\n\r\n                babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;\r\n                (babylonMaterial as PBRMaterial).twoSidedLighting = true;\r\n\r\n                return await promise;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_minecraftMesh(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_sRGBFactors\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_sRGBFactors extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_sRGBFactors\"]: {};\r\n    }\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_sRGBFactors implements IGLTFLoaderExtension {\r\n    /** @internal */\r\n    public readonly name = NAME;\r\n\r\n    /** @internal */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /** @internal */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /** @internal*/\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtraAsync<boolean>(context, material, this.name, async (extraContext, extra) => {\r\n            if (extra) {\r\n                const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n                const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n\r\n                const useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;\r\n                if (!adapter.baseColorTexture) {\r\n                    adapter.baseColor.toLinearSpaceToRef(adapter.baseColor, useExactSrgbConversions);\r\n                }\r\n                if (!adapter.specularColorTexture) {\r\n                    adapter.specularColor.toLinearSpaceToRef(adapter.specularColor, useExactSrgbConversions);\r\n                }\r\n\r\n                return await promise;\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_sRGBFactors(loader));\r\n","/* eslint-disable @typescript-eslint/naming-convention */\nimport type { IKHRInteractivity_Declaration, IKHRInteractivity_Graph, IKHRInteractivity_Node } from \"babylonjs-gltf2interface\";\nimport { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport type { InteractivityEvent, InteractivityGraphToFlowGraphParser } from \"./interactivityGraphParser\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport { FlowGraphTypes, getAnimationTypeByFlowGraphType } from \"core/FlowGraph/flowGraphRichTypes\";\n\ninterface IGLTFToFlowGraphMappingObject<I = any, O = any> {\n    /**\n     * The name of the property in the FlowGraph block.\n     */\n    name: string;\n    /**\n     * The type of the property in the glTF specs.\n     * If not provided will be inferred.\n     */\n    gltfType?: string;\n    /**\n     * The type of the property in the FlowGraph block.\n     * If not defined it equals the glTF type.\n     */\n    flowGraphType?: string;\n    /**\n     * A function that transforms the data from the glTF to the FlowGraph block.\n     */\n    dataTransformer?: (data: I[], parser: InteractivityGraphToFlowGraphParser) => O[];\n    /**\n     * If the property is in the options passed to the constructor of the block.\n     */\n    inOptions?: boolean;\n\n    /**\n     * If the property is a pointer to a value.\n     * This will add an extra JsonPointerParser block to the graph.\n     */\n    isPointer?: boolean;\n\n    /**\n     * If the property is an index to a value.\n     * if defined this will be the name of the array to find the object in.\n     */\n    isVariable?: boolean;\n\n    /**\n     * the name of the class type this value will be mapped to.\n     * This is used if we generate more than one block for a single glTF node.\n     * Defaults to the first block in the mapping.\n     */\n    toBlock?: FlowGraphBlockNames;\n\n    /**\n     * Used in configuration values. If defined, this will be the default value, if no value is provided.\n     */\n    defaultValue?: O;\n}\n\nexport interface IGLTFToFlowGraphMapping {\n    /**\n     * The type of the FlowGraph block(s).\n     * Typically will be a single element in an array.\n     * When adding blocks defined in this module use the KHR_interactivity prefix.\n     */\n    blocks: (FlowGraphBlockNames | string)[];\n    /**\n     * The inputs of the glTF node mapped to the FlowGraph block.\n     */\n    inputs?: {\n        /**\n         * The value inputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow inputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The outputs of the glTF node mapped to the FlowGraph block.\n     */\n    outputs?: {\n        /**\n         * The value outputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow outputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The configuration of the glTF node mapped to the FlowGraph block.\n     * This information is usually passed to the constructor of the block.\n     */\n    configuration?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * If we generate more than one block for a single glTF node, this mapping will be used to map\n     * between the flowGraph classes.\n     */\n    typeToTypeMapping?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * The connections between two or more blocks.\n     * This is used to connect the blocks in the graph\n     */\n    interBlockConnectors?: {\n        /**\n         * The name of the input connection in the first block.\n         */\n        input: string;\n        /**\n         * The name of the output connection in the second block.\n         */\n        output: string;\n\n        /**\n         * The index of the block in the array of blocks that corresponds to the input.\n         */\n        inputBlockIndex: number;\n        /**\n         * The index of the block in the array of blocks that corresponds to the output.\n         */\n        outputBlockIndex: number;\n        /**\n         * If the connection is a variable connection or a flow connection.\n         */\n        isVariable?: boolean;\n    }[];\n\n    /**\n     * This optional function will allow to validate the node, according to the glTF specs.\n     * For example, if a node has a configuration object, it must be present and correct.\n     * This is a basic node-based validation.\n     * This function is expected to return false and log the error if the node is not valid.\n     * Note that this function can also modify the node, if needed.\n     *\n     * @param gltfBlock the glTF node to validate\n     * @param glTFObject the glTF object\n     * @returns true if validated, false if not.\n     */\n    validation?: (gltfBlock: IKHRInteractivity_Node, interactivityGraph: IKHRInteractivity_Graph, glTFObject?: IGLTF) => { valid: boolean; error?: string };\n\n    /**\n     * This is used if we need extra information for the constructor/options that is not provided directly by the glTF node.\n     * This function can return more than one node, if extra nodes are needed for this block to function correctly.\n     * Returning more than one block will usually happen when a json pointer was provided.\n     *\n     * @param gltfBlock the glTF node\n     * @param mapping the mapping object\n     * @param arrays the arrays of the interactivity object\n     * @param serializedObjects the serialized object\n     * @returns an array of serialized nodes that will be added to the graph.\n     */\n    extraProcessor?: (\n        gltfBlock: IKHRInteractivity_Node,\n        declaration: IKHRInteractivity_Declaration,\n        mapping: IGLTFToFlowGraphMapping,\n        parser: InteractivityGraphToFlowGraphParser,\n        serializedObjects: ISerializedFlowGraphBlock[],\n        context: ISerializedFlowGraphContext,\n        globalGLTF?: IGLTF\n    ) => ISerializedFlowGraphBlock[];\n}\n\nexport function getMappingForFullOperationName(fullOperationName: string) {\n    const [op, extension] = fullOperationName.split(\":\");\n    return getMappingForDeclaration({ op, extension });\n}\n\nexport function getMappingForDeclaration(declaration: IKHRInteractivity_Declaration, returnNoOpIfNotAvailable: boolean = true): IGLTFToFlowGraphMapping | undefined {\n    const mapping = declaration.extension ? gltfExtensionsToFlowGraphMapping[declaration.extension]?.[declaration.op] : gltfToFlowGraphMapping[declaration.op];\n    if (!mapping) {\n        Logger.Warn(`No mapping found for operation ${declaration.op} and extension ${declaration.extension || \"KHR_interactivity\"}`);\n        if (returnNoOpIfNotAvailable) {\n            const inputs: IGLTFToFlowGraphMapping[\"inputs\"] = {};\n            const outputs: IGLTFToFlowGraphMapping[\"outputs\"] = {\n                flows: {},\n            };\n            if (declaration.inputValueSockets) {\n                inputs.values = {};\n                for (const key in declaration.inputValueSockets) {\n                    inputs.values[key] = {\n                        name: key,\n                    };\n                }\n            }\n            if (declaration.outputValueSockets) {\n                outputs.values = {};\n                Object.keys(declaration.outputValueSockets).forEach((key) => {\n                    outputs.values![key] = {\n                        name: key,\n                    };\n                });\n            }\n            return {\n                blocks: [], // no blocks, just mapping\n                inputs,\n                outputs,\n            };\n        }\n    }\n    return mapping;\n}\n\n/**\n * This function will add new mapping to glTF interactivity.\n * Other extensions can define new types of blocks, this is the way to let interactivity know how to parse them.\n * @param key the type of node, i.e. \"variable/get\"\n * @param extension the extension of the interactivity operation, i.e. \"KHR_selectability\"\n * @param mapping The mapping object. See documentation or examples below.\n */\nexport function addNewInteractivityFlowGraphMapping(key: string, extension: string, mapping: IGLTFToFlowGraphMapping) {\n    gltfExtensionsToFlowGraphMapping[extension] ||= {};\n    gltfExtensionsToFlowGraphMapping[extension][key] = mapping;\n}\n\nconst gltfExtensionsToFlowGraphMapping: { [extension: string]: { [key: string]: IGLTFToFlowGraphMapping } } = {\n    /**\n     * This is the BABYLON extension for glTF interactivity.\n     * It defines babylon-specific blocks and operations.\n     */\n    BABYLON: {\n        /**\n         * flow/log is a flow node that logs input to the console.\n         * It has \"in\" and \"out\" flows, and takes a message as input.\n         * The message can be any type of value.\n         * The message is logged to the console when the \"in\" flow is triggered.\n         * The \"out\" flow is triggered when the message is logged.\n         */\n        \"flow/log\": {\n            blocks: [FlowGraphBlockNames.ConsoleLog],\n            inputs: {\n                values: {\n                    message: { name: \"message\" },\n                },\n            },\n        },\n    },\n};\n\n// this mapper is just a way to convert the glTF nodes to FlowGraph nodes in terms of input/output connection names and values.\nconst gltfToFlowGraphMapping: { [key: string]: IGLTFToFlowGraphMapping } = {\n    \"event/onStart\": {\n        blocks: [FlowGraphBlockNames.SceneReadyEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/onTick\": {\n        blocks: [FlowGraphBlockNames.SceneTickEvent],\n        inputs: {},\n        outputs: {\n            values: {\n                timeSinceLastTick: { name: \"deltaTime\", gltfType: \"number\" /*, dataTransformer: (time: number) => time / 1000*/ },\n            },\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/send\": {\n        blocks: [FlowGraphBlockNames.SendCustomEvent],\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/send\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"event/receive\": {\n        blocks: [FlowGraphBlockNames.ReceiveCustomEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n        validation(gltfBlock, interactivityGraph) {\n            if (!gltfBlock.configuration) {\n                Logger.Error(\"Receive event should have a configuration object\");\n                return { valid: false, error: \"Receive event should have a configuration object\" };\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            if (!eventConfiguration) {\n                Logger.Error(\"Receive event should have a single configuration object, the event itself\");\n                return { valid: false, error: \"Receive event should have a single configuration object, the event itself\" };\n            }\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                Logger.Error(\"Event id should be a number\");\n                return { valid: false, error: \"Event id should be a number\" };\n            }\n            const event = interactivityGraph.events?.[eventId];\n            if (!event) {\n                Logger.Error(`Event with id ${eventId} not found`);\n                return { valid: false, error: `Event with id ${eventId} not found` };\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/receive\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"math/E\": getSimpleInputMapping(FlowGraphBlockNames.E),\n    \"math/Pi\": getSimpleInputMapping(FlowGraphBlockNames.PI),\n    \"math/Inf\": getSimpleInputMapping(FlowGraphBlockNames.Inf),\n    \"math/NaN\": getSimpleInputMapping(FlowGraphBlockNames.NaN),\n    \"math/abs\": getSimpleInputMapping(FlowGraphBlockNames.Abs),\n    \"math/sign\": getSimpleInputMapping(FlowGraphBlockNames.Sign),\n    \"math/trunc\": getSimpleInputMapping(FlowGraphBlockNames.Trunc),\n    \"math/floor\": getSimpleInputMapping(FlowGraphBlockNames.Floor),\n    \"math/ceil\": getSimpleInputMapping(FlowGraphBlockNames.Ceil),\n    \"math/round\": {\n        blocks: [FlowGraphBlockNames.Round],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.roundHalfAwayFromZero = true;\n            return serializedObjects;\n        },\n    },\n    \"math/fract\": getSimpleInputMapping(FlowGraphBlockNames.Fraction),\n    \"math/neg\": getSimpleInputMapping(FlowGraphBlockNames.Negation),\n    \"math/add\": getSimpleInputMapping(FlowGraphBlockNames.Add, [\"a\", \"b\"], true),\n    \"math/sub\": getSimpleInputMapping(FlowGraphBlockNames.Subtract, [\"a\", \"b\"], true),\n    \"math/mul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.useMatrixPerComponent = true;\n            serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n            // try to infer the type or fallback to Integer\n            // check the gltf block for the inputs, see if they have a type\n            let type = -1;\n            Object.keys(_gltfBlock.values || {}).find((value) => {\n                if (_gltfBlock.values?.[value].type !== undefined) {\n                    type = _gltfBlock.values[value].type;\n                    return true;\n                }\n                return false;\n            });\n            if (type !== -1) {\n                serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.values) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    },\n    \"math/div\": getSimpleInputMapping(FlowGraphBlockNames.Divide, [\"a\", \"b\"], true),\n    \"math/rem\": getSimpleInputMapping(FlowGraphBlockNames.Modulo, [\"a\", \"b\"]),\n    \"math/min\": getSimpleInputMapping(FlowGraphBlockNames.Min, [\"a\", \"b\"]),\n    \"math/max\": getSimpleInputMapping(FlowGraphBlockNames.Max, [\"a\", \"b\"]),\n    \"math/clamp\": getSimpleInputMapping(FlowGraphBlockNames.Clamp, [\"a\", \"b\", \"c\"]),\n    \"math/saturate\": getSimpleInputMapping(FlowGraphBlockNames.Saturate),\n    \"math/mix\": getSimpleInputMapping(FlowGraphBlockNames.MathInterpolation, [\"a\", \"b\", \"c\"]),\n    \"math/eq\": getSimpleInputMapping(FlowGraphBlockNames.Equality, [\"a\", \"b\"]),\n    \"math/lt\": getSimpleInputMapping(FlowGraphBlockNames.LessThan, [\"a\", \"b\"]),\n    \"math/le\": getSimpleInputMapping(FlowGraphBlockNames.LessThanOrEqual, [\"a\", \"b\"]),\n    \"math/gt\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThan, [\"a\", \"b\"]),\n    \"math/ge\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThanOrEqual, [\"a\", \"b\"]),\n    \"math/isNaN\": getSimpleInputMapping(FlowGraphBlockNames.IsNaN),\n    \"math/isInf\": getSimpleInputMapping(FlowGraphBlockNames.IsInfinity),\n    \"math/select\": {\n        blocks: [FlowGraphBlockNames.Conditional],\n        inputs: {\n            values: {\n                condition: { name: \"condition\" },\n                // Should we validate those have the same type here, or assume it is already validated?\n                a: { name: \"onTrue\" },\n                b: { name: \"onFalse\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"output\" },\n            },\n        },\n    },\n    \"math/random\": {\n        blocks: [FlowGraphBlockNames.Random],\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/sin\": getSimpleInputMapping(FlowGraphBlockNames.Sin),\n    \"math/cos\": getSimpleInputMapping(FlowGraphBlockNames.Cos),\n    \"math/tan\": getSimpleInputMapping(FlowGraphBlockNames.Tan),\n    \"math/asin\": getSimpleInputMapping(FlowGraphBlockNames.Asin),\n    \"math/acos\": getSimpleInputMapping(FlowGraphBlockNames.Acos),\n    \"math/atan\": getSimpleInputMapping(FlowGraphBlockNames.Atan),\n    \"math/atan2\": getSimpleInputMapping(FlowGraphBlockNames.Atan2, [\"a\", \"b\"]),\n    \"math/sinh\": getSimpleInputMapping(FlowGraphBlockNames.Sinh),\n    \"math/cosh\": getSimpleInputMapping(FlowGraphBlockNames.Cosh),\n    \"math/tanh\": getSimpleInputMapping(FlowGraphBlockNames.Tanh),\n    \"math/asinh\": getSimpleInputMapping(FlowGraphBlockNames.Asinh),\n    \"math/acosh\": getSimpleInputMapping(FlowGraphBlockNames.Acosh),\n    \"math/atanh\": getSimpleInputMapping(FlowGraphBlockNames.Atanh),\n    \"math/exp\": getSimpleInputMapping(FlowGraphBlockNames.Exponential),\n    \"math/log\": getSimpleInputMapping(FlowGraphBlockNames.Log),\n    \"math/log2\": getSimpleInputMapping(FlowGraphBlockNames.Log2),\n    \"math/log10\": getSimpleInputMapping(FlowGraphBlockNames.Log10),\n    \"math/sqrt\": getSimpleInputMapping(FlowGraphBlockNames.SquareRoot),\n    \"math/cbrt\": getSimpleInputMapping(FlowGraphBlockNames.CubeRoot),\n    \"math/pow\": getSimpleInputMapping(FlowGraphBlockNames.Power, [\"a\", \"b\"]),\n    \"math/length\": getSimpleInputMapping(FlowGraphBlockNames.Length),\n    \"math/normalize\": getSimpleInputMapping(FlowGraphBlockNames.Normalize),\n    \"math/dot\": getSimpleInputMapping(FlowGraphBlockNames.Dot, [\"a\", \"b\"]),\n    \"math/cross\": getSimpleInputMapping(FlowGraphBlockNames.Cross, [\"a\", \"b\"]),\n    \"math/rotate2D\": {\n        blocks: [FlowGraphBlockNames.Rotate2D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                angle: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/rotate3D\": {\n        blocks: [FlowGraphBlockNames.Rotate3D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                rotation: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/transform\": {\n        // glTF transform is vectorN with matrixN\n        blocks: [FlowGraphBlockNames.TransformVector],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine2\": {\n        blocks: [FlowGraphBlockNames.CombineVector2],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine3\": {\n        blocks: [FlowGraphBlockNames.CombineVector3],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine4\": {\n        blocks: [FlowGraphBlockNames.CombineVector4],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    // one input, N outputs! outputs named using numbers.\n    \"math/extract2\": {\n        blocks: [FlowGraphBlockNames.ExtractVector2],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n            },\n        },\n    },\n    \"math/extract3\": {\n        blocks: [FlowGraphBlockNames.ExtractVector3],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n            },\n        },\n    },\n    \"math/extract4\": {\n        blocks: [FlowGraphBlockNames.ExtractVector4],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/transpose\": getSimpleInputMapping(FlowGraphBlockNames.Transpose),\n    \"math/determinant\": getSimpleInputMapping(FlowGraphBlockNames.Determinant),\n    \"math/inverse\": getSimpleInputMapping(FlowGraphBlockNames.InvertMatrix),\n    \"math/matMul\": getSimpleInputMapping(FlowGraphBlockNames.MatrixMultiplication, [\"a\", \"b\"]),\n    \"math/matCompose\": {\n        blocks: [FlowGraphBlockNames.MatrixCompose],\n        inputs: {\n            values: {\n                translation: { name: \"position\", gltfType: \"float3\" },\n                rotation: { name: \"rotationQuaternion\", gltfType: \"float4\" },\n                scale: { name: \"scaling\", gltfType: \"float3\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            const d = serializedObjects[0].dataInputs.find((input) => input.name === \"rotationQuaternion\");\n            if (!d) {\n                throw new Error(\"Rotation quaternion input not found\");\n            }\n            // if value is defined, set the type to quaternion\n            if (context._connectionValues[d.uniqueId]) {\n                context._connectionValues[d.uniqueId].type = FlowGraphTypes.Quaternion;\n            }\n            return serializedObjects;\n        },\n    },\n    \"math/matDecompose\": {\n        blocks: [FlowGraphBlockNames.MatrixDecompose],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                translation: { name: \"position\" },\n                rotation: { name: \"rotationQuaternion\" },\n                scale: { name: \"scaling\" },\n            },\n        },\n    },\n    \"math/quatConjugate\": getSimpleInputMapping(FlowGraphBlockNames.Conjugate, [\"a\"]),\n    \"math/quatMul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        inputs: {\n            values: {\n                a: { name: \"a\", gltfType: \"vector4\" },\n                b: { name: \"b\", gltfType: \"vector4\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.type = FlowGraphTypes.Quaternion;\n            return serializedObjects;\n        },\n    },\n    \"math/quatAngleBetween\": getSimpleInputMapping(FlowGraphBlockNames.AngleBetween, [\"a\", \"b\"]),\n    \"math/quatFromAxisAngle\": {\n        blocks: [FlowGraphBlockNames.QuaternionFromAxisAngle],\n        inputs: {\n            values: {\n                axis: { name: \"a\", gltfType: \"float3\" },\n                angle: { name: \"b\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/quatToAxisAngle\": getSimpleInputMapping(FlowGraphBlockNames.AxisAngleFromQuaternion, [\"a\"]),\n    \"math/quatFromDirections\": getSimpleInputMapping(FlowGraphBlockNames.QuaternionFromDirections, [\"a\", \"b\"]),\n    \"math/combine2x2\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract2x2\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float2x2\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/combine3x3\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract3x3\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float3x3\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n            },\n        },\n    },\n    \"math/combine4x4\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n                j: { name: \"input_9\", gltfType: \"number\" },\n                k: { name: \"input_10\", gltfType: \"number\" },\n                l: { name: \"input_11\", gltfType: \"number\" },\n                m: { name: \"input_12\", gltfType: \"number\" },\n                n: { name: \"input_13\", gltfType: \"number\" },\n                o: { name: \"input_14\", gltfType: \"number\" },\n                p: { name: \"input_15\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract4x4\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n                \"9\": { name: \"output_9\" },\n                \"10\": { name: \"output_10\" },\n                \"11\": { name: \"output_11\" },\n                \"12\": { name: \"output_12\" },\n                \"13\": { name: \"output_13\" },\n                \"14\": { name: \"output_14\" },\n                \"15\": { name: \"output_15\" },\n            },\n        },\n    },\n    \"math/not\": {\n        blocks: [FlowGraphBlockNames.BitwiseNot],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketIn = serializedObjects[0].dataInputs[0];\n            serializedObjects[0].config.valueType = context._connectionValues[socketIn.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/and\": {\n        blocks: [FlowGraphBlockNames.BitwiseAnd],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/or\": {\n        blocks: [FlowGraphBlockNames.BitwiseOr],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/xor\": {\n        blocks: [FlowGraphBlockNames.BitwiseXor],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/asr\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseRightShift, [\"a\", \"b\"]),\n    \"math/lsl\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseLeftShift, [\"a\", \"b\"]),\n    \"math/clz\": getSimpleInputMapping(FlowGraphBlockNames.LeadingZeros),\n    \"math/ctz\": getSimpleInputMapping(FlowGraphBlockNames.TrailingZeros),\n    \"math/popcnt\": getSimpleInputMapping(FlowGraphBlockNames.OneBitsCounter),\n    \"math/rad\": getSimpleInputMapping(FlowGraphBlockNames.DegToRad),\n    \"math/deg\": getSimpleInputMapping(FlowGraphBlockNames.RadToDeg),\n    \"type/boolToInt\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToInt),\n    \"type/boolToFloat\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToFloat),\n    \"type/intToBool\": getSimpleInputMapping(FlowGraphBlockNames.IntToBoolean),\n    \"type/intToFloat\": getSimpleInputMapping(FlowGraphBlockNames.IntToFloat),\n    \"type/floatToInt\": getSimpleInputMapping(FlowGraphBlockNames.FloatToInt),\n    \"type/floatToBool\": getSimpleInputMapping(FlowGraphBlockNames.FloatToBoolean),\n\n    // flows\n    \"flow/sequence\": {\n        blocks: [FlowGraphBlockNames.Sequence],\n        extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/branch\": {\n        blocks: [FlowGraphBlockNames.Branch],\n        outputs: {\n            flows: {\n                true: { name: \"onTrue\" },\n                false: { name: \"onFalse\" },\n            },\n        },\n    },\n    \"flow/switch\": {\n        blocks: [FlowGraphBlockNames.Switch],\n        configuration: {\n            cases: { name: \"cases\", inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n                default: { name: \"default\" },\n            },\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.configuration && gltfBlock.configuration.cases) {\n                const cases = gltfBlock.configuration.cases.value;\n                const onlyIntegers = cases.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    gltfBlock.configuration.cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases);\n                gltfBlock.configuration.cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            // convert all names of output flow to out_$1 apart from \"default\"\n            if (declaration.op !== \"flow/switch\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"Switch should have a single configuration object, the cases array\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.signalOutputs.forEach((output) => {\n                if (output.name !== \"default\") {\n                    output.name = \"out_\" + output.name;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/while\": {\n        blocks: [FlowGraphBlockNames.WhileLoop],\n        outputs: {\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n    },\n    \"flow/for\": {\n        blocks: [FlowGraphBlockNames.ForLoop],\n        configuration: {\n            initialIndex: { name: \"initialIndex\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            values: {\n                startIndex: { name: \"startIndex\", gltfType: \"number\" },\n                endIndex: { name: \"endIndex\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                index: { name: \"index\" },\n            },\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.incrementIndexWhenLoopDone = true;\n            return serializedObjects;\n        },\n    },\n    \"flow/doN\": {\n        blocks: [FlowGraphBlockNames.DoN],\n        configuration: {},\n        inputs: {\n            values: {\n                n: { name: \"maxExecutions\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                currentCount: { name: \"executionCount\" },\n            },\n        },\n    },\n    \"flow/multiGate\": {\n        blocks: [FlowGraphBlockNames.MultiGate],\n        configuration: {\n            isRandom: { name: \"isRandom\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n            isLoop: { name: \"isLoop\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            if (declaration.op !== \"flow/multiGate\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"MultiGate should have a single configuration object, the number of output flows\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/waitAll\": {\n        blocks: [FlowGraphBlockNames.WaitAll],\n        configuration: {\n            inputFlows: { name: \"inputSignalCount\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            flows: {\n                reset: { name: \"reset\" },\n                \"[segment]\": { name: \"in_$1\" },\n            },\n        },\n        validation(gltfBlock) {\n            // check that the configuration value is an integer\n            if (typeof gltfBlock.configuration?.inputFlows?.value[0] !== \"number\") {\n                gltfBlock.configuration = gltfBlock.configuration || {\n                    inputFlows: { value: [0] },\n                };\n                gltfBlock.configuration.inputFlows.value = [0];\n            }\n            return { valid: true };\n        },\n    },\n    \"flow/throttle\": {\n        blocks: [FlowGraphBlockNames.Throttle],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/setDelay\": {\n        blocks: [FlowGraphBlockNames.SetDelay],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/cancelDelay\": {\n        blocks: [FlowGraphBlockNames.CancelDelay],\n    },\n    \"variable/get\": {\n        blocks: [FlowGraphBlockNames.GetVariable],\n        validation(gltfBlock) {\n            if (!gltfBlock.configuration?.variable?.value) {\n                Logger.Error(\"Variable get block should have a variable configuration\");\n                return { valid: false, error: \"Variable get block should have a variable configuration\" };\n            }\n            return { valid: true };\n        },\n        configuration: {\n            variable: {\n                name: \"variable\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n        },\n    },\n    \"variable/set\": {\n        blocks: [FlowGraphBlockNames.SetVariable],\n        configuration: {\n            variable: {\n                name: \"variable\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index: number[], parser): string[] {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n        },\n    },\n    \"variable/setMultiple\": {\n        blocks: [FlowGraphBlockNames.SetVariable],\n        configuration: {\n            variables: {\n                name: \"variables\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                dataTransformer(index: number[][], parser): string[][] {\n                    return [index[0].map((i) => parser.getVariableName(i))];\n                },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[0];\n            serializedGetVariable.dataInputs.forEach((input) => {\n                input.name = parser.getVariableName(+input.name);\n            });\n\n            return serializedObjects;\n        },\n    },\n    \"variable/interpolate\": {\n        blocks: [\n            FlowGraphBlockNames.ValueInterpolation,\n            FlowGraphBlockNames.Context,\n            FlowGraphBlockNames.PlayAnimation,\n            FlowGraphBlockNames.BezierCurveEasing,\n            FlowGraphBlockNames.GetVariable,\n        ],\n        configuration: {\n            variable: {\n                name: \"propertyName\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return [parser.getVariableName(index[0])];\n                },\n            },\n            useSlerp: {\n                name: \"animationType\",\n                inOptions: true,\n                defaultValue: false,\n                dataTransformer: (value) => {\n                    if (value[0] === true) {\n                        return [FlowGraphTypes.Quaternion];\n                    } else {\n                        return [undefined];\n                    }\n                },\n            },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                duration: { name: \"duration_1\", gltfType: \"number\" },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"userVariables\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 4,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // is useSlerp is used, animationType should be set to be quaternion!\n            const serializedValueInterpolation = serializedObjects[0];\n            const propertyIndex = gltfBlock.configuration?.variable.value[0];\n            if (typeof propertyIndex !== \"number\") {\n                Logger.Error(\"Variable index is not defined for variable interpolation block\");\n                throw new Error(\"Variable index is not defined for variable interpolation block\");\n            }\n            const variable = parser.arrays.staticVariables[propertyIndex];\n            // if not set by useSlerp\n            if (typeof serializedValueInterpolation.config.animationType.value === \"undefined\") {\n                // get the value type\n                parser.arrays.staticVariables;\n                serializedValueInterpolation.config.animationType.value = getAnimationTypeByFlowGraphType(variable.type);\n            }\n\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[4];\n            serializedGetVariable.config ||= {};\n            serializedGetVariable.config.variable ||= {};\n            serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);\n\n            // get the control points from the easing block\n            serializedObjects[3].config ||= {};\n\n            return serializedObjects;\n        },\n    },\n    \"pointer/get\": {\n        blocks: [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customGetFunction\",\n                output: \"getFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/set\": {\n        blocks: [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                // must be defined due to the array taking over\n                value: { name: \"value\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customSetFunction\",\n                output: \"setFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/interpolate\": {\n        // interpolate, parse the pointer and play the animation generated. 3 blocks!\n        blocks: [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.BezierCurveEasing],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n                duration: { name: \"duration_1\", gltfType: \"number\" /*, inOptions: true */ },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customBuildAnimation\",\n                output: \"generateAnimationsFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                } else if (serializedObject.className === FlowGraphBlockNames.ValueInterpolation) {\n                    serializedObject.config ||= {};\n                    Object.keys(gltfBlock.values || []).forEach((key) => {\n                        const value = gltfBlock.values?.[key];\n                        if (key === \"value\" && value) {\n                            // get the type of the value\n                            const type = value.type;\n                            if (type !== undefined) {\n                                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;\n                            }\n                        }\n                    });\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"animation/start\": {\n        blocks: [FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                speed: { name: \"speed\", gltfType: \"number\" },\n                startTime: { name: \"from\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n                endTime: { name: \"to\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stop\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stopAt\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        configuration: {},\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                stopTime: { name: \"stopAtFrame\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"math/switch\": {\n        blocks: [FlowGraphBlockNames.DataSwitch],\n        configuration: {\n            cases: { name: \"cases\", inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n            },\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.configuration && gltfBlock.configuration.cases) {\n                const cases = gltfBlock.configuration.cases.value;\n                const onlyIntegers = cases.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    gltfBlock.configuration.cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases);\n                gltfBlock.configuration.cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.dataInputs.forEach((input) => {\n                if (input.name !== \"default\" && input.name !== \"case\") {\n                    input.name = \"in_\" + input.name;\n                }\n            });\n            serializedObject.config ||= {};\n            serializedObject.config.treatCasesAsIntegers = true;\n            return serializedObjects;\n        },\n    },\n    \"debug/log\": {\n        blocks: [FlowGraphBlockNames.ConsoleLog],\n        configuration: {\n            message: { name: \"messageTemplate\", inOptions: true },\n        },\n    },\n};\n\nfunction getSimpleInputMapping(type: FlowGraphBlockNames, inputs: string[] = [\"a\"], inferType?: boolean): IGLTFToFlowGraphMapping {\n    return {\n        blocks: [type],\n        inputs: {\n            values: inputs.reduce(\n                (acc, input) => {\n                    acc[input] = { name: input };\n                    return acc;\n                },\n                {} as { [key: string]: { name: string } }\n            ),\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            if (inferType) {\n                // configure it to work the way glTF specifies\n                serializedObjects[0].config ||= {};\n                serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n                // try to infer the type or fallback to Integer\n                // check the gltf block for the inputs, see if they have a type\n                let type = -1;\n                Object.keys(gltfBlock.values || {}).find((value) => {\n                    if (gltfBlock.values?.[value].type !== undefined) {\n                        type = gltfBlock.values[value].type;\n                        return true;\n                    }\n                    return false;\n                });\n                if (type !== -1) {\n                    serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n                }\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (inferType) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    };\n}\n\nfunction ValidateTypes(gltfBlock: IKHRInteractivity_Node): { valid: boolean; error?: string } {\n    if (gltfBlock.values) {\n        const types = Object.keys(gltfBlock.values)\n            .map((key) => gltfBlock.values![key].type)\n            .filter((type) => type !== undefined);\n        const allSameType = types.every((type) => type === types[0]);\n        if (!allSameType) {\n            return { valid: false, error: \"All inputs must be of the same type\" };\n        }\n    }\n    return { valid: true };\n}\n\nexport function getAllSupportedNativeNodeTypes(): string[] {\n    return Object.keys(gltfToFlowGraphMapping);\n}\n\n/**\n * \n * These are the nodes from the specs:\n\n### Math Nodes\n1. **Constants**\n   - E (`math/E`) FlowGraphBlockNames.E\n   - Pi (`math/Pi`) FlowGraphBlockNames.PI\n   - Infinity (`math/Inf`) FlowGraphBlockNames.Inf\n   - Not a Number (`math/NaN`) FlowGraphBlockNames.NaN\n2. **Arithmetic Nodes**\n   - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n   - Sign (`math/sign`) FlowGraphBlockNames.Sign\n   - Truncate (`math/trunc`) FlowGraphBlockNames.Trunc\n   - Floor (`math/floor`) FlowGraphBlockNames.Floor\n   - Ceil (`math/ceil`) FlowGraphBlockNames.Ceil\n   - Round (`math/round`)  FlowGraphBlockNames.Round\n   - Fraction (`math/fract`) FlowGraphBlockNames.Fract\n   - Negation (`math/neg`) FlowGraphBlockNames.Negation\n   - Addition (`math/add`) FlowGraphBlockNames.Add\n   - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n   - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n   - Division (`math/div`) FlowGraphBlockNames.Divide\n   - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n   - Minimum (`math/min`) FlowGraphBlockNames.Min\n   - Maximum (`math/max`) FlowGraphBlockNames.Max\n   - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n   - Saturate (`math/saturate`) FlowGraphBlockNames.Saturate\n   - Interpolate (`math/mix`) FlowGraphBlockNames.MathInterpolation\n3. **Comparison Nodes**\n   - Equality (`math/eq`) FlowGraphBlockNames.Equality\n   - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n   - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n   - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n   - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n4. **Special Nodes**\n   - Is Not a Number (`math/isNaN`) FlowGraphBlockNames.IsNaN\n   - Is Infinity (`math/isInf`) FlowGraphBlockNames.IsInfinity\n   - Select (`math/select`) FlowGraphBlockNames.Conditional\n   - Switch (`math/switch`) FlowGraphBlockNames.DataSwitch\n   - Random (`math/random`) FlowGraphBlockNames.Random\n5. **Angle and Trigonometry Nodes**\n   - Degrees-To-Radians (`math/rad`) FlowGraphBlockNames.DegToRad\n   - Radians-To-Degrees (`math/deg`) FlowGraphBlockNames.RadToDeg\n   - Sine (`math/sin`)  FlowGraphBlockNames.Sin\n   - Cosine (`math/cos`) FlowGraphBlockNames.Cos\n   - Tangent (`math/tan`) FlowGraphBlockNames.Tan\n   - Arcsine (`math/asin`) FlowGraphBlockNames.Asin\n   - Arccosine (`math/acos`) FlowGraphBlockNames.Acos\n   - Arctangent (`math/atan`) FlowGraphBlockNames.Atan\n   - Arctangent 2 (`math/atan2`) FlowGraphBlockNames.Atan2\n6. **Hyperbolic Nodes**\n   - Hyperbolic Sine (`math/sinh`) FlowGraphBlockNames.Sinh\n   - Hyperbolic Cosine (`math/cosh`) FlowGraphBlockNames.Cosh\n   - Hyperbolic Tangent (`math/tanh`) FlowGraphBlockNames.Tanh\n   - Inverse Hyperbolic Sine (`math/asinh`) FlowGraphBlockNames.Asinh\n   - Inverse Hyperbolic Cosine (`math/acosh`) FlowGraphBlockNames.Acosh\n   - Inverse Hyperbolic Tangent (`math/atanh`) FlowGraphBlockNames.Atanh\n7. **Exponential Nodes**\n   - Exponent (`math/exp`) FlowGraphBlockNames.Exponential\n   - Natural Logarithm (`math/log`) FlowGraphBlockNames.Log\n   - Base-2 Logarithm (`math/log2`) FlowGraphBlockNames.Log2\n   - Base-10 Logarithm (`math/log10`) FlowGraphBlockNames.Log10\n   - Square Root (`math/sqrt`) FlowGraphBlockNames.SquareRoot\n   - Cube Root (`math/cbrt`) FlowGraphBlockNames.CubeRoot\n   - Power (`math/pow`) FlowGraphBlockNames.Power\n8. **Vector Nodes**\n   - Length (`math/length`) FlowGraphBlockNames.Length\n   - Normalize (`math/normalize`) FlowGraphBlockNames.Normalize\n   - Dot Product (`math/dot`) FlowGraphBlockNames.Dot\n   - Cross Product (`math/cross`) FlowGraphBlockNames.Cross\n   - Rotate 2D (`math/rotate2D`) FlowGraphBlockNames.Rotate2D\n   - Rotate 3D (`math/rotate3D`) FlowGraphBlockNames.Rotate3D\n   - Transform (`math/transform`) FlowGraphBlockNames.TransformVector\n9. **Matrix Nodes**\n   - Transpose (`math/transpose`) FlowGraphBlockNames.Transpose\n   - Determinant (`math/determinant`) FlowGraphBlockNames.Determinant\n   - Inverse (`math/inverse`) FlowGraphBlockNames.InvertMatrix\n   - Multiplication (`math/matMul`) FlowGraphBlockNames.MatrixMultiplication\n   - Compose (`math/matCompose`) FlowGraphBlockNames.MatrixCompose\n   - Decompose (`math/matDecompose`) FlowGraphBlockNames.MatrixDecompose\n10. **Quaternion Nodes**\n    - Conjugate (`math/quatConjugate`) FlowGraphBlockNames.Conjugate\n    - Multiplication (`math/quatMul`) FlowGraphBlockNames.Multiply\n    - Angle Between Quaternions (`math/quatAngleBetween`) FlowGraphBlockNames.AngleBetween\n    - Quaternion From Axis Angle (`math/quatFromAxisAngle`) FlowGraphBlockNames.QuaternionFromAxisAngle\n    - Quaternion To Axis Angle (`math/quatToAxisAngle`) FlowGraphBlockNames.QuaternionToAxisAngle\n    - Quaternion From Two Directional Vectors (`math/quatFromDirections`) FlowGraphBlockNames.QuaternionFromDirections\n11. **Swizzle Nodes**\n    - Combine (`math/combine2`, `math/combine3`, `math/combine4`, `math/combine2x2`, `math/combine3x3`, `math/combine4x4`)\n        FlowGraphBlockNames.CombineVector2, FlowGraphBlockNames.CombineVector3, FlowGraphBlockNames.CombineVector4\n        FlowGraphBlockNames.CombineMatrix2D, FlowGraphBlockNames.CombineMatrix3D, FlowGraphBlockNames.CombineMatrix\n    - Extract (`math/extract2`, `math/extract3`, `math/extract4`, `math/extract2x2`, `math/extract3x3`, `math/extract4x4`)\n        FlowGraphBlockNames.ExtractVector2, FlowGraphBlockNames.ExtractVector3, FlowGraphBlockNames.ExtractVector4\n        FlowGraphBlockNames.ExtractMatrix2D, FlowGraphBlockNames.ExtractMatrix3D, FlowGraphBlockNames.ExtractMatrix\n12. **Integer Arithmetic Nodes**\n    - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n    - Sign (`math/sign`) FlowGraphBlockNames.Sign\n    - Negation (`math/neg`) FlowGraphBlockNames.Negation\n    - Addition (`math/add`) FlowGraphBlockNames.Add\n    - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n    - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n    - Division (`math/div`) FlowGraphBlockNames.Divide\n    - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n    - Minimum (`math/min`) FlowGraphBlockNames.Min\n    - Maximum (`math/max`) FlowGraphBlockNames.Max\n    - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n13. **Integer Comparison Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n    - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n    - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n    - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n14. **Integer Bitwise Nodes**\n    - Bitwise NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Bitwise AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Bitwise OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Bitwise XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n    - Right Shift (`math/asr`) FlowGraphBlockNames.BitwiseRightShift\n    - Left Shift (`math/lsl`) FlowGraphBlockNames.BitwiseLeftShift\n    - Count Leading Zeros (`math/clz`) FlowGraphBlockNames.LeadingZeros\n    - Count Trailing Zeros (`math/ctz`) FlowGraphBlockNames.TrailingZeros\n    - Count One Bits (`math/popcnt`) FlowGraphBlockNames.OneBitsCounter\n15. **Boolean Arithmetic Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Boolean NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Boolean AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Boolean OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Boolean XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n\n### Type Conversion Nodes\n1. **Boolean Conversion Nodes**\n   - Boolean to Integer (`type/boolToInt`) FlowGraphBlockNames.BooleanToInt\n   - Boolean to Float (`type/boolToFloat`) FlowGraphBlockNames.BooleanToFloat\n2. **Integer Conversion Nodes**\n   - Integer to Boolean (`type/intToBool`) FlowGraphBlockNames.IntToBoolean\n   - Integer to Float (`type/intToFloat`) FlowGraphBlockNames.IntToFloat\n3. **Float Conversion Nodes**\n   - Float to Boolean (`type/floatToBool`) FlowGraphBlockNames.FloatToBoolean\n   - Float to Integer (`type/floatToInt`) FlowGraphBlockNames.FloatToInt\n\n### Control Flow Nodes\n1. **Sync Nodes**\n   - Sequence (`flow/sequence`) FlowGraphBlockNames.Sequence\n   - Branch (`flow/branch`) FlowGraphBlockNames.Branch\n   - Switch (`flow/switch`) FlowGraphBlockNames.Switch\n   - While Loop (`flow/while`) FlowGraphBlockNames.WhileLoop\n   - For Loop (`flow/for`) FlowGraphBlockNames.ForLoop\n   - Do N (`flow/doN`) FlowGraphBlockNames.DoN\n   - Multi Gate (`flow/multiGate`) FlowGraphBlockNames.MultiGate\n   - Wait All (`flow/waitAll`) FlowGraphBlockNames.WaitAll\n   - Throttle (`flow/throttle`) FlowGraphBlockNames.Throttle\n2. **Delay Nodes**\n   - Set Delay (`flow/setDelay`) FlowGraphBlockNames.SetDelay\n   - Cancel Delay (`flow/cancelDelay`) FlowGraphBlockNames.CancelDelay\n\n### State Manipulation Nodes\n1. **Custom Variable Access**\n   - Variable Get (`variable/get`) FlowGraphBlockNames.GetVariable\n   - Variable Set (`variable/set`) FlowGraphBlockNames.SetVariable\n   - Variable Interpolate (`variable/interpolate`)\n2. **Object Model Access** // TODO fully test this!!!\n   - JSON Pointer Template Parsing (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Effective JSON Pointer Generation (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Get (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Set (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Interpolate (`pointer/interpolate`) [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.Easing]\n\n### Animation Control Nodes\n1. **Animation Play** (`animation/start`) FlowGraphBlockNames.PlayAnimation\n2. **Animation Stop** (`animation/stop`) FlowGraphBlockNames.StopAnimation \n3. **Animation Stop At** (`animation/stopAt`) FlowGraphBlockNames.StopAnimation \n\n### Event Nodes\n1. **Lifecycle Event Nodes**\n   - On Start (`event/onStart`) FlowGraphBlockNames.SceneReadyEvent\n   - On Tick (`event/onTick`) FlowGraphBlockNames.SceneTickEvent\n2. **Custom Event Nodes**\n   - Receive (`event/receive`) FlowGraphBlockNames.ReceiveCustomEvent\n   - Send (`event/send`) FlowGraphBlockNames.SendCustomEvent\n\n */\n","import type { IKHRInteractivity_Graph, IKHRInteractivity_Node, IKHRInteractivity_OutputSocketReference, IKHRInteractivity_Variable } from \"babylonjs-gltf2interface\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { IGLTFToFlowGraphMapping } from \"./declarationMapper\";\nimport { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphConnection, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport { RandomGUID } from \"core/Misc/guid\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { FlowGraphConnectionType } from \"core/FlowGraph/flowGraphConnection\";\nimport { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface InteractivityEvent {\n    eventId: string;\n    eventData?: {\n        eventData: boolean;\n        id: string;\n        type: string;\n        value?: any;\n    }[];\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const gltfTypeToBabylonType: {\n    [key: string]: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" };\n} = {\n    float: { length: 1, flowGraphType: FlowGraphTypes.Number, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: FlowGraphTypes.Boolean, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: FlowGraphTypes.Vector2, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: FlowGraphTypes.Vector3, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: FlowGraphTypes.Vector4, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: FlowGraphTypes.Matrix, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: FlowGraphTypes.Matrix2D, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: FlowGraphTypes.Matrix3D, elementType: \"number\" },\n    int: { length: 1, flowGraphType: FlowGraphTypes.Integer, elementType: \"number\" },\n};\n\nexport class InteractivityGraphToFlowGraphParser {\n    /**\n     * Note - the graph should be rejected if the same type is defined twice.\n     * We currently don't validate that.\n     */\n    private _types: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" }[] = [];\n    private _mappings: { flowGraphMapping: IGLTFToFlowGraphMapping; fullOperationName: string }[] = [];\n    private _staticVariables: { type: FlowGraphTypes; value: any[] }[] = [];\n    private _events: InteractivityEvent[] = [];\n    private _internalEventsCounter: number = 0;\n    private _nodes: { blocks: ISerializedFlowGraphBlock[]; fullOperationName: string }[] = [];\n\n    constructor(\n        private _interactivityGraph: IKHRInteractivity_Graph,\n        private _gltf: IGLTF,\n        public _animationTargetFps: number = 60\n    ) {\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n\n    public get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n\n    private _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n\n    private _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n\n    private _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n\n    private _parseVariable(variable: IKHRInteractivity_Variable, dataTransform?: (value: any, parser: InteractivityGraphToFlowGraphParser) => any) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case FlowGraphTypes.Boolean:\n                    value.push(false);\n                    break;\n                case FlowGraphTypes.Integer:\n                    value.push(0);\n                    break;\n                case FlowGraphTypes.Number:\n                    value.push(NaN);\n                    break;\n                case FlowGraphTypes.Vector2:\n                    value.push(NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector3:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector4:\n                case FlowGraphTypes.Matrix2D:\n                case FlowGraphTypes.Quaternion:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case FlowGraphTypes.Matrix:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case FlowGraphTypes.Matrix3D:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        // in case of NaN, Infinity, we need to parse the string to the object itself\n        if (type.elementType === \"number\" && typeof value[0] === \"string\") {\n            value[0] = parseFloat(value[0]);\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n\n    private _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted: InteractivityEvent = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n\n    private _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);\n                if (!validationResult.valid) {\n                    throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);\n                }\n            }\n            const blocks: ISerializedFlowGraphBlock[] = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n\n    private _getEmptyBlock(className: string, type: string): ISerializedFlowGraphBlock {\n        const uniqueId = RandomGUID();\n        const dataInputs: ISerializedFlowGraphConnection[] = [];\n        const dataOutputs: ISerializedFlowGraphConnection[] = [];\n        const signalInputs: ISerializedFlowGraphConnection[] = [];\n        const signalOutputs: ISerializedFlowGraphConnection[] = [];\n        const config: IFlowGraphBlockConfiguration = {};\n        const metadata = {};\n        return {\n            uniqueId,\n            className,\n            dataInputs,\n            dataOutputs,\n            signalInputs,\n            signalOutputs,\n            config,\n            type,\n            metadata,\n        };\n    }\n\n    private _parseNodeConfiguration(node: IKHRInteractivity_Node, block: ISerializedFlowGraphBlock, nodeMapping: IGLTFToFlowGraphMapping, blockType: FlowGraphBlockNames | string) {\n        const configuration = block.config;\n        if (node.configuration) {\n            const keys = Object.keys(node.configuration);\n            for (const key of keys) {\n                const value = node.configuration?.[key];\n                // value is always an array, never a number or string\n                if (!value) {\n                    Logger.Error([\"No value found for node configuration\", key]);\n                    throw new Error(\"Error parsing node configuration\");\n                }\n                const configMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    // get the right name for the configuration key\n                    const configKey = configMapping?.name || key;\n                    if ((!value || typeof value.value === \"undefined\") && typeof configMapping?.defaultValue !== \"undefined\") {\n                        configuration[configKey] = {\n                            value: configMapping.defaultValue,\n                        };\n                    } else if (value.value.length >= 0) {\n                        // supporting int[] and int/boolean/string\n                        configuration[configKey] = {\n                            value: value.value.length === 1 ? value.value[0] : value.value,\n                        };\n                    } else {\n                        Logger.Warn([\"Invalid value for node configuration\", value]);\n                    }\n                    // make sure we transform the data if needed\n                    if (configMapping && configMapping.dataTransformer) {\n                        configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];\n                    }\n                }\n            }\n        }\n    }\n\n    private _parseNodeConnections(context: ISerializedFlowGraphContext) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if ((value as IKHRInteractivity_Variable).value !== undefined) {\n                    const convertedValue = this._parseVariable(value as IKHRInteractivity_Variable, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                } else if (typeof (value as IKHRInteractivity_OutputSocketReference).node !== \"undefined\") {\n                    const nodeOutId = (value as IKHRInteractivity_OutputSocketReference).node;\n                    const nodeOutSocketName = (value as IKHRInteractivity_OutputSocketReference).socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                } else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(\n                    gltfNode,\n                    declaration,\n                    outputMapper.flowGraphMapping,\n                    this,\n                    flowGraphBlocks.blocks,\n                    context,\n                    this._gltf\n                );\n            }\n        }\n    }\n\n    private _createNewSocketConnection(name: string, isOutput?: boolean): ISerializedFlowGraphConnection {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? FlowGraphConnectionType.Output : FlowGraphConnectionType.Input,\n            connectedPointIds: [],\n        };\n    }\n\n    private _connectFlowGraphNodes(input: string, output: string, serializedInput: ISerializedFlowGraphBlock, serializedOutput: ISerializedFlowGraphBlock, isVariable?: boolean) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n\n    public getVariableName(index: number) {\n        return \"staticVariable_\" + index;\n    }\n\n    public serializeToFlowGraph(): ISerializedFlowGraph {\n        const context: ISerializedFlowGraphContext = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), [] as ISerializedFlowGraphBlock[]);\n\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IKHRInteractivity } from \"babylonjs-gltf2interface\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\nimport { ParseFlowGraphAsync } from \"core/FlowGraph/flowGraphParser\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { AddObjectAccessorToKey, GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport { InteractivityGraphToFlowGraphParser } from \"./KHR_interactivity/interactivityGraphParser\";\r\nimport { addToBlockFactory } from \"core/FlowGraph/Blocks/flowGraphBlockFactory\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IAnimation } from \"../glTFLoaderInterfaces\";\r\n\r\nconst NAME = \"KHR_interactivity\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_interactivity extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_interactivity\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * Loader extension for KHR_interactivity\r\n */\r\nexport class KHR_interactivity implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _pathConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     * @param _loader\r\n     */\r\n    constructor(private _loader: GLTFLoader) {\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        this._pathConverter = GetPathToObjectConverter(this._loader.gltf);\r\n        // avoid starting animations automatically.\r\n        _loader._skipStartAnimationStep = true;\r\n\r\n        // Update object model with new pointers\r\n\r\n        const scene = _loader.babylonScene;\r\n        if (scene) {\r\n            _AddInteractivityObjectModel(scene);\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathConverter;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises\r\n    public async onReady(): Promise<void> {\r\n        if (!this._loader.babylonScene || !this._pathConverter) {\r\n            return;\r\n        }\r\n        const scene = this._loader.babylonScene;\r\n        const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity as IKHRInteractivity;\r\n        if (!interactivityDefinition) {\r\n            // This can technically throw, but it's not a critical error\r\n            return;\r\n        }\r\n\r\n        const coordinator = new FlowGraphCoordinator({ scene });\r\n        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously\r\n        const graphs = interactivityDefinition.graphs.map((graph) => {\r\n            const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);\r\n            return parser.serializeToFlowGraph();\r\n        });\r\n        // parse each graph async\r\n        await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));\r\n\r\n        coordinator.start();\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * populates the object model with the interactivity extension\r\n */\r\nexport function _AddInteractivityObjectModel(scene: Scene) {\r\n    // Note - all of those are read-only, as per the specs!\r\n\r\n    // active camera rotation\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/rotation\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Quaternion(NaN, NaN, NaN, NaN);\r\n            }\r\n            const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();\r\n            if (!scene.useRightHandedSystem) {\r\n                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return quat;\r\n        },\r\n        type: \"Quaternion\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n    // activeCamera position\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/position\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Vector3(NaN, NaN, NaN);\r\n            }\r\n            const pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position\r\n            if (!scene.useRightHandedSystem) {\r\n                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return pos;\r\n        },\r\n        type: \"Vector3\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n\r\n    // /animations/{} pointers:\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/isPlaying\", {\r\n        get: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup?.isPlaying ?? false;\r\n        },\r\n        type: \"boolean\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/minTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.from ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/maxTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.to ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    // playhead\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/playhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/virtualPlayhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n}\r\n\r\n// Register flow graph blocks. Do it here so they are available when the extension is enabled.\r\naddToBlockFactory(NAME, \"FlowGraphGLTFDataProvider\", async () => {\r\n    return (await import(\"./KHR_interactivity/flowGraphGLTFDataProvider\")).FlowGraphGLTFDataProvider;\r\n});\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));\r\n","import type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_visibility\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_node_visibility extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_visibility\"]: {};\n    }\n}\n\n// object model extension for visibility\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_visibility/visible\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.isVisible !== undefined) {\n            return tn.isVisible;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.inheritVisibility = true;\n        });\n        if (node._babylonTransformNode) {\n            (node._babylonTransformNode as AbstractMesh).isVisible = value;\n        }\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.isVisible = value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"isVisible\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_node_visibility\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_visibility implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader?: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    public onReady(): void {\n        if (!this._loader) {\n            return;\n        }\n\n        const nodes = this._loader.gltf.nodes;\n        if (nodes) {\n            for (const node of nodes) {\n                const babylonTransformNode = node._babylonTransformNode;\n                if (babylonTransformNode) {\n                    babylonTransformNode.inheritVisibility = true;\n                    if (node.extensions && node.extensions.KHR_node_visibility && node.extensions.KHR_node_visibility.visible === false) {\n                        babylonTransformNode.isVisible = false;\n                    }\n                }\n            }\n        }\n    }\n\n    public dispose() {\n        delete this._loader;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_visibility(loader));\n","import { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { addNewInteractivityFlowGraphMapping } from \"./KHR_interactivity/declarationMapper\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_selectability\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_selectability extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_selectability\"]: {};\n    }\n}\n\n// add the interactivity mapping for the onSelect event\naddNewInteractivityFlowGraphMapping(\"event/onSelect\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.MeshPickEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [\"pickedMesh_\" + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            selectedNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n            selectionPoint: { name: \"pickedPoint\" },\n            selectionRayOrigin: { name: \"pickOrigin\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"asset\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"pickedMesh\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n        // find the listener nodeIndex value\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = \"pickedMesh_\" + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\n// object model extension for selectable\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_selectability/selectable\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.isPickable !== undefined) {\n            return tn.isPickable;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.isPickable = value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"isPickable\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_selectability\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_selectability implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            if (node.extensions?.KHR_node_selectability && node.extensions?.KHR_node_selectability.selectable === false) {\n                node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {\n                    mesh.isPickable = false;\n                });\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_selectability(loader));\n","import { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport type { GLTFLoader } from \"../glTFLoader\";\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport { addNewInteractivityFlowGraphMapping } from \"./KHR_interactivity/declarationMapper\";\nimport type { INode } from \"../glTFLoaderInterfaces\";\nimport { AddObjectAccessorToKey } from \"./objectModelMapping\";\n\nconst NAME = \"KHR_node_hoverability\";\n\ndeclare module \"../../glTFFileLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface GLTFLoaderExtensionOptions {\n        /**\n         * Defines options for the KHR_node_hoverability extension.\n         */\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\n        [\"KHR_node_hoverability\"]: {};\n    }\n}\n\n// interactivity\nconst MeshPointerOverPrefix = \"targetMeshPointerOver_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverIn\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOverEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOverPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshUnderPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n        // find the listener nodeIndex value\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOverPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nconst MeshPointerOutPrefix = \"targetMeshPointerOut_\";\naddNewInteractivityFlowGraphMapping(\"event/onHoverOut\", NAME, {\n    // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)\n    blocks: [FlowGraphBlockNames.PointerOutEvent, FlowGraphBlockNames.GetVariable, FlowGraphBlockNames.IndexOf, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n    configuration: {\n        stopPropagation: { name: \"stopPropagation\" },\n        nodeIndex: {\n            name: \"variable\",\n            toBlock: FlowGraphBlockNames.GetVariable,\n            dataTransformer(data) {\n                return [MeshPointerOutPrefix + data[0]];\n            },\n        },\n    },\n    outputs: {\n        values: {\n            hoverNodeIndex: { name: \"index\", toBlock: FlowGraphBlockNames.IndexOf },\n            controllerIndex: { name: \"pointerId\" },\n        },\n        flows: {\n            out: { name: \"done\" },\n        },\n    },\n    interBlockConnectors: [\n        {\n            input: \"targetMesh\",\n            output: \"value\",\n            inputBlockIndex: 0,\n            outputBlockIndex: 1,\n            isVariable: true,\n        },\n        {\n            input: \"array\",\n            output: \"nodes\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 3,\n            isVariable: true,\n        },\n        {\n            input: \"object\",\n            output: \"meshOutOfPointer\",\n            inputBlockIndex: 2,\n            outputBlockIndex: 0,\n            isVariable: true,\n        },\n    ],\n    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {\n        // add the glTF to the configuration of the last serialized object\n        const serializedObject = serializedObjects[serializedObjects.length - 1];\n        serializedObject.config = serializedObject.config || {};\n        serializedObject.config.glTF = globalGLTF;\n\n        const nodeIndex = gltfBlock.configuration?.[\"nodeIndex\"]?.value[0];\n        if (nodeIndex === undefined || typeof nodeIndex !== \"number\") {\n            throw new Error(\"nodeIndex not found in configuration\");\n        }\n        const variableName = MeshPointerOutPrefix + nodeIndex;\n        // find the nodeIndex value\n        serializedObjects[1].config.variable = variableName;\n        context._userVariables[variableName] = {\n            className: \"Mesh\",\n            id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,\n            uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId,\n        };\n        return serializedObjects;\n    },\n});\n\nAddObjectAccessorToKey(\"/nodes/{}/extensions/KHR_node_hoverability/hoverable\", {\n    get: (node: INode) => {\n        const tn = node._babylonTransformNode as any;\n        if (tn && tn.pointerOverDisableMeshTesting !== undefined) {\n            return tn.pointerOverDisableMeshTesting;\n        }\n        return true;\n    },\n    set: (value: boolean, node: INode) => {\n        node._primitiveBabylonMeshes?.forEach((mesh) => {\n            mesh.pointerOverDisableMeshTesting = !value;\n        });\n    },\n    getTarget: (node: INode) => node._babylonTransformNode,\n    getPropertyName: [() => \"pointerOverDisableMeshTesting\"],\n    type: \"boolean\",\n});\n\n/**\n * Loader extension for KHR_node_hoverability\n * @see https://github.com/KhronosGroup/glTF/pull/2426\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_node_hoverability implements IGLTFLoaderExtension {\n    /**\n     * The name of this extension.\n     */\n    public readonly name = NAME;\n    /**\n     * Defines whether this extension is enabled.\n     */\n    public enabled: boolean;\n\n    private _loader: GLTFLoader;\n\n    /**\n     * @internal\n     */\n    constructor(loader: GLTFLoader) {\n        this._loader = loader;\n        this.enabled = loader.isExtensionUsed(NAME);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises\n    public async onReady(): Promise<void> {\n        this._loader.gltf.nodes?.forEach((node) => {\n            // default is true, so only apply if false\n            if (node.extensions?.KHR_node_hoverability && node.extensions?.KHR_node_hoverability.hoverable === false) {\n                node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {\n                    mesh.pointerOverDisableMeshTesting = true;\n                });\n            }\n        });\n    }\n\n    public dispose() {\n        (this._loader as any) = null;\n    }\n}\n\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new KHR_node_hoverability(loader));\n","import type { Nullable } from \"core/types\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\n\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport type { INode, ICamera, IMaterial } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"ExtrasAsMetadata\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the ExtrasAsMetadata extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"ExtrasAsMetadata\"]: {};\r\n    }\r\n}\r\n\r\ninterface IObjectWithMetadata {\r\n    metadata: any;\r\n}\r\n\r\n/**\r\n * Store glTF extras (if present) in BJS objects' metadata\r\n */\r\nexport class ExtrasAsMetadata implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled = true;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _assignExtras(babylonObject: IObjectWithMetadata, gltfProp: IProperty): void {\r\n        if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {\r\n            const metadata = (babylonObject.metadata = babylonObject.metadata || {});\r\n            const gltf = (metadata.gltf = metadata.gltf || {});\r\n            gltf.extras = gltfProp.extras;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._loader.loadNodeAsync(context, node, (babylonTransformNode): void => {\r\n            this._assignExtras(babylonTransformNode, node);\r\n            assign(babylonTransformNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._loader.loadCameraAsync(context, camera, (babylonCamera): void => {\r\n            this._assignExtras(babylonCamera, camera);\r\n            assign(babylonCamera);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);\r\n        this._assignExtras(babylonMaterial, material);\r\n        return babylonMaterial;\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, false, (loader) => new ExtrasAsMetadata(loader));\r\n","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiterPattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiterPattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substring(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n","import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices: Nullable<Array<number>>;\r\n    positions: Nullable<Array<number>>;\r\n    normals: Nullable<Array<number>>;\r\n    colors: Nullable<Array<number>>;\r\n    uvs: Nullable<Array<number>>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n    isObject: boolean; // If the entity is defined as an object (\"o\"), or group (\"g\")\r\n    _babylonMesh?: AbstractMesh; // The corresponding Babylon mesh\r\n    hasLines?: boolean; // If the mesh has lines\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a line(l vertex vertex) */\r\n    public static LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\r\n    /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\r\n    public static LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n    /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\r\n    public static LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _extColors: Array<Color4> = []; //Extension color\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n    private _pushTriangle: (faces: Array<string>, faceIndex: number) => void;\r\n    private _handednessSign: number;\r\n    private _hasLineData: boolean = false; //If this mesh has line segment(l) data\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param data The vertex's data\r\n     * * indicesPositionFromObj: The index in positions array\r\n     * * indicesUvsFromObj: The index in uvs array\r\n     * * indicesNormalFromObj: The index in normals array\r\n     * * positionVectorFromOBJ: The value of position at index objIndice\r\n     * * textureVectorFromOBJ: The value of uvs\r\n     * * normalsVectorFromOBJ: The value of normals at index objNormale\r\n     * * positionColorsFromOBJ: The value of color at index objIndice\r\n     */\r\n    private _setData(data: {\r\n        indicePositionFromObj: number;\r\n        indiceUvsFromObj?: number;\r\n        indiceNormalFromObj?: number;\r\n        positionVectorFromOBJ: Vector3;\r\n        textureVectorFromOBJ?: Vector2;\r\n        normalsVectorFromOBJ?: Vector3;\r\n        positionColorsFromOBJ?: Color4;\r\n    }) {\r\n        //Use default values if undefined\r\n        data.indiceUvsFromObj ??= -1;\r\n        data.indiceNormalFromObj ??= -1;\r\n\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj, data.indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(data.positionVectorFromOBJ);\r\n\r\n            if (data.textureVectorFromOBJ !== undefined) {\r\n                //Push the uvs for Babylon\r\n                //Each element is a Vector2(u,v)\r\n                this._wrappedUvsForBabylon.push(data.textureVectorFromOBJ);\r\n            }\r\n            if (data.normalsVectorFromOBJ !== undefined) {\r\n                //Push the normals for Babylon\r\n                //Each element is a Vector3(x,y,z)\r\n                this._wrappedNormalsForBabylon.push(data.normalsVectorFromOBJ);\r\n            }\r\n            if (data.positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(data.positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[data.indicePositionFromObj].normals.push(data.indiceNormalFromObj);\r\n            this._tuplePosNorm[data.indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[data.indicePositionFromObj].uv.push(data.indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        try {\r\n            //Every array has the same length\r\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n                //Push the x, y, z values of each element in the unwrapped array\r\n                this._unwrappedPositionsForBabylon.push(\r\n                    this._wrappedPositionForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedPositionForBabylon[l].y,\r\n                    this._wrappedPositionForBabylon[l].z\r\n                );\r\n                if (this._wrappedNormalsForBabylon.length) {\r\n                    this._unwrappedNormalsForBabylon.push(\r\n                        this._wrappedNormalsForBabylon[l].x * this._handednessSign,\r\n                        this._wrappedNormalsForBabylon[l].y,\r\n                        this._wrappedNormalsForBabylon[l].z\r\n                    );\r\n                }\r\n                if (this._wrappedUvsForBabylon.length) {\r\n                    this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n                }\r\n                if (this._unwrappedColorsForBabylon.length) {\r\n                    //Push the r, g, b, a values of each element in the unwrapped array\r\n                    this._unwrappedColorsForBabylon.push(\r\n                        this._wrappedColorsForBabylon[l].r,\r\n                        this._wrappedColorsForBabylon[l].g,\r\n                        this._wrappedColorsForBabylon[l].b,\r\n                        this._wrappedColorsForBabylon[l].a\r\n                    );\r\n                }\r\n            }\r\n            // Reset arrays for the next new meshes\r\n            this._wrappedPositionForBabylon.length = 0;\r\n            this._wrappedNormalsForBabylon.length = 0;\r\n            this._wrappedUvsForBabylon.length = 0;\r\n            this._wrappedColorsForBabylon.length = 0;\r\n            this._tuplePosNorm.length = 0;\r\n            this._curPositionInIndices = 0;\r\n        } catch (e) {\r\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._pushTriangle(faces, faceIndex);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * To get color between color and extension color\r\n     * @param index Integer The index of the element in the array\r\n     * @returns value of target color\r\n     */\r\n    private _getColor(index: number) {\r\n        if (this._loadingOptions.importVertexColors) {\r\n            return this._extColors[index] ?? this._colors[index];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvs\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                // Reverse tab. Otherwise face are displayed in the wrong sens\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            if (this._unwrappedNormalsForBabylon.length) {\r\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            }\r\n            if (this._unwrappedUVForBabylon.length) {\r\n                this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n            }\r\n            if (this._unwrappedColorsForBabylon.length) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon.length = 0;\r\n            this._unwrappedPositionsForBabylon.length = 0;\r\n            this._unwrappedColorsForBabylon.length = 0;\r\n            this._unwrappedNormalsForBabylon.length = 0;\r\n            this._unwrappedUVForBabylon.length = 0;\r\n            this._hasLineData = false;\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    private static _IsLineElement(line: string) {\r\n        return line.startsWith(\"l\");\r\n    }\r\n\r\n    private static _IsObjectElement(line: string) {\r\n        return line.startsWith(\"o\");\r\n    }\r\n\r\n    private static _IsGroupElement(line: string) {\r\n        return line.startsWith(\"g\");\r\n    }\r\n\r\n    private static _GetZbrushMRGB(line: string, notParse: boolean) {\r\n        if (!line.startsWith(\"mrgb\")) {\r\n            return null;\r\n        }\r\n        line = line.replace(\"mrgb\", \"\").trim();\r\n        // if include vertex color , not load mrgb anymore\r\n        if (notParse) {\r\n            return [];\r\n        }\r\n        const regex = /[a-z0-9]/g;\r\n        const regArray = line.match(regex);\r\n        if (!regArray || regArray.length % 8 !== 0) {\r\n            return [];\r\n        }\r\n        const array: Color4[] = [];\r\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\r\n            //each item is MMRRGGBB, m is material index\r\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\r\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\r\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\r\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\r\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        //Move Santitize here to forbid delete zbrush data\r\n        // Sanitize data\r\n        data = data.replace(/#MRGB/g, \"mrgb\");\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n        if (this._loadingOptions.useLegacyBehavior) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = 1;\r\n        } else if (scene.useRightHandedSystem) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\r\n            this._handednessSign = 1;\r\n        } else {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = -1;\r\n        }\r\n\r\n        // Split the file into lines\r\n        // Preprocess line data\r\n        const linesOBJ = data.split(\"\\n\");\r\n        const lineLines: string[][] = [];\r\n        let currentGroup: string[] = [];\r\n\r\n        lineLines.push(currentGroup);\r\n\r\n        for (let i = 0; i < linesOBJ.length; i++) {\r\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\r\n                currentGroup = [];\r\n                lineLines.push(currentGroup);\r\n            }\r\n\r\n            if (SolidParser._IsLineElement(line)) {\r\n                const lineValues = line.split(\" \");\r\n                // create line elements with two vertices only\r\n                for (let i = 1; i < lineValues.length - 1; i++) {\r\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\r\n                }\r\n            } else {\r\n                currentGroup.push(line);\r\n            }\r\n        }\r\n\r\n        const lines = lineLines.flat();\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                //Get information about one position possible for the vertices\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1 2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1 2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\r\n                for (const element of result) {\r\n                    this._extColors.push(element);\r\n                }\r\n            } else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1/1 2/2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: null,\r\n                    positions: null,\r\n                    normals: null,\r\n                    uvs: null,\r\n                    colors: null,\r\n                    materialName: this._materialNameFromObj,\r\n                    isObject: SolidParser.ObjectDescriptor.test(line),\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: null,\r\n                            positions: null,\r\n                            normals: null,\r\n                            uvs: null,\r\n                            colors: null,\r\n                            materialName: this._materialNameFromObj,\r\n                            isObject: false,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                Logger.Log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                //Reverse indices for displaying faces in the good sense\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            if (this._unwrappedNormalsForBabylon.length) {\r\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            }\r\n            if (this._unwrappedUVForBabylon.length) {\r\n                this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n            }\r\n            if (this._unwrappedColorsForBabylon.length) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                if (this._loadingOptions.useLegacyBehavior) {\r\n                    // reverse tab of indices\r\n                    this._indicesForBabylon.reverse();\r\n                }\r\n\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._extColors.length) {\r\n                    for (const color of this._extColors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                } else {\r\n                    if (this._colors.length) {\r\n                        for (const color of this._colors) {\r\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n                isObject: true,\r\n                hasLines: this._hasLineData,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n            this._handledMesh._babylonMesh = babylonMesh;\r\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\r\n            if (!this._handledMesh.isObject) {\r\n                for (let k = j - 1; k >= 0; --k) {\r\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\r\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh!;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n            //If the mesh is a line mesh\r\n            if (this._handledMesh.hasLines) {\r\n                babylonMesh._internalMetadata ??= {};\r\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\r\n            }\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.indices = this._handledMesh.indices;\r\n            vertexData.positions = this._handledMesh.positions;\r\n            if (this._loadingOptions.computeNormals || !this._handledMesh.normals) {\r\n                // Compute normals if requested or if normals are not defined\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals;\r\n            }\r\n            if (this._handledMesh.uvs) {\r\n                vertexData.uvs = this._handledMesh.uvs;\r\n            }\r\n            if (this._handledMesh.colors) {\r\n                vertexData.colors = this._handledMesh.colors;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the obj loader.\r\n         */\r\n        [OBJFileLoaderMetadata.name]: Partial<OBJLoadingOptions>;\r\n    }\r\n}\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n\r\n    /**\r\n     * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\r\n     */\r\n    public static USE_LEGACY_BEHAVIOR = false;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = OBJFileLoaderMetadata.name;\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public readonly extensions = OBJFileLoaderMetadata.extensions;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: Partial<Readonly<OBJLoadingOptions>>) {\r\n        this._loadingOptions = { ...OBJFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(options[OBJFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        // eslint-disable-next-line github/no-then\r\n        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        // eslint-disable-next-line github/no-then\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return (\r\n            this.importMeshAsync(null, scene, data, rootUrl)\r\n                // eslint-disable-next-line github/no-then\r\n                .then((result) => {\r\n                    result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                    result.meshes.forEach((mesh) => {\r\n                        const material = mesh.material;\r\n                        if (material) {\r\n                            // Materials\r\n                            if (container.materials.indexOf(material) == -1) {\r\n                                container.materials.push(material);\r\n\r\n                                // Textures\r\n                                const textures = material.getActiveTextures();\r\n                                textures.forEach((t) => {\r\n                                    if (container.textures.indexOf(t) == -1) {\r\n                                        container.textures.push(t);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                    this._assetContainer = null;\r\n                    return container;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((ex) => {\r\n                    this._assetContainer = null;\r\n                    throw ex;\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseSolidAsync(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse: string[] = [];\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Sanitize data\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(mtlPromises).then(() => {\r\n            const isLine = (mesh: AbstractMesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\r\n\r\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\r\n            babylonMeshesArray.forEach((mesh) => {\r\n                if (isLine(mesh)) {\r\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\r\n                    // If another mesh is using this material and it is not a line then we need to clone it.\r\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\r\n                    if (needClone) {\r\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\r\n                    }\r\n                    mat.wireframe = true;\r\n                    mesh.material = mat;\r\n                    if (mesh._internalMetadata) {\r\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\n//Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new OBJFileLoader());\r\n","import type { ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const OBJFileLoaderMetadata = {\r\n    name: \"obj\",\r\n    extensions: \".obj\",\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const STLFileLoaderMetadata = {\r\n    name: \"stl\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".stl\": { isBinary: true },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { ISceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { STLFileLoaderMetadata } from \"./stlFileLoader.metadata\";\r\nimport \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the stl loader.\r\n         */\r\n        [STLFileLoaderMetadata.name]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * STL file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class STLFileLoader implements ISceneLoaderPlugin {\r\n    /** @internal */\r\n    public solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g;\r\n\r\n    /** @internal */\r\n    public facetsPattern = /facet([\\s\\S]*?)endfacet/g;\r\n    /** @internal */\r\n    public normalPattern = /normal[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n    /** @internal */\r\n    public vertexPattern = /vertex[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = STLFileLoaderMetadata.name;\r\n\r\n    /**\r\n     * Defines the extensions the stl loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     * we'll convert to string if it looks like it's an ASCII .stl\r\n     */\r\n    public readonly extensions = STLFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Defines if Y and Z axes are swapped or not when loading an STL file.\r\n     * The default is false to maintain backward compatibility. When set to\r\n     * true, coordinates from the STL file are used without change.\r\n     */\r\n    public static DO_NOT_ALTER_FILE_COORDINATES = false;\r\n\r\n    /**\r\n     * Import meshes into a scene.\r\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\r\n     * @param scene The scene to import into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @param meshes The meshes array to import into\r\n     * @returns True if successful or false otherwise\r\n     */\r\n    public importMesh(meshesNames: any, scene: Scene, data: any, rootUrl: string, meshes: Nullable<AbstractMesh[]>): boolean {\r\n        let matches;\r\n\r\n        if (typeof data !== \"string\") {\r\n            if (this._isBinary(data)) {\r\n                // binary .stl\r\n                const babylonMesh = new Mesh(\"stlmesh\", scene);\r\n                this._parseBinary(babylonMesh, data);\r\n                if (meshes) {\r\n                    meshes.push(babylonMesh);\r\n                }\r\n                return true;\r\n            }\r\n\r\n            // ASCII .stl\r\n\r\n            // convert to string\r\n            data = new TextDecoder().decode(new Uint8Array(data));\r\n        }\r\n\r\n        //if arrived here, data is a string, containing the STLA data.\r\n\r\n        while ((matches = this.solidPattern.exec(data))) {\r\n            let meshName = matches[1];\r\n            const meshNameFromEnd = matches[3];\r\n            if (meshNameFromEnd && meshName != meshNameFromEnd) {\r\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\r\n                return false;\r\n            }\r\n\r\n            // check meshesNames\r\n            if (meshesNames && meshName) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (!meshesNames.indexOf(meshName)) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (meshName !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // stl mesh name can be empty as well\r\n            meshName = meshName || \"stlmesh\";\r\n\r\n            const babylonMesh = new Mesh(meshName, scene);\r\n            this._parseASCII(babylonMesh, matches[2]);\r\n            if (meshes) {\r\n                meshes.push(babylonMesh);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Load into a scene.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns true if successful or false otherwise\r\n     */\r\n    public load(scene: Scene, data: any, rootUrl: string): boolean {\r\n        const result = this.importMesh(null, scene, data, rootUrl, null);\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    public loadAssetContainer(scene: Scene, data: string, rootUrl: string): AssetContainer {\r\n        const container = new AssetContainer(scene);\r\n        scene._blockEntityCollection = true;\r\n        this.importMesh(null, scene, data, rootUrl, container.meshes);\r\n        scene._blockEntityCollection = false;\r\n        return container;\r\n    }\r\n\r\n    private _isBinary(data: any) {\r\n        // check if file size is correct for binary stl\r\n        const reader = new DataView(data);\r\n\r\n        // A Binary STL header is 80 bytes, if the data size is not great than\r\n        // that then it's not a binary STL.\r\n        if (reader.byteLength <= 80) {\r\n            return false;\r\n        }\r\n\r\n        const faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;\r\n        const nFaces = reader.getUint32(80, true);\r\n\r\n        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {\r\n            return true;\r\n        }\r\n\r\n        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'\r\n        const ascii = [115, 111, 108, 105, 100];\r\n        for (let off = 0; off < 5; off++) {\r\n            if (reader.getUint8(off) !== ascii[off]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private _parseBinary(mesh: Mesh, data: ArrayBuffer) {\r\n        const reader = new DataView(data);\r\n        const faces = reader.getUint32(80, true);\r\n\r\n        const dataOffset = 84;\r\n        const faceLength = 12 * 4 + 2;\r\n\r\n        let offset = 0;\r\n\r\n        const positions = new Float32Array(faces * 3 * 3);\r\n        const normals = new Float32Array(faces * 3 * 3);\r\n        const indices = new Uint32Array(faces * 3);\r\n        let indicesCount = 0;\r\n\r\n        for (let face = 0; face < faces; face++) {\r\n            const start = dataOffset + face * faceLength;\r\n            const normalX = reader.getFloat32(start, true);\r\n            const normalY = reader.getFloat32(start + 4, true);\r\n            const normalZ = reader.getFloat32(start + 8, true);\r\n\r\n            for (let i = 1; i <= 3; i++) {\r\n                const vertexstart = start + i * 12;\r\n\r\n                // ordering is intentional to match ascii import\r\n                positions[offset] = reader.getFloat32(vertexstart, true);\r\n                normals[offset] = normalX;\r\n\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 2] = normalY;\r\n                    normals[offset + 1] = normalZ;\r\n                } else {\r\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);\r\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);\r\n\r\n                    normals[offset + 1] = normalY;\r\n                    normals[offset + 2] = normalZ;\r\n                }\r\n\r\n                offset += 3;\r\n            }\r\n\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices[indicesCount] = indicesCount;\r\n                indices[indicesCount + 1] = indicesCount + 2;\r\n                indices[indicesCount + 2] = indicesCount + 1;\r\n                indicesCount += 3;\r\n            } else {\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n                indices[indicesCount] = indicesCount++;\r\n            }\r\n        }\r\n\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n\r\n    private _parseASCII(mesh: Mesh, solidData: string) {\r\n        const positions = [];\r\n        const normals = [];\r\n        const indices = [];\r\n        let indicesCount = 0;\r\n\r\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\r\n        let matches;\r\n        while ((matches = this.facetsPattern.exec(solidData))) {\r\n            const facet = matches[1];\r\n            //one normal per face\r\n            const normalMatches = this.normalPattern.exec(facet);\r\n            this.normalPattern.lastIndex = 0;\r\n            if (!normalMatches) {\r\n                continue;\r\n            }\r\n            const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\r\n\r\n            let vertexMatch;\r\n            while ((vertexMatch = this.vertexPattern.exec(facet))) {\r\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\r\n                    normals.push(normal[0], normal[1], normal[2]);\r\n                } else {\r\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));\r\n\r\n                    // Flipping the second and third component because inverted\r\n                    // when normal was declared.\r\n                    normals.push(normal[0], normal[2], normal[1]);\r\n                }\r\n            }\r\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\r\n                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\r\n                indicesCount += 3;\r\n            } else {\r\n                indices.push(indicesCount++, indicesCount++, indicesCount++);\r\n            }\r\n            this.vertexPattern.lastIndex = 0;\r\n        }\r\n\r\n        this.facetsPattern.lastIndex = 0;\r\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n        mesh.setIndices(indices);\r\n        mesh.computeWorldMatrix(true);\r\n    }\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new STLFileLoader());\r\n","import type { ISceneLoaderPluginExtensions, ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const SPLATFileLoaderMetadata = {\r\n    name: \"splat\",\r\n\r\n    extensions: {\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".splat\": { isBinary: true },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".ply\": { isBinary: true },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".spz\": { isBinary: true },\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".json\": { isBinary: false }, // For SOG metadata files\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        \".sog\": { isBinary: true },\r\n    } as const satisfies ISceneLoaderPluginExtensions,\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","import type { Scene } from \"core/scene\";\r\nimport type { IParsedPLY } from \"./splatDefs\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { AbstractEngine } from \"core/Engines\";\r\n\r\n/**\r\n * Definition of a SOG data file\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface SOGDataFile {\r\n    /**\r\n     * index 0 is number of splats index 1 is number of components per splat (3 for vec3, 4 for vec4, etc.)\r\n     */\r\n    shape: number[];\r\n    /**\r\n     * type of components\r\n     */\r\n    dtype: string;\r\n    /**\r\n     * min range of data\r\n     */\r\n    mins?: number | number[];\r\n    /**\r\n     * max range of data\r\n     */\r\n    maxs?: number | number[];\r\n    /**\r\n     * palette for indexed data (quantized)\r\n     */\r\n    codebook?: number[]; // Only for version 2\r\n    /**\r\n     * type of encoding\r\n     */\r\n    encoding?: string;\r\n    /**\r\n     * number of bits for quantization (if any)\r\n     */\r\n    quantization?: number;\r\n    /**\r\n     * webp file names\r\n     */\r\n    files: string[];\r\n    /**\r\n     * SH band count (if applicable)\r\n     */\r\n    bands?: number;\r\n}\r\n\r\n/**\r\n * Definition of the root SOG data file\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface SOGRootData {\r\n    /**\r\n     * version of the SOG format\r\n     */\r\n    version?: number;\r\n    /**\r\n     * mean positions of the splats\r\n     */\r\n    means: SOGDataFile;\r\n    /**\r\n     * scales of the splats\r\n     */\r\n    scales: SOGDataFile;\r\n    /**\r\n     * quaternions of the splats\r\n     */\r\n    quats: SOGDataFile;\r\n    /**\r\n     * SH0 coefficients of the splats (base color)\r\n     */\r\n    sh0: SOGDataFile;\r\n    /**\r\n     *  Optional higher order SH coefficients of the splats (lighting information)\r\n     */\r\n    shN?: SOGDataFile;\r\n    /**\r\n     * number of splats (optional, can be inferred from means.shape[0])\r\n     */\r\n    count?: number;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface IWebPImage {\r\n    bits: Uint8Array;\r\n    width: number;\r\n}\r\nconst SH_C0 = 0.28209479177387814;\r\n\r\nasync function LoadWebpImageData(rootUrlOrData: string | Uint8Array, filename: string, engine: AbstractEngine): Promise<IWebPImage> {\r\n    const promise = new Promise<IWebPImage>((resolve, reject) => {\r\n        const image = engine.createCanvasImage();\r\n        if (!image) {\r\n            throw new Error(\"Failed to create ImageBitmap\");\r\n        }\r\n        image.onload = () => {\r\n            try {\r\n                // Draw to canvas\r\n                const canvas = engine.createCanvas(image.width, image.height);\r\n                if (!canvas) {\r\n                    throw new Error(\"Failed to create canvas\");\r\n                }\r\n                const ctx = canvas.getContext(\"2d\");\r\n                if (!ctx) {\r\n                    throw new Error(\"Failed to get 2D context\");\r\n                }\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                // Extract pixel data (RGBA per pixel)\r\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n                resolve({ bits: new Uint8Array(imageData.data.buffer), width: imageData.width });\r\n            } catch (error) {\r\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                reject(`Error loading image ${image.src} with exception: ${error}`);\r\n            }\r\n        };\r\n        image.onerror = (error) => {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(`Error loading image ${image.src} with exception: ${error}`);\r\n        };\r\n\r\n        image.crossOrigin = \"anonymous\"; // To avoid CORS issues\r\n        let objectUrl: string | undefined;\r\n        if (typeof rootUrlOrData === \"string\") {\r\n            // old behavior: URL + filename\r\n            if (!filename) {\r\n                throw new Error(\"filename is required when using a URL\");\r\n            }\r\n            image.src = rootUrlOrData + filename;\r\n        } else {\r\n            // new behavior: Uint8Array\r\n            const blob = new Blob([rootUrlOrData as any], { type: \"image/webp\" });\r\n            objectUrl = URL.createObjectURL(blob);\r\n            image.src = objectUrl;\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\nasync function ParseSogDatas(data: SOGRootData, imageDataArrays: IWebPImage[], scene: Scene): Promise<IParsedPLY> {\r\n    const splatCount = data.count ? data.count : data.means.shape[0];\r\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n    const position = new Float32Array(buffer);\r\n    const scale = new Float32Array(buffer);\r\n    const rgba = new Uint8ClampedArray(buffer);\r\n    const rot = new Uint8ClampedArray(buffer);\r\n\r\n    // Undo the symmetric log transform used at encode time:\r\n    const unlog = (n: number) => Math.sign(n) * (Math.exp(Math.abs(n)) - 1);\r\n\r\n    const meansl = imageDataArrays[0].bits;\r\n    const meansu = imageDataArrays[1].bits;\r\n    // Check that data.means.mins is an array\r\n    if (!Array.isArray(data.means.mins) || !Array.isArray(data.means.maxs)) {\r\n        throw new Error(\"Missing arrays in SOG data.\");\r\n    }\r\n\r\n    // --- Positions\r\n    for (let i = 0; i < splatCount; i++) {\r\n        const index = i * 4;\r\n        for (let j = 0; j < 3; j++) {\r\n            const meansMin = data.means.mins[j];\r\n            const meansMax = data.means.maxs[j];\r\n            const meansup = meansu[index + j];\r\n            const meanslow = meansl[index + j];\r\n            const q = (meansup << 8) | meanslow;\r\n            const n = Scalar.Lerp(meansMin, meansMax, q / 65535);\r\n            position[i * 8 + j] = unlog(n);\r\n        }\r\n    }\r\n\r\n    // --- Scales\r\n    const scales = imageDataArrays[2].bits;\r\n    if (data.version === 2) {\r\n        if (!data.scales.codebook) {\r\n            throw new Error(\"Missing codebook in SOG version 2 scales data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const sc = data.scales.codebook[scales[index + j]];\r\n                const sce = Math.exp(sc);\r\n                scale[i * 8 + 3 + j] = sce;\r\n            }\r\n        }\r\n    } else {\r\n        if (!Array.isArray(data.scales.mins) || !Array.isArray(data.scales.maxs)) {\r\n            throw new Error(\"Missing arrays in SOG scales data.\");\r\n        }\r\n\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const sc = scales[index + j];\r\n                const lsc = Scalar.Lerp(data.scales.mins[j], data.scales.maxs[j], sc / 255);\r\n                const lsce = Math.exp(lsc);\r\n                scale[i * 8 + 3 + j] = lsce;\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Colors/SH0\r\n    const colors = imageDataArrays[4].bits;\r\n    if (data.version === 2) {\r\n        if (!data.sh0.codebook) {\r\n            throw new Error(\"Missing codebook in SOG version 2 sh0 data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const component = 0.5 + data.sh0.codebook[colors[index + j]] * SH_C0;\r\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * component)));\r\n            }\r\n            rgba[i * 32 + 24 + 3] = colors[index + 3];\r\n        }\r\n    } else {\r\n        if (!Array.isArray(data.sh0.mins) || !Array.isArray(data.sh0.maxs)) {\r\n            throw new Error(\"Missing arrays in SOG sh0 data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 4; j++) {\r\n                const colorsMin = data.sh0.mins[j];\r\n                const colorsMax = data.sh0.maxs[j];\r\n\r\n                const colort = colors[index + j];\r\n                const c = Scalar.Lerp(colorsMin, colorsMax, colort / 255);\r\n\r\n                let csh;\r\n                if (j < 3) {\r\n                    csh = 0.5 + c * SH_C0;\r\n                } else {\r\n                    csh = 1.0 / (1.0 + Math.exp(-c));\r\n                }\r\n\r\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * csh)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Rotations\r\n    // Dequantize the stored three components:\r\n    const toComp = (c: number) => ((c / 255 - 0.5) * 2.0) / Math.SQRT2;\r\n\r\n    const quatArray = imageDataArrays[3].bits;\r\n    for (let i = 0; i < splatCount; i++) {\r\n        const quatsr = quatArray[i * 4 + 0];\r\n        const quatsg = quatArray[i * 4 + 1];\r\n        const quatsb = quatArray[i * 4 + 2];\r\n        const quatsa = quatArray[i * 4 + 3];\r\n\r\n        const a = toComp(quatsr);\r\n        const b = toComp(quatsg);\r\n        const c = toComp(quatsb);\r\n\r\n        const mode = quatsa - 252; // 0..3 (R,G,B,A is one of the four components)\r\n\r\n        // Reconstruct the omitted component so that ||q|| = 1 and w.l.o.g. the omitted one is non-negative\r\n        const t = a * a + b * b + c * c;\r\n        const d = Math.sqrt(Math.max(0, 1 - t));\r\n\r\n        // Place components according to mode\r\n        let q: [number, number, number, number];\r\n        switch (mode) {\r\n            case 0:\r\n                q = [d, a, b, c];\r\n                break; // omitted = x\r\n            case 1:\r\n                q = [a, d, b, c];\r\n                break; // omitted = y\r\n            case 2:\r\n                q = [a, b, d, c];\r\n                break; // omitted = z\r\n            case 3:\r\n                q = [a, b, c, d];\r\n                break; // omitted = w\r\n            default:\r\n                throw new Error(\"Invalid quaternion mode\");\r\n        }\r\n\r\n        rot[i * 32 + 28 + 0] = q[0] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 1] = q[1] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 2] = q[2] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 3] = q[3] * 127.5 + 127.5;\r\n    }\r\n\r\n    // --- SH\r\n    if (data.shN) {\r\n        const coeffCounts = [0, 3, 8, 15];\r\n        const coeffs = data.shN.bands ? coeffCounts[data.shN.bands] : data.shN.shape[1] / 3; // 3 components per coeff\r\n        const shCentroids = imageDataArrays[5].bits;\r\n        const shLabelsData = imageDataArrays[6].bits;\r\n        const shCentroidsWidth = imageDataArrays[5].width;\r\n\r\n        const shComponentCount = coeffs * 3;\r\n\r\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n        //let shIndexRead = byteOffset;\r\n\r\n        // sh is an array of uint8array that will be used to create sh textures\r\n        const sh: Uint8Array[] = [];\r\n\r\n        const engine = scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n        const height = Math.ceil(splatCount / width);\r\n        // create array for the number of textures needed.\r\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n            sh.push(texture);\r\n        }\r\n\r\n        if (data.version === 2) {\r\n            if (!data.shN.codebook) {\r\n                throw new Error(\"Missing codebook in SOG version 2 shN data.\");\r\n            }\r\n\r\n            for (let i = 0; i < splatCount; i++) {\r\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\r\n                const u = (n % 64) * coeffs;\r\n                const v = Math.floor(n / 64);\r\n\r\n                for (let k = 0; k < coeffs; k++) {\r\n                    for (let j = 0; j < 3; j++) {\r\n                        const shIndexWrite = k * 3 + j;\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n\r\n                        const shValue = data.shN.codebook[shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4]] * 127.5 + 127.5;\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < splatCount; i++) {\r\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\r\n                const u = (n % 64) * coeffs;\r\n                const v = Math.floor(n / 64);\r\n                const shMin = data.shN.mins as number;\r\n                const shMax = data.shN.maxs as number;\r\n\r\n                for (let j = 0; j < 3; j++) {\r\n                    for (let k = 0; k < coeffs / 3; k++) {\r\n                        const shIndexWrite = k * 3 + j;\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n\r\n                        const shValue = Scalar.Lerp(shMin, shMax, shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4] / 255) * 127.5 + 127.5;\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return await new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh });\r\n        });\r\n    }\r\n\r\n    return await new Promise((resolve) => {\r\n        resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false });\r\n    });\r\n}\r\n\r\n/**\r\n * Parse SOG data from either a SOGRootData object (with webp files loaded from rootUrl) or from a Map of filenames to Uint8Array file data (including meta.json)\r\n * @param dataOrFiles Either the SOGRootData or a Map of filenames to Uint8Array file data (including meta.json)\r\n * @param rootUrl Base URL to load webp files from (if dataOrFiles is SOGRootData)\r\n * @param scene The Babylon.js scene\r\n * @returns Parsed data\r\n */\r\nexport async function ParseSogMeta(dataOrFiles: SOGRootData | Map<string, Uint8Array>, rootUrl: string, scene: Scene): Promise<IParsedPLY> {\r\n    let data: SOGRootData;\r\n    let files: Map<string, Uint8Array> | undefined;\r\n\r\n    if (dataOrFiles instanceof Map) {\r\n        files = dataOrFiles;\r\n\r\n        const metaFile = files.get(\"meta.json\");\r\n        if (!metaFile) {\r\n            throw new Error(\"meta.json not found in files Map\");\r\n        }\r\n\r\n        data = JSON.parse(new TextDecoder().decode(metaFile)) as SOGRootData;\r\n    } else {\r\n        data = dataOrFiles;\r\n    }\r\n\r\n    // Collect all file names\r\n    const urls = [...data.means.files, ...data.scales.files, ...data.quats.files, ...data.sh0.files];\r\n    if (data.shN) {\r\n        urls.push(...data.shN.files);\r\n    }\r\n\r\n    // Load webp images in parallel\r\n    const imageDataArrays: IWebPImage[] = await Promise.all(\r\n        urls.map(async (fileName) => {\r\n            if (files && files.has(fileName)) {\r\n                // load from in-memory Uint8Array\r\n                const fileData = files.get(fileName)!;\r\n                return await LoadWebpImageData(fileData, fileName, scene.getEngine());\r\n            } else {\r\n                // fallback: load from URL\r\n                return await LoadWebpImageData(rootUrl, fileName, scene.getEngine());\r\n            }\r\n        })\r\n    );\r\n\r\n    return await ParseSogDatas(data, imageDataArrays, scene);\r\n}\r\n","/* eslint-disable @typescript-eslint/promise-function-async*/\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, ISceneLoaderProgressEvent, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\r\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport type { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport { ParseSpz } from \"./spz\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport type { IParsedPLY } from \"./splatDefs\";\r\nimport { ParseSogMeta } from \"./sog\";\r\nimport type { SOGRootData } from \"./sog\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the splat loader.\r\n         */\r\n        [SPLATFileLoaderMetadata.name]: Partial<SPLATLoadingOptions>;\r\n    }\r\n}\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * @experimental\r\n * SPLAT file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class SPLATFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = SPLATFileLoaderMetadata.name;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private readonly _loadingOptions: Readonly<SPLATLoadingOptions>;\r\n    /**\r\n     * Defines the extensions the splat loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     */\r\n    public readonly extensions = SPLATFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Creates loader for gaussian splatting files\r\n     * @param loadingOptions options for loading and parsing splat and PLY files.\r\n     */\r\n    constructor(loadingOptions: Partial<Readonly<SPLATLoadingOptions>> = SPLATFileLoader._DefaultLoadingOptions) {\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    private static readonly _DefaultLoadingOptions = {\r\n        keepInRam: false,\r\n        flipY: false,\r\n    } as const satisfies SPLATLoadingOptions;\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the gaussian splatting data to load\r\n     * @param rootUrl root url to load from\r\n     * @param _onProgress callback called while file is loading\r\n     * @param _fileName Defines the name of the file to load\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        _onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        _fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    private static _BuildPointCloud(pointcloud: PointsCloudSystem, data: ArrayBuffer): boolean {\r\n        if (!data.byteLength) {\r\n            return false;\r\n        }\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(data);\r\n\r\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const pointcloudfunc = function (particle: any, i: number) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            particle.position = new Vector3(x, y, z);\r\n\r\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n            particle.color = new Color4(r, g, b, 1);\r\n        };\r\n\r\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\r\n        return true;\r\n    }\r\n\r\n    private static _BuildMesh(scene: Scene, parsedPLY: IParsedPLY): Mesh {\r\n        const mesh = new Mesh(\"PLYMesh\", scene);\r\n\r\n        const uBuffer = new Uint8Array(parsedPLY.data);\r\n        const fBuffer = new Float32Array(parsedPLY.data);\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const positions = [];\r\n\r\n        const vertexData = new VertexData();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            positions.push(x, y, z);\r\n        }\r\n\r\n        if (parsedPLY.hasVertexColors) {\r\n            const colors = new Float32Array(vertexCount * 4);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n                colors[i * 4 + 0] = r;\r\n                colors[i * 4 + 1] = g;\r\n                colors[i * 4 + 2] = b;\r\n                colors[i * 4 + 3] = 1;\r\n            }\r\n            vertexData.colors = colors;\r\n        }\r\n\r\n        vertexData.positions = positions;\r\n        vertexData.indices = parsedPLY.faces!;\r\n\r\n        vertexData.applyToMesh(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax, @typescript-eslint/naming-convention\r\n    private async _unzipWithFFlateAsync(data: Uint8Array): Promise<Map<string, Uint8Array>> {\r\n        // ensure fflate is loaded\r\n        if (typeof (window as any).fflate === \"undefined\") {\r\n            await Tools.LoadScriptAsync(this._loadingOptions.deflateURL ?? \"https://unpkg.com/fflate/umd/index.js\");\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n        // @ts-ignore\r\n        const { unzipSync } = (window as any).fflate as typeof import(\"fflate\");\r\n\r\n        const unzipped = unzipSync(data); // { [filename: string]: Uint8Array }\r\n\r\n        const files = new Map<string, Uint8Array>();\r\n        for (const [name, content] of Object.entries(unzipped)) {\r\n            files.set(name, content as Uint8Array);\r\n        }\r\n        return files;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        const makeGSFromParsedSOG = (parsedSOG: IParsedPLY) => {\r\n            scene._blockEntityCollection = !!this._assetContainer;\r\n            const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n            gaussianSplatting._parentContainer = this._assetContainer;\r\n            gaussianSplatting.viewDirectionFactor.set(1, -1, 1);\r\n            babylonMeshesArray.push(gaussianSplatting);\r\n            gaussianSplatting.updateData(parsedSOG.data, parsedSOG.sh);\r\n            scene._blockEntityCollection = false;\r\n        };\r\n\r\n        // check if data is json string\r\n        if (typeof data === \"string\") {\r\n            const dataSOG = JSON.parse(data) as SOGRootData;\r\n            if (dataSOG && dataSOG.means && dataSOG.scales && dataSOG.quats && dataSOG.sh0) {\r\n                return new Promise((resolve) => {\r\n                    ParseSogMeta(dataSOG, rootUrl, scene)\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        .then((parsedSOG) => {\r\n                            makeGSFromParsedSOG(parsedSOG);\r\n                            resolve(babylonMeshesArray);\r\n                        })\r\n                        // eslint-disable-next-line github/no-then\r\n                        .catch(() => {\r\n                            throw new Error(\"Failed to parse SOG data.\");\r\n                        });\r\n                });\r\n            }\r\n        }\r\n\r\n        const u8 = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n        // ZIP signature check for SOG\r\n        if (u8[0] === 0x50 && u8[1] === 0x4b) {\r\n            return new Promise((resolve) => {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                this._unzipWithFFlateAsync(u8).then((files) => {\r\n                    ParseSogMeta(files, rootUrl, scene)\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        .then((parsedSOG) => {\r\n                            makeGSFromParsedSOG(parsedSOG);\r\n                            resolve(babylonMeshesArray);\r\n                        }) // eslint-disable-next-line github/no-then\r\n                        .catch(() => {\r\n                            throw new Error(\"Failed to parse SOG zip data.\");\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        const readableStream = new ReadableStream({\r\n            start(controller) {\r\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\r\n                controller.close();\r\n            },\r\n        });\r\n\r\n        // Use GZip DecompressionStream\r\n        const decompressionStream = new DecompressionStream(\"gzip\");\r\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\r\n\r\n        return new Promise((resolve) => {\r\n            new Response(decompressedStream)\r\n                .arrayBuffer()\r\n                // eslint-disable-next-line github/no-then\r\n                .then((buffer) => {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    ParseSpz(buffer, scene, this._loadingOptions).then((parsedSPZ) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                        if (parsedSPZ.trainedWithAntialiasing) {\r\n                            const gsMaterial = gaussianSplatting.material as GaussianSplattingMaterial;\r\n                            gsMaterial.kernelSize = 0.1;\r\n                            gsMaterial.compensation = true;\r\n                        }\r\n                        gaussianSplatting._parentContainer = this._assetContainer;\r\n                        babylonMeshesArray.push(gaussianSplatting);\r\n                        gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);\r\n                        scene._blockEntityCollection = false;\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch(() => {\r\n                    // Catch any decompression errors\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    SPLATFileLoader._ConvertPLYToSplat(data as ArrayBuffer).then(async (parsedPLY) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        switch (parsedPLY.mode) {\r\n                            case Mode.Splat:\r\n                                {\r\n                                    const gaussianSplatting = new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                                    gaussianSplatting._parentContainer = this._assetContainer;\r\n                                    babylonMeshesArray.push(gaussianSplatting);\r\n                                    gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);\r\n                                    if (parsedPLY.compressed || !parsedPLY.rawSplat) {\r\n                                        gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.PointCloud:\r\n                                {\r\n                                    const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\r\n                                    if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\r\n                                        // eslint-disable-next-line github/no-then\r\n                                        await pointcloud.buildMeshAsync().then((mesh) => {\r\n                                            babylonMeshesArray.push(mesh);\r\n                                        });\r\n                                    } else {\r\n                                        pointcloud.dispose();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.Mesh:\r\n                                {\r\n                                    if (parsedPLY.faces) {\r\n                                        babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\r\n                                    } else {\r\n                                        throw new Error(\"PLY mesh doesn't contain face informations.\");\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                throw new Error(\"Unsupported Splat mode\");\r\n                        }\r\n                        scene._blockEntityCollection = false;\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return (\r\n            this.importMeshAsync(null, scene, data, rootUrl)\r\n                // eslint-disable-next-line github/no-then\r\n                .then((result) => {\r\n                    for (const mesh of result.meshes) {\r\n                        container.meshes.push(mesh);\r\n                    }\r\n                    // mesh material will be null before 1st rendered frame.\r\n                    this._assetContainer = null;\r\n                    return container;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((ex) => {\r\n                    this._assetContainer = null;\r\n                    throw ex;\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        // eslint-disable-next-line github/no-then\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    private static _ConvertPLYToSplat(data: ArrayBuffer): Promise<IParsedPLY> {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: data, rawSplat: true });\r\n            });\r\n        }\r\n\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const faceElement = /element face (\\d+)\\n/.exec(header);\r\n        let faceCount = 0;\r\n        if (faceElement) {\r\n            faceCount = parseInt(faceElement[1]);\r\n        }\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        type PlyProperty = {\r\n            name: string;\r\n            type: string;\r\n            offset: number;\r\n        };\r\n\r\n        const enum ElementMode {\r\n            Vertex = 0,\r\n            Chunk = 1,\r\n            SH = 2,\r\n        }\r\n\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, type, name] = prop.split(\" \");\r\n\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.SH) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                }\r\n                if (!offsets[type]) {\r\n                    Logger.Warn(`Unsupported property type: ${type}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                } else if (type == \"sh\") {\r\n                    chunkMode = ElementMode.SH;\r\n                }\r\n            }\r\n        }\r\n\r\n        const rowVertexLength = rowVertexOffset;\r\n        const rowChunkLength = rowChunkOffset;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data) as any).then(async (splatsData: any) => {\r\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\r\n            // faces\r\n            const faces: number[] = [];\r\n            if (faceCount) {\r\n                for (let i = 0; i < faceCount; i++) {\r\n                    const faceVertexCount = dataView.getUint8(offset);\r\n                    if (faceVertexCount != 3) {\r\n                        continue; // only support triangles\r\n                    }\r\n                    offset += 1;\r\n\r\n                    for (let j = 0; j < faceVertexCount; j++) {\r\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\r\n                        faces.push(vertexIndex);\r\n                    }\r\n                    offset += 12;\r\n                }\r\n            }\r\n\r\n            // early exit for chunked/quantized ply\r\n            if (chunkCount) {\r\n                return await new Promise((resolve) => {\r\n                    resolve({ mode: Mode.Splat, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true, rawSplat: false });\r\n                });\r\n            }\r\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\r\n            // if faces are found, then it's a standard mesh\r\n            let propertyCount = 0;\r\n            let propertyColorCount = 0;\r\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\r\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\r\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\r\n                const property = vertexProperties[propertyIndex];\r\n                if (splatProperties.includes(property.name)) {\r\n                    propertyCount++;\r\n                }\r\n                if (splatColorProperties.includes(property.name)) {\r\n                    propertyColorCount++;\r\n                }\r\n            }\r\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\r\n            const currentMode = faceCount ? Mode.Mesh : hasMandatoryProperties ? Mode.Splat : Mode.PointCloud;\r\n            // parsed ready ready to be used as a splat\r\n            return await new Promise((resolve) => {\r\n                resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: !!propertyColorCount, compressed: false, rawSplat: false });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport type { IParsedPLY } from \"./splatDefs\";\r\n\r\n/**\r\n * Parses SPZ data and returns a promise resolving to an IParsedPLY object.\r\n * @param data The ArrayBuffer containing SPZ data.\r\n * @param scene The Babylon.js scene.\r\n * @param loadingOptions Options for loading Gaussian Splatting files.\r\n * @returns A promise resolving to the parsed SPZ data.\r\n */\r\nexport function ParseSpz(data: ArrayBuffer, scene: Scene, loadingOptions: SPLATLoadingOptions): Promise<IParsedPLY> {\r\n    const ubuf = new Uint8Array(data);\r\n    const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\r\n    // debug infos\r\n    const splatCount = ubufu32[2];\r\n\r\n    const shDegree = ubuf[12];\r\n    const fractionalBits = ubuf[13];\r\n    const flags = ubuf[14];\r\n    const reserved = ubuf[15];\r\n    const version = ubufu32[1];\r\n\r\n    // check magic and version\r\n    if (reserved || ubufu32[0] != 0x5053474e || (version != 2 && version != 3)) {\r\n        // reserved must be 0\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Reject, data: buffer, hasVertexColors: false });\r\n        });\r\n    }\r\n\r\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n    const positionScale = 1.0 / (1 << fractionalBits);\r\n\r\n    const int32View = new Int32Array(1);\r\n    const uint8View = new Uint8Array(int32View.buffer);\r\n    const read24bComponent = function (u8: Uint8Array, offset: number) {\r\n        uint8View[0] = u8[offset + 0];\r\n        uint8View[1] = u8[offset + 1];\r\n        uint8View[2] = u8[offset + 2];\r\n        uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\r\n        return int32View[0] * positionScale;\r\n    };\r\n\r\n    let byteOffset = 16;\r\n\r\n    const position = new Float32Array(buffer);\r\n    const scale = new Float32Array(buffer);\r\n    const rgba = new Uint8ClampedArray(buffer);\r\n    const rot = new Uint8ClampedArray(buffer);\r\n\r\n    let coordinateSign = 1;\r\n    let quaternionOffset = 0;\r\n    if (!loadingOptions.flipY) {\r\n        coordinateSign = -1;\r\n        quaternionOffset = 255;\r\n    }\r\n    // positions\r\n    for (let i = 0; i < splatCount; i++) {\r\n        position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\r\n        position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);\r\n        position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);\r\n        byteOffset += 9;\r\n    }\r\n\r\n    // colors\r\n    const shC0 = 0.282;\r\n    for (let i = 0; i < splatCount; i++) {\r\n        for (let component = 0; component < 3; component++) {\r\n            const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\r\n            // 0.15 is hard coded value from spz\r\n            // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\r\n            // be useful to represent base colors that are out of range if the higher spherical harmonics bands\r\n            // bring them back into range so we multiply by a smaller value.\r\n            const value = (byteValue - 127.5) / (0.15 * 255);\r\n            rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\r\n        }\r\n\r\n        rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\r\n    }\r\n    byteOffset += splatCount * 4;\r\n\r\n    // scales\r\n    for (let i = 0; i < splatCount; i++) {\r\n        scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\r\n        scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\r\n        scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\r\n        byteOffset += 3;\r\n    }\r\n\r\n    // convert quaternion\r\n    if (version >= 3) {\r\n        /*\r\n            In version 3, rotations are represented as the smallest three components of the normalized rotation quaternion, for optimal rotation accuracy.\r\n            The largest component can be derived from the others and is not stored. Its index is stored on 2 bits\r\n            and each of the smallest three components is encoded as a 10-bit signed integer.\r\n        */\r\n        const sqrt12 = Math.SQRT1_2;\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const r = [ubuf[byteOffset + 0], ubuf[byteOffset + 1], ubuf[byteOffset + 2], ubuf[byteOffset + 3]];\r\n\r\n            const comp = r[0] + (r[1] << 8) + (r[2] << 16) + (r[3] << 24);\r\n\r\n            const cmask = (1 << 9) - 1;\r\n            const rotation = [];\r\n            const iLargest = comp >>> 30;\r\n            let remaining = comp;\r\n            let sumSquares = 0;\r\n\r\n            for (let i = 3; i >= 0; --i) {\r\n                if (i !== iLargest) {\r\n                    const mag = remaining & cmask;\r\n                    const negbit = (remaining >>> 9) & 0x1;\r\n                    remaining = remaining >>> 10;\r\n\r\n                    rotation[i] = sqrt12 * (mag / cmask);\r\n                    if (negbit === 1) {\r\n                        rotation[i] = -rotation[i];\r\n                    }\r\n\r\n                    // accumulate the sum of squares\r\n                    sumSquares += rotation[i] * rotation[i];\r\n                }\r\n            }\r\n\r\n            const square = 1 - sumSquares;\r\n            rotation[iLargest] = Math.sqrt(Math.max(square, 0));\r\n\r\n            rotation[1] *= coordinateSign;\r\n            rotation[2] *= coordinateSign;\r\n\r\n            const shuffle = [3, 0, 1, 2]; // shuffle to match the order of the quaternion components in the splat file\r\n            for (let j = 0; j < 4; j++) {\r\n                rot[i * 32 + 28 + j] = Math.round(127.5 + rotation[shuffle[j]] * 127.5);\r\n            }\r\n\r\n            byteOffset += 4;\r\n        }\r\n    } else {\r\n        /*\r\n            In version 2, rotations are represented as the `(x, y, z)` components of the normalized rotation quaternion. The\r\n            `w` component can be derived from the others and is not stored. Each component is encoded as an\r\n            8-bit signed integer.\r\n        */\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const x = ubuf[byteOffset + 0];\r\n            const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;\r\n            const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;\r\n            const nx = x / 127.5 - 1;\r\n            const ny = y / 127.5 - 1;\r\n            const nz = z / 127.5 - 1;\r\n            rot[i * 32 + 28 + 1] = x;\r\n            rot[i * 32 + 28 + 2] = y;\r\n            rot[i * 32 + 28 + 3] = z;\r\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\r\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\r\n\r\n            byteOffset += 3;\r\n        }\r\n    }\r\n\r\n    //SH\r\n    if (shDegree) {\r\n        // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\r\n        // number of vec3 vector needed per splat\r\n        const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\r\n        // number of component values : 3 per vector3 (45)\r\n        const shComponentCount = shVectorCount * 3;\r\n\r\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n        let shIndexRead = byteOffset;\r\n\r\n        // sh is an array of uint8array that will be used to create sh textures\r\n        const sh: Uint8Array[] = [];\r\n\r\n        const engine = scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n        const height = Math.ceil(splatCount / width);\r\n        // create array for the number of textures needed.\r\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n            sh.push(texture);\r\n        }\r\n\r\n        for (let i = 0; i < splatCount; i++) {\r\n            for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\r\n                const shValue = ubuf[shIndexRead++];\r\n\r\n                const textureIndex = Math.floor(shIndexWrite / 16);\r\n                const shArray = sh[textureIndex];\r\n\r\n                const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n            }\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\r\n        });\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\r\n    });\r\n}\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Loaders from \"loaders/BVH/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    for (const key in Loaders) {\r\n        if (!(<any>GlobalObject).BABYLON[key]) {\r\n            (<any>GlobalObject).BABYLON[key] = (<any>Loaders)[key];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"loaders/BVH/index\";\r\n","import * as FileLoader from \"loaders/glTF/glTFFileLoader\";\r\nimport * as Validation from \"loaders/glTF/glTFValidation\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    (<any>GlobalObject).BABYLON = (<any>GlobalObject).BABYLON || {};\r\n    for (const key in FileLoader) {\r\n        (<any>GlobalObject).BABYLON[key] = (<any>FileLoader)[key];\r\n    }\r\n    for (const key in Validation) {\r\n        (<any>GlobalObject).BABYLON[key] = (<any>Validation)[key];\r\n    }\r\n}\r\n\r\nexport * from \"loaders/glTF/glTFFileLoader\";\r\nexport * from \"loaders/glTF/glTFValidation\";\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as GLTF1 from \"loaders/glTF/1.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    (<any>GlobalObject).BABYLON = (<any>GlobalObject).BABYLON || {};\r\n    (<any>GlobalObject).BABYLON.GLTF1 = (<any>GlobalObject).BABYLON.GLTF1 || {};\r\n    for (const key in GLTF1) {\r\n        (<any>GlobalObject).BABYLON.GLTF1[key] = (<any>GLTF1)[key];\r\n    }\r\n}\r\n\r\nexport { GLTF1 };\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Extensions from \"loaders/glTF/2.0/Extensions/index\";\r\nimport * as Interfaces from \"loaders/glTF/2.0/glTFLoaderInterfaces\";\r\nimport * as GLTF2 from \"loaders/glTF/2.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    (<any>GlobalObject).BABYLON = (<any>GlobalObject).BABYLON || {};\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    const BABYLON = (<any>GlobalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Loader = BABYLON.GLTF2.Loader || {};\r\n    BABYLON.GLTF2.Loader.Extensions = BABYLON.GLTF2.Loader.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (const key in Extensions) {\r\n        BABYLON.GLTF2.Loader.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Interfaces) {\r\n        BABYLON.GLTF2.Loader[key] = (<any>Interfaces)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport { GLTF2 };\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Loaders from \"loaders/OBJ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    for (const key in Loaders) {\r\n        if (!(<any>GlobalObject).BABYLON[key]) {\r\n            (<any>GlobalObject).BABYLON[key] = (<any>Loaders)[key];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"loaders/OBJ/index\";\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Loaders from \"loaders/STL/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    for (const key in Loaders) {\r\n        if (!(<any>GlobalObject).BABYLON[key]) {\r\n            (<any>GlobalObject).BABYLON[key] = (<any>Loaders)[key];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"loaders/STL/index\";\r\n","import * as loaders from \"@lts/loaders/legacy/legacy\";\r\nexport { loaders };\r\nexport default loaders;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","leafPrototypes","getProto","config","glTF","animationGroups","animations","map","a","_babylonAnimationGroup","registerDataOutput","RichTypeAny","nodes","n","_babylonTransformNode","getClassName","FlowGraphBlock","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","constructor","create","__assign","assign","t","s","i","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","__generator","body","f","y","_","label","sent","trys","ops","g","Iterator","verb","Symbol","iterator","v","op","pop","push","__spreadArray","to","from","pack","ar","l","slice","concat","SuppressedError","material","_material","enableSpecularAntiAliasing","unlit","backFaceCulling","twoSidedLighting","alphaCutOff","useAlphaFromAlbedoTexture","useRadianceOverAlpha","useSpecularOverAlpha","albedoColor","albedoTexture","baseDiffuseRoughness","brdf","baseDiffuseModel","Constants","MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR","baseDiffuseRoughnessTexture","metallic","metallicTexture","useRoughnessFromMetallicTextureGreen","useRoughnessFromMetallicTextureAlpha","useMetallnessFromMetallicTextureBlue","enableSpecularEdgeColor","enableEdgeColor","dielectricSpecularModel","MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR","conductorSpecularModel","MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR","metallicF0Factor","metallicReflectanceTexture","useOnlyMetallicFromMetallicReflectanceTexture","metallicReflectanceColor","reflectanceTexture","roughness","baseMetalnessTexture","indexOfRefraction","emissiveColor","emissiveIntensity","emissiveTexture","ambientTexture","useAmbientInGrayScale","ambientTextureStrength","configureCoat","clearCoat","isEnabled","useRoughnessFromMainTexture","remapF0OnInterfaceChange","intensity","texture","isTintEnabled","Color3","White","tintColor","tintTexture","textureRoughness","subSurface","refractionIntensity","isRefractionEnabled","refractionIntensityTexture","useGltfStyleTextures","tintColorAtDistance","isDispersionEnabled","dispersion","configureTransmission","volumeIndexOfRefraction","useAlbedoToTintRefraction","minimumThickness","maximumThickness","thicknessTexture","useThicknessAsDepth","configureSubsurface","useAlbedoToTintTranslucency","isTranslucencyEnabled","translucencyIntensity","translucencyIntensityTexture","translucencyColorTexture","configureFuzz","sheen","albedoScaling","color","anisotropy","angle","configureGltfStyleAnisotropy","useGltfStyle","iridescence","_dispersion","alpha","bumpTexture","forceIrradianceInFragment","setNormalMapInversions","invertX","invertY","invertNormalMapX","invertNormalMapY","level","OptionalPathExceptionsList","regex","RegExp","_gltf","_infoTree","convert","path","objectTree","infoTree","target","undefined","startsWith","Error","parts","split","shift","includes","ignoreObjectTree","part","isLength","__array__","__ignoreObjectTree__","find","test","__target__","object","info","GetTexture","payload","textureType","textureInObject","babylonMaterial","GetMaterial","_index","_data","fillMode","MATERIAL_TriangleFillMode","GenerateTextureMap","offset","componentsCount","type","get","Vector2","uOffset","vOffset","getTarget","set","x","getPropertyName","rotation","wAng","scale","uScale","vScale","index","objectModelMapping","cameras","orthographic","xmag","camera","_babylonCamera","orthoLeft","orthoRight","ymag","orthoBottom","orthoTop","zfar","maxZ","znear","minZ","perspective","aspectRatio","getEngine","getAspectRatio","isReadOnly","yfov","fov","node","translation","position","copyFrom","rotationQuaternion","scaling","weights","_numMorphTargets","_primitiveBabylonMeshes","morphTargetManager","influence","matrix","Matrix","Compose","globalMatrix","Identity","rootNode","parent","forceUpdate","_isDirty","rootMatrix","computeWorldMatrix","invert","multiplyToRef","extensions","EXT_lights_ies","multiplier","getChildren","child","SpotLight","light","diffuse","KHR_node_visibility","visible","isVisible","forEach","mesh","materials","emissiveFactor","KHR_texture_transform","normalTexture","occlusionTexture","strength","mat","pbrMetallicRoughness","baseColorFactor","Color4","FromColor3","r","baseColorTexture","metallicFactor","roughnessFactor","metallicRoughnessTexture","KHR_materials_anisotropy","anisotropyStrength","anisotropyRotation","anisotropyTexture","KHR_materials_clearcoat","clearcoatFactor","clearcoatRoughnessFactor","clearcoatTexture","clearcoatNormalTexture","clearcoatRoughnessTexture","KHR_materials_dispersion","KHR_materials_emissive_strength","emissiveStrength","KHR_materials_ior","ior","KHR_materials_iridescence","iridescenceFactor","iridescenceIor","iridescenceTexture","iridescenceThicknessMaximum","iridescenceThicknessMinimum","iridescenceThicknessTexture","KHR_materials_sheen","sheenColorFactor","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","KHR_materials_specular","specularFactor","specularColorFactor","specularTexture","specularColorTexture","KHR_materials_transmission","transmissionFactor","transmissionTexture","KHR_materials_diffuse_transmission","diffuseTransmissionFactor","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","diffuseTransmissionColorTexture","KHR_materials_volume","attenuationColor","attenuationDistance","thicknessFactor","KHR_lights_punctual","lights","_babylonLight","_lights","_light","range","spot","innerConeAngle","innerAngle","outerConeAngle","EXT_lights_image_based","_babylonTexture","Quaternion","FromRotationMatrix","getReflectionTextureMatrix","getScene","useRightHandedSystem","Inverse","FromQuaternionToRef","animation","meshes","primitives","_instanceData","babylonSourceMesh","GetPathToObjectConverter","gltf","GLTFPathToObjectConverter","GetMappingForKey","key","keyParts","replace","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor","getVector3","_target","source","Vector3","FromArray","scaleInPlace","getQuaternion","getWeights","name","getValue","getStride","_buildAnimation","fps","keys","babylonAnimation","Animation","setKeys","buildAnimations","babylonAnimations","babylonAnimatable","AnimationPropertyInfo","targetIndex","frame","inTangent","outTangent","babylonMesh","morphTarget","babylonAnimationClone","clone","TransformNodeAnimationPropertyInfo","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_QUATERNION","WeightAnimationPropertyInfo","ANIMATIONTYPE_FLOAT","_useAlphaFromBaseColorTexture","baseColor","baseMetalness","_useRoughnessFromMetallicTextureGreen","_useMetallicFromMetallicTextureBlue","_enableEdgeColor","specularWeight","specularWeightTexture","_useSpecularWeightFromSpecularColorTexture","_useSpecularWeightFromAlpha","specularColor","specularRoughness","specularRoughnessTexture","specularIor","emissionColor","emissionLuminance","emissionColorTexture","ambientOcclusionTexture","coatWeight","coatWeightTexture","coatColor","coatColorTexture","coatRoughness","coatRoughnessTexture","coatIor","coatDarkening","coatDarkeningTexture","coatRoughnessAnisotropy","geometryCoatTangentAngle","geometryCoatTangentTexture","_useCoatRoughnessAnisotropyFromTangentTexture","specularRoughnessAnisotropy","geometryTangentAngle","geometryTangentTexture","_useSpecularRoughnessAnisotropyFromTangentTexture","_useGltfStyleAnisotropy","thinFilmWeight","thinFilmIor","thinFilmThicknessMin","thinFilmThickness","thinFilmWeightTexture","thinFilmThicknessTexture","_useThinFilmThicknessFromTextureGreen","geometryOpacity","geometryNormalTexture","geometryCoatNormalTexture","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","getter","__esModule","getPrototypeOf","obj","mode","ns","def","indexOf","getOwnPropertyNames","definition","o","defineProperty","enumerable","globalThis","Function","window","prop","toStringTag","_XPosition","_YPosition","_ZPosition","_XRotation","_YRotation","_ZRotation","_HierarchyNode","_MotionNode","skeleton","loopMode","ANIMATIONLOOPMODE_CYCLE","list","CreateBVHNode","numFrames","frameRate","channels","children","frames","ConvertNode","context","z","Translation","BoneOffset","bone","Bone","hasPosition","some","c","hasRotation","posAnim","rotAnim","posKeys","rotKeys","CreateAnimations","getKeys","ReadFrameData","data","frameNumber","tokenIndex","keyframe","combinedRotation","channel","parsedValue","parseFloat","trim","endsWith","Tools","ToRadians","rotationMatrix","RotationX","RotationY","RotationZ","multiply","FromRotationMatrixToRef","ReadNode","lines","firstLine","tokens","toUpperCase","tokensSplit","isNaN","numChannels","parseInt","splice","line","ReadBvh","text","scene","assetContainer","loadingOptions","_blockEntityCollection","Skeleton","_parentContainer","LoaderContext","nodeLine","motionLine","framesLine","framesTokens","frameTimeLine","frameTimeTokens","frameTime","frameLine","returnToRest","BVHFileLoaderMetadata","isBinary","_loadingOptions","BVHFileLoader","_DefaultLoadingOptions","createPlugin","options","canDirectLoad","isBvhHeader","isNotBvhHeader","importMeshAsync","_meshesNames","particleSystems","skeletons","transformNodes","geometries","spriteManagers","loadAsync","loadAssetContainerAsync","AssetContainer","ValidateAsync","rootUrl","fileName","getExternalResource","externalResourceFunction","uri","ArrayBuffer","isView","GLTFValidator","validateBytes","validateString","WorkerFunc","pendingExternalResources","onmessage","message","id","importScripts","url","postMessage","reason","RegisterSceneLoaderPlugin","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","Worker","workerContent","workerBlobUrl","URL","createObjectURL","Blob","worker","onError","error","removeEventListener","onMessage","buffer","terminate","addEventListener","GetBabylonScriptURL","Configuration","slicedData","_LoadScriptPromise","LoadBabylonScriptAsync","_DefaultCdnUrl","GLTFMagicBase64Encoded","GLTFFileLoaderMetadata","mimeType","readAsync","arrayBuffer","byteOffset","byteLength","Uint8Array","EComponentType","EShaderType","EParameterType","ETextureWrapMode","ETextureFilterType","ETextureFormat","ECullingType","EBlendingFunction","alwaysComputeBoundingBox","alwaysComputeSkeletonRootNode","animationStartMode","FIRST","compileMaterials","compileShadowGenerators","coordinateSystemMode","AUTO","createInstances","loadAllMaterials","loadMorphTargets","loadNodeAnimations","loadOnlyMaterials","loadSkins","skipMaterials","targetFps","transparencyAsCoverage","useClipPlane","useGltfTextureNames","useRangeRequests","useSRGBBuffers","validate","useOpenPBR","GLTFLoaderDefaultOptions","GLTFLoaderBaseOptions","onParsedObservable","Observable","onMeshLoadedObservable","onSkinLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","onValidatedObservable","_loader","_state","_requests","onLoaderStateChangedObservable","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","callback","_onParsedObserver","remove","add","_onMeshLoadedObserver","_onSkinLoadedObserver","skinnedNode","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","_onCompleteObserver","_onErrorObserver","_onDisposeObserver","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","dispose","abort","_progressCallback","preprocessUrlAsync","clear","notifyObservers","loadFile","fileOrUrl","onSuccess","onProgress","useArrayBuffer","_loadBinary","GetFilename","Logger","Warn","dataBuffer","_loadFile","webRequest","setRequestHeader","_unpackBinaryAsync","DataReader","loaderData","_validate","json","_parseJson","arrayBufferView","RangeError","readViewAsync","meshesNames","_getLoader","container","textures","morphTargetManagers","directLoad","DecodeBase64UrlToBinary","GLTFFileLoader","whenCompleteAsync","addOnce","_setState","state","onOpened","request","event","_onProgress","_lengthComputable","_total","_loaded","lengthComputable","loaded","total","GLTFValidation","_loadFileAsync","asset","version","minVersion","_parseVersion","_compareVersion","major","minor","createLoader","_CreateGLTF1Loader","_CreateGLTF2Loader","parsed","JSON","parse","dataReader","magic","readUint32","RuntimeError","ErrorCodes","GLTFLoaderUnexpectedMagicError","loggingEnabled","unpacked","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","readString","bin","ChunkFormat","chunkLength","skipBytes","match","_logOpen","_logClose","spaces","_logSpaces","substring","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","IncrementalLoading","HomogeneousCoordinates","extensionOptions","capturePerformanceCounters","customRootNode","onCameraLoaded","onMaterialLoaded","onMeshLoaded","onParsed","onSkinLoaded","onTextureLoaded","onValidated","ETokenType","SetMatrix","parameter","uniformName","shaderMaterial","semantic","getWorldMatrix","getProjectionMatrix","getViewMatrix","Transpose","getTransformMatrix","FLOAT_MAT2","setMatrix2x2","GetAsMatrix2x2","FLOAT_MAT3","setMatrix3x3","GetAsMatrix3x3","FLOAT_MAT4","setMatrix","SetUniform","uniform","FLOAT","setFloat","FLOAT_VEC2","setVector2","FLOAT_VEC3","setVector3","FLOAT_VEC4","setVector4","Vector4","GetWrapMode","CLAMP_TO_EDGE","Texture","CLAMP_ADDRESSMODE","MIRRORED_REPEAT","MIRROR_ADDRESSMODE","REPEAT","WRAP_ADDRESSMODE","GetByteStrideFromType","GetTextureFilterMode","LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","TRILINEAR_SAMPLINGMODE","NEAREST","NEAREST_MIPMAP_NEAREST","NEAREST_SAMPLINGMODE","BILINEAR_SAMPLINGMODE","GetBufferFromBufferView","gltfRuntime","bufferView","componentType","loadedBufferView","loadedBufferViews","BYTE","Int8Array","UNSIGNED_BYTE","SHORT","Int16Array","UNSIGNED_SHORT","Uint16Array","Float32Array","GetBufferFromAccessor","bufferViews","count","GLTFUtils","DecodeBufferToText","view","fromCharCode","GetDefaultMaterial","_DefaultMaterial","Effect","ShadersStore","join","attributes","uniforms","samplers","needAlphaBlending","ShaderMaterial","vertex","fragment","setColor4","toParse","_pos","currentToken","UNKNOWN","currentIdentifier","currentString","isLetterOrDigitPattern","_toParse","_maxPos","getNextToken","isEnd","END_OF_INPUT","read","IDENTIFIER","peek","forward","glTFTransforms","BabylonTransforms","glTFAnimationPaths","BabylonAnimationPaths","ParseObject","parsedObjects","runtimeProperty","parsedObject","NormalizeUVs","GetAttribute","attributeParameter","Number","ConfigureBoneTransformation","GetParentBone","skins","jointName","newSkeleton","bones","nde","GetNodeToRoot","nodesToRoot","nodeToRoot","j","GetJointNode","NodeIsInJoints","jointNames","ImportMesh","newMesh","Mesh","babylonNode","subMaterials","vertexData","verticesStarts","verticesCounts","indexStarts","indexCounts","meshIndex","meshId","tempVertexData","VertexData","primitive","accessors","normals","positions","uvKind","VertexBuffer","UVKind","uvs","matricesIndices","matricesWeights","colors","indices","Int32Array","merge","getMaterialById","MultiMaterial","StandardMaterial","Geometry","subMeshes","SubMesh","AddToMesh","ConfigureNode","newNode","ImportNode","lastNode","importOnlyMeshes","skin","importMeshesNames","getLastSkeletonById","babylonSkeleton","nodesToRootToAdd","k","_parent","GetNodesToRoot","jointNode","existingBone","getBoneById","foundBone","parentBone","joint","prepare","ImportSkeleton","orthoCamera","FreeCamera","Zero","Camera","ORTHOGRAPHIC_CAMERA","attachControl","perspectiveCamera","persCamera","getRenderWidth","getRenderHeight","ambienLight","hemiLight","HemisphericLight","directionalLight","dirLight","DirectionalLight","pointLight","ptLight","PointLight","spotLight","spLight","fallOfAngle","fallOffExponent","exponent","dummy","decompose","ConfigureNodeFromMatrix","updateCache","TraverseNodes","meshIncluded","PostLoad","currentScene","thing","scenes","anim","lastAnimation","sampler","inputData","outputData","parameters","input","output","bufferInput","bufferOutput","targetId","targetNode","getNodeById","getNodeByName","isBone","targetPath","targetPathIndex","animationType","ANIMATIONTYPE_MATRIX","arrayOffset","modifyKey","getBaseMatrix","stopAnimation","beginAnimation","LoadAnimations","MAX_VALUE","ParseShaderUniforms","tokenizer","technique","unTreatedUniforms","unif","uniformParameter","transformIndex","ImportMaterials","GLTFLoaderExtension","LoadMaterialAsync","CreateRuntime","parsedData","buffers","images","shaders","programs","techniques","extensionsUsed","buffersCount","shaderscount","loadedBufferCount","loadedShaderCount","dummyNodes","parsedBuffers","buf","parsedBuffer","ParseBuffers","parsedShaders","sha","parsedShader","ParseShaders","LoadBufferAsync","IsBase64","setTimeout","DecodeBase64","LoadFile","status","statusText","LoadTextureBufferAsync","babylonTexture","CreateTextureAsync","createMipMaps","minFilter","NEAREST_MIPMAP_LINEAR","samplingMode","blob","blobURL","revokeBlobURL","revokeObjectURL","newTexture","wrapS","wrapU","wrapT","wrapV","LoadShaderStringAsync","shader","shaderString","atob","defaultMaterial","diffuseColor","sideOrientation","Material","CounterClockWiseSideOrientation","program","states","vertexShader","pixelShader","fragmentShader","newVertexShader","newPixelShader","vertexTokenizer","Tokenizer","pixelTokenizer","SAMPLER_2D","attr","attribute","foundAttribute","shaderPath","enable","effect","OnShaderCompileError","onCompiled","materialValues","values","techniqueUniforms","onLoadTexture","setTexture","LoadTextureAsync","PrepareShaderMaterialUniforms","onBind","getEffect","OnBindShaderMaterial","OnShaderCompileSuccess","functions","cullFace","BACK","blendFunc","blendFuncSeparate","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","ONE","alphaMode","ALPHA_COMBINE","ZERO","ALPHA_ONEONE","ALPHA_ADD","ONE_MINUS_SRC_COLOR","ALPHA_SUBTRACT","DST_COLOR","ALPHA_MULTIPLY","ALPHA_MAXIMIZED","RegisterExtension","extension","GLTFLoader","Extensions","_importMeshAsync","LoadRuntimeAsync","_createNodes","AbstractMesh","skl","_loadBuffersAsync","_loadShadersAsync","_loadAsync","LoadRuntimeExtensionsAsync","onload","hasShaders","processShader","VERTEX","bind","onLoad","hasBuffers","processBuffer","_name","loadRuntimeAsync","loadRuntimeExtensionsAsync","loadBufferAsync","loadTextureBufferAsync","createTextureAsync","loadShaderStringAsync","loadMaterialAsync","_ApplyExtensions","loaderExtension","GLTFLoaderBase","_LoadTextureBufferAsync","_CreateTextureAsync","func","defaultFunc","extensionName","_bin","sourceExt","binaryExtensionShader","shaderBytes","GLTFBinaryExtension","ambientLight","ambient","point","directional","fallOffAngle","Math","PI","standardMaterial","disableLighting","doubleSided","transparency","specularPower","shininess","_loadTexture","ambientColor","emission","specular","propertyPath","GLTFMaterialsCommonExtension","RegisteredGLTFExtensions","Map","registeredGLTFExtensions","registerGLTFExtension","isGLTFExtension","unregisterGLTFExtension","delete","LazyAnimationGroupModulePromise","Lazy","LazyLoaderAnimationModulePromise","Get","array","TryGet","Assign","LoadBoundingInfoFromPositionAccessor","min","max","minArray","maxArray","minVector","TmpVectors","copyFromFloats","maxVector","normalized","divider","oneOverDivider","BoundingInfo","_completePromises","_assetContainer","_babylonLights","_disableInstancedMesh","_allMaterialsDirtyRequired","_skipStartAnimationStep","_extensions","_disposed","_rootUrl","_fileName","_uniqueRootUrl","_rootBabylonMesh","_defaultBabylonMaterialData","_postSceneLoadActions","_materialAdapterCache","WeakMap","_pbrMaterialImpl","UnregisterExtension","_babylonScene","_getOrCreateMaterialAdapter","adapter","adapterClass","_loadData","_getMeshes","_getSkeletons","_getAnimationGroups","_getTransformNodes","_getGeometries","resultFunc","Date","now","_loadExtensionsAsync","isExtensionUsed","materialClass","OpenPBRMaterial","OpenPBRMaterialLoadingAdapter","PBRMaterial","PBRMaterialLoadingAdapter","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadSceneAsync","ArrayItem","m","babylonDrawMode","TriangleFillMode","_loadMaterialAsync","_forceBlockMaterialDirtyMechanism","_compileMaterialsAsync","_compileShadowGeneratorsAsync","resultPromise","all","setEnabled","maxSimultaneousLights","_extensionsOnReady","_startAnimations","SetImmediate","catch","_setupData","binaryBuffer","nodeParents","_createRootNode","parentIndex","extensionPromises","registeredExtension","enabled","sort","order","extensionsRequired","rootMesh","_LoadTransform","FORCE_RIGHT_HANDED","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","action","_loadAnimationsAsync","logClose","_forEachPrimitive","geometry","_babylonTransformNodeForSkin","NONE","babylonAnimationGroups","start","ALL","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","loadCameraAsync","babylonCamera","childNode","childBabylonMesh","hasMesh","hasSkin","nodeName","transformNode","TransformNode","_loadMeshAsync","babylonTransformNodeForSkin","metadata","deepMerge","_loadSkinAsync","parentNode","asMesh","isAnInstance","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","babylonAbstractMesh","promise","shouldInstance","targets","createInstance","ClockWiseSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","_GetDrawMode","_createDefaultMaterial","_extensionsLoadVertexDataAsync","isUnIndexed","_loadIndicesAccessorAsync","setIndices","loadAttribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","PositionKind","babylonBoundingInfo","_boundingInfo","setVerticesBuffer","MatricesIndicesExtraKind","numBoneInfluencers","NormalKind","TangentKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesWeightsExtraKind","ColorKind","hasVertexAlpha","targetNames","extras","MorphTargetManager","areUpdatesFrozen","weight","addTarget","MorphTarget","numTargets","babylonMorphTarget","_loadMorphTargetVertexDataAsync","setData","getVertexBuffer","_loadFloatAccessorAsync","setPositions","setNormals","tangents","dataIndex","setTangents","setUVs","setUV2s","componentSize","getSize","pixid","floor","setColors","One","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","_findSkeletonRootNode","joints","skeletonNode","isParent","babylonBones","_loadBone","paths","unshift","_isJoint","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","baseMatrix","FromArrayToRef","invertToRef","babylonParentBone","getParent","getAbsoluteInverseBindMatrix","updateMatrix","_updateAbsoluteBindMatrices","_extensionsLoadCameraAsync","setTarget","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","AnimationGroup","babylonAnimationGroup","_loadAnimationChannelAsync","babylonTarget","addTargetedAnimation","normalize","animationContext","_extensionsLoadAnimationChannelAsync","channelTargetPath","pathIsWeights","properties","targetInfo","_loadAnimationChannelFromTargetInfoAsync","invfps","_loadAnimationSamplerAsync","numAnimations","propertyInfo","stride","outputOffset","inputAccessor","outputAccessor","_extensionsLoadBufferAsync","loadUriAsync","loadBufferViewAsync","_extensionsLoadBufferViewAsync","_loadAccessorAsync","numComponents","_GetNumComponents","byteStride","GetTypeByteLength","ForEach","_GetTypedArray","sparse","typedArray","indicesBufferView","valuesBufferView","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","engine","Buffer","_babylonVertexBuffer","babylonBuffer","_loadMaterialMetallicRoughnessPropertiesAsync","loadTextureInfoAsync","nonColorData","useMetallicFromMetallicTextureBlue","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","transparencyMode","MATERIAL_OPAQUE","transparencyAsAlphaCoverage","extensionMaterial","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","loadMaterialAlphaProperties","aoTexture","emissionTexture","aoStrength","ambientOcclusionTextureStrength","MATERIAL_ALPHATEST","alphaCutoff","hasAlpha","MATERIAL_ALPHABLEND","useAlphaFromBaseColorTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","coordinatesIndex","_extensionsLoadTextureAsync","DefaultSampler","image","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","Deferred","textureCreationOptions","noMipmap","noMipMaps","exception","GetMimeType","loaderOptions","loadImageAsync","dataUrl","updateURL","internalTexture","getInternalTexture","_GetTextureSamplingMode","_GetTextureWrapMode","property","_extensionsLoadUriAsync","_ValidateUri","IsBase64DataUrl","log","LoadFileError","babylonObject","pointer","_internalMetadata","pointers","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","GetTypedArrayConstructor","componentTypeLength","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","forceCompilationAsync","useInstances","clipPlane","getShadowGenerator","_forEachExtensions","_applyExtensions","functionName","actionAsync","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","LoadExtraAsync","extra","startPerformanceCounter","endPerformanceCounter","NAME","loader","extensionContext","babylonLight","babylonScene","shape","width","height","RectAreaLight","size","radius","falloffType","Light","FALLOFF_GLTF","lightParentNode","RotationAxis","Up","EXT_lights_area","_loadLightAsync","environmentTexture","specularImages","mipmap","faces","face","specularImageContext","RawCubeTexture","specularImageSize","irradianceCoefficients","sphericalHarmonics","SphericalHarmonics","convertIrradianceToLambertianRadiance","sphericalPolynomial","SphericalPolynomial","FromHarmonics","lodGenerationScale","log2","updateRGBDAsync","instanceCount","translationBuffer","rotationBuffer","scaleBuffer","colorBuffer","matrices","ComposeToRef","copyToArray","thinInstanceSetBuffer","EXT_mesh_gpu_instancing","bufferViewMeshopt","_meshOptData","MeshoptCompression","Default","decodeGltfBufferAsync","filter","EXT_meshopt_compression","EXT_texture_webp","EXT_texture_avif","babylonSpotLight","Backward","bufferData","iesProfileTexture","useNormalizedFlagFromAccessor","DracoDecoder","DefaultAvailable","dracoDecoder","uniqueId","_dracoBabylonGeometry","positionAccessor","_decodeMeshToGeometryForGltfAsync","KHR_draco_mesh_compression","babylonDirectionalLight","setAll","KHR_lights","_loadSpecularGlossinessPropertiesAsync","diffuseFactor","reflectivityColor","microSurface","glossinessFactor","diffuseTexture","specularGlossinessTexture","reflectivityTexture","useMicroSurfaceFromReflectivityMapAlpha","KHR_materials_pbrSpecularGlossiness","_loadUnlitPropertiesAsync","isUnlit","KHR_materials_unlit","_loadClearCoatPropertiesAsync","KHR_materials_clearcoat_darkening","darkeningExtension","_loadClearCoatDarkeningPropertiesAsync","KHR_materials_clearcoat_ior","iorExtension","clearcoatIor","KHR_materials_clearcoat_anisotropy","anisotropyExtension","_loadClearCoatAnisotropyPropertiesAsync","KHR_materials_clearcoat_color","colorExtension","_loadClearCoatColorPropertiesAsync","geometryCoatNormalTextureScale","clearcoatDarkeningFactor","clearcoatDarkeningTexture","colorFactor","clearcoatColorFactor","fromArray","clearcoatColorTexture","clearcoatAnisotropyWeight","clearcoatAnisotropyStrength","clearcoatAnisotropyAngle","clearcoatAnisotropyRotation","EXT_materials_anisotropy_openpbr","openPbrAnisotropyEnabled","clearcoatAnisotropyTexture","_loadIridescencePropertiesAsync","iridescenceIOR","thinFilmThicknessMinimum","thinFilmThicknessMaximum","_loadAnisotropyPropertiesAsync","anisotropyWeight","anisotropyAngle","_loadEmissiveProperties","_loadSheenPropertiesAsync","sheenColor","Black","sheenRoughness","fuzzWeight","fuzzColor","fuzzRoughness","fuzzColorTexture","fuzzRoughnessTexture","_loadSpecularPropertiesAsync","EXT_materials_specular_edge_color","specularEdgeColorEnabled","_loadIorPropertiesAsync","_DEFAULT_IOR","GetAvailableVariants","extensionMetadata","_GetExtensionMetadata","variants","getAvailableVariants","KHR_materials_variants","SelectVariant","variantName","select","entries","entry","lastSelected","selectVariant","Reset","original","reset","GetLastSelectedVariant","getLastSelectedVariant","_variants","rootBabylonMesh","defaultVariant","onLoaded","selectedVariant","lastSelectedVariant","isArray","mappingIndex","mapping","mappings","mappingVariantIndex","variantIndex","variant","onClonedObservable","newOne","newRoot","variantEntry","_opaqueRenderTarget","_opaqueMeshesCache","_transparentMeshesCache","_materialObservers","_options","TransmissionHelper","_GetDefaultOptions","_scene","_transmissionHelper","_parseScene","_setupRenderTargets","renderSize","samples","lodGenerationOffset","renderTargetTextureType","TEXTURETYPE_HALF_FLOAT","generateMipmaps","updateOptions","newValues","newOptions","oldOptions","getOpaqueTarget","_shouldRenderAsTransmission","_addMesh","onMaterialChangedObservable","_onMeshMaterialChanged","refractionTexture","_removeMesh","idx","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","_isRenderTargetValid","saveSceneEnvIntensity","RenderTargetTexture","ignoreCameraViewport","renderList","clearColor","gammaSpace","renderSprites","renderParticles","disableImageProcessing","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","toLinearSpaceToRef","useExactSrgbConversions","onAfterUnbindObservable","_loadTransparentPropertiesAsync","transmissionWeight","texturePromise","transmissionWeightTexture","_loadTranslucentPropertiesAsync","subsurfaceWeight","subsurfaceColor","subsurfaceWeightTexture","subsurfaceColorTexture","_loadVolumePropertiesAsync","transmissionDepth","transmissionColor","volumeThickness","volumeThicknessTexture","_loadDispersionPropertiesAsync","transmissionDispersionAbbeNumber","_loadDiffuseRoughnessPropertiesAsync","diffuseRoughnessFactor","diffuseRoughnessTexture","KHR_materials_diffuse_roughness","KHR_mesh_quantization","useRGBAIfASTCBC7NotAvailableWhenUASTC","KHR_texture_basisu","uRotationCenter","vRotationCenter","xmpGltf","KHR_xmp_json_ld","xmpNode","packet","packets","xmp","getColor3","getFloat","getMinusFloat","getNextFloat","getFloatBy2","getTextureTransformTree","textureName","MaterialAnimationPropertyInfo","CameraAnimationPropertyInfo","ANIMATIONTYPE_COLOR3","baseColorTextureInterpolation","metallicRoughnessTextureInterpolation","normalTextureInterpolation","occlusionTextureInterpolation","emissiveTextureInterpolation","anisotropyTextureInterpolation","clearcoatTextureInterpolation","clearcoatNormalTextureInterpolation","clearcoatRoughnessTextureInterpolation","iridescenceTextureInterpolation","iridescenceThicknessTextureInterpolation","sheenTextureInterpolation","sheenRoughnessTextureInterpolation","specularTextureInterpolation","specularColorTextureInterpolation","transmissionTextureInterpolation","thicknessTextureInterpolation","diffuseTransmissionTextureInterpolation","diffuseTransmissionColorTextureInterpolation","LightAnimationPropertyInfo","MeshAnimationPropertyInfo","_pathToObjectConverter","KHR_animation_pointer","_clips","_emitters","clips","emitters","emitterIndex","emitter","refDistance","maxDistance","rolloffFactor","distanceModel","outerAngle","_loadEmitterAsync","_babylonSounds","sound","attachToMesh","setLocalDirectionToMesh","Forward","setDirectionalCone","ToDegrees","events","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","_babylonData","clipPromises","loop","autoplay","volume","clipContext","objectURL","Sound","weightedSound","WeightedSound","directionalConeInnerAngle","directionalConeOuterAngle","_getEventAction","time","startOffset","currentFrame","frameOffset","play","stop","pause","babylonAnimationEvent","AnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","MSFT_audio_emitter","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_bufferLODs","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","indexLOD","_loadBufferLOD","nodeLODs","_getLODs","ids","nodeLOD","previousNodeLOD","_disposeTransformNode","firstPromise","materialLODs","materialLOD","previousDataLOD","_disposeMaterials","previousIndexLOD","bufferLODs","end","bufferLOD","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","every","babylonTextures","getActiveTextures","hasTexture","MSFT_lod","extraContext","forceDepthWrite","separateCullingPass","MSFT_minecraftMesh","getMappingForFullOperationName","fullOperationName","getMappingForDeclaration","declaration","returnNoOpIfNotAvailable","gltfExtensionsToFlowGraphMapping","gltfToFlowGraphMapping","inputs","flows","inputValueSockets","outputValueSockets","blocks","outputs","addNewInteractivityFlowGraphMapping","MSFT_sRGBFactors","BABYLON","out","timeSinceLastTick","gltfType","extraProcessor","gltfBlock","_mapping","parser","serializedObjects","configuration","eventId","arrays","serializedObject","eventData","validation","interactivityGraph","valid","eventConfiguration","getSimpleInputMapping","roundHalfAwayFromZero","_gltfBlock","_declaration","_parser","useMatrixPerComponent","preventIntegerFloatArithmetic","types","flowGraphType","ValidateTypes","condition","dataInputs","_connectionValues","axis","inputIsColumnMajor","h","socketIn","valueType","socketInA","socketInB","_arrays","outputSignalCount","signalOutputs","true","false","cases","inOptions","defaultValue","selection","default","caseValue","toString","uniqueCases","Set","loopBody","initialIndex","startIndex","endIndex","incrementIndexWhenLoopDone","currentCount","isRandom","isLoop","inputFlows","err","variable","isVariable","dataTransformer","getVariableName","variables","useSlerp","duration","p1","toBlock","p2","in","interBlockConnectors","inputBlockIndex","outputBlockIndex","serializedValueInterpolation","propertyIndex","staticVariables","getAnimationTypeByFlowGraphType","serializedGetVariable","className","outputValue","speed","startTime","_animationTargetFps","endTime","_context","globalGLTF","stopTime","treatCasesAsIntegers","inferType","reduce","acc","getAllSupportedNativeNodeTypes","gltfTypeToBabylonType","float","elementType","bool","float2","float3","float4","float4x4","float2x2","float3x3","int","_interactivityGraph","_types","_mappings","_staticVariables","_events","_internalEventsCounter","_nodes","_parseTypes","_parseDeclarations","_parseVariables","_parseEvents","_parseNodes","signature","declarations","flowGraphMapping","_parseVariable","dataTransform","NaN","fill","converted","eventValue","validationResult","blockType","block","_getEmptyBlock","_parseNodeConfiguration","RandomGUID","dataOutputs","signalInputs","nodeMapping","configMapping","configKey","_parseNodeConnections","gltfNode","flowGraphBlocks","outputMapper","flowsFromGLTF","flowsKeys","flowKey","flow","flowMapping","socketOutName","socketOut","_createNewSocketConnection","inputNodeId","nodeIn","inputMapper","flowInMapping","socket","arrayMapping","nodeInSocketName","inputBlock","connectedPointIds","valuesFromGLTF","valuesKeys","valueKey","valueMapping","socketInName","convertedValue","nodeOutId","nodeOutSocketName","nodeOut","outBlock","connector","_connectFlowGraphNodes","isOutput","_connectionType","serializedInput","serializedOutput","inputArray","outputArray","inputConnection","outputConnection","serializeToFlowGraph","_userVariables","rightHanded","allBlocks","val","executionContexts","_pathConverter","_AddInteractivityObjectModel","interactivityDefinition","KHR_interactivity","coordinator","FlowGraphCoordinator","dispatchEventsSynchronously","graphs","graph","InteractivityGraphToFlowGraphParser","ParseFlowGraphAsync","pathConverter","activeCamera","quat","w","pos","getTranslation","isPlaying","getCurrentFrame","addToBlockFactory","FlowGraphGLTFDataProvider","tn","inheritVisibility","stopPropagation","nodeIndex","selectedNodeIndex","controllerIndex","selectionPoint","selectionRayOrigin","variableName","isPickable","KHR_node_selectability","selectable","MeshPointerOverPrefix","hoverNodeIndex","MeshPointerOutPrefix","pointerOverDisableMeshTesting","KHR_node_hoverability","hoverable","_assignExtras","gltfProp","ExtrasAsMetadata","parseMTL","delimiterPattern","charAt","toLowerCase","MTLFileLoader","_GetTexture","bumpMultiplierIndex","bumpMultiplier","opacityTexture","lastDelimiter","lastIndexOf","INVERT_TEXTURE_Y","materialToUse","babylonMeshesArray","_positions","_normals","_uvs","_colors","_extColors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","_hasLineData","_materialToUse","_babylonMeshesArray","_isInArray","arr","_isInArrayUV","uv","_setData","indiceUvsFromObj","indiceNormalFromObj","optimizeWithUV","indicePositionFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_unwrapData","_handednessSign","_getTriangles","faceIndex","_pushTriangle","_getColor","importVertexColors","_setDataForCurrentFaceWithPattern1","_setDataForCurrentFaceWithPattern2","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","useLegacyBehavior","reverse","hasLines","_optimizeNormals","getVerticesData","mapVertices","lst","normal","v0Idx","vIdx","setVerticesData","_IsLineElement","_IsObjectElement","_IsGroupElement","_GetZbrushMRGB","notParse","regArray","regIndex","onFileToLoadFound","linesOBJ","lineLines","currentGroup","SolidParser","lineValues","flat","VertexPattern","NormalPattern","exec","UVPattern","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","LinePattern1","LinePattern2","element","LinePattern3","GroupDescriptor","ObjectDescriptor","objMesh","materialName","isObject","UseMtlDescriptor","MtlLibGroupDescriptor","SmoothDescriptor","newMaterial","RandomId","pointsCloud","directMaterial","_babylonMesh","computeNormals","ComputeNormals","optimizeNormals","OBJFileLoader","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","SKIP_MATERIALS","USE_LEGACY_BEHAVIOR","_loadMTL","onFailure","pathOfFile","_parseSolidAsync","ex","fileToLoad","materialsFromMTLFile","mtlPromises","dataLoaded","_indices","getTotalIndices","isLine","Boolean","getBindedMeshes","wireframe","STLFileLoaderMetadata","solidPattern","facetsPattern","normalPattern","vertexPattern","importMesh","matches","_isBinary","_parseBinary","TextDecoder","decode","meshName","meshNameFromEnd","_parseASCII","load","loadAssetContainer","reader","DataView","getUint32","ascii","off","getUint8","Uint32Array","indicesCount","normalX","getFloat32","normalY","normalZ","vertexstart","STLFileLoader","DO_NOT_ALTER_FILE_COORDINATES","solidData","facet","normalMatches","lastIndex","vertexMatch","SPLATFileLoaderMetadata","SH_C0","LoadWebpImageData","rootUrlOrData","filename","objectUrl","createCanvasImage","canvas","createCanvas","ctx","getContext","drawImage","imageData","getImageData","bits","src","onerror","crossOrigin","ParseSogDatas","imageDataArrays","splatCount","means","rgba","Uint8ClampedArray","rot","unlog","sign","exp","abs","meansl","meansu","mins","maxs","meansMin","meansMax","meansup","meanslow","q","Scalar","Lerp","scales","codebook","sc","sce","lsc","lsce","sh0","component","round","colorsMin","colorsMax","colort","csh","toComp","SQRT2","quatArray","quatsr","quatsg","quatsb","quatsa","sqrt","shN","coeffCounts","coeffs","bands","shCentroids","shLabelsData","shCentroidsWidth","shComponentCount","textureCount","ceil","getCaps","maxTextureSize","textureIndex","u","shIndexWrite","shArray","byteIndexInTexture","offsetPerSplat","shValue","shMin","shMax","hasVertexColors","sh","ParseSogMeta","dataOrFiles","metaFile","files","urls","quats","has","SPLATFileLoader","_parseAsync","_BuildPointCloud","pointcloud","uBuffer","fBuffer","vertexCount","addPoints","particle","_BuildMesh","parsedPLY","_unzipWithFFlateAsync","fflate","LoadScriptAsync","deflateURL","unzipSync","unzipped","content","makeGSFromParsedSOG","parsedSOG","gaussianSplatting","GaussianSplattingMesh","keepInRam","viewDirectionFactor","updateData","u8","readableStream","ReadableStream","controller","enqueue","close","decompressionStream","DecompressionStream","decompressedStream","pipeThrough","Response","ubuf","ubufu32","shDegree","fractionalBits","flags","reserved","positionScale","int32View","uint8View","read24bComponent","coordinateSign","quaternionOffset","flipY","Clamp","sqrt12","SQRT1_2","comp","iLargest","remaining","sumSquares","mag","negbit","square","shuffle","nx","ny","nz","shIndexRead","trainedWithAntialiasing","ParseSpz","parsedSPZ","gsMaterial","kernelSize","compensation","_ConvertPLYToSplat","compressed","rawSplat","PointsCloudSystem","buildMeshAsync","header","headerEndIndex","faceElement","faceCount","chunkElement","chunkCount","ElementMode","rowVertexOffset","rowChunkOffset","offsets","double","uint","short","ushort","uchar","chunkMode","vertexProperties","chunkProperties","rowVertexLength","rowChunkLength","ConvertPLYWithSHToSplatAsync","splatsData","dataView","headerEnd","faceVertexCount","vertexIndex","propertyCount","propertyColorCount","splatProperties","splatColorProperties","hasMandatoryProperties","currentMode","GlobalObject","GLTF1","GLTF2","Loader"],"sourceRoot":""}