{"version":3,"file":"babylon.objFileLoader.min.js","mappings":"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","sources":["webpack://LOADERS/webpack/universalModuleDefinition","webpack://LOADERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://LOADERS/webpack/bootstrap","webpack://LOADERS/webpack/runtime/define property getters","webpack://LOADERS/webpack/runtime/global","webpack://LOADERS/webpack/runtime/hasOwnProperty shorthand","webpack://LOADERS/webpack/runtime/make namespace object","webpack://LOADERS/../../../dev/loaders/src/OBJ/mtlFileLoader.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/solidParser.ts","webpack://LOADERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.metadata.ts","webpack://LOADERS/../../../dev/loaders/src/OBJ/objFileLoader.ts","webpack://LOADERS/../../../lts/loaders/src/legacy/legacy-objFileLoader.ts","webpack://LOADERS/./src/objFileLoader.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-loaders\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-loaders\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"LOADERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\n/**\r\n * Class reading and parsing the MTL file bundled with the obj file.\r\n */\r\nexport class MTLFileLoader {\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static INVERT_TEXTURE_Y = true;\r\n\r\n    /**\r\n     * All material loaded from the mtl will be set here\r\n     */\r\n    public materials: StandardMaterial[] = [];\r\n\r\n    /**\r\n     * This function will read the mtl file and create each material described inside\r\n     * This function could be improve by adding :\r\n     * -some component missing (Ni, Tf...)\r\n     * -including the specific options available\r\n     *\r\n     * @param scene defines the scene the material will be created in\r\n     * @param data defines the mtl data to parse\r\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\r\n     * @param assetContainer defines the asset container to store the material in (can be null)\r\n     */\r\n    public parseMTL(scene: Scene, data: string | ArrayBuffer, rootUrl: string, assetContainer: Nullable<AssetContainer>): void {\r\n        if (data instanceof ArrayBuffer) {\r\n            return;\r\n        }\r\n\r\n        //Split the lines from the file\r\n        const lines = data.split(\"\\n\");\r\n        // whitespace char ie: [ \\t\\r\\n\\f]\r\n        const delimiterPattern = /\\s+/;\r\n        //Array with RGB colors\r\n        let color: number[];\r\n        //New material\r\n        let material: Nullable<StandardMaterial> = null;\r\n\r\n        //Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim();\r\n\r\n            // Blank line or comment\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            //Get the first parameter (keyword)\r\n            const pos = line.indexOf(\" \");\r\n            let key = pos >= 0 ? line.substring(0, pos) : line;\r\n            key = key.toLowerCase();\r\n\r\n            //Get the data following the key\r\n            const value: string = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\r\n\r\n            //This mtl keyword will create the new material\r\n            if (key === \"newmtl\") {\r\n                //Check if it is the first material.\r\n                // Materials specifications are described after this keyword.\r\n                if (material) {\r\n                    //Add the previous material in the material array.\r\n                    this.materials.push(material);\r\n                }\r\n                //Create a new material.\r\n                // value is the name of the material read in the mtl file\r\n\r\n                scene._blockEntityCollection = !!assetContainer;\r\n                material = new StandardMaterial(value, scene);\r\n                material._parentContainer = assetContainer;\r\n                scene._blockEntityCollection = false;\r\n            } else if (key === \"kd\" && material) {\r\n                // Diffuse color (color under white light) using RGB values\r\n\r\n                //value  = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.diffuseColor = Color3.FromArray(color);\r\n            } else if (key === \"ka\" && material) {\r\n                // Ambient color (color under shadow) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set tghe color into the material\r\n                material.ambientColor = Color3.FromArray(color);\r\n            } else if (key === \"ks\" && material) {\r\n                // Specular color (color when light is reflected from shiny surface) using RGB values\r\n\r\n                //value = \"r g b\"\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                //color = [r,g,b]\r\n                //Set the color into the material\r\n                material.specularColor = Color3.FromArray(color);\r\n            } else if (key === \"ke\" && material) {\r\n                // Emissive color using RGB values\r\n                color = value.split(delimiterPattern, 3).map(parseFloat);\r\n                material.emissiveColor = Color3.FromArray(color);\r\n            } else if (key === \"ns\" && material) {\r\n                //value = \"Integer\"\r\n                material.specularPower = parseFloat(value);\r\n            } else if (key === \"d\" && material) {\r\n                //d is dissolve for current material. It mean alpha for BABYLON\r\n                material.alpha = parseFloat(value);\r\n\r\n                //Texture\r\n                //This part can be improved by adding the possible options of texture\r\n            } else if (key === \"map_ka\" && material) {\r\n                // ambient texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_kd\" && material) {\r\n                // Diffuse texture map with a loaded image\r\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ks\" && material) {\r\n                // Specular texture map with a loaded image\r\n                //We must first get the folder of the image\r\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n            } else if (key === \"map_ns\") {\r\n                //Specular\r\n                //Specular highlight component\r\n                //We must first get the folder of the image\r\n                //\r\n                //Not supported by BABYLON\r\n                //\r\n                //    continue;\r\n            } else if (key === \"map_bump\" && material) {\r\n                //The bump texture\r\n                const values = value.split(delimiterPattern);\r\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\r\n                let bumpMultiplier: Nullable<string> = null;\r\n\r\n                if (bumpMultiplierIndex >= 0) {\r\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\r\n                    values.splice(bumpMultiplierIndex, 2); // remove\r\n                }\r\n\r\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\r\n                if (material.bumpTexture && bumpMultiplier !== null) {\r\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\r\n                }\r\n            } else if (key === \"map_d\" && material) {\r\n                // The dissolve of the material\r\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\r\n\r\n                //Options for illumination\r\n            } else if (key === \"illum\") {\r\n                //Illumination\r\n                if (value === \"0\") {\r\n                    //That mean Kd == Kd\r\n                } else if (value === \"1\") {\r\n                    //Color on and Ambient on\r\n                } else if (value === \"2\") {\r\n                    //Highlight on\r\n                } else if (value === \"3\") {\r\n                    //Reflection on and Ray trace on\r\n                } else if (value === \"4\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace on\r\n                } else if (value === \"5\") {\r\n                    //Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"6\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n                } else if (value === \"7\") {\r\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n                } else if (value === \"8\") {\r\n                    //Reflection on and Ray trace off\r\n                } else if (value === \"9\") {\r\n                    //Transparency: Glass on, Reflection: Ray trace off\r\n                } else if (value === \"10\") {\r\n                    //Casts shadows onto invisible surfaces\r\n                }\r\n            } else {\r\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\r\n            }\r\n        }\r\n        //At the end of the file, add the last material\r\n        if (material) {\r\n            this.materials.push(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture for the material.\r\n     *\r\n     * If the material is imported from input file,\r\n     * We sanitize the url to ensure it takes the texture from aside the material.\r\n     *\r\n     * @param rootUrl The root url to load from\r\n     * @param value The value stored in the mtl\r\n     * @param scene\r\n     * @returns The Texture\r\n     */\r\n    private static _GetTexture(rootUrl: string, value: string, scene: Scene): Nullable<Texture> {\r\n        if (!value) {\r\n            return null;\r\n        }\r\n\r\n        let url = rootUrl;\r\n        // Load from input file.\r\n        if (rootUrl === \"file:\") {\r\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\r\n            if (lastDelimiter === -1) {\r\n                lastDelimiter = value.lastIndexOf(\"/\");\r\n            }\r\n\r\n            if (lastDelimiter > -1) {\r\n                url += value.substring(lastDelimiter + 1);\r\n            } else {\r\n                url += value;\r\n            }\r\n        }\r\n        // Not from input file.\r\n        else {\r\n            url += value;\r\n        }\r\n\r\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\r\n    }\r\n}\r\n","import type { AssetContainer } from \"core/assetContainer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ntype MeshObject = {\r\n    name: string;\r\n    indices: Nullable<Array<number>>;\r\n    positions: Nullable<Array<number>>;\r\n    normals: Nullable<Array<number>>;\r\n    colors: Nullable<Array<number>>;\r\n    uvs: Nullable<Array<number>>;\r\n    materialName: string;\r\n    directMaterial?: Nullable<Material>;\r\n    isObject: boolean; // If the entity is defined as an object (\"o\"), or group (\"g\")\r\n    _babylonMesh?: AbstractMesh; // The corresponding Babylon mesh\r\n    hasLines?: boolean; // If the mesh has lines\r\n};\r\n\r\n/**\r\n * Class used to load mesh data from OBJ content\r\n */\r\nexport class SolidParser {\r\n    // Descriptor\r\n    /** Object descriptor */\r\n    public static ObjectDescriptor = /^o/;\r\n    /** Group descriptor */\r\n    public static GroupDescriptor = /^g/;\r\n    /** Material lib descriptor */\r\n    public static MtlLibGroupDescriptor = /^mtllib /;\r\n    /** Use a material descriptor */\r\n    public static UseMtlDescriptor = /^usemtl /;\r\n    /** Smooth descriptor */\r\n    public static SmoothDescriptor = /^s /;\r\n\r\n    // Patterns\r\n    /** Pattern used to detect a vertex */\r\n    public static VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\r\n    /** Pattern used to detect a normal */\r\n    public static NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a UV set */\r\n    public static UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\r\n    /** Pattern used to detect a first kind of face (f vertex vertex vertex) */\r\n    public static FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\r\n    /** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\r\n    public static FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\r\n    public static FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\r\n    public static FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\r\n    public static FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\r\n    /** Pattern used to detect a line(l vertex vertex) */\r\n    public static LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\r\n    /** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\r\n    public static LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n    /** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\r\n    public static LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n    private _positions: Array<Vector3> = []; //values for the positions of vertices\r\n    private _normals: Array<Vector3> = []; //Values for the normals\r\n    private _uvs: Array<Vector2> = []; //Values for the textures\r\n    private _colors: Array<Color4> = [];\r\n    private _extColors: Array<Color4> = []; //Extension color\r\n    private _meshesFromObj: Array<MeshObject> = []; //[mesh] Contains all the obj meshes\r\n    private _handledMesh: MeshObject; //The current mesh of meshes array\r\n    private _indicesForBabylon: Array<number> = []; //The list of indices for VertexData\r\n    private _wrappedPositionForBabylon: Array<Vector3> = []; //The list of position in vectors\r\n    private _wrappedUvsForBabylon: Array<Vector2> = []; //Array with all value of uvs to match with the indices\r\n    private _wrappedColorsForBabylon: Array<Color4> = []; // Array with all color values to match with the indices\r\n    private _wrappedNormalsForBabylon: Array<Vector3> = []; //Array with all value of normals to match with the indices\r\n    private _tuplePosNorm: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }> = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\r\n    private _curPositionInIndices = 0;\r\n    private _hasMeshes: boolean = false; //Meshes are defined in the file\r\n    private _unwrappedPositionsForBabylon: Array<number> = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\r\n    private _unwrappedColorsForBabylon: Array<number> = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\r\n    private _unwrappedNormalsForBabylon: Array<number> = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\r\n    private _unwrappedUVForBabylon: Array<number> = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\r\n    private _triangles: Array<string> = []; //Indices from new triangles coming from polygons\r\n    private _materialNameFromObj: string = \"\"; //The name of the current material\r\n    private _objMeshName: string = \"\"; //The name of the current obj mesh\r\n    private _increment: number = 1; //Id for meshes created by the multimaterial\r\n    private _isFirstMaterial: boolean = true;\r\n    private _grayColor = new Color4(0.5, 0.5, 0.5, 1);\r\n    private _materialToUse: string[];\r\n    private _babylonMeshesArray: Array<Mesh>;\r\n    private _pushTriangle: (faces: Array<string>, faceIndex: number) => void;\r\n    private _handednessSign: number;\r\n    private _hasLineData: boolean = false; //If this mesh has line segment(l) data\r\n\r\n    /**\r\n     * Creates a new SolidParser\r\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\r\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\r\n     * @param loadingOptions defines the loading options to use\r\n     */\r\n    public constructor(materialToUse: string[], babylonMeshesArray: Array<Mesh>, loadingOptions: OBJLoadingOptions) {\r\n        this._materialToUse = materialToUse;\r\n        this._babylonMeshesArray = babylonMeshesArray;\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    /**\r\n     * Search for obj in the given array.\r\n     * This function is called to check if a couple of data already exists in an array.\r\n     *\r\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\r\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\r\n     * @param obj Array<number>\r\n     * @returns {boolean}\r\n     */\r\n    private _isInArray(arr: Array<{ normals: Array<number>; idx: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\r\n    }\r\n\r\n    private _isInArrayUV(arr: Array<{ normals: Array<number>; idx: Array<number>; uv: Array<number> }>, obj: Array<number>) {\r\n        if (!arr[obj[0]]) {\r\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\r\n        }\r\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\r\n\r\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\r\n            return arr[obj[0]].idx[idx];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * This function set the data for each triangle.\r\n     * Data are position, normals and uvs\r\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\r\n     * If the tuple already exist, add only their indice\r\n     *\r\n     * @param data The vertex's data\r\n     * * indicesPositionFromObj: The index in positions array\r\n     * * indicesUvsFromObj: The index in uvs array\r\n     * * indicesNormalFromObj: The index in normals array\r\n     * * positionVectorFromOBJ: The value of position at index objIndice\r\n     * * textureVectorFromOBJ: The value of uvs\r\n     * * normalsVectorFromOBJ: The value of normals at index objNormale\r\n     * * positionColorsFromOBJ: The value of color at index objIndice\r\n     */\r\n    private _setData(data: {\r\n        indicePositionFromObj: number;\r\n        indiceUvsFromObj?: number;\r\n        indiceNormalFromObj?: number;\r\n        positionVectorFromOBJ: Vector3;\r\n        textureVectorFromOBJ?: Vector2;\r\n        normalsVectorFromOBJ?: Vector3;\r\n        positionColorsFromOBJ?: Color4;\r\n    }) {\r\n        //Use default values if undefined\r\n        data.indiceUvsFromObj ??= -1;\r\n        data.indiceNormalFromObj ??= -1;\r\n\r\n        //Check if this tuple already exists in the list of tuples\r\n        let _index: number;\r\n        if (this._loadingOptions.optimizeWithUV) {\r\n            _index = this._isInArrayUV(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj, data.indiceUvsFromObj]);\r\n        } else {\r\n            _index = this._isInArray(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj]);\r\n        }\r\n\r\n        //If it not exists\r\n        if (_index === -1) {\r\n            //Add an new indice.\r\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\r\n            //We add vertices data in this order\r\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\r\n            //Push the position of vertice for Babylon\r\n            //Each element is a Vector3(x,y,z)\r\n            this._wrappedPositionForBabylon.push(data.positionVectorFromOBJ);\r\n\r\n            if (data.textureVectorFromOBJ !== undefined) {\r\n                //Push the uvs for Babylon\r\n                //Each element is a Vector2(u,v)\r\n                this._wrappedUvsForBabylon.push(data.textureVectorFromOBJ);\r\n            }\r\n            if (data.normalsVectorFromOBJ !== undefined) {\r\n                //Push the normals for Babylon\r\n                //Each element is a Vector3(x,y,z)\r\n                this._wrappedNormalsForBabylon.push(data.normalsVectorFromOBJ);\r\n            }\r\n            if (data.positionColorsFromOBJ !== undefined) {\r\n                //Push the colors for Babylon\r\n                //Each element is a BABYLON.Color4(r,g,b,a)\r\n                this._wrappedColorsForBabylon.push(data.positionColorsFromOBJ);\r\n            }\r\n\r\n            //Add the tuple in the comparison list\r\n            this._tuplePosNorm[data.indicePositionFromObj].normals.push(data.indiceNormalFromObj);\r\n            this._tuplePosNorm[data.indicePositionFromObj].idx.push(this._curPositionInIndices++);\r\n            if (this._loadingOptions.optimizeWithUV) {\r\n                this._tuplePosNorm[data.indicePositionFromObj].uv.push(data.indiceUvsFromObj);\r\n            }\r\n        } else {\r\n            //The tuple already exists\r\n            //Add the index of the already existing tuple\r\n            //At this index we can get the value of position, normal, color and uvs of vertex\r\n            this._indicesForBabylon.push(_index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\r\n     */\r\n    private _unwrapData() {\r\n        try {\r\n            //Every array has the same length\r\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\r\n                //Push the x, y, z values of each element in the unwrapped array\r\n                this._unwrappedPositionsForBabylon.push(\r\n                    this._wrappedPositionForBabylon[l].x * this._handednessSign,\r\n                    this._wrappedPositionForBabylon[l].y,\r\n                    this._wrappedPositionForBabylon[l].z\r\n                );\r\n                if (this._wrappedNormalsForBabylon.length) {\r\n                    this._unwrappedNormalsForBabylon.push(\r\n                        this._wrappedNormalsForBabylon[l].x * this._handednessSign,\r\n                        this._wrappedNormalsForBabylon[l].y,\r\n                        this._wrappedNormalsForBabylon[l].z\r\n                    );\r\n                }\r\n                if (this._wrappedUvsForBabylon.length) {\r\n                    this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\r\n                }\r\n                if (this._unwrappedColorsForBabylon.length) {\r\n                    //Push the r, g, b, a values of each element in the unwrapped array\r\n                    this._unwrappedColorsForBabylon.push(\r\n                        this._wrappedColorsForBabylon[l].r,\r\n                        this._wrappedColorsForBabylon[l].g,\r\n                        this._wrappedColorsForBabylon[l].b,\r\n                        this._wrappedColorsForBabylon[l].a\r\n                    );\r\n                }\r\n            }\r\n            // Reset arrays for the next new meshes\r\n            this._wrappedPositionForBabylon.length = 0;\r\n            this._wrappedNormalsForBabylon.length = 0;\r\n            this._wrappedUvsForBabylon.length = 0;\r\n            this._wrappedColorsForBabylon.length = 0;\r\n            this._tuplePosNorm.length = 0;\r\n            this._curPositionInIndices = 0;\r\n        } catch (e) {\r\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles from polygons\r\n     * It is important to notice that a triangle is a polygon\r\n     * We get 5 patterns of face defined in OBJ File :\r\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\r\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\r\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\r\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\r\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\r\n     * Each pattern is divided by the same method\r\n     * @param faces Array[String] The indices of elements\r\n     * @param v Integer The variable to increment\r\n     */\r\n    private _getTriangles(faces: Array<string>, v: number) {\r\n        //Work for each element of the array\r\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\r\n            //Add on the triangle variable the indexes to obtain triangles\r\n            this._pushTriangle(faces, faceIndex);\r\n        }\r\n\r\n        //Result obtained after 2 iterations:\r\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\r\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\r\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\r\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\r\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\r\n    }\r\n\r\n    /**\r\n     * To get color between color and extension color\r\n     * @param index Integer The index of the element in the array\r\n     * @returns value of target color\r\n     */\r\n    private _getColor(index: number) {\r\n        if (this._loadingOptions.importVertexColors) {\r\n            return this._extColors[index] ?? this._colors[index];\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 1\r\n     * In this pattern we get vertice positions\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern1(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        //For each element in the triangles array.\r\n        //This var could contains 1 to an infinity of triangles\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 2\r\n     * In this pattern we get vertice positions and uvs\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern2(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1\"\r\n            //Split the data for getting position and uv\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\r\n            //Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            //Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern3(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1/1/1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            // Set uv indice\r\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\r\n            // Set normal indice\r\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Create triangles and push the data for each polygon for the pattern 4\r\n     * In this pattern we get vertice positions and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern4(face: Array<string>, v: number) {\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"1//1\"\r\n            //Split the data for getting position and normals\r\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\r\n            // We check indices, and normals\r\n            const indicePositionFromObj = parseInt(point[0]) - 1;\r\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    /*\r\n     * Create triangles and push the data for each polygon for the pattern 3\r\n     * In this pattern we get vertice positions, uvs and normals\r\n     * @param face\r\n     * @param v\r\n     */\r\n    private _setDataForCurrentFaceWithPattern5(face: Array<string>, v: number) {\r\n        //Get the indices of triangles for each polygon\r\n        this._getTriangles(face, v);\r\n\r\n        for (let k = 0; k < this._triangles.length; k++) {\r\n            //triangle[k] = \"-1/-1/-1\"\r\n            //Split the data for getting position, uv, and normals\r\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\r\n            // Set position indice\r\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\r\n            // Set uv indice\r\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\r\n            // Set normal indice\r\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\r\n\r\n            this._setData({\r\n                indicePositionFromObj,\r\n                indiceUvsFromObj,\r\n                indiceNormalFromObj,\r\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\r\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\r\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\r\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\r\n            });\r\n        }\r\n        //Reset variable for the next line\r\n        this._triangles.length = 0;\r\n    }\r\n\r\n    private _addPreviousObjMesh() {\r\n        //Check if it is not the first mesh. Otherwise we don't have data.\r\n        if (this._meshesFromObj.length > 0) {\r\n            //Get the previous mesh for applying the data about the faces\r\n            //=> in obj file, faces definition append after the name of the mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            //Set the data into Array for the mesh\r\n            this._unwrapData();\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                // Reverse tab. Otherwise face are displayed in the wrong sens\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Set the information for the mesh\r\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\r\n            this._handledMesh.indices = this._indicesForBabylon.slice();\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\r\n            if (this._unwrappedNormalsForBabylon.length) {\r\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\r\n            }\r\n            if (this._unwrappedUVForBabylon.length) {\r\n                this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\r\n            }\r\n            if (this._unwrappedColorsForBabylon.length) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\r\n            }\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n\r\n            //Reset the array for the next mesh\r\n            this._indicesForBabylon.length = 0;\r\n            this._unwrappedPositionsForBabylon.length = 0;\r\n            this._unwrappedColorsForBabylon.length = 0;\r\n            this._unwrappedNormalsForBabylon.length = 0;\r\n            this._unwrappedUVForBabylon.length = 0;\r\n            this._hasLineData = false;\r\n        }\r\n    }\r\n\r\n    private _optimizeNormals(mesh: AbstractMesh): void {\r\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\r\n        const mapVertices: { [key: string]: number[] } = {};\r\n\r\n        if (!positions || !normals) {\r\n            return;\r\n        }\r\n\r\n        for (let i = 0; i < positions.length / 3; i++) {\r\n            const x = positions[i * 3 + 0];\r\n            const y = positions[i * 3 + 1];\r\n            const z = positions[i * 3 + 2];\r\n            const key = x + \"_\" + y + \"_\" + z;\r\n\r\n            let lst = mapVertices[key];\r\n            if (!lst) {\r\n                lst = [];\r\n                mapVertices[key] = lst;\r\n            }\r\n            lst.push(i);\r\n        }\r\n\r\n        const normal = new Vector3();\r\n        for (const key in mapVertices) {\r\n            const lst = mapVertices[key];\r\n            if (lst.length < 2) {\r\n                continue;\r\n            }\r\n\r\n            const v0Idx = lst[0];\r\n            for (let i = 1; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\r\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\r\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\r\n            }\r\n\r\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\r\n            normal.normalize();\r\n\r\n            for (let i = 0; i < lst.length; ++i) {\r\n                const vIdx = lst[i];\r\n                normals[vIdx * 3 + 0] = normal.x;\r\n                normals[vIdx * 3 + 1] = normal.y;\r\n                normals[vIdx * 3 + 2] = normal.z;\r\n            }\r\n        }\r\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    }\r\n\r\n    private static _IsLineElement(line: string) {\r\n        return line.startsWith(\"l\");\r\n    }\r\n\r\n    private static _IsObjectElement(line: string) {\r\n        return line.startsWith(\"o\");\r\n    }\r\n\r\n    private static _IsGroupElement(line: string) {\r\n        return line.startsWith(\"g\");\r\n    }\r\n\r\n    private static _GetZbrushMRGB(line: string, notParse: boolean) {\r\n        if (!line.startsWith(\"mrgb\")) {\r\n            return null;\r\n        }\r\n        line = line.replace(\"mrgb\", \"\").trim();\r\n        // if include vertex color , not load mrgb anymore\r\n        if (notParse) {\r\n            return [];\r\n        }\r\n        const regex = /[a-z0-9]/g;\r\n        const regArray = line.match(regex);\r\n        if (!regArray || regArray.length % 8 !== 0) {\r\n            return [];\r\n        }\r\n        const array: Color4[] = [];\r\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\r\n            //each item is MMRRGGBB, m is material index\r\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\r\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\r\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\r\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\r\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Function used to parse an OBJ string\r\n     * @param meshesNames defines the list of meshes to load (all if not defined)\r\n     * @param data defines the OBJ string\r\n     * @param scene defines the hosting scene\r\n     * @param assetContainer defines the asset container to load data in\r\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\r\n     */\r\n    public parse(meshesNames: any, data: string, scene: Scene, assetContainer: Nullable<AssetContainer>, onFileToLoadFound: (fileToLoad: string) => void): void {\r\n        //Move Santitize here to forbid delete zbrush data\r\n        // Sanitize data\r\n        data = data.replace(/#MRGB/g, \"mrgb\");\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n        if (this._loadingOptions.useLegacyBehavior) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = 1;\r\n        } else if (scene.useRightHandedSystem) {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\r\n            this._handednessSign = 1;\r\n        } else {\r\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\r\n            this._handednessSign = -1;\r\n        }\r\n\r\n        // Split the file into lines\r\n        // Preprocess line data\r\n        const linesOBJ = data.split(\"\\n\");\r\n        const lineLines: string[][] = [];\r\n        let currentGroup: string[] = [];\r\n\r\n        lineLines.push(currentGroup);\r\n\r\n        for (let i = 0; i < linesOBJ.length; i++) {\r\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\r\n\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            }\r\n\r\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\r\n                currentGroup = [];\r\n                lineLines.push(currentGroup);\r\n            }\r\n\r\n            if (SolidParser._IsLineElement(line)) {\r\n                const lineValues = line.split(\" \");\r\n                // create line elements with two vertices only\r\n                for (let i = 1; i < lineValues.length - 1; i++) {\r\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\r\n                }\r\n            } else {\r\n                currentGroup.push(line);\r\n            }\r\n        }\r\n\r\n        const lines = lineLines.flat();\r\n        // Look at each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\r\n            let result;\r\n            // Comment or newLine\r\n            if (line.length === 0 || line.charAt(0) === \"#\") {\r\n                continue;\r\n            } else if (SolidParser.VertexPattern.test(line)) {\r\n                //Get information about one position possible for the vertices\r\n                result = line.match(/[^ ]+/g)!; // match will return non-null due to passing regex pattern\r\n\r\n                // Value of result with line: \"v 1.0 2.0 3.0\"\r\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\r\n                // Create a Vector3 with the position x, y, z\r\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n\r\n                if (this._loadingOptions.importVertexColors) {\r\n                    if (result.length >= 7) {\r\n                        const r = parseFloat(result[4]);\r\n                        const g = parseFloat(result[5]);\r\n                        const b = parseFloat(result[6]);\r\n\r\n                        this._colors.push(\r\n                            new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7]))\r\n                        );\r\n                    } else {\r\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\r\n                        this._colors.push(this._grayColor);\r\n                    }\r\n                }\r\n            } else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\r\n                //Create a Vector3 with the normals x, y, z\r\n                //Value of result\r\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\r\n                //Add the Vector in the list of normals\r\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\r\n            } else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\r\n                //Create a Vector2 with the normals u, v\r\n                //Value of result\r\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\r\n                //Add the Vector in the list of uvs\r\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\r\n\r\n                //Identify patterns of faces\r\n                //Face could be defined in different type of pattern\r\n            } else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern4(\r\n                    result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern5(\r\n                    result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\r\n                //Value of result:\r\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\r\n                    1\r\n                );\r\n            } else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"f 1 2 3\", \"1 2 3\"...]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\r\n                    1\r\n                );\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1 2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern1(\r\n                    result[1].trim().split(\" \"), // [\"1\", \"2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1 2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern2(\r\n                    result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\r\n                for (const element of result) {\r\n                    this._extColors.push(element);\r\n                }\r\n            } else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\r\n                //Value of result\r\n                //[\"l 1/1/1 2/2/2\"]\r\n\r\n                //Set the data for this face\r\n                this._setDataForCurrentFaceWithPattern3(\r\n                    result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\r\n                    0\r\n                );\r\n                this._hasLineData = true;\r\n\r\n                // Define a mesh or an object\r\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\r\n            } else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\r\n                // Create a new mesh corresponding to the name of the group.\r\n                // Definition of the mesh\r\n                const objMesh: MeshObject = {\r\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\r\n                    indices: null,\r\n                    positions: null,\r\n                    normals: null,\r\n                    uvs: null,\r\n                    colors: null,\r\n                    materialName: this._materialNameFromObj,\r\n                    isObject: SolidParser.ObjectDescriptor.test(line),\r\n                };\r\n                this._addPreviousObjMesh();\r\n\r\n                //Push the last mesh created with only the name\r\n                this._meshesFromObj.push(objMesh);\r\n\r\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\r\n                this._hasMeshes = true;\r\n                this._isFirstMaterial = true;\r\n                this._increment = 1;\r\n                //Keyword for applying a material\r\n            } else if (SolidParser.UseMtlDescriptor.test(line)) {\r\n                //Get the name of the material\r\n                this._materialNameFromObj = line.substring(7).trim();\r\n\r\n                //If this new material is in the same mesh\r\n\r\n                if (!this._isFirstMaterial || !this._hasMeshes) {\r\n                    //Set the data for the previous mesh\r\n                    this._addPreviousObjMesh();\r\n                    //Create a new mesh\r\n                    const objMesh: MeshObject =\r\n                        //Set the name of the current obj mesh\r\n                        {\r\n                            name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\r\n                            indices: null,\r\n                            positions: null,\r\n                            normals: null,\r\n                            uvs: null,\r\n                            colors: null,\r\n                            materialName: this._materialNameFromObj,\r\n                            isObject: false,\r\n                        };\r\n                    this._increment++;\r\n                    //If meshes are already defined\r\n                    this._meshesFromObj.push(objMesh);\r\n                    this._hasMeshes = true;\r\n                }\r\n                //Set the material name if the previous line define a mesh\r\n\r\n                if (this._hasMeshes && this._isFirstMaterial) {\r\n                    //Set the material name to the previous mesh (1 material per mesh)\r\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\r\n                    this._isFirstMaterial = false;\r\n                }\r\n                // Keyword for loading the mtl file\r\n            } else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\r\n                // Get the name of mtl file\r\n                onFileToLoadFound(line.substring(7).trim());\r\n\r\n                // Apply smoothing\r\n            } else if (SolidParser.SmoothDescriptor.test(line)) {\r\n                // smooth shading => apply smoothing\r\n                // Today I don't know it work with babylon and with obj.\r\n                // With the obj file  an integer is set\r\n            } else {\r\n                //If there is another possibility\r\n                Logger.Log(\"Unhandled expression at line : \" + line);\r\n            }\r\n        }\r\n        // At the end of the file, add the last mesh into the meshesFromObj array\r\n        if (this._hasMeshes) {\r\n            // Set the data for the last mesh\r\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\r\n\r\n            if (this._loadingOptions.useLegacyBehavior) {\r\n                //Reverse indices for displaying faces in the good sense\r\n                this._indicesForBabylon.reverse();\r\n            }\r\n\r\n            //Get the good array\r\n            this._unwrapData();\r\n            //Set array\r\n            this._handledMesh.indices = this._indicesForBabylon;\r\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\r\n            if (this._unwrappedNormalsForBabylon.length) {\r\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon;\r\n            }\r\n            if (this._unwrappedUVForBabylon.length) {\r\n                this._handledMesh.uvs = this._unwrappedUVForBabylon;\r\n            }\r\n            if (this._unwrappedColorsForBabylon.length) {\r\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\r\n            }\r\n            this._handledMesh.hasLines = this._hasLineData;\r\n        }\r\n\r\n        // If any o or g keyword not found, create a mesh with a random id\r\n        if (!this._hasMeshes) {\r\n            let newMaterial: Nullable<StandardMaterial> = null;\r\n            if (this._indicesForBabylon.length) {\r\n                if (this._loadingOptions.useLegacyBehavior) {\r\n                    // reverse tab of indices\r\n                    this._indicesForBabylon.reverse();\r\n                }\r\n\r\n                //Get positions normals uvs\r\n                this._unwrapData();\r\n            } else {\r\n                // There is no indices in the file. We will have to switch to point cloud rendering\r\n                for (const pos of this._positions) {\r\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\r\n                }\r\n\r\n                if (this._normals.length) {\r\n                    for (const normal of this._normals) {\r\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\r\n                    }\r\n                }\r\n\r\n                if (this._uvs.length) {\r\n                    for (const uv of this._uvs) {\r\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\r\n                    }\r\n                }\r\n\r\n                if (this._extColors.length) {\r\n                    for (const color of this._extColors) {\r\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                    }\r\n                } else {\r\n                    if (this._colors.length) {\r\n                        for (const color of this._colors) {\r\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!this._materialNameFromObj) {\r\n                    // Create a material with point cloud on\r\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\r\n\r\n                    newMaterial.pointsCloud = true;\r\n\r\n                    this._materialNameFromObj = newMaterial.name;\r\n\r\n                    if (!this._normals.length) {\r\n                        newMaterial.disableLighting = true;\r\n                        newMaterial.emissiveColor = Color3.White();\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Set data for one mesh\r\n            this._meshesFromObj.push({\r\n                name: Geometry.RandomId(),\r\n                indices: this._indicesForBabylon,\r\n                positions: this._unwrappedPositionsForBabylon,\r\n                colors: this._unwrappedColorsForBabylon,\r\n                normals: this._unwrappedNormalsForBabylon,\r\n                uvs: this._unwrappedUVForBabylon,\r\n                materialName: this._materialNameFromObj,\r\n                directMaterial: newMaterial,\r\n                isObject: true,\r\n                hasLines: this._hasLineData,\r\n            });\r\n        }\r\n\r\n        //Set data for each mesh\r\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\r\n            //check meshesNames (stlFileLoader)\r\n            if (meshesNames && this._meshesFromObj[j].name) {\r\n                if (meshesNames instanceof Array) {\r\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    if (this._meshesFromObj[j].name !== meshesNames) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Get the current mesh\r\n            //Set the data with VertexBuffer for each mesh\r\n            this._handledMesh = this._meshesFromObj[j];\r\n            //Create a Mesh with the name of the obj mesh\r\n\r\n            scene._blockEntityCollection = !!assetContainer;\r\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\r\n            babylonMesh._parentContainer = assetContainer;\r\n            scene._blockEntityCollection = false;\r\n            this._handledMesh._babylonMesh = babylonMesh;\r\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\r\n            if (!this._handledMesh.isObject) {\r\n                for (let k = j - 1; k >= 0; --k) {\r\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\r\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh!;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //Push the name of the material to an array\r\n            //This is indispensable for the importMesh function\r\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\r\n            //If the mesh is a line mesh\r\n            if (this._handledMesh.hasLines) {\r\n                babylonMesh._internalMetadata ??= {};\r\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\r\n            }\r\n\r\n            if (this._handledMesh.positions?.length === 0) {\r\n                //Push the mesh into an array\r\n                this._babylonMeshesArray.push(babylonMesh);\r\n                continue;\r\n            }\r\n\r\n            const vertexData: VertexData = new VertexData(); //The container for the values\r\n            //Set the data for the babylonMesh\r\n            vertexData.indices = this._handledMesh.indices;\r\n            vertexData.positions = this._handledMesh.positions;\r\n            if (this._loadingOptions.computeNormals || !this._handledMesh.normals) {\r\n                // Compute normals if requested or if normals are not defined\r\n                const normals: Array<number> = new Array<number>();\r\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\r\n                vertexData.normals = normals;\r\n            } else {\r\n                vertexData.normals = this._handledMesh.normals;\r\n            }\r\n            if (this._handledMesh.uvs) {\r\n                vertexData.uvs = this._handledMesh.uvs;\r\n            }\r\n            if (this._handledMesh.colors) {\r\n                vertexData.colors = this._handledMesh.colors;\r\n            }\r\n            //Set the data from the VertexBuffer to the current Mesh\r\n            vertexData.applyToMesh(babylonMesh);\r\n            if (this._loadingOptions.invertY) {\r\n                babylonMesh.scaling.y *= -1;\r\n            }\r\n            if (this._loadingOptions.optimizeNormals) {\r\n                this._optimizeNormals(babylonMesh);\r\n            }\r\n\r\n            //Push the mesh into an array\r\n            this._babylonMeshesArray.push(babylonMesh);\r\n\r\n            if (this._handledMesh.directMaterial) {\r\n                babylonMesh.material = this._handledMesh.directMaterial;\r\n            }\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","import type { ISceneLoaderPluginMetadata } from \"core/index\";\r\n\r\nexport const OBJFileLoaderMetadata = {\r\n    name: \"obj\",\r\n    extensions: \".obj\",\r\n} as const satisfies ISceneLoaderPluginMetadata;\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderPlugin, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\r\nimport { MTLFileLoader } from \"./mtlFileLoader\";\r\nimport type { OBJLoadingOptions } from \"./objLoadingOptions\";\r\nimport { SolidParser } from \"./solidParser\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the obj loader.\r\n         */\r\n        [OBJFileLoaderMetadata.name]: Partial<OBJLoadingOptions>;\r\n    }\r\n}\r\n\r\n/**\r\n * OBJ file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class OBJFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines if UVs are optimized by default during load.\r\n     */\r\n    public static OPTIMIZE_WITH_UV = true;\r\n    /**\r\n     * Invert model on y-axis (does a model scaling inversion)\r\n     */\r\n    public static INVERT_Y = false;\r\n    /**\r\n     * Invert Y-Axis of referenced textures on load\r\n     */\r\n    public static get INVERT_TEXTURE_Y() {\r\n        return MTLFileLoader.INVERT_TEXTURE_Y;\r\n    }\r\n\r\n    public static set INVERT_TEXTURE_Y(value: boolean) {\r\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\r\n    }\r\n\r\n    /**\r\n     * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\r\n     */\r\n    public static IMPORT_VERTEX_COLORS = false;\r\n    /**\r\n     * Compute the normals for the model, even if normals are present in the file.\r\n     */\r\n    public static COMPUTE_NORMALS = false;\r\n    /**\r\n     * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\r\n     * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\r\n     */\r\n    public static OPTIMIZE_NORMALS = false;\r\n    /**\r\n     * Defines custom scaling of UV coordinates of loaded meshes.\r\n     */\r\n    public static UV_SCALING = new Vector2(1, 1);\r\n    /**\r\n     * Skip loading the materials even if defined in the OBJ file (materials are ignored).\r\n     */\r\n    public static SKIP_MATERIALS = false;\r\n\r\n    /**\r\n     * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\r\n     *\r\n     * Defaults to true for backwards compatibility.\r\n     */\r\n    public static MATERIAL_LOADING_FAILS_SILENTLY = true;\r\n\r\n    /**\r\n     * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\r\n     */\r\n    public static USE_LEGACY_BEHAVIOR = false;\r\n\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = OBJFileLoaderMetadata.name;\r\n    /**\r\n     * Defines the extension the plugin is able to load.\r\n     */\r\n    public readonly extensions = OBJFileLoaderMetadata.extensions;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private _loadingOptions: OBJLoadingOptions;\r\n\r\n    /**\r\n     * Creates loader for .OBJ files\r\n     *\r\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\r\n     */\r\n    constructor(loadingOptions?: Partial<Readonly<OBJLoadingOptions>>) {\r\n        this._loadingOptions = { ...OBJFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\r\n    }\r\n\r\n    private static get _DefaultLoadingOptions(): OBJLoadingOptions {\r\n        return {\r\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\r\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\r\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\r\n            invertY: OBJFileLoader.INVERT_Y,\r\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            UVScaling: OBJFileLoader.UV_SCALING,\r\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\r\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\r\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\r\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calls synchronously the MTL file attached to this obj.\r\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\r\n     * Without this function materials are not displayed in the first frame (but displayed after).\r\n     * In consequence it is impossible to get material information in your HTML file\r\n     *\r\n     * @param url The URL of the MTL file\r\n     * @param rootUrl defines where to load data from\r\n     * @param onSuccess Callback function to be called when the MTL file is loaded\r\n     * @param onFailure\r\n     */\r\n    private _loadMTL(\r\n        url: string,\r\n        rootUrl: string,\r\n        onSuccess: (response: string | ArrayBuffer, responseUrl?: string) => any,\r\n        onFailure: (pathOfFile: string, exception?: any) => void\r\n    ) {\r\n        //The complete path to the mtl file\r\n        const pathOfFile = rootUrl + url;\r\n\r\n        // Loads through the babylon tools to allow fileInput search.\r\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request?: WebRequest, exception?: any) => {\r\n            onFailure(pathOfFile, exception);\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync | ISceneLoaderPlugin {\r\n        return new OBJFileLoader(options[OBJFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * If the data string can be loaded directly.\r\n     * @returns if the data can be loaded directly\r\n     */\r\n    public canDirectLoad(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public importMeshAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<ISceneLoaderAsyncResult> {\r\n        //get the meshes from OBJ file\r\n        // eslint-disable-next-line github/no-then\r\n        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        // eslint-disable-next-line github/no-then\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return (\r\n            this.importMeshAsync(null, scene, data, rootUrl)\r\n                // eslint-disable-next-line github/no-then\r\n                .then((result) => {\r\n                    result.meshes.forEach((mesh) => container.meshes.push(mesh));\r\n                    result.meshes.forEach((mesh) => {\r\n                        const material = mesh.material;\r\n                        if (material) {\r\n                            // Materials\r\n                            if (container.materials.indexOf(material) == -1) {\r\n                                container.materials.push(material);\r\n\r\n                                // Textures\r\n                                const textures = material.getActiveTextures();\r\n                                textures.forEach((t) => {\r\n                                    if (container.textures.indexOf(t) == -1) {\r\n                                        container.textures.push(t);\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                    });\r\n                    this._assetContainer = null;\r\n                    return container;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((ex) => {\r\n                    this._assetContainer = null;\r\n                    throw ex;\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Read the OBJ file and create an Array of meshes.\r\n     * Each mesh contains all information given by the OBJ and the MTL file.\r\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\r\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene defines the scene where are displayed the data\r\n     * @param data defines the content of the obj file\r\n     * @param rootUrl defines the path to the folder\r\n     * @returns the list of loaded meshes\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseSolidAsync(meshesNames: any, scene: Scene, data: string, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        let fileToLoad: string = \"\"; //The name of the mtlFile to load\r\n        const materialsFromMTLFile: MTLFileLoader = new MTLFileLoader();\r\n        const materialToUse: string[] = [];\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        // Sanitize data\r\n        data = data.replace(/#.*$/gm, \"\").trim();\r\n\r\n        // Main function\r\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\r\n\r\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName: string) => {\r\n            fileToLoad = fileName;\r\n        });\r\n\r\n        // load the materials\r\n        const mtlPromises: Array<Promise<void>> = [];\r\n        // Check if we have a file to load\r\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\r\n            //Load the file synchronously\r\n            mtlPromises.push(\r\n                new Promise((resolve, reject) => {\r\n                    this._loadMTL(\r\n                        fileToLoad,\r\n                        rootUrl,\r\n                        (dataLoaded) => {\r\n                            try {\r\n                                //Create materials thanks MTLLoader function\r\n                                materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\r\n                                //Look at each material loaded in the mtl file\r\n                                for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\r\n                                    //Three variables to get all meshes with the same material\r\n                                    let startIndex = 0;\r\n                                    const _indices = [];\r\n                                    let _index;\r\n\r\n                                    //The material from MTL file is used in the meshes loaded\r\n                                    //Push the indice in an array\r\n                                    //Check if the material is not used for another mesh\r\n                                    while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\r\n                                        _indices.push(_index);\r\n                                        startIndex = _index + 1;\r\n                                    }\r\n                                    //If the material is not used dispose it\r\n                                    if (_index === -1 && _indices.length === 0) {\r\n                                        //If the material is not needed, remove it\r\n                                        materialsFromMTLFile.materials[n].dispose();\r\n                                    } else {\r\n                                        for (let o = 0; o < _indices.length; o++) {\r\n                                            //Apply the material to the Mesh for each mesh with the material\r\n                                            const mesh = babylonMeshesArray[_indices[o]];\r\n                                            const material = materialsFromMTLFile.materials[n];\r\n                                            mesh.material = material;\r\n\r\n                                            if (!mesh.getTotalIndices()) {\r\n                                                // No indices, we need to turn on point cloud\r\n                                                material.pointsCloud = true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                resolve();\r\n                            } catch (e) {\r\n                                Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\r\n                                if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                    resolve();\r\n                                } else {\r\n                                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                    reject(e);\r\n                                }\r\n                            }\r\n                        },\r\n                        (pathOfFile: string, exception?: any) => {\r\n                            Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\r\n                            if (this._loadingOptions.materialLoadingFailsSilently) {\r\n                                resolve();\r\n                            } else {\r\n                                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                reject(exception);\r\n                            }\r\n                        }\r\n                    );\r\n                })\r\n            );\r\n        }\r\n        //Return an array with all Mesh\r\n        // eslint-disable-next-line github/no-then\r\n        return Promise.all(mtlPromises).then(() => {\r\n            const isLine = (mesh: AbstractMesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\r\n\r\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\r\n            babylonMeshesArray.forEach((mesh) => {\r\n                if (isLine(mesh)) {\r\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\r\n                    // If another mesh is using this material and it is not a line then we need to clone it.\r\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\r\n                    if (needClone) {\r\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\r\n                    }\r\n                    mat.wireframe = true;\r\n                    mesh.material = mat;\r\n                    if (mesh._internalMetadata) {\r\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return babylonMeshesArray;\r\n        });\r\n    }\r\n}\r\n\r\n//Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new OBJFileLoader());\r\n","/* eslint-disable @typescript-eslint/no-restricted-imports */\r\nimport * as Loaders from \"loaders/OBJ/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst GlobalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof GlobalObject !== \"undefined\") {\r\n    for (const key in Loaders) {\r\n        if (!(<any>GlobalObject).BABYLON[key]) {\r\n            (<any>GlobalObject).BABYLON[key] = (<any>Loaders)[key];\r\n        }\r\n    }\r\n}\r\n\r\nexport * from \"loaders/OBJ/index\";\r\n","import * as loaders from \"@lts/loaders/legacy/legacy-objFileLoader\";\r\nexport { loaders };\r\nexport default loaders;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","materials","parseMTL","scene","data","rootUrl","assetContainer","ArrayBuffer","color","lines","split","delimiterPattern","material","i","length","line","trim","charAt","pos","indexOf","substring","toLowerCase","push","_blockEntityCollection","StandardMaterial","_parentContainer","map","parseFloat","diffuseColor","Color3","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","MTLFileLoader","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","Texture","INVERT_TEXTURE_Y","materialToUse","babylonMeshesArray","loadingOptions","_positions","_normals","_uvs","_colors","_extColors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","Color4","_hasLineData","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","arr","normals","idx","_isInArrayUV","uv","_setData","_index","indiceUvsFromObj","indiceNormalFromObj","optimizeWithUV","indicePositionFromObj","positionVectorFromOBJ","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_unwrapData","l","x","_handednessSign","y","z","b","a","Error","_getTriangles","faces","v","faceIndex","_pushTriangle","_getColor","index","importVertexColors","_setDataForCurrentFaceWithPattern1","face","k","parseInt","_setDataForCurrentFaceWithPattern2","point","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","useLegacyBehavior","reverse","indices","slice","positions","uvs","colors","hasLines","_optimizeNormals","mesh","getVerticesData","VertexBuffer","PositionKind","NormalKind","mapVertices","lst","normal","Vector3","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","_IsLineElement","startsWith","_IsObjectElement","_IsGroupElement","_GetZbrushMRGB","notParse","replace","regArray","match","array","regIndex","parse","meshesNames","onFileToLoadFound","useRightHandedSystem","linesOBJ","lineLines","currentGroup","SolidParser","lineValues","flat","result","VertexPattern","test","NormalPattern","exec","UVPattern","Vector2","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","LinePattern1","LinePattern2","element","LinePattern3","GroupDescriptor","ObjectDescriptor","objMesh","name","materialName","isObject","UseMtlDescriptor","toString","MtlLibGroupDescriptor","SmoothDescriptor","Logger","Log","newMaterial","Geometry","RandomId","pointsCloud","disableLighting","White","directMaterial","j","Array","babylonMesh","Mesh","_babylonMesh","parent","_internalMetadata","vertexData","VertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","__assign","assign","t","s","n","arguments","p","apply","create","SuppressedError","extensions","_assetContainer","OBJFileLoader","_DefaultLoadingOptions","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","USE_LEGACY_BEHAVIOR","_loadMTL","onSuccess","onFailure","pathOfFile","Tools","LoadFile","request","exception","createPlugin","options","canDirectLoad","importMeshAsync","_parseSolidAsync","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","loadAsync","loadAssetContainerAsync","container","AssetContainer","forEach","getActiveTextures","textures","catch","ex","fileToLoad","materialsFromMTLFile","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","startIndex","_indices","dispose","getTotalIndices","Warn","all","isLine","Boolean","mat","getBindedMeshes","filter","clone","wireframe","RegisterSceneLoaderPlugin","GlobalObject","BABYLON"],"sourceRoot":""}