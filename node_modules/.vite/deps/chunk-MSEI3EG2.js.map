{
  "version": 3,
  "sources": ["../../../dev/core/src/Maths/math.vector.functions.ts", "../../../dev/core/src/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.ts"],
  "sourcesContent": ["import { Clamp } from \"./math.scalar.functions\";\r\nimport type { DeepImmutable } from \"../types\";\r\nimport type { IVector2Like, IVector3Like } from \"./math.like\";\r\nimport { Quaternion, Vector3 } from \"./math.vector\";\r\nimport type { Vector4 } from \"./math.vector\";\r\n\r\n/**\r\n * Creates a string representation of the IVector2Like\r\n * @param vector defines the IVector2Like to stringify\r\n * @param decimalCount defines the number of decimals to use\r\n * @returns a string with the IVector2Like coordinates.\r\n */\r\nexport function Vector2ToFixed(vector: IVector2Like, decimalCount: number): string {\r\n    return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)}}`;\r\n}\r\n\r\n/**\r\n * Computes the dot product of two IVector3Like objects.\r\n * @param a defines the first vector\r\n * @param b defines the second vector\r\n * @returns the dot product\r\n */\r\nexport function Vector3Dot<T extends IVector3Like, U extends IVector3Like>(a: DeepImmutable<T>, b: DeepImmutable<U>) {\r\n    return a.x * b.x + a.y * b.y + a.z * b.z;\r\n}\r\n\r\n/**\r\n * Sets the given floats into the result.\r\n * @param x defines the x coordinate\r\n * @param y defines the y coordinate\r\n * @param z defines the z coordinate\r\n * @param result defines the target vector\r\n * @returns the result vector\r\n */\r\nexport function Vector3FromFloatsToRef<T extends IVector3Like>(x: number, y: number, z: number, result: T): T {\r\n    result.x = x;\r\n    result.y = y;\r\n    result.z = z;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Stores the scaled values of a vector into the result.\r\n * @param a defines the source vector\r\n * @param scale defines the scale factor\r\n * @param result defines the target vector\r\n * @returns the scaled vector\r\n */\r\nexport function Vector3ScaleToRef<T extends IVector3Like, ResultT extends IVector3Like>(a: DeepImmutable<T>, scale: number, result: ResultT): ResultT {\r\n    result.x = a.x * scale;\r\n    result.y = a.y * scale;\r\n    result.z = a.z * scale;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a string representation of the Vector3\r\n * @param vector defines the Vector3 to stringify\r\n * @param decimalCount defines the number of decimals to use\r\n * @returns a string with the Vector3 coordinates.\r\n */\r\nexport function Vector3ToFixed(vector: Vector3, decimalCount: number): string {\r\n    return `{X: ${vector._x.toFixed(decimalCount)} Y: ${vector._y.toFixed(decimalCount)} Z: ${vector._z.toFixed(decimalCount)}}`;\r\n}\r\n\r\n/**\r\n * Creates a string representation of the Vector4\r\n * @param vector defines the Vector4 to stringify\r\n * @param decimalCount defines the number of decimals to use\r\n * @returns a string with the Vector4 coordinates.\r\n */\r\nexport function Vector4ToFixed(vector: Vector4, decimalCount: number): string {\r\n    return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)} Z: ${vector.z.toFixed(decimalCount)} W: ${vector.w.toFixed(decimalCount)}}`;\r\n}\r\n\r\n/**\r\n * Returns the angle in radians between two quaternions\r\n * @param q1 defines the first quaternion\r\n * @param q2 defines the second quaternion\r\n * @returns the angle in radians between the two quaternions\r\n */\r\nexport function GetAngleBetweenQuaternions(q1: DeepImmutable<Quaternion>, q2: DeepImmutable<Quaternion>): number {\r\n    return Math.acos(Clamp(Quaternion.Dot(q1, q2))) * 2;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirections<T extends Vector3>(a: DeepImmutable<T>, b: DeepImmutable<T>): Quaternion {\r\n    const result = new Quaternion();\r\n    GetQuaternionFromDirectionsToRef(a, b, result);\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @param result defines the target quaternion\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirectionsToRef<T extends Vector3, ResultT extends Quaternion>(a: DeepImmutable<T>, b: DeepImmutable<T>, result: ResultT): ResultT {\r\n    const axis = Vector3.Cross(a, b);\r\n    const angle = Math.acos(Clamp(Vector3Dot(a, b), -1, 1));\r\n    Quaternion.RotationAxisToRef(axis, angle, result);\r\n    return result;\r\n}\r\n", "import { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport {\n    RichTypeVector3,\n    FlowGraphTypes,\n    RichTypeNumber,\n    RichTypeAny,\n    RichTypeVector2,\n    RichTypeMatrix,\n    getRichTypeByFlowGraphType,\n    RichTypeQuaternion,\n    RichTypeBoolean,\n} from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock\";\nimport { Quaternion, Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport type { Matrix, Vector2 } from \"core/Maths/math.vector\";\nimport type { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"core/FlowGraph/CustomTypes\";\nimport type { FlowGraphMatrix, FlowGraphVector } from \"core/FlowGraph/utils\";\nimport { _GetClassNameOf } from \"core/FlowGraph/utils\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport { GetAngleBetweenQuaternions, GetQuaternionFromDirections } from \"../../../../Maths/math.vector.functions\";\nimport type { Nullable } from \"../../../../types\";\n\nconst AxisCacheName = \"cachedOperationAxis\";\nconst AngleCacheName = \"cachedOperationAngle\";\nconst CacheExecIdName = \"cachedExecutionId\";\n\n/**\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), FlowGraphBlockNames.Length, config);\n    }\n\n    private _polymorphicLength(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                return (a as Vector3).length();\n            default:\n                throw new Error(`Cannot compute length of value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Length, FlowGraphLengthBlock);\n\n/**\n * Configuration for normalized vector\n */\nexport interface IFlowGraphNormalizeBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * If true, the block will return NaN if the input vector has a length of 0.\n     * This is the expected behavior for glTF interactivity graphs.\n     */\n    nanOnZeroLength?: boolean;\n}\n\n/**\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, FlowGraphVector> {\n    constructor(config?: IFlowGraphNormalizeBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), FlowGraphBlockNames.Normalize, config);\n    }\n\n    private _polymorphicNormalize(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        let normalized: FlowGraphVector;\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                normalized = a.normalizeToNew();\n                if (this.config?.nanOnZeroLength) {\n                    const length = a.length();\n                    if (length === 0) {\n                        normalized.setAll(NaN);\n                    }\n                }\n                return normalized;\n            default:\n                throw new Error(`Cannot normalize value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Normalize, FlowGraphNormalizeBlock);\n\n/**\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), FlowGraphBlockNames.Dot, config);\n    }\n\n    private _polymorphicDot(a: FlowGraphVector, b: FlowGraphVector) {\n        const className = _GetClassNameOf(a);\n        switch (className) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                // casting is needed because dot requires both to be the same type\n                return (a as Vector3).dot(b as Vector3);\n            default:\n                throw new Error(`Cannot get dot product of ${a} and ${b}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Dot, FlowGraphDotBlock);\n\n/**\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), FlowGraphBlockNames.Cross, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Cross, FlowGraphCrossBlock);\n\n/**\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock<Vector2, number, Vector2> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => a.rotate(b), FlowGraphBlockNames.Rotate2D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate2D, FlowGraphRotate2DBlock);\n\n/**\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphBinaryOperationBlock<Vector3, Quaternion, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeQuaternion, RichTypeVector3, (a, b) => a.applyRotationQuaternion(b), FlowGraphBlockNames.Rotate3D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate3D, FlowGraphRotate3DBlock);\n\nfunction TransformVector(a: FlowGraphVector, b: FlowGraphMatrix): FlowGraphVector {\n    const className = _GetClassNameOf(a);\n    switch (className) {\n        case FlowGraphTypes.Vector2:\n            return (b as FlowGraphMatrix2D).transformVector(a as Vector2);\n        case FlowGraphTypes.Vector3:\n            return (b as FlowGraphMatrix3D).transformVector(a as Vector3);\n        case FlowGraphTypes.Vector4:\n            a = a as Vector4;\n            // transform the vector 4 with the matrix here. Vector4.TransformCoordinates transforms a 3D coordinate, not Vector4\n            return new Vector4(\n                a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3],\n                a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7],\n                a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11],\n                a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]\n            );\n        default:\n            throw new Error(`Cannot transform value ${a}`);\n    }\n}\n\n/**\n * Configuration for the transform block.\n */\nexport interface IFlowGraphTransformBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The vector type\n     */\n    vectorType: FlowGraphTypes;\n}\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphMatrix, FlowGraphVector> {\n    constructor(config?: IFlowGraphTransformBlockConfiguration) {\n        const vectorType = config?.vectorType || FlowGraphTypes.Vector3;\n        const matrixType =\n            vectorType === FlowGraphTypes.Vector2 ? FlowGraphTypes.Matrix2D : vectorType === FlowGraphTypes.Vector3 ? FlowGraphTypes.Matrix3D : FlowGraphTypes.Matrix;\n        super(\n            getRichTypeByFlowGraphType(vectorType),\n            getRichTypeByFlowGraphType(matrixType),\n            getRichTypeByFlowGraphType(vectorType),\n            TransformVector,\n            FlowGraphBlockNames.TransformVector,\n            config\n        );\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformVector, FlowGraphTransformBlock);\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformCoordinatesBlock extends FlowGraphBinaryOperationBlock<Vector3, Matrix, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), FlowGraphBlockNames.TransformCoordinates, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformCoordinates, FlowGraphTransformCoordinatesBlock);\n\n/**\n * Conjugate the quaternion.\n */\nexport class FlowGraphConjugateBlock extends FlowGraphUnaryOperationBlock<Quaternion, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, (a) => a.conjugate(), FlowGraphBlockNames.Conjugate, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.Conjugate, FlowGraphConjugateBlock);\n\n/**\n * Get the angle between two quaternions.\n */\nexport class FlowGraphAngleBetweenBlock extends FlowGraphBinaryOperationBlock<Quaternion, Quaternion, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, RichTypeNumber, (a, b) => GetAngleBetweenQuaternions(a, b), FlowGraphBlockNames.AngleBetween, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AngleBetween, FlowGraphAngleBetweenBlock);\n\n/**\n * Get the quaternion from an axis and an angle.\n */\nexport class FlowGraphQuaternionFromAxisAngleBlock extends FlowGraphBinaryOperationBlock<Vector3, number, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeNumber, RichTypeQuaternion, (a, b) => Quaternion.RotationAxis(a, b), FlowGraphBlockNames.QuaternionFromAxisAngle, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.QuaternionFromAxisAngle, FlowGraphQuaternionFromAxisAngleBlock);\n\n/**\n * Get the axis and angle from a quaternion.\n */\nexport class FlowGraphAxisAngleFromQuaternionBlock extends FlowGraphBlock {\n    /**\n     * The input of this block.\n     */\n    public readonly a: FlowGraphDataConnection<Quaternion>;\n\n    /**\n     * The output axis of rotation.\n     */\n    public readonly axis: FlowGraphDataConnection<Vector3>;\n\n    /**\n     * The output angle of rotation.\n     */\n    public readonly angle: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: Whether the value is valid.\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n\n        this.a = this.registerDataInput(\"a\", RichTypeQuaternion);\n\n        this.axis = this.registerDataOutput(\"axis\", RichTypeVector3);\n        this.angle = this.registerDataOutput(\"angle\", RichTypeNumber);\n\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\n    }\n\n    /** @override */\n    public override _updateOutputs(context: FlowGraphContext) {\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\n        const cachedAxis = context._getExecutionVariable<Nullable<Vector3>>(this, AxisCacheName, null);\n        const cachedAngle = context._getExecutionVariable<Nullable<number>>(this, AngleCacheName, null);\n        if (cachedAxis !== undefined && cachedAxis !== null && cachedAngle !== undefined && cachedAngle !== null && cachedExecutionId === context.executionId) {\n            this.axis.setValue(cachedAxis, context);\n            this.angle.setValue(cachedAngle, context);\n        } else {\n            try {\n                const { axis, angle } = this.a.getValue(context).toAxisAngle();\n                context._setExecutionVariable(this, AxisCacheName, axis);\n                context._setExecutionVariable(this, AngleCacheName, angle);\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\n                this.axis.setValue(axis, context);\n                this.angle.setValue(angle, context);\n                this.isValid.setValue(true, context);\n            } catch (e) {\n                this.isValid.setValue(false, context);\n            }\n        }\n    }\n\n    /** @override */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.AxisAngleFromQuaternion;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AxisAngleFromQuaternion, FlowGraphAxisAngleFromQuaternionBlock);\n\n/**\n * Get the quaternion from two direction vectors.\n */\nexport class FlowGraphQuaternionFromDirectionsBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeQuaternion, (a, b) => GetQuaternionFromDirections(a, b), FlowGraphBlockNames.QuaternionFromDirections, config);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
