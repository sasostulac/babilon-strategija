{
  "version": 3,
  "sources": ["../../../dev/core/src/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.ts"],
  "sourcesContent": ["import type { Observer } from \"../../../Misc/observable\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\n/**\r\n * Parameters used to create a FlowGraphReceiveCustomEventBlock.\r\n */\r\nexport interface IFlowGraphReceiveCustomEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The id of the event to receive.\r\n     * This event id is unique to the environment (not the context).\r\n     */\r\n    eventId: string;\r\n    /**\r\n     * The names of the data outputs for that event. Should be in the same order as the event data in\r\n     * SendCustomEvent\r\n     */\r\n    eventData: { [key: string]: { type: RichType<any> } };\r\n}\r\n\r\n/**\r\n * A block that receives a custom event.\r\n * It saves the event data in the data outputs, based on the provided eventData in the configuration. For example, if the event data is\r\n * `{ x: { type: RichTypeNumber }, y: { type: RichTypeNumber } }`, the block will have two data outputs: x and y.\r\n */\r\nexport class FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {\r\n    public override initPriority: number = 1;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphReceiveCustomEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        // use event data to register data outputs\r\n        for (const key in this.config.eventData) {\r\n            this.registerDataOutput(key, this.config.eventData[key].type);\r\n        }\r\n    }\r\n\r\n    public override _preparePendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        // check if we are not exceeding the max number of events\r\n        if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {\r\n            this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);\r\n            return;\r\n        }\r\n\r\n        const eventObserver = observable.add((eventData: { [key: string]: any }) => {\r\n            const keys = Object.keys(eventData);\r\n            for (const key of keys) {\r\n                this.getDataOutput(key)?.setValue(eventData[key], context);\r\n            }\r\n            this._execute(context);\r\n        });\r\n        context._setExecutionVariable(this, \"_eventObserver\", eventObserver);\r\n    }\r\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        if (observable) {\r\n            const eventObserver = context._getExecutionVariable<Nullable<Observer<any[]>>>(this, \"_eventObserver\", null);\r\n            observable.remove(eventObserver);\r\n        } else {\r\n            Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);\r\n        }\r\n    }\r\n\r\n    public override _executeEvent(_context: FlowGraphContext, _payload: any): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ReceiveCustomEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ReceiveCustomEvent, FlowGraphReceiveCustomEventBlock);\r\n"],
  "mappings": ";;;;;;;;;;;;;;AA+BM,IAAO,mCAAP,cAAgD,oBAAmB;EAGrE,YAIoB,QAAsD;AAEtE,UAAM,MAAM;AAFI,SAAA,SAAA;AANJ,SAAA,eAAuB;AAUnC,eAAW,OAAO,KAAK,OAAO,WAAW;AACrC,WAAK,mBAAmB,KAAK,KAAK,OAAO,UAAU,GAAG,EAAE,IAAI;IAChE;EACJ;EAEgB,qBAAqB,SAAyB;AAC1D,UAAM,aAAa,QAAQ,cAAc,YAAY,yBAAyB,KAAK,OAAO,OAAO;AAEjG,QAAI,cAAc,WAAW,aAAY,KAAM,WAAW,UAAU,SAAS,qBAAqB,kBAAkB;AAChH,WAAK,aAAa,SAAS,kEAAkE,KAAK,OAAO,OAAO,YAAY,qBAAqB,gBAAgB,GAAG;AACpK;IACJ;AAEA,UAAM,gBAAgB,WAAW,IAAI,CAAC,cAAqC;AACvE,YAAM,OAAO,OAAO,KAAK,SAAS;AAClC,iBAAW,OAAO,MAAM;AACpB,aAAK,cAAc,GAAG,GAAG,SAAS,UAAU,GAAG,GAAG,OAAO;MAC7D;AACA,WAAK,SAAS,OAAO;IACzB,CAAC;AACD,YAAQ,sBAAsB,MAAM,kBAAkB,aAAa;EACvE;EACgB,oBAAoB,SAAyB;AACzD,UAAM,aAAa,QAAQ,cAAc,YAAY,yBAAyB,KAAK,OAAO,OAAO;AACjG,QAAI,YAAY;AACZ,YAAM,gBAAgB,QAAQ,sBAAiD,MAAM,kBAAkB,IAAI;AAC3G,iBAAW,OAAO,aAAa;IACnC,OAAO;AACH,YAAM,KAAK,kEAAkE,KAAK,OAAO,OAAO,EAAE;IACtG;EACJ;EAEgB,cAAc,UAA4B,UAAa;AACnE,WAAO;EACX;;;;EAKgB,eAAY;AACxB,WAAA;EACJ;;AAEJ,cAAa,oCAAyC,gCAAgC;",
  "names": []
}
