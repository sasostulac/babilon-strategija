{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/dumpTools.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { _WarnImport } from \"./devTools\";\r\n\r\nimport type { ThinEngine } from \"../Engines/thinEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\r\nimport { Tools } from \"./tools\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Logger } from \"./logger\";\r\n\r\ntype DumpResources = {\r\n    canvas: HTMLCanvasElement | OffscreenCanvas;\r\n    dumpEngine?: {\r\n        engine: ThinEngine;\r\n        renderer: EffectRenderer;\r\n        wrapper: EffectWrapper;\r\n    };\r\n};\r\n\r\nlet ResourcesPromise: Promise<DumpResources> | null = null;\r\n\r\nasync function _CreateDumpResourcesAsync(): Promise<DumpResources> {\r\n    // Create a compatible canvas. Prefer an HTMLCanvasElement if possible to avoid alpha issues with OffscreenCanvas + WebGL in many browsers.\r\n    const canvas = (EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100)) as HTMLCanvasElement | OffscreenCanvas; // will be resized later\r\n    if (canvas instanceof OffscreenCanvas) {\r\n        Logger.Warn(\"DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.\");\r\n    }\r\n\r\n    // If WebGL via ThinEngine is not available (e.g. Native), use the BitmapRenderer.\r\n    // If https://github.com/whatwg/html/issues/10142 is resolved, we can migrate to just BitmapRenderer and avoid an engine dependency altogether.\r\n    const { ThinEngine: thinEngineClass } = await import(\"../Engines/thinEngine\");\r\n    if (!thinEngineClass.IsSupported) {\r\n        if (!canvas.getContext(\"bitmaprenderer\")) {\r\n            throw new Error(\"DumpData: No WebGL or bitmap rendering context available. Cannot dump data.\");\r\n        }\r\n        return { canvas };\r\n    }\r\n\r\n    const options = {\r\n        preserveDrawingBuffer: true,\r\n        depth: false,\r\n        stencil: false,\r\n        alpha: true,\r\n        premultipliedAlpha: false,\r\n        antialias: false,\r\n        failIfMajorPerformanceCaveat: false,\r\n    };\r\n    const engine = new thinEngineClass(canvas, false, options);\r\n\r\n    // remove this engine from the list of instances to avoid using it for other purposes\r\n    EngineStore.Instances.pop();\r\n    // However, make sure to dispose it when no other engines are left\r\n    EngineStore.OnEnginesDisposedObservable.add((e) => {\r\n        // guaranteed to run when no other instances are left\r\n        // only dispose if it's not the current engine\r\n        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\r\n            // Dump the engine and the associated resources\r\n            Dispose();\r\n        }\r\n    });\r\n\r\n    engine.getCaps().parallelShaderCompile = undefined;\r\n\r\n    const renderer = new EffectRenderer(engine);\r\n    const { passPixelShader } = await import(\"../Shaders/pass.fragment\");\r\n    const wrapper = new EffectWrapper({\r\n        engine,\r\n        name: passPixelShader.name,\r\n        fragmentShader: passPixelShader.shader,\r\n        samplerNames: [\"textureSampler\"],\r\n    });\r\n\r\n    return {\r\n        canvas: canvas,\r\n        dumpEngine: { engine, renderer, wrapper },\r\n    };\r\n}\r\n\r\nasync function _GetDumpResourcesAsync() {\r\n    if (!ResourcesPromise) {\r\n        ResourcesPromise = _CreateDumpResourcesAsync();\r\n    }\r\n    return await ResourcesPromise;\r\n}\r\n\r\n/**\r\n * Dumps the current bound framebuffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param engine defines the hosting engine\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a void promise\r\n */\r\n// Should have \"Async\" in the name but this is a public API and we can't break it now\r\n// eslint-disable-next-line no-restricted-syntax\r\nexport async function DumpFramebuffer(\r\n    width: number,\r\n    height: number,\r\n    engine: AbstractEngine,\r\n    successCallback?: (data: string) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    quality?: number\r\n) {\r\n    // Read the contents of the framebuffer\r\n    const bufferView = await engine.readPixels(0, 0, width, height);\r\n\r\n    const data = new Uint8Array(bufferView.buffer);\r\n\r\n    DumpData(width, height, data, successCallback as (data: string | ArrayBuffer) => void, mimeType, fileName, true, undefined, quality);\r\n}\r\n\r\nexport async function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType: string | undefined,\r\n    fileName: string | undefined,\r\n    invertY: boolean | undefined,\r\n    toArrayBuffer: true,\r\n    quality?: number\r\n): Promise<ArrayBuffer>;\r\nexport async function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType?: string,\r\n    fileName?: string,\r\n    invertY?: boolean,\r\n    toArrayBuffer?: boolean,\r\n    quality?: number\r\n): Promise<string>;\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n * @returns a promise that resolve to the final data\r\n */\r\nexport async function DumpDataAsync(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): Promise<string | ArrayBuffer> {\r\n    // Convert if data are float32\r\n    if (data instanceof Float32Array) {\r\n        const data2 = new Uint8Array(data.length);\r\n        let n = data.length;\r\n        while (n--) {\r\n            const v = data[n];\r\n            data2[n] = Math.round(Clamp(v) * 255);\r\n        }\r\n        data = data2;\r\n    }\r\n\r\n    const resources = await _GetDumpResourcesAsync();\r\n\r\n    // Keep the async render + read from the shared canvas atomic\r\n    // eslint-disable-next-line no-async-promise-executor\r\n    return await new Promise<string | ArrayBuffer>(async (resolve) => {\r\n        if (resources.dumpEngine) {\r\n            const dumpEngine = resources.dumpEngine;\r\n            dumpEngine.engine.setSize(width, height, true);\r\n\r\n            // Create the image\r\n            const texture = dumpEngine.engine.createRawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\r\n\r\n            dumpEngine.renderer.setViewport();\r\n            dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);\r\n            dumpEngine.wrapper.effect._bindTexture(\"textureSampler\", texture);\r\n            dumpEngine.renderer.draw();\r\n\r\n            texture.dispose();\r\n        } else {\r\n            const ctx = resources.canvas.getContext(\"bitmaprenderer\") as ImageBitmapRenderingContext;\r\n            resources.canvas.width = width;\r\n            resources.canvas.height = height;\r\n\r\n            const imageData = new ImageData(width, height); // ImageData(data, sw, sh) ctor not yet widely implemented\r\n            imageData.data.set(data as Uint8ClampedArray);\r\n            const imageBitmap = await createImageBitmap(imageData, { premultiplyAlpha: \"none\", imageOrientation: invertY ? \"flipY\" : \"from-image\" });\r\n\r\n            ctx.transferFromImageBitmap(imageBitmap);\r\n        }\r\n\r\n        Tools.ToBlob(\r\n            resources.canvas,\r\n            (blob) => {\r\n                if (!blob) {\r\n                    throw new Error(\"DumpData: Failed to convert canvas to blob.\");\r\n                }\r\n\r\n                if (fileName !== undefined) {\r\n                    Tools.DownloadBlob(blob, fileName);\r\n                }\r\n\r\n                const fileReader = new FileReader();\r\n                fileReader.onload = (event: any) => {\r\n                    const result = event.target!.result as string | ArrayBuffer;\r\n                    resolve(result);\r\n                };\r\n\r\n                if (toArrayBuffer) {\r\n                    fileReader.readAsArrayBuffer(blob);\r\n                } else {\r\n                    fileReader.readAsDataURL(blob);\r\n                }\r\n            },\r\n            mimeType,\r\n            quality\r\n        );\r\n    });\r\n}\r\n\r\n/**\r\n * Dumps an array buffer\r\n * @param width defines the rendering width\r\n * @param height defines the rendering height\r\n * @param data the data array\r\n * @param successCallback defines the callback triggered once the data are available\r\n * @param mimeType defines the mime type of the result\r\n * @param fileName The name of the file to download. If present, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\r\n * @param invertY true to invert the picture in the Y dimension\r\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\r\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\r\n */\r\nexport function DumpData(\r\n    width: number,\r\n    height: number,\r\n    data: ArrayBufferView,\r\n    successCallback?: (data: string | ArrayBuffer) => void,\r\n    mimeType = \"image/png\",\r\n    fileName?: string,\r\n    invertY = false,\r\n    toArrayBuffer = false,\r\n    quality?: number\r\n): void {\r\n    // For back-compat: if no fileName and no callback, force download the result\r\n    if (fileName === undefined && !successCallback) {\r\n        fileName = \"\";\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n    DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality)\r\n        // eslint-disable-next-line github/no-then\r\n        .then((result) => {\r\n            if (successCallback) {\r\n                successCallback(result);\r\n            }\r\n        });\r\n}\r\n\r\n/**\r\n * Dispose the dump tools associated resources\r\n */\r\nexport function Dispose() {\r\n    if (!ResourcesPromise) {\r\n        return;\r\n    }\r\n\r\n    // in cases where the engine is not yet created, we need to wait for it to dispose it\r\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n    ResourcesPromise?.then((resources) => {\r\n        if (resources.canvas instanceof HTMLCanvasElement) {\r\n            resources.canvas.remove();\r\n        }\r\n        if (resources.dumpEngine) {\r\n            resources.dumpEngine.engine.dispose();\r\n            resources.dumpEngine.renderer.dispose();\r\n            resources.dumpEngine.wrapper.dispose();\r\n        }\r\n    });\r\n\r\n    ResourcesPromise = null;\r\n}\r\n\r\n/**\r\n * Object containing a set of static utilities functions to dump data from a canvas\r\n * @deprecated use functions\r\n */\r\nexport const DumpTools = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpData,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpDataAsync,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    DumpFramebuffer,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    Dispose,\r\n};\r\n\r\n/**\r\n * This will be executed automatically for UMD and es5.\r\n * If esm dev wants the side effects to execute they will have to run it manually\r\n * Once we build native modules those need to be exported.\r\n * @internal\r\n */\r\nconst InitSideEffects = () => {\r\n    // References the dependencies.\r\n    Tools.DumpData = DumpData;\r\n    Tools.DumpDataAsync = DumpDataAsync;\r\n    Tools.DumpFramebuffer = DumpFramebuffer;\r\n};\r\n\r\nInitSideEffects();\r\n"],
  "mappings": "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",
  "names": []
}
