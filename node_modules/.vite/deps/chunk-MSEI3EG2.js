import {
  FlowGraphBinaryOperationBlock
} from "./chunk-3EPZWF7E.js";
import {
  FlowGraphUnaryOperationBlock
} from "./chunk-FDTFCBEE.js";
import {
  _GetClassNameOf
} from "./chunk-3F6WI3CQ.js";
import {
  FlowGraphBlock,
  RichTypeAny,
  RichTypeBoolean,
  RichTypeMatrix,
  RichTypeNumber,
  RichTypeQuaternion,
  RichTypeVector2,
  RichTypeVector3,
  getRichTypeByFlowGraphType
} from "./chunk-OCDSLKBA.js";
import {
  Quaternion,
  Vector3,
  Vector4
} from "./chunk-EURVBQY7.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Clamp
} from "./chunk-QCCD6NMF.js";

// node_modules/@babylonjs/core/Maths/math.vector.functions.js
function Vector2ToFixed(vector, decimalCount) {
  return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)}}`;
}
function Vector3Dot(a, b) {
  return a.x * b.x + a.y * b.y + a.z * b.z;
}
function Vector3FromFloatsToRef(x, y, z, result) {
  result.x = x;
  result.y = y;
  result.z = z;
  return result;
}
function Vector3ScaleToRef(a, scale, result) {
  result.x = a.x * scale;
  result.y = a.y * scale;
  result.z = a.z * scale;
  return result;
}
function Vector3ToFixed(vector, decimalCount) {
  return `{X: ${vector._x.toFixed(decimalCount)} Y: ${vector._y.toFixed(decimalCount)} Z: ${vector._z.toFixed(decimalCount)}}`;
}
function Vector4ToFixed(vector, decimalCount) {
  return `{X: ${vector.x.toFixed(decimalCount)} Y: ${vector.y.toFixed(decimalCount)} Z: ${vector.z.toFixed(decimalCount)} W: ${vector.w.toFixed(decimalCount)}}`;
}
function GetAngleBetweenQuaternions(q1, q2) {
  return Math.acos(Clamp(Quaternion.Dot(q1, q2))) * 2;
}
function GetQuaternionFromDirections(a, b) {
  const result = new Quaternion();
  GetQuaternionFromDirectionsToRef(a, b, result);
  return result;
}
function GetQuaternionFromDirectionsToRef(a, b, result) {
  const axis = Vector3.Cross(a, b);
  const angle = Math.acos(Clamp(Vector3Dot(a, b), -1, 1));
  Quaternion.RotationAxisToRef(axis, angle, result);
  return result;
}

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.js
var AxisCacheName = "cachedOperationAxis";
var AngleCacheName = "cachedOperationAngle";
var CacheExecIdName = "cachedExecutionId";
var FlowGraphLengthBlock = class extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), "FlowGraphLengthBlock", config);
  }
  _polymorphicLength(a) {
    const aClassName = _GetClassNameOf(a);
    switch (aClassName) {
      case "Vector2":
      case "Vector3":
      case "Vector4":
      case "Quaternion":
        return a.length();
      default:
        throw new Error(`Cannot compute length of value ${a}`);
    }
  }
};
RegisterClass("FlowGraphLengthBlock", FlowGraphLengthBlock);
var FlowGraphNormalizeBlock = class extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), "FlowGraphNormalizeBlock", config);
  }
  _polymorphicNormalize(a) {
    const aClassName = _GetClassNameOf(a);
    let normalized;
    switch (aClassName) {
      case "Vector2":
      case "Vector3":
      case "Vector4":
      case "Quaternion":
        normalized = a.normalizeToNew();
        if (this.config?.nanOnZeroLength) {
          const length = a.length();
          if (length === 0) {
            normalized.setAll(NaN);
          }
        }
        return normalized;
      default:
        throw new Error(`Cannot normalize value ${a}`);
    }
  }
};
RegisterClass("FlowGraphNormalizeBlock", FlowGraphNormalizeBlock);
var FlowGraphDotBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), "FlowGraphDotBlock", config);
  }
  _polymorphicDot(a, b) {
    const className = _GetClassNameOf(a);
    switch (className) {
      case "Vector2":
      case "Vector3":
      case "Vector4":
      case "Quaternion":
        return a.dot(b);
      default:
        throw new Error(`Cannot get dot product of ${a} and ${b}`);
    }
  }
};
RegisterClass("FlowGraphDotBlock", FlowGraphDotBlock);
var FlowGraphCrossBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), "FlowGraphCrossBlock", config);
  }
};
RegisterClass("FlowGraphCrossBlock", FlowGraphCrossBlock);
var FlowGraphRotate2DBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => a.rotate(b), "FlowGraphRotate2DBlock", config);
  }
};
RegisterClass("FlowGraphRotate2DBlock", FlowGraphRotate2DBlock);
var FlowGraphRotate3DBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeQuaternion, RichTypeVector3, (a, b) => a.applyRotationQuaternion(b), "FlowGraphRotate3DBlock", config);
  }
};
RegisterClass("FlowGraphRotate3DBlock", FlowGraphRotate3DBlock);
function TransformVector(a, b) {
  const className = _GetClassNameOf(a);
  switch (className) {
    case "Vector2":
      return b.transformVector(a);
    case "Vector3":
      return b.transformVector(a);
    case "Vector4":
      a = a;
      return new Vector4(a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3], a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7], a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11], a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]);
    default:
      throw new Error(`Cannot transform value ${a}`);
  }
}
var FlowGraphTransformBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    const vectorType = config?.vectorType || "Vector3";
    const matrixType = vectorType === "Vector2" ? "Matrix2D" : vectorType === "Vector3" ? "Matrix3D" : "Matrix";
    super(getRichTypeByFlowGraphType(vectorType), getRichTypeByFlowGraphType(matrixType), getRichTypeByFlowGraphType(vectorType), TransformVector, "FlowGraphTransformVectorBlock", config);
  }
};
RegisterClass("FlowGraphTransformVectorBlock", FlowGraphTransformBlock);
var FlowGraphTransformCoordinatesBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), "FlowGraphTransformCoordinatesBlock", config);
  }
};
RegisterClass("FlowGraphTransformCoordinatesBlock", FlowGraphTransformCoordinatesBlock);
var FlowGraphConjugateBlock = class extends FlowGraphUnaryOperationBlock {
  constructor(config) {
    super(RichTypeQuaternion, RichTypeQuaternion, (a) => a.conjugate(), "FlowGraphConjugateBlock", config);
  }
};
RegisterClass("FlowGraphConjugateBlock", FlowGraphConjugateBlock);
var FlowGraphAngleBetweenBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeQuaternion, RichTypeQuaternion, RichTypeNumber, (a, b) => GetAngleBetweenQuaternions(a, b), "FlowGraphAngleBetweenBlock", config);
  }
};
RegisterClass("FlowGraphAngleBetweenBlock", FlowGraphAngleBetweenBlock);
var FlowGraphQuaternionFromAxisAngleBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeNumber, RichTypeQuaternion, (a, b) => Quaternion.RotationAxis(a, b), "FlowGraphQuaternionFromAxisAngleBlock", config);
  }
};
RegisterClass("FlowGraphQuaternionFromAxisAngleBlock", FlowGraphQuaternionFromAxisAngleBlock);
var FlowGraphAxisAngleFromQuaternionBlock = class extends FlowGraphBlock {
  constructor(config) {
    super(config);
    this.a = this.registerDataInput("a", RichTypeQuaternion);
    this.axis = this.registerDataOutput("axis", RichTypeVector3);
    this.angle = this.registerDataOutput("angle", RichTypeNumber);
    this.isValid = this.registerDataOutput("isValid", RichTypeBoolean);
  }
  /** @override */
  _updateOutputs(context) {
    const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);
    const cachedAxis = context._getExecutionVariable(this, AxisCacheName, null);
    const cachedAngle = context._getExecutionVariable(this, AngleCacheName, null);
    if (cachedAxis !== void 0 && cachedAxis !== null && cachedAngle !== void 0 && cachedAngle !== null && cachedExecutionId === context.executionId) {
      this.axis.setValue(cachedAxis, context);
      this.angle.setValue(cachedAngle, context);
    } else {
      try {
        const { axis, angle } = this.a.getValue(context).toAxisAngle();
        context._setExecutionVariable(this, AxisCacheName, axis);
        context._setExecutionVariable(this, AngleCacheName, angle);
        context._setExecutionVariable(this, CacheExecIdName, context.executionId);
        this.axis.setValue(axis, context);
        this.angle.setValue(angle, context);
        this.isValid.setValue(true, context);
      } catch (e) {
        this.isValid.setValue(false, context);
      }
    }
  }
  /** @override */
  getClassName() {
    return "FlowGraphAxisAngleFromQuaternionBlock";
  }
};
RegisterClass("FlowGraphAxisAngleFromQuaternionBlock", FlowGraphAxisAngleFromQuaternionBlock);
var FlowGraphQuaternionFromDirectionsBlock = class extends FlowGraphBinaryOperationBlock {
  constructor(config) {
    super(RichTypeVector3, RichTypeVector3, RichTypeQuaternion, (a, b) => GetQuaternionFromDirections(a, b), "FlowGraphQuaternionFromDirectionsBlock", config);
  }
};

export {
  Vector2ToFixed,
  Vector3Dot,
  Vector3FromFloatsToRef,
  Vector3ScaleToRef,
  Vector3ToFixed,
  Vector4ToFixed,
  GetAngleBetweenQuaternions,
  GetQuaternionFromDirections,
  GetQuaternionFromDirectionsToRef,
  FlowGraphLengthBlock,
  FlowGraphNormalizeBlock,
  FlowGraphDotBlock,
  FlowGraphCrossBlock,
  FlowGraphRotate2DBlock,
  FlowGraphRotate3DBlock,
  FlowGraphTransformBlock,
  FlowGraphTransformCoordinatesBlock,
  FlowGraphConjugateBlock,
  FlowGraphAngleBetweenBlock,
  FlowGraphQuaternionFromAxisAngleBlock,
  FlowGraphAxisAngleFromQuaternionBlock,
  FlowGraphQuaternionFromDirectionsBlock
};
//# sourceMappingURL=chunk-MSEI3EG2.js.map
