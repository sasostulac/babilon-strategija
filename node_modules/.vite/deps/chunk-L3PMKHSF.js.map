{
  "version": 3,
  "sources": ["../../../dev/core/src/Animations/animationEvent.ts", "../../../dev/core/src/AudioV2/abstractAudio/audioEngineV2.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/abstractSpatialAudioListener.ts", "../../../dev/core/src/AudioV2/abstractAudio/subProperties/spatialAudioListener.ts", "../../../dev/core/src/AudioV2/webAudio/subProperties/spatialWebAudioListener.ts", "../../../dev/core/src/AudioV2/abstractAudio/mainAudioOut.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioMainOut.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioUnmuteUI.ts", "../../../dev/core/src/AudioV2/webAudio/webAudioEngine.ts", "../../../dev/core/src/Audio/audioEngine.ts", "../../../dev/core/src/Audio/sound.ts", "../../../dev/core/src/Audio/soundTrack.ts", "../../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts", "../../../dev/core/src/Audio/audioSceneComponent.ts", "../../../dev/core/src/Audio/weightedsound.ts", "../../../dev/core/src/Bones/skeleton.ts", "../../../dev/core/src/Culling/ray.core.ts", "../../../dev/core/src/Cameras/Inputs/BaseCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/cameraInputsManager.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraKeyboardMoveInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraMouseWheelInput.ts", "../../../dev/core/src/Cameras/Inputs/freeCameraTouchInput.ts", "../../../dev/core/src/Cameras/freeCameraInputsManager.ts", "../../../dev/core/src/Cameras/freeCamera.ts", "../../../dev/core/src/Lights/hemisphericLight.ts", "../../../dev/core/src/FlowGraph/Blocks/flowGraphBlockFactory.ts", "../../../dev/core/src/FlowGraph/flowGraphParser.ts", "../../../dev/core/src/Materials/Textures/cubeTexture.ts", "../../../dev/core/src/Lights/pointLight.ts", "../../../dev/core/src/Lights/LTC/ltcTextureTool.ts", "../../../dev/core/src/Lights/areaLight.ts", "../../../dev/core/src/Lights/rectAreaLight.ts", "../../../dev/core/src/Materials/Textures/rawTexture2DArray.ts", "../../../dev/core/src/Morph/morphTargetManager.ts", "../../../dev/core/src/Materials/Textures/rawCubeTexture.ts", "../../../dev/core/src/Materials/shadowDepthWrapper.ts", "../../../dev/core/src/Shaders/gaussianSplattingDepth.fragment.ts", "../../../dev/core/src/Shaders/gaussianSplattingDepth.vertex.ts", "../../../dev/core/src/ShadersWGSL/gaussianSplattingDepth.fragment.ts", "../../../dev/core/src/ShadersWGSL/gaussianSplattingDepth.vertex.ts", "../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingMaterial.ts", "../../../dev/core/src/Meshes/Compression/dracoDecoder.ts", "../../../dev/core/src/Meshes/Compression/meshoptCompression.ts", "../../../dev/core/src/Meshes/GaussianSplatting/gaussianSplattingMesh.ts", "../../../dev/core/src/Misc/deferred.ts", "../../../dev/core/src/Misc/dataReader.ts", "../../../dev/core/src/Misc/lazy.ts", "../../../dev/core/src/Particles/cloudPoint.ts", "../../../dev/core/src/Culling/ray.ts", "../../../dev/core/src/Particles/pointsCloudSystem.ts"],
  "sourcesContent": ["/**\r\n * Composed of a frame, and an action function\r\n */\r\nexport class AnimationEvent {\r\n    /**\r\n     * Specifies if the animation event is done\r\n     */\r\n    public isDone: boolean = false;\r\n\r\n    /**\r\n     * Initializes the animation event\r\n     * @param frame The frame for which the event is triggered\r\n     * @param action The event to perform when triggered\r\n     * @param onlyOnce Specifies if the event should be triggered only once\r\n     */\r\n    constructor(\r\n        /** The frame for which the event is triggered **/\r\n        public frame: number,\r\n        /** The event to perform when triggered **/\r\n        public action: (currentFrame: number) => void,\r\n        /** Specifies if the event should be triggered only once**/\r\n        public onlyOnce?: boolean\r\n    ) {}\r\n\r\n    /** @internal */\r\n    public _clone(): AnimationEvent {\r\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport type { AbstractAudioNode, AbstractNamedAudioNode } from \"./abstractAudioNode\";\nimport type { AbstractSoundSource, ISoundSourceOptions } from \"./abstractSoundSource\";\nimport type { AudioBus, IAudioBusOptions } from \"./audioBus\";\nimport type { IMainAudioBusOptions, MainAudioBus } from \"./mainAudioBus\";\nimport type { IStaticSoundOptions, StaticSound } from \"./staticSound\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { IStreamingSoundOptions, StreamingSound } from \"./streamingSound\";\nimport type { AbstractSpatialAudioListener, ISpatialAudioListenerOptions } from \"./subProperties/abstractSpatialAudioListener\";\n\nconst Instances: AudioEngineV2[] = [];\n\n/**\n * Gets the most recently created v2 audio engine.\n * @returns The most recently created v2 audio engine.\n */\nexport function LastCreatedAudioEngine(): Nullable<AudioEngineV2> {\n    if (Instances.length === 0) {\n        return null;\n    }\n\n    return Instances[Instances.length - 1];\n}\n\n/**\n * Options for creating a v2 audio engine.\n */\nexport interface IAudioEngineV2Options extends ISpatialAudioListenerOptions {\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     */\n    parameterRampDuration: number;\n    /**\n     * The initial output volume of the audio engine. Defaults to `1`.\n     */\n    volume: number;\n}\n\n/**\n * The state of a v2 audio engine.\n * @see {@link AudioEngineV2.state}\n */\nexport type AudioEngineV2State = \"closed\" | \"interrupted\" | \"running\" | \"suspended\";\n\n/**\n * Abstract base class for v2 audio engines.\n *\n * A v2 audio engine based on the WebAudio API can be created with the {@link CreateAudioEngineAsync} function.\n */\nexport abstract class AudioEngineV2 {\n    /** Not owned, but all items should be in `_nodes` container, too, which is owned. */\n    private readonly _mainBuses = new Set<MainAudioBus>();\n\n    /** Owned top-level sound and bus nodes. */\n    private readonly _nodes = new Set<AbstractNamedAudioNode>();\n\n    private _defaultMainBus: Nullable<MainAudioBus> = null;\n\n    private _parameterRampDuration: number = 0.01;\n\n    protected constructor(options: Partial<IAudioEngineV2Options>) {\n        Instances.push(this);\n\n        if (typeof options.parameterRampDuration === \"number\") {\n            this.parameterRampDuration = options.parameterRampDuration;\n        }\n    }\n\n    /**\n     * The elapsed time since the audio engine was started, in seconds.\n     */\n    public abstract readonly currentTime: number;\n\n    /**\n     * The default main bus that will be used for audio buses and sounds if their `outBus` option is not set.\n     * @see {@link IAudioBusOptions.outBus}\n     * @see {@link IAbstractSoundOptions.outBus}\n     */\n    public get defaultMainBus(): Nullable<MainAudioBus> {\n        if (this._mainBuses.size === 0) {\n            return null;\n        }\n\n        if (!this._defaultMainBus) {\n            this._defaultMainBus = Array.from(this._mainBuses)[0];\n        }\n\n        return this._defaultMainBus;\n    }\n\n    /**\n     * The spatial audio listener properties for the audio engine.\n     * - Each audio engine has exactly one listener.\n     */\n    public abstract readonly listener: AbstractSpatialAudioListener;\n\n    /**\n     * The main output node.\n     * - This is the last node in the audio graph before the audio is sent to the speakers.\n     */\n    public abstract readonly mainOut: AbstractAudioNode;\n\n    /**\n     * The current state of the audio engine.\n     *\n     * Possible values are:\n     * - `\"closed\"`: The audio engine has been closed.\n     * - `\"interrupted\"`: The audio engine has been interrupted and is not running.\n     * - `\"running\"`: The audio engine is running normally.\n     * - `\"suspended\"`: The audio engine is suspended and is not running.\n     */\n    public abstract readonly state: AudioEngineV2State;\n\n    /**\n     * The output volume of the audio engine.\n     */\n    public abstract volume: number;\n\n    /**\n     * The smoothing duration to use when changing audio parameters, in seconds. Defaults to `0.01` (10 milliseconds).\n     *\n     * Due to limitations in some browsers, it is not recommended to set this value to longer than `0.01` seconds.\n     *\n     * Setting this value to longer than `0.01` seconds may result in errors being throw when setting audio parameters.\n     */\n    public get parameterRampDuration(): number {\n        return this._parameterRampDuration;\n    }\n\n    public set parameterRampDuration(value: number) {\n        this._parameterRampDuration = Math.max(0, value);\n    }\n\n    /**\n     * Creates a new audio bus.\n     * @param name - The name of the audio bus.\n     * @param options - The options to use when creating the audio bus.\n     * @returns A promise that resolves with the created audio bus.\n     */\n    public abstract createBusAsync(name: string, options?: Partial<IAudioBusOptions>): Promise<AudioBus>;\n\n    /**\n     * Creates a new main audio bus.\n     * @param name - The name of the main audio bus.\n     * @param options - The options to use when creating the main audio bus.\n     * @returns A promise that resolves with the created main audio bus.\n     */\n    public abstract createMainBusAsync(name: string, options?: Partial<IMainAudioBusOptions>): Promise<MainAudioBus>;\n\n    /**\n     * Creates a new microphone sound source.\n     * @param name - The name of the sound.\n     * @param options - The options for the sound source.\n     * @returns A promise that resolves to the created sound source.\n     */\n    public abstract createMicrophoneSoundSourceAsync(name: string, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource>;\n\n    /**\n     * Creates a new static sound.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the static sound.\n     * @returns A promise that resolves to the created static sound.\n     */\n    public abstract createSoundAsync(\n        name: string,\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options?: Partial<IStaticSoundOptions>\n    ): Promise<StaticSound>;\n\n    /**\n     * Creates a new static sound buffer.\n     * @param source - The source of the sound buffer.\n     * @param options - The options for the static sound buffer.\n     * @returns A promise that resolves to the created static sound buffer.\n     */\n    public abstract createSoundBufferAsync(\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options?: Partial<IStaticSoundBufferOptions>\n    ): Promise<StaticSoundBuffer>;\n\n    /**\n     * Creates a new sound source.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the sound source.\n     * @returns A promise that resolves to the created sound source.\n     */\n    public abstract createSoundSourceAsync(name: string, source: AudioNode, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource>;\n\n    /**\n     * Creates a new streaming sound.\n     * @param name - The name of the sound.\n     * @param source - The source of the sound.\n     * @param options - The options for the streaming sound.\n     * @returns A promise that resolves to the created streaming sound.\n     */\n    public abstract createStreamingSoundAsync(name: string, source: HTMLMediaElement | string | string[], options?: Partial<IStreamingSoundOptions>): Promise<StreamingSound>;\n\n    /**\n     * Releases associated resources.\n     */\n    public dispose(): void {\n        if (Instances.includes(this)) {\n            Instances.splice(Instances.indexOf(this), 1);\n        }\n\n        const nodeIt = this._nodes.values();\n        for (let next = nodeIt.next(); !next.done; next = nodeIt.next()) {\n            next.value.dispose();\n        }\n\n        this._mainBuses.clear();\n        this._nodes.clear();\n\n        this._defaultMainBus = null;\n    }\n\n    /**\n     * Checks if the specified format is valid.\n     * @param format The format to check as an audio file extension like \"mp3\" or \"wav\".\n     * @returns `true` if the format is valid; otherwise `false`.\n     */\n    public abstract isFormatValid(format: string): boolean;\n\n    /**\n     * Pauses the audio engine if it is running.\n     * @returns A promise that resolves when the audio engine is paused.\n     */\n    public abstract pauseAsync(): Promise<void>;\n\n    /**\n     * Resumes the audio engine if it is not running.\n     * @returns A promise that resolves when the audio engine is running.\n     */\n    public abstract resumeAsync(): Promise<void>;\n\n    /**\n     * Sets the audio output volume with optional ramping.\n     * If the duration is 0 then the volume is set immediately, otherwise it is ramped to the new value over the given duration using the given shape.\n     * If a ramp is already in progress then the volume is not set and an error is thrown.\n     * @param value The value to set the volume to.\n     * @param options The options to use for ramping the volume change.\n     */\n    public abstract setVolume(value: number, options?: Partial<IAudioParameterRampOptions>): void;\n\n    /**\n     * Unlocks the audio engine if it is locked.\n     * - Note that the returned promise may already be resolved if the audio engine is already unlocked.\n     * @returns A promise that is resolved when the audio engine is unlocked.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public unlockAsync(): Promise<void> {\n        return this.resumeAsync();\n    }\n\n    protected _addMainBus(mainBus: MainAudioBus): void {\n        this._mainBuses.add(mainBus);\n\n        this._addNode(mainBus);\n    }\n\n    protected _removeMainBus(mainBus: MainAudioBus): void {\n        this._mainBuses.delete(mainBus);\n        this._defaultMainBus = null;\n\n        this._removeNode(mainBus);\n    }\n\n    protected _addNode(node: AbstractNamedAudioNode): void {\n        this._nodes.add(node);\n    }\n\n    protected _removeNode(node: AbstractNamedAudioNode): void {\n        this._nodes.delete(node);\n    }\n}\n\n/**\n * @internal\n * @param engine - The given audio engine. If `null` then the last created audio engine is used.\n * @returns the given audio engine or the last created audio engine.\n * @throws An error if the resulting engine is `null`.\n */\nexport function _GetAudioEngine(engine: Nullable<AudioEngineV2>): AudioEngineV2 {\n    if (!engine) {\n        engine = LastCreatedAudioEngine();\n    }\n\n    if (engine) {\n        return engine;\n    }\n\n    throw new Error(\"No audio engine.\");\n}\n\n/**\n * Creates a new audio bus.\n * @param name - The name of the audio bus.\n * @param options - The options to use when creating the audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateAudioBusAsync(name: string, options: Partial<IAudioBusOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<AudioBus> {\n    engine = _GetAudioEngine(engine);\n    return engine.createBusAsync(name, options);\n}\n\n/**\n * Creates a new main audio bus.\n * @param name - The name of the main audio bus.\n * @param options - The options to use when creating the main audio bus.\n * @param engine - The audio engine.\n * @returns A promise that resolves with the created main audio bus.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMainAudioBusAsync(name: string, options: Partial<IMainAudioBusOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<MainAudioBus> {\n    engine = _GetAudioEngine(engine);\n    return engine.createMainBusAsync(name, options);\n}\n\n/**\n * Creates a new microphone sound source.\n * @param name - The name of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateMicrophoneSoundSourceAsync(name: string, options: Partial<ISoundSourceOptions> = {}, engine: Nullable<AudioEngineV2> = null): Promise<AbstractSoundSource> {\n    engine = _GetAudioEngine(engine);\n    return engine.createMicrophoneSoundSourceAsync(name, options);\n}\n\n/**\n * Creates a new static sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the static sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundAsync(\n    name: string,\n    source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n    options: Partial<IStaticSoundOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StaticSound> {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundAsync(name, source, options);\n}\n\n/**\n * Creates a new static sound buffer.\n * @param source - The source of the sound buffer.\n * @param options - The options for the static sound buffer.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created static sound buffer.\n */\nexport async function CreateSoundBufferAsync(\n    source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n    options: Partial<IStaticSoundBufferOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StaticSoundBuffer> {\n    engine = _GetAudioEngine(engine);\n    return await engine.createSoundBufferAsync(source, options);\n}\n\n/**\n * Creates a new sound source.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the sound source.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created sound source.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateSoundSourceAsync(\n    name: string,\n    source: AudioNode,\n    options: Partial<ISoundSourceOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<AbstractSoundSource> {\n    engine = _GetAudioEngine(engine);\n    return engine.createSoundSourceAsync(name, source, options);\n}\n\n/**\n * Creates a new streaming sound.\n * @param name - The name of the sound.\n * @param source - The source of the sound.\n * @param options - The options for the streaming sound.\n * @param engine - The audio engine.\n * @returns A promise that resolves to the created streaming sound.\n */\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\nexport function CreateStreamingSoundAsync(\n    name: string,\n    source: HTMLMediaElement | string | string[],\n    options: Partial<IStreamingSoundOptions> = {},\n    engine: Nullable<AudioEngineV2> = null\n): Promise<StreamingSound> {\n    engine = _GetAudioEngine(engine);\n    return engine.createStreamingSoundAsync(name, source, options);\n}\n", "import { Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport type { Node } from \"../../../node\";\nimport type { Nullable } from \"../../../types\";\nimport type { SpatialAudioAttachmentType } from \"../../spatialAudioAttachmentType\";\n\nexport const _SpatialAudioListenerDefaults = {\n    position: Vector3.Zero(),\n    rotation: Vector3.Zero(),\n    rotationQuaternion: new Quaternion(),\n} as const;\n\n/**\n * Options for spatial audio.\n */\nexport interface ISpatialAudioListenerOptions {\n    /**\n     * Whether to automatically update the position and rotation of the listener. Defaults to `true`.\n     */\n    listenerAutoUpdate: boolean;\n    /**\n     * Set to `true` to enable the listener. Defaults to `false`.\n     */\n    listenerEnabled: boolean;\n    /**\n     * The minimum update time in seconds of the listener if it is attached to a mesh, scene or transform node. Defaults to `0`.\n     * - The listener's position and rotation will not update faster than this time, but they may update slower depending on the frame rate.\n     */\n    listenerMinUpdateTime: number;\n    /**\n     * The listener position. Defaults to (0, 0, 0).\n     */\n    listenerPosition: Vector3;\n    /**\n     * The listener rotation, as Euler angles. Defaults to (0, 0, 0).\n     */\n    listenerRotation: Vector3;\n    /**\n     * The listener rotation, as a quaternion. Defaults to (0, 0, 0, 1).\n     */\n    listenerRotationQuaternion: Quaternion;\n}\n\n/**\n * @param options The spatial audio listener options to check.\n * @returns `true` if spatial audio listener options are defined, otherwise `false`.\n */\nexport function _HasSpatialAudioListenerOptions(options: Partial<ISpatialAudioListenerOptions>): boolean {\n    return (\n        options.listenerEnabled ||\n        options.listenerMinUpdateTime !== undefined ||\n        options.listenerPosition !== undefined ||\n        options.listenerRotation !== undefined ||\n        options.listenerRotationQuaternion !== undefined\n    );\n}\n\n/**\n * Abstract class representing the spatial audio `listener` property on an audio engine.\n *\n * @see {@link AudioEngineV2.listener}\n */\nexport abstract class AbstractSpatialAudioListener {\n    /**\n     * Whether the listener is attached to a camera, mesh or transform node.\n     */\n    public abstract isAttached: boolean;\n\n    /**\n     * The minimum update time in seconds of the listener if it is attached to a mesh, scene or transform node. Defaults to `0`.\n     * - The listener's position and rotation will not update faster than this time, but they may update slower depending on the frame rate.\n     */\n    public abstract minUpdateTime: number;\n\n    /**\n     * The listener position. Defaults to (0, 0, 0).\n     */\n    public abstract position: Vector3;\n\n    /**\n     * The listener rotation, as Euler angles. Defaults to (0, 0, 0).\n     */\n    public abstract rotation: Vector3;\n\n    /**\n     * The listener rotation, as a quaternion. Defaults to (0, 0, 0, 1).\n     */\n    public abstract rotationQuaternion: Quaternion;\n\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    public abstract attach(sceneNode: Nullable<Node>, useBoundingBox?: boolean, attachmentType?: SpatialAudioAttachmentType): void;\n\n    /**\n     * Detaches from the scene node if attached.\n     */\n    public abstract detach(): void;\n\n    /**\n     * Updates the position and rotation of the associated audio engine object in the audio rendering graph.\n     *\n     * This is called automatically by default and only needs to be called manually if automatic updates are disabled.\n     */\n    public abstract update(): void;\n}\n", "import type { Node } from \"../../../node\";\nimport type { Nullable } from \"../../../types\";\nimport { SpatialAudioAttachmentType } from \"../../spatialAudioAttachmentType\";\nimport { _SpatialAudioAttacherComponent } from \"../components/spatialAudioAttacherComponent\";\nimport type { ISpatialAudioListenerOptions } from \"./abstractSpatialAudioListener\";\nimport { _SpatialAudioListenerDefaults, AbstractSpatialAudioListener } from \"./abstractSpatialAudioListener\";\n\n/** @internal */\nexport abstract class _SpatialAudioListener extends AbstractSpatialAudioListener {\n    protected _attacherComponent: Nullable<_SpatialAudioAttacherComponent> = null;\n\n    protected constructor() {\n        super();\n\n        this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n    }\n\n    /** @internal */\n    public get isAttached(): boolean {\n        return this._attacherComponent !== null && this._attacherComponent.isAttached;\n    }\n\n    /**\n     * Attaches to a scene node.\n     *\n     * Detaches automatically before attaching to the given scene node.\n     * If `sceneNode` is `null` it is the same as calling `detach()`.\n     *\n     * @param sceneNode The scene node to attach to, or `null` to detach.\n     * @param useBoundingBox Whether to use the bounding box of the node for positioning. Defaults to `false`.\n     * @param attachmentType Whether to attach to the node's position and/or rotation. Defaults to `PositionAndRotation`.\n     */\n    public attach(sceneNode: Nullable<Node>, useBoundingBox: boolean = false, attachmentType: SpatialAudioAttachmentType = SpatialAudioAttachmentType.PositionAndRotation): void {\n        if (!this._attacherComponent) {\n            this._attacherComponent = new _SpatialAudioAttacherComponent(this);\n        }\n        this._attacherComponent.attach(sceneNode, useBoundingBox, attachmentType);\n    }\n\n    /**\n     * Detaches from the scene node if attached.\n     */\n    public detach(): void {\n        this._attacherComponent?.detach();\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._attacherComponent?.dispose();\n        this._attacherComponent = null;\n    }\n\n    /** @internal */\n    public setOptions(options: Partial<ISpatialAudioListenerOptions>): void {\n        if (options.listenerMinUpdateTime !== undefined) {\n            this.minUpdateTime = options.listenerMinUpdateTime;\n        }\n\n        if (options.listenerPosition) {\n            this.position = options.listenerPosition.clone();\n        }\n\n        if (options.listenerRotationQuaternion) {\n            this.rotationQuaternion = options.listenerRotationQuaternion.clone();\n        } else if (options.listenerRotation) {\n            this.rotation = options.listenerRotation.clone();\n        } else {\n            this.rotationQuaternion = _SpatialAudioListenerDefaults.rotationQuaternion.clone();\n        }\n\n        this.update();\n    }\n\n    public abstract _updatePosition(): void;\n    public abstract _updateRotation(): void;\n}\n", "import { Matrix, Quaternion, Vector3 } from \"../../../Maths/math.vector\";\nimport { _SpatialAudioListener } from \"../../abstractAudio/subProperties/spatialAudioListener\";\nimport { _SpatialWebAudioUpdaterComponent } from \"../components/spatialWebAudioUpdaterComponent\";\nimport { _WebAudioParameterComponent } from \"../components/webAudioParameterComponent\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\n\nconst TmpMatrix = Matrix.Zero();\nconst TmpQuaternion = new Quaternion();\nconst TmpVector1 = Vector3.Zero();\nconst TmpVector2 = Vector3.Zero();\n\n/** @internal */\nexport function _CreateSpatialAudioListener(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number): _SpatialAudioListener {\n    const listener = engine._audioContext.listener;\n    if (\n        listener.forwardX &&\n        listener.forwardY &&\n        listener.forwardZ &&\n        listener.positionX &&\n        listener.positionY &&\n        listener.positionZ &&\n        listener.upX &&\n        listener.upY &&\n        listener.upZ\n    ) {\n        return new _SpatialWebAudioListener(engine, autoUpdate, minUpdateTime);\n    } else {\n        return new _SpatialWebAudioListenerFallback(engine, autoUpdate, minUpdateTime);\n    }\n}\n\nabstract class _AbstractSpatialWebAudioListener extends _SpatialAudioListener {\n    protected readonly _listener: AudioListener;\n\n    protected _lastPosition: Vector3 = Vector3.Zero();\n    protected _lastRotation: Vector3 = Vector3.Zero();\n    protected _lastRotationQuaternion: Quaternion = new Quaternion();\n    protected _updaterComponent: _SpatialWebAudioUpdaterComponent;\n\n    /** @internal */\n    public readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public readonly position: Vector3 = Vector3.Zero();\n    /** @internal */\n    public readonly rotation: Vector3 = Vector3.Zero();\n    /** @internal */\n    public readonly rotationQuaternion: Quaternion = new Quaternion();\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number) {\n        super();\n\n        this._listener = engine._audioContext.listener;\n        this.engine = engine;\n\n        this._updaterComponent = new _SpatialWebAudioUpdaterComponent(this, autoUpdate, minUpdateTime);\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._updaterComponent.dispose();\n        this._updaterComponent = null!;\n    }\n\n    /** @internal */\n    public get minUpdateTime(): number {\n        return this._updaterComponent.minUpdateTime;\n    }\n\n    /** @internal */\n    public set minUpdateTime(value: number) {\n        this._updaterComponent.minUpdateTime = value;\n    }\n\n    /** @internal */\n    public update(): void {\n        if (this.isAttached) {\n            this._attacherComponent?.update();\n        } else {\n            this._updatePosition();\n            this._updateRotation();\n        }\n    }\n\n    public _updatePosition(): void {\n        if (this._lastPosition.equalsWithEpsilon(this.position)) {\n            return;\n        }\n\n        this._setWebAudioPosition(this.position);\n\n        this._lastPosition.copyFrom(this.position);\n    }\n\n    public _updateRotation(): void {\n        if (!this._lastRotationQuaternion.equalsWithEpsilon(this.rotationQuaternion)) {\n            TmpQuaternion.copyFrom(this.rotationQuaternion);\n            this._lastRotationQuaternion.copyFrom(this.rotationQuaternion);\n        } else if (!this._lastRotation.equalsWithEpsilon(this.rotation)) {\n            Quaternion.FromEulerAnglesToRef(this.rotation.x, this.rotation.y, this.rotation.z, TmpQuaternion);\n            this._lastRotation.copyFrom(this.rotation);\n        } else {\n            return;\n        }\n\n        Matrix.FromQuaternionToRef(TmpQuaternion, TmpMatrix);\n\n        // NB: The WebAudio API is right-handed.\n        Vector3.TransformNormalToRef(Vector3.RightHandedForwardReadOnly, TmpMatrix, TmpVector1);\n        Vector3.TransformNormalToRef(Vector3.Up(), TmpMatrix, TmpVector2);\n\n        this._setWebAudioOrientation(TmpVector1, TmpVector2);\n    }\n\n    protected abstract _setWebAudioPosition(position: Vector3): void;\n    protected abstract _setWebAudioOrientation(forward: Vector3, up: Vector3): void;\n}\n\n/**\n * Full-featured spatial audio listener for the Web Audio API.\n *\n * Used in browsers that support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the AudioContext listener.\n *\n * NB: Firefox falls back to using this implementation.\n *\n * @see _SpatialWebAudioListenerFallback for the implementation used if only `setPosition` and `setOrientation` are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListener extends _AbstractSpatialWebAudioListener {\n    private _forwardX: _WebAudioParameterComponent;\n    private _forwardY: _WebAudioParameterComponent;\n    private _forwardZ: _WebAudioParameterComponent;\n    private _positionX: _WebAudioParameterComponent;\n    private _positionY: _WebAudioParameterComponent;\n    private _positionZ: _WebAudioParameterComponent;\n    private _upX: _WebAudioParameterComponent;\n    private _upY: _WebAudioParameterComponent;\n    private _upZ: _WebAudioParameterComponent;\n\n    public constructor(engine: _WebAudioEngine, autoUpdate: boolean, minUpdateTime: number) {\n        super(engine, autoUpdate, minUpdateTime);\n\n        const listener = engine._audioContext.listener;\n        this._forwardX = new _WebAudioParameterComponent(engine, listener.forwardX);\n        this._forwardY = new _WebAudioParameterComponent(engine, listener.forwardY);\n        this._forwardZ = new _WebAudioParameterComponent(engine, listener.forwardZ);\n        this._positionX = new _WebAudioParameterComponent(engine, listener.positionX);\n        this._positionY = new _WebAudioParameterComponent(engine, listener.positionY);\n        this._positionZ = new _WebAudioParameterComponent(engine, listener.positionZ);\n        this._upX = new _WebAudioParameterComponent(engine, listener.upX);\n        this._upY = new _WebAudioParameterComponent(engine, listener.upY);\n        this._upZ = new _WebAudioParameterComponent(engine, listener.upZ);\n    }\n\n    protected override _setWebAudioPosition(position: Vector3): void {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (this.isAttached && (this._positionX.isRamping || this._positionY.isRamping || this._positionZ.isRamping)) {\n            return;\n        }\n\n        this._positionX.targetValue = position.x;\n        this._positionY.targetValue = position.y;\n        this._positionZ.targetValue = position.z;\n    }\n\n    protected override _setWebAudioOrientation(forward: Vector3, up: Vector3): void {\n        // If attached and there is a ramp in progress, we assume another update is coming soon that we can wait for.\n        // We don't do this for unattached nodes because there may not be another update coming.\n        if (\n            this.isAttached &&\n            (this._forwardX.isRamping || this._forwardY.isRamping || this._forwardZ.isRamping || this._upX.isRamping || this._upY.isRamping || this._upZ.isRamping)\n        ) {\n            return;\n        }\n\n        this._forwardX.targetValue = forward.x;\n        this._forwardY.targetValue = forward.y;\n        this._forwardZ.targetValue = forward.z;\n\n        this._upX.targetValue = up.x;\n        this._upY.targetValue = up.y;\n        this._upZ.targetValue = up.z;\n    }\n}\n\n/**\n * Fallback spatial audio listener for the Web Audio API.\n *\n * Used in browsers that do not support the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z` properties on the\n * AudioContext listener.\n *\n * @see _SpatialWebAudioListener for the implementation used if the `forwardX/Y/Z`, `positionX/Y/Z`, and `upX/Y/Z`\n * properties are available.\n *\n * NB: This sub property is not backed by a sub node and all properties are set directly on the audio context listener.\n *\n * @internal\n */\nclass _SpatialWebAudioListenerFallback extends _AbstractSpatialWebAudioListener {\n    protected override _setWebAudioPosition(position: Vector3): void {\n        this._listener.setPosition(position.x, position.y, position.z);\n    }\n\n    protected override _setWebAudioOrientation(forward: Vector3, up: Vector3): void {\n        this._listener.setOrientation(forward.x, forward.y, forward.z, up.x, up.y, up.z);\n    }\n}\n", "import { AudioNodeType, AbstractAudioNode } from \"./abstractAudioNode\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\n/**\n * Abstract class for the main audio output node.\n *\n * A main audio output is the last audio node in the audio graph before the audio is sent to the speakers.\n *\n * @see {@link AudioEngineV2.mainOut}\n * @internal\n */\nexport abstract class _MainAudioOut extends AbstractAudioNode {\n    protected constructor(engine: AudioEngineV2) {\n        super(engine, AudioNodeType.HAS_INPUTS);\n    }\n}\n", "import type { Nullable } from \"../../types\";\nimport { _MainAudioOut } from \"../abstractAudio/mainAudioOut\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode } from \"./webAudioNode\";\n\n/** @internal */\nexport class _WebAudioMainOut extends _MainAudioOut implements IWebAudioInNode {\n    private _gainNode: GainNode;\n    private _volume: _WebAudioParameterComponent;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n\n        this._setGainNode(new GainNode(engine._audioContext));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._volume.dispose();\n        this._gainNode.disconnect();\n        this._destinationNode.disconnect();\n    }\n\n    /** @internal */\n    public get _inNode(): GainNode {\n        return this._gainNode;\n    }\n\n    public set _inNode(value: GainNode) {\n        if (this._gainNode === value) {\n            return;\n        }\n\n        this._setGainNode(value);\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this._volume.targetValue;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        this._volume.targetValue = value;\n    }\n\n    private get _destinationNode(): AudioNode {\n        return this.engine._audioDestination;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioMainOut\";\n    }\n\n    /** @internal */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        this._volume.setTargetValue(value, options);\n    }\n\n    private _setGainNode(gainNode: GainNode): void {\n        if (this._gainNode === gainNode) {\n            return;\n        }\n\n        this._gainNode?.disconnect();\n        gainNode.connect(this._destinationNode);\n\n        this._volume = new _WebAudioParameterComponent(this.engine, gainNode.gain);\n\n        this._gainNode = gainNode;\n    }\n}\n", "import type { Nullable } from \"../../types\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\n\n/**\n * Adds a UI button that starts the audio engine's underlying audio context when the user presses it.\n * @internal\n */\nexport class _WebAudioUnmuteUI {\n    private _button: Nullable<HTMLButtonElement> = null;\n    private _enabled: boolean = true;\n    private _engine: _WebAudioEngine;\n    private _style: Nullable<HTMLStyleElement> = null;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine, parentElement?: HTMLElement) {\n        this._engine = engine;\n        const parent = parentElement || EngineStore.LastCreatedEngine?.getInputElement()?.parentElement || document.body;\n        const top = (parent?.offsetTop || 0) + 20;\n\n        this._style = document.createElement(\"style\");\n        this._style.appendChild(\n            document.createTextNode(\n                `.babylonUnmute{position:absolute;top:${top}px;margin-left:20px;height:40px;width:60px;background-color:rgba(51,51,51,0.7);background-image:url(\"data:image/svg+xml;charset=UTF-8,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2239%22%20height%3D%2232%22%20viewBox%3D%220%200%2039%2032%22%3E%3Cpath%20fill%3D%22white%22%20d%3D%22M9.625%2018.938l-0.031%200.016h-4.953q-0.016%200-0.031-0.016v-12.453q0-0.016%200.031-0.016h4.953q0.031%200%200.031%200.016v12.453zM12.125%207.688l8.719-8.703v27.453l-8.719-8.719-0.016-0.047v-9.938zM23.359%207.875l1.406-1.406%204.219%204.203%204.203-4.203%201.422%201.406-4.219%204.219%204.219%204.203-1.484%201.359-4.141-4.156-4.219%204.219-1.406-1.422%204.219-4.203z%22%3E%3C%2Fpath%3E%3C%2Fsvg%3E\");background-size:80%;background-repeat:no-repeat;background-position:center;background-position-y:4px;border:none;outline:none;transition:transform 0.125s ease-out;cursor:pointer;z-index:9999;}.babylonUnmute:hover{transform:scale(1.05)}`\n            )\n        );\n        document.head.appendChild(this._style);\n\n        this._button = document.createElement(\"button\");\n        this._button.className = \"babylonUnmute\";\n        this._button.id = \"babylonUnmuteButton\";\n\n        this._button.addEventListener(\"click\", () => {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._engine.unlockAsync();\n        });\n\n        parent.appendChild(this._button);\n\n        this._engine.stateChangedObservable.add(this._onStateChanged);\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._button?.remove();\n        this._button = null;\n\n        this._style?.remove();\n        this._style = null;\n\n        this._engine.stateChangedObservable.removeCallback(this._onStateChanged);\n    }\n\n    /** @internal */\n    public get enabled(): boolean {\n        return this._enabled;\n    }\n\n    public set enabled(value: boolean) {\n        this._enabled = value;\n        if (value) {\n            if (this._engine.state !== \"running\") {\n                this._show();\n            }\n        } else {\n            this._hide();\n        }\n    }\n\n    private _show(): void {\n        if (!this._button) {\n            return;\n        }\n\n        this._button.style.display = \"block\";\n    }\n\n    private _hide(): void {\n        if (!this._button) {\n            return;\n        }\n\n        this._button.style.display = \"none\";\n    }\n\n    private _onStateChanged = () => {\n        if (!this._button) {\n            return;\n        }\n\n        if (this._engine.state === \"running\") {\n            this._hide();\n        } else {\n            this._show();\n        }\n    };\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractNamedAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { AbstractSoundSource, ISoundSourceOptions } from \"../abstractAudio/abstractSoundSource\";\nimport type { AudioBus, IAudioBusOptions } from \"../abstractAudio/audioBus\";\nimport type { AudioEngineV2State, IAudioEngineV2Options } from \"../abstractAudio/audioEngineV2\";\nimport { AudioEngineV2 } from \"../abstractAudio/audioEngineV2\";\nimport type { IMainAudioBusOptions, MainAudioBus } from \"../abstractAudio/mainAudioBus\";\nimport type { IStaticSoundOptions, StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStreamingSoundOptions, StreamingSound } from \"../abstractAudio/streamingSound\";\nimport type { AbstractSpatialAudioListener } from \"../abstractAudio/subProperties/abstractSpatialAudioListener\";\nimport { _HasSpatialAudioListenerOptions } from \"../abstractAudio/subProperties/abstractSpatialAudioListener\";\nimport type { _SpatialAudioListener } from \"../abstractAudio/subProperties/spatialAudioListener\";\nimport type { IAudioParameterRampOptions } from \"../audioParameter\";\nimport { _CreateSpatialAudioListener } from \"./subProperties/spatialWebAudioListener\";\nimport { _WebAudioMainOut } from \"./webAudioMainOut\";\nimport { _WebAudioUnmuteUI } from \"./webAudioUnmuteUI\";\n\n/**\n * Options for creating a v2 audio engine that uses the WebAudio API.\n */\nexport interface IWebAudioEngineOptions extends IAudioEngineV2Options {\n    /**\n     * The audio context to be used by the engine.\n     */\n    audioContext: AudioContext;\n    /**\n     * The default UI's parent element. Defaults to the last created graphics engine's canvas if it exists; otherwise the HTML document's body.\n     */\n    defaultUIParentElement?: HTMLElement;\n    /**\n     * Set to `true` to disable the default UI. Defaults to `false`.\n     */\n    disableDefaultUI?: boolean;\n    /**\n     * Set to `true` to automatically resume the audio context when the user interacts with the page. Defaults to `true`.\n     */\n    resumeOnInteraction: boolean;\n    /**\n     * Set to `true` to automatically resume the audio context when the browser pauses audio playback. Defaults to `true`.\n     */\n    resumeOnPause: boolean;\n    /**\n     * The interval in milliseconds to try resuming audio playback when `resumeOnPause` is `true`. Defaults to `1000`.\n     */\n    resumeOnPauseRetryInterval: number;\n}\n\n/**\n * Creates a new v2 audio engine that uses the WebAudio API.\n * @param options - The options for creating the audio engine.\n * @returns A promise that resolves with the created audio engine.\n */\nexport async function CreateAudioEngineAsync(options: Partial<IWebAudioEngineOptions> = {}): Promise<AudioEngineV2> {\n    const engine = new _WebAudioEngine(options);\n    await engine._initAsync(options);\n    return engine;\n}\n\nconst FormatMimeTypes: { [key: string]: string } = {\n    aac: \"audio/aac\",\n    ac3: \"audio/ac3\",\n    flac: \"audio/flac\",\n    m4a: \"audio/mp4\",\n    mp3: 'audio/mpeg; codecs=\"mp3\"',\n    mp4: \"audio/mp4\",\n    ogg: 'audio/ogg; codecs=\"vorbis\"',\n    wav: \"audio/wav\",\n    webm: 'audio/webm; codecs=\"vorbis\"',\n};\n\n/** @internal */\nexport class _WebAudioEngine extends AudioEngineV2 {\n    private _audioContextStarted = false;\n    private _destinationNode: Nullable<AudioNode> = null;\n    private _invalidFormats = new Set<string>();\n    private _isUpdating = false;\n    private _listener: Nullable<_SpatialAudioListener> = null;\n    private readonly _listenerAutoUpdate: boolean = true;\n    private readonly _listenerMinUpdateTime: number = 0;\n    private _mainOut: _WebAudioMainOut;\n    private _pauseCalled = false;\n    private _resumeOnInteraction = true;\n    private _resumeOnPause = true;\n    private _resumeOnPauseRetryInterval = 1000;\n    private _resumeOnPauseTimerId: any = null;\n    private _resumePromise: Nullable<Promise<void>> = null;\n    private _silentHtmlAudio: Nullable<HTMLAudioElement> = null;\n    private _unmuteUI: Nullable<_WebAudioUnmuteUI> = null;\n    private _updateObservable: Nullable<Observable<void>> = null;\n    private readonly _validFormats = new Set<string>();\n    private _volume = 1;\n\n    /** @internal */\n    public readonly _audioContext: AudioContext;\n\n    /** @internal */\n    public readonly _isUsingOfflineAudioContext: boolean = false;\n\n    /** @internal */\n    public readonly isReadyPromise: Promise<void> = new Promise((resolve) => {\n        this._resolveIsReadyPromise = resolve;\n    });\n\n    /** @internal */\n    public stateChangedObservable: Observable<string> = new Observable();\n\n    /** @internal */\n    public userGestureObservable: Observable<void> = new Observable();\n\n    /** @internal */\n    public constructor(options: Partial<IWebAudioEngineOptions> = {}) {\n        super(options);\n\n        if (typeof options.listenerAutoUpdate === \"boolean\") {\n            this._listenerAutoUpdate = options.listenerAutoUpdate;\n        }\n\n        if (typeof options.listenerMinUpdateTime === \"number\") {\n            this._listenerMinUpdateTime = options.listenerMinUpdateTime;\n        }\n\n        this._volume = options.volume ?? 1;\n\n        if (options.audioContext) {\n            this._isUsingOfflineAudioContext = options.audioContext instanceof OfflineAudioContext;\n            this._audioContext = options.audioContext;\n        } else {\n            this._audioContext = new AudioContext();\n        }\n\n        if (!options.disableDefaultUI) {\n            this._unmuteUI = new _WebAudioUnmuteUI(this, options.defaultUIParentElement);\n        }\n    }\n\n    /** @internal */\n    public async _initAsync(options: Partial<IWebAudioEngineOptions>): Promise<void> {\n        this._resumeOnInteraction = typeof options.resumeOnInteraction === \"boolean\" ? options.resumeOnInteraction : true;\n        this._resumeOnPause = typeof options.resumeOnPause === \"boolean\" ? options.resumeOnPause : true;\n        this._resumeOnPauseRetryInterval = options.resumeOnPauseRetryInterval ?? 1000;\n\n        document.addEventListener(\"click\", this._onUserGestureAsync);\n\n        await this._initAudioContextAsync();\n\n        if (_HasSpatialAudioListenerOptions(options)) {\n            this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime);\n            this._listener.setOptions(options);\n        }\n\n        this._resolveIsReadyPromise();\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        return this._audioContext.currentTime ?? 0;\n    }\n\n    /** @internal */\n    public get _inNode(): AudioNode {\n        return this._audioContext.destination;\n    }\n\n    /** @internal */\n    public get mainOut(): _WebAudioMainOut {\n        return this._mainOut;\n    }\n\n    /** @internal */\n    public get listener(): AbstractSpatialAudioListener {\n        return this._listener ?? (this._listener = _CreateSpatialAudioListener(this, this._listenerAutoUpdate, this._listenerMinUpdateTime));\n    }\n\n    /** @internal */\n    public get state(): AudioEngineV2State {\n        // Always return \"running\" for OfflineAudioContext so sound `play` calls work while the context is suspended.\n        return this._isUsingOfflineAudioContext ? \"running\" : this._audioContext.state;\n    }\n\n    /** @internal */\n    public get volume(): number {\n        return this._volume;\n    }\n\n    /** @internal */\n    public set volume(value: number) {\n        if (this._volume === value) {\n            return;\n        }\n\n        this._volume = value;\n\n        if (this._mainOut) {\n            this._mainOut.volume = value;\n        }\n    }\n\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     * */\n    public get _audioDestination(): AudioNode {\n        return this._destinationNode ? this._destinationNode : (this._destinationNode = this._audioContext.destination);\n    }\n\n    public set _audioDestination(value: Nullable<AudioNode>) {\n        this._destinationNode = value;\n    }\n\n    /**\n     * This property should only be used by the legacy audio engine.\n     * @internal\n     */\n    public get _unmuteUIEnabled(): boolean {\n        return this._unmuteUI ? this._unmuteUI.enabled : false;\n    }\n\n    public set _unmuteUIEnabled(value: boolean) {\n        if (this._unmuteUI) {\n            this._unmuteUI.enabled = value;\n        }\n    }\n\n    /** @internal */\n    public async createBusAsync(name: string, options: Partial<IAudioBusOptions> = {}): Promise<AudioBus> {\n        const module = await import(\"./webAudioBus\");\n\n        const bus = new module._WebAudioBus(name, this, options);\n        await bus._initAsync(options);\n\n        return bus;\n    }\n\n    /** @internal */\n    public async createMainBusAsync(name: string, options: Partial<IMainAudioBusOptions> = {}): Promise<MainAudioBus> {\n        const module = await import(\"./webAudioMainBus\");\n\n        const bus = new module._WebAudioMainBus(name, this);\n        await bus._initAsync(options);\n\n        return bus;\n    }\n\n    /** @internal */\n    public async createMicrophoneSoundSourceAsync(name: string, options?: Partial<ISoundSourceOptions>): Promise<AbstractSoundSource> {\n        let mediaStream: MediaStream;\n\n        try {\n            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });\n        } catch (e) {\n            throw new Error(\"Unable to access microphone: \" + e);\n        }\n\n        return await this.createSoundSourceAsync(name, new MediaStreamAudioSourceNode(this._audioContext, { mediaStream }), {\n            outBusAutoDefault: false,\n            ...options,\n        });\n    }\n\n    /** @internal */\n    public async createSoundAsync(\n        name: string,\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options: Partial<IStaticSoundOptions> = {}\n    ): Promise<StaticSound> {\n        const module = await import(\"./webAudioStaticSound\");\n\n        const sound = new module._WebAudioStaticSound(name, this, options);\n        await sound._initAsync(source, options);\n\n        return sound;\n    }\n\n    /** @internal */\n    public async createSoundBufferAsync(\n        source: ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[],\n        options: Partial<IStaticSoundBufferOptions> = {}\n    ): Promise<StaticSoundBuffer> {\n        const module = await import(\"./webAudioStaticSound\");\n\n        const soundBuffer = new module._WebAudioStaticSoundBuffer(this);\n        await soundBuffer._initAsync(source, options);\n\n        return soundBuffer;\n    }\n\n    /** @internal */\n    public async createSoundSourceAsync(name: string, source: AudioNode, options: Partial<ISoundSourceOptions> = {}): Promise<AbstractSoundSource> {\n        const module = await import(\"./webAudioSoundSource\");\n\n        const soundSource = new module._WebAudioSoundSource(name, source, this, options);\n        await soundSource._initAsync(options);\n\n        return soundSource;\n    }\n\n    /** @internal */\n    public async createStreamingSoundAsync(name: string, source: HTMLMediaElement | string | string[], options: Partial<IStreamingSoundOptions> = {}): Promise<StreamingSound> {\n        const module = await import(\"./webAudioStreamingSound\");\n\n        const sound = new module._WebAudioStreamingSound(name, this, options);\n        await sound._initAsync(source, options);\n\n        return sound;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._listener?.dispose();\n        this._listener = null;\n\n        // Note that OfflineAudioContext does not have a `close` method.\n        if (this._audioContext.state !== \"closed\" && !this._isUsingOfflineAudioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._audioContext.close();\n        }\n\n        document.removeEventListener(\"click\", this._onUserGestureAsync);\n        this._audioContext.removeEventListener(\"statechange\", this._onAudioContextStateChange);\n\n        this._silentHtmlAudio?.remove();\n\n        this._updateObservable?.clear();\n        this._updateObservable = null;\n\n        this._unmuteUI?.dispose();\n        this._unmuteUI = null;\n\n        this.stateChangedObservable.clear();\n    }\n\n    /** @internal */\n    public flagInvalidFormat(format: string): void {\n        this._invalidFormats.add(format);\n    }\n\n    /** @internal */\n    public isFormatValid(format: string): boolean {\n        if (this._validFormats.has(format)) {\n            return true;\n        }\n\n        if (this._invalidFormats.has(format)) {\n            return false;\n        }\n\n        const mimeType = FormatMimeTypes[format];\n        if (mimeType === undefined) {\n            return false;\n        }\n\n        const audio = new Audio();\n        if (audio.canPlayType(mimeType) === \"\") {\n            this._invalidFormats.add(format);\n            return false;\n        }\n\n        this._validFormats.add(format);\n\n        return true;\n    }\n\n    /** @internal */\n    public override async pauseAsync(): Promise<void> {\n        await this._audioContext.suspend();\n\n        this._pauseCalled = true;\n    }\n\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public override resumeAsync(): Promise<void> {\n        this._pauseCalled = false;\n\n        if (this._resumePromise) {\n            return this._resumePromise;\n        }\n\n        this._resumePromise = this._audioContext.resume();\n        return this._resumePromise;\n    }\n\n    /** @internal */\n    public setVolume(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        if (this._mainOut) {\n            this._mainOut.setVolume(value, options);\n        } else {\n            throw new Error(\"Main output not initialized yet.\");\n        }\n    }\n\n    /** @internal */\n    public override _addMainBus(mainBus: MainAudioBus): void {\n        super._addMainBus(mainBus);\n    }\n\n    /** @internal */\n    public override _removeMainBus(mainBus: MainAudioBus): void {\n        super._removeMainBus(mainBus);\n    }\n\n    /** @internal */\n    public override _addNode(node: AbstractNamedAudioNode): void {\n        super._addNode(node);\n    }\n\n    /** @internal */\n    public override _removeNode(node: AbstractNamedAudioNode): void {\n        super._removeNode(node);\n    }\n\n    /** @internal */\n    public _addUpdateObserver(callback: () => void): void {\n        if (!this._updateObservable) {\n            this._updateObservable = new Observable<void>();\n        }\n\n        this._updateObservable.add(callback);\n        this._startUpdating();\n    }\n\n    public _removeUpdateObserver(callback: () => void): void {\n        if (this._updateObservable) {\n            this._updateObservable.removeCallback(callback);\n        }\n    }\n\n    private _initAudioContextAsync: () => Promise<void> = async () => {\n        this._audioContext.addEventListener(\"statechange\", this._onAudioContextStateChange);\n\n        this._mainOut = new _WebAudioMainOut(this);\n        this._mainOut.volume = this._volume;\n\n        await this.createMainBusAsync(\"default\");\n    };\n\n    private _onAudioContextStateChange = () => {\n        if (this.state === \"running\") {\n            clearInterval(this._resumeOnPauseTimerId);\n            this._audioContextStarted = true;\n            this._resumePromise = null;\n        }\n        if (this.state === \"suspended\" || this.state === \"interrupted\") {\n            if (this._audioContextStarted && this._resumeOnPause && !this._pauseCalled) {\n                clearInterval(this._resumeOnPauseTimerId);\n\n                this._resumeOnPauseTimerId = setInterval(() => {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this.resumeAsync();\n                }, this._resumeOnPauseRetryInterval);\n            }\n        }\n\n        this.stateChangedObservable.notifyObservers(this.state);\n    };\n\n    private _onUserGestureAsync: () => void = async () => {\n        if (this._resumeOnInteraction) {\n            await this._audioContext.resume();\n        }\n\n        // On iOS the ringer switch must be turned on for WebAudio to play.\n        // This gets WebAudio to play with the ringer switch turned off by playing an HTMLAudioElement.\n        if (!this._silentHtmlAudio) {\n            this._silentHtmlAudio = document.createElement(\"audio\");\n\n            const audio = this._silentHtmlAudio;\n            audio.controls = false;\n            audio.preload = \"auto\";\n            audio.loop = true;\n\n            // Wave data for 0.0001 seconds of silence.\n            audio.src = \"data:audio/wav;base64,UklGRjAAAABXQVZFZm10IBAAAAABAAEAgLsAAAB3AQACABAAZGF0YQwAAAAAAAEA/v8CAP//AQA=\";\n\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            audio.play();\n        }\n\n        this.userGestureObservable.notifyObservers();\n    };\n\n    private _resolveIsReadyPromise: () => void;\n\n    private _startUpdating = () => {\n        if (this._isUpdating) {\n            return;\n        }\n\n        this._isUpdating = true;\n\n        if (this.state === \"running\") {\n            this._update();\n        } else {\n            const callback = () => {\n                if (this.state === \"running\") {\n                    this._update();\n                    this.stateChangedObservable.removeCallback(callback);\n                }\n            };\n\n            this.stateChangedObservable.add(callback);\n        }\n    };\n\n    private _update = (): void => {\n        if (this._updateObservable?.hasObservers()) {\n            this._updateObservable.notifyObservers();\n            requestAnimationFrame(this._update);\n        } else {\n            this._isUpdating = false;\n        }\n    };\n}\n", "import type { Analyser } from \"./analyser\";\r\n\r\nimport type { Nullable } from \"../types\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport { _WebAudioEngine } from \"../AudioV2/webAudio/webAudioEngine\";\r\nimport type { _WebAudioMainBus } from \"../AudioV2/webAudio/webAudioMainBus\";\r\n\r\n// Sets the default audio engine to Babylon.js\r\nAbstractEngine.AudioEngineFactory = (\r\n    hostElement: Nullable<HTMLElement>,\r\n    audioContext: Nullable<AudioContext>,\r\n    audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode>\r\n) => {\r\n    return new AudioEngine(hostElement, audioContext, audioDestination);\r\n};\r\n\r\n/**\r\n * This represents the default audio engine used in babylon.\r\n * It is responsible to play, synchronize and analyse sounds throughout the  application.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class AudioEngine implements IAudioEngine {\r\n    private _audioContext: Nullable<AudioContext> = null;\r\n    private _masterGain: GainNode;\r\n    private _tryToRun = false;\r\n    private _useCustomUnlockedButton: boolean = false;\r\n\r\n    /**\r\n     * Gets whether the current host supports Web Audio and thus could create AudioContexts.\r\n     */\r\n    public canUseWebAudio: boolean = true;\r\n\r\n    /**\r\n     * The master gain node defines the global audio volume of your audio engine.\r\n     */\r\n    public get masterGain(): GainNode {\r\n        return this._masterGain;\r\n    }\r\n\r\n    public set masterGain(value: GainNode) {\r\n        this._masterGain = this._v2.mainOut._inNode = value;\r\n    }\r\n\r\n    /**\r\n     * Defines if Babylon should emit a warning if WebAudio is not supported.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public WarnedWebAudioUnsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not mp3 are supported by your browser.\r\n     */\r\n    public isMP3supported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether or not ogg are supported by your browser.\r\n     */\r\n    public isOGGsupported: boolean = false;\r\n\r\n    /**\r\n     * Gets whether audio has been unlocked on the device.\r\n     * Some Browsers have strong restrictions about Audio and won't autoplay unless\r\n     * a user interaction has happened.\r\n     */\r\n    public unlocked: boolean = false;\r\n\r\n    /**\r\n     * Defines if the audio engine relies on a custom unlocked button.\r\n     * In this case, the embedded button will not be displayed.\r\n     */\r\n    public get useCustomUnlockedButton(): boolean {\r\n        return this._useCustomUnlockedButton;\r\n    }\r\n\r\n    public set useCustomUnlockedButton(value: boolean) {\r\n        this._useCustomUnlockedButton = value;\r\n        this._v2._unmuteUIEnabled = !value;\r\n    }\r\n\r\n    /**\r\n     * Event raised when audio has been unlocked on the browser.\r\n     */\r\n    public onAudioUnlockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /**\r\n     * Event raised when audio has been locked on the browser.\r\n     */\r\n    public onAudioLockedObservable = new Observable<IAudioEngine>();\r\n\r\n    /** @internal */\r\n    public _v2: _WebAudioEngine;\r\n\r\n    /**\r\n     * Gets the current AudioContext if available.\r\n     */\r\n    public get audioContext(): Nullable<AudioContext> {\r\n        if (this._v2.state === \"running\") {\r\n            // Do not wait for the promise to unlock.\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this._triggerRunningStateAsync();\r\n        }\r\n        return this._v2._audioContext;\r\n    }\r\n\r\n    private _connectedAnalyser: Nullable<Analyser>;\r\n\r\n    /**\r\n     * Instantiates a new audio engine.\r\n     *\r\n     * @param hostElement defines the host element where to display the mute icon if necessary\r\n     * @param audioContext defines the audio context to be used by the audio engine\r\n     * @param audioDestination defines the audio destination node to be used by audio engine\r\n     */\r\n    constructor(\r\n        hostElement: Nullable<HTMLElement> = null,\r\n        audioContext: Nullable<AudioContext> = null,\r\n        audioDestination: Nullable<AudioDestinationNode | MediaStreamAudioDestinationNode> = null\r\n    ) {\r\n        const v2 = new _WebAudioEngine({\r\n            audioContext: audioContext ? audioContext : undefined,\r\n            defaultUIParentElement: hostElement?.parentElement ? hostElement.parentElement : undefined,\r\n        });\r\n\r\n        // Historically the unmute button is disabled until a sound tries to play and can't, which results in a call\r\n        // to `AudioEngine.lock()`, which is where the unmute button is enabled if no custom UI is requested.\r\n        v2._unmuteUIEnabled = false;\r\n\r\n        this._masterGain = new GainNode(v2._audioContext);\r\n        v2._audioDestination = audioDestination;\r\n\r\n        v2.stateChangedObservable.add((state) => {\r\n            if (state === \"running\") {\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            } else {\r\n                this.unlocked = false;\r\n                this.onAudioLockedObservable.notifyObservers(this);\r\n            }\r\n        });\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n        v2._initAsync({ resumeOnInteraction: false }).then(() => {\r\n            const mainBusOutNode = (v2.defaultMainBus as _WebAudioMainBus)._outNode;\r\n            if (mainBusOutNode) {\r\n                mainBusOutNode.disconnect(v2.mainOut._inNode);\r\n                mainBusOutNode.connect(this._masterGain);\r\n            }\r\n\r\n            v2.mainOut._inNode = this._masterGain;\r\n            v2.stateChangedObservable.notifyObservers(v2.state);\r\n        });\r\n\r\n        this.isMP3supported = v2.isFormatValid(\"mp3\");\r\n        this.isOGGsupported = v2.isFormatValid(\"ogg\");\r\n\r\n        this._v2 = v2;\r\n    }\r\n\r\n    /**\r\n     * Flags the audio engine in Locked state.\r\n     * This happens due to new browser policies preventing audio to autoplay.\r\n     */\r\n    public lock() {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._v2._audioContext.suspend();\r\n\r\n        if (!this._useCustomUnlockedButton) {\r\n            this._v2._unmuteUIEnabled = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unlocks the audio engine once a user action has been done on the dom.\r\n     * This is helpful to resume play once browser policies have been satisfied.\r\n     */\r\n    public unlock() {\r\n        if (this._audioContext?.state === \"running\") {\r\n            if (!this.unlocked) {\r\n                // Notify users that the audio stack is unlocked/unmuted\r\n                this.unlocked = true;\r\n                this.onAudioUnlockedObservable.notifyObservers(this);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        this._triggerRunningStateAsync();\r\n    }\r\n\r\n    /** @internal */\r\n    public _resumeAudioContextOnStateChange(): void {\r\n        this._audioContext?.addEventListener(\r\n            \"statechange\",\r\n            () => {\r\n                if (this.unlocked && this._audioContext?.state !== \"running\") {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                    this._resumeAudioContextAsync();\r\n                }\r\n            },\r\n            {\r\n                once: true,\r\n                passive: true,\r\n                signal: AbortSignal.timeout(3000),\r\n            }\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _resumeAudioContextAsync(): Promise<void> {\r\n        if (this._v2._isUsingOfflineAudioContext) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this._v2._audioContext.resume();\r\n    }\r\n\r\n    /**\r\n     * Destroy and release the resources associated with the audio context.\r\n     */\r\n    public dispose(): void {\r\n        this._v2.dispose();\r\n\r\n        this.onAudioUnlockedObservable.clear();\r\n        this.onAudioLockedObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * Gets the global volume sets on the master gain.\r\n     * @returns the global volume if set or -1 otherwise\r\n     */\r\n    public getGlobalVolume(): number {\r\n        return this.masterGain.gain.value;\r\n    }\r\n\r\n    /**\r\n     * Sets the global volume of your experience (sets on the master gain).\r\n     * @param newVolume Defines the new global volume of the application\r\n     */\r\n    public setGlobalVolume(newVolume: number): void {\r\n        this.masterGain.gain.value = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Connect the audio engine to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n\r\n        this._connectedAnalyser = analyser;\r\n        this.masterGain.disconnect();\r\n        this._connectedAnalyser.connectAudioNodes(this.masterGain, this._v2._audioContext.destination);\r\n    }\r\n\r\n    private async _triggerRunningStateAsync() {\r\n        if (this._tryToRun) {\r\n            return;\r\n        }\r\n        this._tryToRun = true;\r\n\r\n        await this._resumeAudioContextAsync();\r\n\r\n        this._tryToRun = false;\r\n        this.unlocked = true;\r\n\r\n        this.onAudioUnlockedObservable.notifyObservers(this);\r\n    }\r\n}\r\n", "import { Tools } from \"../Misc/tools\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { IAudioEngine } from \"./Interfaces/IAudioEngine\";\r\nimport type { Observer } from \"../Misc/observable\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { _RetryWithInterval } from \"core/Misc/timingTools\";\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public autoplay: boolean = false;\r\n\r\n    private _loop = false;\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (value === this._loop) {\r\n            return;\r\n        }\r\n\r\n        this._loop = value;\r\n        this.updateOptions({ loop: value });\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public isPlaying: boolean = false;\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public isPaused: boolean = false;\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public maxDistance: number = 100;\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public distanceModel: string = \"linear\";\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        if (this._htmlAudioElement) {\r\n            return this._htmlAudioElement.currentTime;\r\n        }\r\n\r\n        if (AbstractEngine.audioEngine?.audioContext && (this.isPlaying || this.isPaused)) {\r\n            // The `_currentTime` member is only updated when the sound is paused. Add the time since the last start\r\n            // to get the actual current time.\r\n            const timeSinceLastStart = this.isPaused ? 0 : AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\r\n            return this._currentTime + timeSinceLastStart;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._spatialSound;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        if (newValue == this._spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const wasPlaying = this.isPlaying;\r\n        this.pause();\r\n\r\n        if (newValue) {\r\n            this._spatialSound = newValue;\r\n            this._updateSpatialParameters();\r\n        } else {\r\n            this._disableSpatialSound();\r\n        }\r\n\r\n        if (wasPlaying) {\r\n            this.play();\r\n        }\r\n    }\r\n\r\n    private _spatialSound: boolean = false;\r\n    private _panningModel: string = \"equalpower\";\r\n    private _playbackRate: number = 1;\r\n    private _streaming: boolean = false;\r\n    private _startTime: number = 0;\r\n    private _currentTime: number = 0;\r\n    private _position: Vector3 = Vector3.Zero();\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: Nullable<() => any>;\r\n    private _audioBuffer: Nullable<AudioBuffer>;\r\n    private _soundSource: Nullable<AudioBufferSourceNode>;\r\n    private _streamingSource: Nullable<AudioNode>;\r\n    private _soundPanner: Nullable<PannerNode>;\r\n    private _soundGain: Nullable<GainNode>;\r\n    private _inputAudioNode: Nullable<AudioNode>;\r\n    private _outputAudioNode: Nullable<AudioNode>;\r\n    // Used if you'd like to create a directional sound.\r\n    // If not set, the sound will be omnidirectional\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _coneOuterGain: number = 0;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _htmlAudioElement: Nullable<HTMLAudioElement>;\r\n    private _urlType: \"Unknown\" | \"String\" | \"Array\" | \"ArrayBuffer\" | \"MediaStream\" | \"AudioBuffer\" | \"MediaElement\" = \"Unknown\";\r\n    private _length?: number;\r\n    private _offset?: number;\r\n    private _tryToPlayTimeout: Nullable<NodeJS.Timeout>;\r\n    private _audioUnlockedObserver?: Nullable<Observer<IAudioEngine>>;\r\n    private _url?: Nullable<string>;\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        this.name = name;\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n\r\n        this._readyToPlayCallback = readyToPlayCallback;\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n        if (options) {\r\n            this.autoplay = options.autoplay || false;\r\n            this._loop = options.loop || false;\r\n            // if volume === 0, we need another way to check this option\r\n            if (options.volume !== undefined) {\r\n                this._volume = options.volume;\r\n            }\r\n            this._spatialSound = options.spatialSound ?? false;\r\n            this.maxDistance = options.maxDistance ?? 100;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n            this.rolloffFactor = options.rolloffFactor || 1;\r\n            this.refDistance = options.refDistance || 1;\r\n            this.distanceModel = options.distanceModel || \"linear\";\r\n            this._playbackRate = options.playbackRate || 1;\r\n            this._streaming = options.streaming ?? false;\r\n            this._length = options.length;\r\n            this._offset = options.offset;\r\n        }\r\n\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._soundGain = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._soundGain.gain.value = this._volume;\r\n            this._inputAudioNode = this._soundGain;\r\n            this._outputAudioNode = this._soundGain;\r\n            if (this._spatialSound) {\r\n                this._createSpatialParameters();\r\n            }\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            let validParameter = true;\r\n\r\n            // if no parameter is passed, you need to call setAudioBuffer yourself to prepare the sound\r\n            if (urlOrArrayBuffer) {\r\n                try {\r\n                    if (typeof urlOrArrayBuffer === \"string\") {\r\n                        this._urlType = \"String\";\r\n                        this._url = urlOrArrayBuffer;\r\n                    } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n                        this._urlType = \"ArrayBuffer\";\r\n                    } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n                        this._urlType = \"MediaElement\";\r\n                    } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n                        this._urlType = \"MediaStream\";\r\n                    } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n                        this._urlType = \"AudioBuffer\";\r\n                    } else if (Array.isArray(urlOrArrayBuffer)) {\r\n                        this._urlType = \"Array\";\r\n                    }\r\n\r\n                    let urls: string[] = [];\r\n                    let codecSupportedFound = false;\r\n\r\n                    switch (this._urlType) {\r\n                        case \"MediaElement\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"MediaStream\":\r\n                            this._streaming = true;\r\n                            this._isReadyToPlay = true;\r\n                            this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);\r\n\r\n                            if (this.autoplay) {\r\n                                this.play(0, this._offset, this._length);\r\n                            }\r\n\r\n                            if (this._readyToPlayCallback) {\r\n                                this._readyToPlayCallback();\r\n                            }\r\n                            break;\r\n                        case \"ArrayBuffer\":\r\n                            if ((<ArrayBuffer>urlOrArrayBuffer).byteLength > 0) {\r\n                                codecSupportedFound = true;\r\n                                this._soundLoaded(urlOrArrayBuffer);\r\n                            }\r\n                            break;\r\n                        case \"AudioBuffer\":\r\n                            this._audioBufferLoaded(urlOrArrayBuffer);\r\n                            break;\r\n                        case \"String\":\r\n                            urls.push(urlOrArrayBuffer);\r\n                        // eslint-disable-next-line no-fallthrough\r\n                        case \"Array\":\r\n                            if (urls.length === 0) {\r\n                                urls = urlOrArrayBuffer;\r\n                            }\r\n                            // If we found a supported format, we load it immediately and stop the loop\r\n                            for (let i = 0; i < urls.length; i++) {\r\n                                const url = urls[i];\r\n                                codecSupportedFound =\r\n                                    (options && options.skipCodecCheck) ||\r\n                                    (url.indexOf(\".mp3\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isMP3supported) ||\r\n                                    (url.indexOf(\".ogg\", url.length - 4) !== -1 && AbstractEngine.audioEngine.isOGGsupported) ||\r\n                                    url.indexOf(\".wav\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".m4a\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\".mp4\", url.length - 4) !== -1 ||\r\n                                    url.indexOf(\"blob:\") !== -1;\r\n                                if (codecSupportedFound) {\r\n                                    // Loading sound\r\n                                    if (!this._streaming) {\r\n                                        this._scene._loadFile(\r\n                                            url,\r\n                                            (data) => {\r\n                                                this._soundLoaded(data as ArrayBuffer);\r\n                                            },\r\n                                            undefined,\r\n                                            true,\r\n                                            true,\r\n                                            (exception) => {\r\n                                                if (exception) {\r\n                                                    Logger.Error(\"XHR \" + exception.status + \" error on: \" + url + \".\");\r\n                                                }\r\n                                                Logger.Error(\"Sound creation aborted.\");\r\n                                                this._scene.mainSoundTrack.removeSound(this);\r\n                                            }\r\n                                        );\r\n                                    }\r\n                                    // Streaming sound using HTML5 Audio tag\r\n                                    else {\r\n                                        this._htmlAudioElement = new Audio(url);\r\n                                        this._htmlAudioElement.controls = false;\r\n                                        this._htmlAudioElement.loop = this.loop;\r\n                                        Tools.SetCorsBehavior(url, this._htmlAudioElement);\r\n                                        this._htmlAudioElement.preload = \"auto\";\r\n                                        this._htmlAudioElement.addEventListener(\r\n                                            \"canplaythrough\",\r\n                                            () => {\r\n                                                this._isReadyToPlay = true;\r\n                                                if (this.autoplay) {\r\n                                                    this.play(0, this._offset, this._length);\r\n                                                }\r\n                                                if (this._readyToPlayCallback) {\r\n                                                    this._readyToPlayCallback();\r\n                                                }\r\n                                            },\r\n                                            { once: true }\r\n                                        );\r\n                                        document.body.appendChild(this._htmlAudioElement);\r\n                                        this._htmlAudioElement.load();\r\n                                    }\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        default:\r\n                            validParameter = false;\r\n                            break;\r\n                    }\r\n\r\n                    if (!validParameter) {\r\n                        Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n                    } else {\r\n                        if (!codecSupportedFound) {\r\n                            this._isReadyToPlay = true;\r\n                            // Simulating a ready to play event to avoid breaking code path\r\n                            if (this._readyToPlayCallback) {\r\n                                setTimeout(() => {\r\n                                    if (this._readyToPlayCallback) {\r\n                                        this._readyToPlayCallback();\r\n                                    }\r\n                                }, 1000);\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (ex) {\r\n                    Logger.Error(\"Unexpected error. Sound creation aborted.\");\r\n                    this._scene.mainSoundTrack.removeSound(this);\r\n                }\r\n            }\r\n        } else {\r\n            // Adding an empty sound to avoid breaking audio calls for non Web Audio browsers\r\n            this._scene.mainSoundTrack.addSound(this);\r\n            if (AbstractEngine.audioEngine && !AbstractEngine.audioEngine.WarnedWebAudioUnsupported) {\r\n                Logger.Error(\"Web Audio is not supported by your browser.\");\r\n                AbstractEngine.audioEngine.WarnedWebAudioUnsupported = true;\r\n            }\r\n            // Simulating a ready to play event to avoid breaking code for non web audio browsers\r\n            if (this._readyToPlayCallback) {\r\n                setTimeout(() => {\r\n                    if (this._readyToPlayCallback) {\r\n                        this._readyToPlayCallback();\r\n                    }\r\n                }, 1000);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            if (this.isPlaying) {\r\n                this.stop();\r\n            }\r\n            this._isReadyToPlay = false;\r\n            if (this.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(this);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n            }\r\n            if (this._soundGain) {\r\n                this._soundGain.disconnect();\r\n                this._soundGain = null;\r\n            }\r\n            if (this._soundPanner) {\r\n                this._soundPanner.disconnect();\r\n                this._soundPanner = null;\r\n            }\r\n            if (this._soundSource) {\r\n                this._soundSource.disconnect();\r\n                this._soundSource = null;\r\n            }\r\n            this._audioBuffer = null;\r\n\r\n            if (this._htmlAudioElement) {\r\n                this._htmlAudioElement.pause();\r\n                this._htmlAudioElement.src = \"\";\r\n                document.body.removeChild(this._htmlAudioElement);\r\n                this._htmlAudioElement = null;\r\n            }\r\n\r\n            if (this._streamingSource) {\r\n                this._streamingSource.disconnect();\r\n                this._streamingSource = null;\r\n            }\r\n\r\n            if (this._connectedTransformNode && this._registerFunc) {\r\n                this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n                this._connectedTransformNode = null;\r\n            }\r\n\r\n            this._clearTimeoutsAndObservers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    private _audioBufferLoaded(buffer: AudioBuffer) {\r\n        if (!AbstractEngine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        this._audioBuffer = buffer;\r\n        this._isReadyToPlay = true;\r\n        if (this.autoplay) {\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n        if (this._readyToPlayCallback) {\r\n            this._readyToPlayCallback();\r\n        }\r\n    }\r\n\r\n    private _soundLoaded(audioData: ArrayBuffer) {\r\n        if (!AbstractEngine.audioEngine?.audioContext) {\r\n            return;\r\n        }\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n        AbstractEngine.audioEngine.audioContext.decodeAudioData(\r\n            audioData,\r\n            (buffer) => {\r\n                this._audioBufferLoaded(buffer);\r\n            },\r\n            (err: any) => {\r\n                Logger.Error(\"Error while decoding audio data for: \" + this.name + \" / Error: \" + err);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            this._audioBuffer = audioBuffer;\r\n            this._isReadyToPlay = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            this._playbackRate = options.playbackRate ?? this._playbackRate;\r\n            this._length = options.length ?? undefined;\r\n            this.spatialSound = options.spatialSound ?? this._spatialSound;\r\n            this._setOffset(options.offset ?? undefined);\r\n            this.setVolume(options.volume ?? this._volume);\r\n            this._updateSpatialParameters();\r\n            if (this.isPlaying) {\r\n                if (this._streaming && this._htmlAudioElement) {\r\n                    this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    if (this._htmlAudioElement.loop !== this.loop) {\r\n                        this._htmlAudioElement.loop = this.loop;\r\n                    }\r\n                } else {\r\n                    if (this._soundSource) {\r\n                        this._soundSource.playbackRate.value = this._playbackRate;\r\n                        if (this._soundSource.loop !== this.loop) {\r\n                            this._soundSource.loop = this.loop;\r\n                        }\r\n                        if (this._offset !== undefined && this._soundSource.loopStart !== this._offset) {\r\n                            this._soundSource.loopStart = this._offset;\r\n                        }\r\n                        if (this._length !== undefined && this._length !== this._soundSource.loopEnd) {\r\n                            this._soundSource.loopEnd = (this._offset! | 0) + this._length;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createSpatialParameters() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            if (this._scene.headphone) {\r\n                this._panningModel = \"HRTF\";\r\n            }\r\n            this._soundPanner = this._soundPanner ?? AbstractEngine.audioEngine.audioContext.createPanner();\r\n            if (this._soundPanner && this._outputAudioNode) {\r\n                this._updateSpatialParameters();\r\n                this._soundPanner.connect(this._outputAudioNode);\r\n                this._inputAudioNode = this._soundPanner;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _disableSpatialSound() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        this._inputAudioNode = this._soundGain;\r\n        this._soundPanner?.disconnect();\r\n        this._soundPanner = null;\r\n        this._spatialSound = false;\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (!this._spatialSound) {\r\n            return;\r\n        }\r\n        if (this._soundPanner) {\r\n            if (this.useCustomAttenuation) {\r\n                // Tricks to disable in a way embedded Web Audio attenuation\r\n                this._soundPanner.distanceModel = \"linear\";\r\n                this._soundPanner.maxDistance = Number.MAX_VALUE;\r\n                this._soundPanner.refDistance = 1;\r\n                this._soundPanner.rolloffFactor = 1;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            } else {\r\n                this._soundPanner.distanceModel = this.distanceModel as any;\r\n                this._soundPanner.maxDistance = this.maxDistance;\r\n                this._soundPanner.refDistance = this.refDistance;\r\n                this._soundPanner.rolloffFactor = this.rolloffFactor;\r\n                this._soundPanner.panningModel = this._panningModel as any;\r\n            }\r\n        } else {\r\n            this._createSpatialParameters();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        this._panningModel = \"HRTF\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        this._panningModel = \"equalpower\";\r\n        this._switchPanningModel();\r\n    }\r\n\r\n    private _switchPanningModel() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n            this._soundPanner.panningModel = this._panningModel as any;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            if (this._isOutputConnected) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n        this._coneInnerAngle = coneInnerAngle;\r\n        this._coneOuterAngle = coneOuterAngle;\r\n        this._coneOuterGain = coneOuterGain;\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._offset, this._length);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value != this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value != this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio && this._spatialSound && this._soundPanner) {\r\n                this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (newPosition.equals(this._position)) {\r\n            return;\r\n        }\r\n        this._position.copyFrom(newPosition);\r\n\r\n        if (\r\n            AbstractEngine.audioEngine?.canUseWebAudio &&\r\n            this._spatialSound &&\r\n            this._soundPanner &&\r\n            !isNaN(this._position.x) &&\r\n            !isNaN(this._position.y) &&\r\n            !isNaN(this._position.z)\r\n        ) {\r\n            this._soundPanner.positionX.value = this._position.x;\r\n            this._soundPanner.positionY.value = this._position.y;\r\n            this._soundPanner.positionZ.value = this._position.z;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this._soundPanner) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n        this._soundPanner.orientationX.value = direction.x;\r\n        this._soundPanner.orientationY.value = direction.y;\r\n        this._soundPanner.orientationZ.value = direction.z;\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {\r\n            const distance = this._scene.audioListenerPositionProvider\r\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\r\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        if (this._isReadyToPlay && this._scene.audioEnabled && AbstractEngine.audioEngine?.audioContext) {\r\n            try {\r\n                this._clearTimeoutsAndObservers();\r\n\r\n                let startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine?.audioContext.currentTime;\r\n                if (!this._soundSource || !this._streamingSource) {\r\n                    if (this._spatialSound && this._soundPanner) {\r\n                        if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {\r\n                            this._soundPanner.positionX.value = this._position.x;\r\n                            this._soundPanner.positionY.value = this._position.y;\r\n                            this._soundPanner.positionZ.value = this._position.z;\r\n                        }\r\n                        if (this._isDirectional) {\r\n                            this._soundPanner.coneInnerAngle = this._coneInnerAngle;\r\n                            this._soundPanner.coneOuterAngle = this._coneOuterAngle;\r\n                            this._soundPanner.coneOuterGain = this._coneOuterGain;\r\n                            if (this._connectedTransformNode) {\r\n                                this._updateDirection();\r\n                            } else {\r\n                                this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (this._streaming) {\r\n                    if (!this._streamingSource && this._htmlAudioElement) {\r\n                        this._streamingSource = AbstractEngine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);\r\n                        this._htmlAudioElement.onended = () => {\r\n                            this._onended();\r\n                        };\r\n                        this._htmlAudioElement.playbackRate = this._playbackRate;\r\n                    }\r\n                    if (this._streamingSource) {\r\n                        this._streamingSource.disconnect();\r\n                        if (this._inputAudioNode) {\r\n                            this._streamingSource.connect(this._inputAudioNode);\r\n                        }\r\n                    }\r\n                    if (this._htmlAudioElement) {\r\n                        // required to manage properly the new suspended default state of Chrome\r\n                        // When the option 'streaming: true' is used, we need first to wait for\r\n                        // the audio engine to be unlocked by a user gesture before trying to play\r\n                        // an HTML Audio element\r\n                        const tryToPlay = () => {\r\n                            if (AbstractEngine.audioEngine?.unlocked) {\r\n                                if (!this._htmlAudioElement) {\r\n                                    return;\r\n                                }\r\n\r\n                                this._htmlAudioElement.currentTime = offset ?? 0;\r\n                                const playPromise = this._htmlAudioElement.play();\r\n\r\n                                // In browsers that dont yet support this functionality,\r\n                                // playPromise wont be defined.\r\n                                if (playPromise !== undefined) {\r\n                                    // eslint-disable-next-line github/no-then\r\n                                    playPromise.catch(() => {\r\n                                        // Automatic playback failed.\r\n                                        // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                        AbstractEngine.audioEngine?.lock();\r\n                                        if (this.loop || this.autoplay) {\r\n                                            this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                                tryToPlay();\r\n                                            });\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine?.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            }\r\n                        };\r\n                        tryToPlay();\r\n                    }\r\n                } else {\r\n                    const tryToPlay = () => {\r\n                        if (AbstractEngine.audioEngine?.audioContext) {\r\n                            length = length || this._length;\r\n\r\n                            if (offset !== undefined) {\r\n                                this._setOffset(offset);\r\n                            }\r\n\r\n                            if (this._soundSource) {\r\n                                const oldSource = this._soundSource;\r\n                                oldSource.onended = () => {\r\n                                    oldSource.disconnect();\r\n                                };\r\n                            }\r\n                            this._soundSource = AbstractEngine.audioEngine?.audioContext.createBufferSource();\r\n                            if (this._soundSource && this._inputAudioNode) {\r\n                                this._soundSource.buffer = this._audioBuffer;\r\n                                this._soundSource.connect(this._inputAudioNode);\r\n                                this._soundSource.loop = this.loop;\r\n                                if (offset !== undefined) {\r\n                                    this._soundSource.loopStart = offset;\r\n                                }\r\n                                if (length !== undefined) {\r\n                                    this._soundSource.loopEnd = (offset! | 0) + length;\r\n                                }\r\n                                this._soundSource.playbackRate.value = this._playbackRate;\r\n                                this._soundSource.onended = () => {\r\n                                    this._onended();\r\n                                };\r\n                                startTime = time ? AbstractEngine.audioEngine?.audioContext.currentTime + time : AbstractEngine.audioEngine.audioContext.currentTime;\r\n                                const actualOffset = ((this.isPaused ? this.currentTime : 0) + (this._offset ?? 0)) % this._soundSource.buffer!.duration;\r\n                                this._soundSource.start(startTime, actualOffset, this.loop ? undefined : length);\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    if (AbstractEngine.audioEngine?.audioContext.state === \"suspended\") {\r\n                        // Wait a bit for FF as context seems late to be ready.\r\n                        this._tryToPlayTimeout = setTimeout(() => {\r\n                            if (AbstractEngine.audioEngine?.audioContext!.state === \"suspended\") {\r\n                                // Automatic playback failed.\r\n                                // Waiting for the audio engine to be unlocked by user click on unmute\r\n                                AbstractEngine.audioEngine.lock();\r\n                                if (this.loop || this.autoplay) {\r\n                                    this._audioUnlockedObserver = AbstractEngine.audioEngine.onAudioUnlockedObservable.addOnce(() => {\r\n                                        tryToPlay();\r\n                                    });\r\n                                }\r\n                            } else {\r\n                                tryToPlay();\r\n                            }\r\n                        }, 500);\r\n                    } else {\r\n                        tryToPlay();\r\n                    }\r\n                }\r\n                this._startTime = startTime;\r\n                this.isPlaying = true;\r\n                this.isPaused = false;\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        this.isPlaying = false;\r\n        this._startTime = 0;\r\n        this._currentTime = 0;\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                    // Test needed for Firefox or it will generate an Invalid State Error\r\n                    if (this._htmlAudioElement.currentTime > 0) {\r\n                        this._htmlAudioElement.currentTime = 0;\r\n                    }\r\n                } else {\r\n                    this._streamingSource?.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n            } else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\r\n                const stopTime = time ? AbstractEngine.audioEngine.audioContext.currentTime + time : undefined;\r\n                this._soundSource.onended = () => {\r\n                    this.isPlaying = false;\r\n                    this.isPaused = false;\r\n                    this._startTime = 0;\r\n                    this._currentTime = 0;\r\n                    if (this._soundSource) {\r\n                        this._soundSource.onended = () => void 0;\r\n                    }\r\n                    this._onended();\r\n                };\r\n                this._soundSource.stop(stopTime);\r\n            } else {\r\n                this.isPlaying = false;\r\n            }\r\n        } else if (this.isPaused) {\r\n            this.isPaused = false;\r\n            this._startTime = 0;\r\n            this._currentTime = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (this.isPlaying) {\r\n            this._clearTimeoutsAndObservers();\r\n            if (this._streaming) {\r\n                if (this._htmlAudioElement) {\r\n                    this._htmlAudioElement.pause();\r\n                } else {\r\n                    this._streamingSource?.disconnect();\r\n                }\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n            } else if (AbstractEngine.audioEngine?.audioContext && this._soundSource) {\r\n                this._soundSource.onended = () => void 0;\r\n                this._soundSource.stop();\r\n                this.isPlaying = false;\r\n                this.isPaused = true;\r\n                this._currentTime += AbstractEngine.audioEngine.audioContext.currentTime - this._startTime;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._soundGain) {\r\n            if (time && AbstractEngine.audioEngine.audioContext) {\r\n                this._soundGain.gain.cancelScheduledValues(AbstractEngine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, AbstractEngine.audioEngine.audioContext.currentTime);\r\n                this._soundGain.gain.linearRampToValueAtTime(newVolume, AbstractEngine.audioEngine.audioContext.currentTime + time);\r\n            } else {\r\n                this._soundGain.gain.value = newVolume;\r\n            }\r\n        }\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        this._playbackRate = newPlaybackRate;\r\n        if (this.isPlaying) {\r\n            if (this._streaming && this._htmlAudioElement) {\r\n                this._htmlAudioElement.playbackRate = this._playbackRate;\r\n            } else if (this._soundSource) {\r\n                this._soundSource.playbackRate.value = this._playbackRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        return this._playbackRate;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this._spatialSound) {\r\n            this._spatialSound = true;\r\n            this._createSpatialParameters();\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._offset, this._length);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!this._streaming) {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => this._isReadyToPlay,\r\n                    () => {\r\n                        clonedSound._audioBuffer = this.getAudioBuffer();\r\n                        clonedSound._isReadyToPlay = true;\r\n                        if (clonedSound.autoplay) {\r\n                            clonedSound.play(0, this._offset, this._length);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n\r\n            const currentOptions = {\r\n                autoplay: this.autoplay,\r\n                loop: this.loop,\r\n                volume: this._volume,\r\n                spatialSound: this._spatialSound,\r\n                maxDistance: this.maxDistance,\r\n                useCustomAttenuation: this.useCustomAttenuation,\r\n                rolloffFactor: this.rolloffFactor,\r\n                refDistance: this.refDistance,\r\n                distanceModel: this.distanceModel,\r\n            };\r\n\r\n            const clonedSound = new Sound(this.name + \"_cloned\", new ArrayBuffer(0), this._scene, null, currentOptions);\r\n            if (this.useCustomAttenuation) {\r\n                clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n            }\r\n            clonedSound.setPosition(this._position);\r\n            clonedSound.setPlaybackRate(this._playbackRate);\r\n            setBufferAndRun();\r\n\r\n            return clonedSound;\r\n        }\r\n        // Can't clone a streaming sound\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        return this._audioBuffer;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        return this._soundSource;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundGain;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this._url,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this._spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this._playbackRate,\r\n            panningModel: this._panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this._spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this._coneInnerAngle;\r\n            serializationObject.coneOuterAngle = this._coneOuterAngle;\r\n            serializationObject.coneOuterGain = this._coneOuterGain;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n\r\n        let newSound: Sound;\r\n\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => sourceSound._isReadyToPlay,\r\n                    () => {\r\n                        newSound._audioBuffer = sourceSound.getAudioBuffer();\r\n                        newSound._isReadyToPlay = true;\r\n                        if (newSound.autoplay) {\r\n                            newSound.play(0, newSound._offset, newSound._length);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n\r\n        return newSound;\r\n    }\r\n\r\n    private _setOffset(value?: number) {\r\n        if (this._offset === value) {\r\n            return;\r\n        }\r\n        if (this.isPaused) {\r\n            this.stop();\r\n            this.isPaused = false;\r\n        }\r\n        this._offset = value;\r\n    }\r\n\r\n    private _clearTimeoutsAndObservers() {\r\n        if (this._tryToPlayTimeout) {\r\n            clearTimeout(this._tryToPlayTimeout);\r\n            this._tryToPlayTimeout = null;\r\n        }\r\n        if (this._audioUnlockedObserver) {\r\n            AbstractEngine.audioEngine?.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);\r\n            this._audioUnlockedObserver = null;\r\n        }\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.Sound\", Sound);\r\n", "import type { Sound } from \"./sound\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Options allowed during the creation of a sound track.\r\n */\r\nexport interface ISoundTrackOptions {\r\n    /**\r\n     * The volume the sound track should take during creation\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * Define if the sound track is the main sound track of the scene\r\n     */\r\n    mainTrack?: boolean;\r\n}\r\n\r\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n */\r\nexport class SoundTrack {\r\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\r\n    public id: number = -1;\r\n    /**\r\n     * The list of sounds included in the sound track.\r\n     */\r\n    public soundCollection: Array<Sound>;\r\n\r\n    private _outputAudioNode: Nullable<GainNode>;\r\n    private _scene: Scene;\r\n    private _connectedAnalyser: Analyser;\r\n    private _options: ISoundTrackOptions;\r\n    private _isInitialized = false;\r\n\r\n    /**\r\n     * Creates a new sound track.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n     * @param scene Define the scene the sound track belongs to\r\n     * @param options\r\n     */\r\n    constructor(scene?: Nullable<Scene>, options: ISoundTrackOptions = {}) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        this.soundCollection = [];\r\n        this._options = options;\r\n\r\n        if (!this._options.mainTrack && this._scene.soundTracks) {\r\n            this._scene.soundTracks.push(this);\r\n            this.id = this._scene.soundTracks.length - 1;\r\n        }\r\n    }\r\n\r\n    private _initializeSoundTrackAudioGraph() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\r\n\r\n            if (this._options) {\r\n                if (this._options.volume) {\r\n                    this._outputAudioNode.gain.value = this._options.volume;\r\n                }\r\n            }\r\n\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound track and its associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\r\n            if (this._connectedAnalyser) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n            }\r\n            while (this.soundCollection.length) {\r\n                this.soundCollection[0].dispose();\r\n            }\r\n            if (this._outputAudioNode) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a sound to this sound track\r\n     * @param sound define the sound to add\r\n     * @ignoreNaming\r\n     */\r\n    public addSound(sound: Sound): void {\r\n        if (!this._isInitialized) {\r\n            this._initializeSoundTrackAudioGraph();\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\r\n        }\r\n        if (sound.soundTrackId !== undefined) {\r\n            if (sound.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(sound);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\r\n            }\r\n        }\r\n\r\n        this.soundCollection.push(sound);\r\n        sound.soundTrackId = this.id;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound to this sound track\r\n     * @param sound define the sound to remove\r\n     * @ignoreNaming\r\n     */\r\n    public removeSound(sound: Sound): void {\r\n        const index = this.soundCollection.indexOf(sound);\r\n        if (index !== -1) {\r\n            this.soundCollection.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global volume for the full sound track.\r\n     * @param newVolume Define the new volume of the sound track\r\n     */\r\n    public setVolume(newVolume: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the sound track to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        this._connectedAnalyser = analyser;\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\r\n        }\r\n    }\r\n}\r\n", "import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (BabylonFileParsers[name]) {\r\n        return BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (IndividualBabylonFileParsers[name]) {\r\n        return IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(BabylonFileParsers, parserName)) {\r\n            BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "import { Sound } from \"./sound\";\r\nimport { SoundTrack } from \"./soundTrack\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"./audioEngine\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    // TODO: add sound\r\n    let loadedSounds: Sound[] = [];\r\n    let loadedSound: Sound;\r\n    container.sounds = container.sounds || [];\r\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\r\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\r\n            const parsedSound = parsedData.sounds[index];\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n                if (!parsedSound.url) {\r\n                    parsedSound.url = parsedSound.name;\r\n                }\r\n                if (!loadedSounds[parsedSound.url]) {\r\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\r\n                    loadedSounds[parsedSound.url] = loadedSound;\r\n                    container.sounds.push(loadedSound);\r\n                } else {\r\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\r\n                }\r\n            } else {\r\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\r\n            }\r\n        }\r\n    }\r\n\r\n    loadedSounds = [];\r\n});\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing field\r\n         */\r\n        _mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The main sound track played by the scene.\r\n         * It contains your primary collection of sounds.\r\n         */\r\n        mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The list of sound tracks added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        soundTracks: Nullable<Array<SoundTrack>>;\r\n\r\n        /**\r\n         * Gets a sound using a given name\r\n         * @param name defines the name to search for\r\n         * @returns the found sound or null if not found at all.\r\n         */\r\n        getSoundByName(name: string): Nullable<Sound>;\r\n\r\n        /**\r\n         * Gets or sets if audio support is enabled\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioEnabled: boolean;\r\n\r\n        /**\r\n         * Gets or sets if audio will be output to headphones\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        headphone: boolean;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener position provider\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioListenerPositionProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener rotation provider\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic\r\n         */\r\n        audioListenerRotationProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets a refresh rate when using 3D audio positioning\r\n         */\r\n        audioPositioningRefreshRate: number;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (!this._mainSoundTrack) {\r\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\r\n        }\r\n\r\n        return this._mainSoundTrack;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getSoundByName = function (name: string): Nullable<Sound> {\r\n    let index: number;\r\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\r\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\r\n            return this.mainSoundTrack.soundCollection[index];\r\n        }\r\n    }\r\n\r\n    if (this.soundTracks) {\r\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\r\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\r\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\r\n                    return this.soundTracks[sdIndex].soundCollection[index];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioEnabled;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.enableAudio();\r\n        } else {\r\n            compo.disableAudio();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"headphone\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.headphone;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.switchAudioModeForHeadphones();\r\n        } else {\r\n            compo.switchAudioModeForNormalSpeakers();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerPositionProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerPositionProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerRotationProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerRotationProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioPositioningRefreshRate;\r\n    },\r\n    set: function (this: Scene, value: number) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        compo.audioPositioningRefreshRate = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Defines the sound scene component responsible to manage any sounds\r\n * in a given scene.\r\n */\r\nexport class AudioSceneComponent implements ISceneSerializableComponent {\r\n    private static _CameraDirection = new Vector3(0, 0, -1);\r\n\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_AUDIO;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _audioEnabled = true;\r\n    /**\r\n     * Gets whether audio is enabled or not.\r\n     * Please use related enable/disable method to switch state.\r\n     */\r\n    public get audioEnabled(): boolean {\r\n        return this._audioEnabled;\r\n    }\r\n\r\n    private _headphone = false;\r\n    /**\r\n     * Gets whether audio is outputting to headphone or not.\r\n     * Please use the according Switch methods to change output.\r\n     */\r\n    public get headphone(): boolean {\r\n        return this._headphone;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a refresh rate when using 3D audio positioning\r\n     */\r\n    public audioPositioningRefreshRate = 500;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener position for all sounds in the scene\r\n     * By default, this is the position of the first active camera\r\n     */\r\n    public audioListenerPositionProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener rotation for all sounds in the scene\r\n     * By default, this is the rotation of the first active camera\r\n     */\r\n    public audioListenerRotationProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        scene.soundTracks = [] as SoundTrack[];\r\n        scene.sounds = [] as Sound[];\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here. (Not rendering related)\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        serializationObject.sounds = [];\r\n\r\n        if (this.scene.soundTracks) {\r\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\r\n                const soundtrack = this.scene.soundTracks[index];\r\n\r\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\r\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.play();\r\n            sound.autoplay = true;\r\n            this.scene.mainSoundTrack.addSound(sound);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose = false): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.stop();\r\n            sound.autoplay = false;\r\n            this.scene.mainSoundTrack.removeSound(sound);\r\n            if (dispose) {\r\n                sound.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.scene;\r\n        if (scene._mainSoundTrack) {\r\n            scene.mainSoundTrack.dispose();\r\n        }\r\n\r\n        if (scene.soundTracks) {\r\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\r\n                scene.soundTracks[scIndex].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables audio in the associated scene.\r\n     */\r\n    public disableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = false;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.suspend();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            scene.mainSoundTrack.soundCollection[i].pause();\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    scene.soundTracks[i].soundCollection[j].pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables audio in the associated scene.\r\n     */\r\n    public enableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = true;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.resume();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\r\n                scene.mainSoundTrack.soundCollection[i].play();\r\n            }\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\r\n                        scene.soundTracks[i].soundCollection[j].play();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to headphone output.\r\n     */\r\n    public switchAudioModeForHeadphones() {\r\n        const scene = this.scene;\r\n        this._headphone = true;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToHRTF();\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to normal speakers.\r\n     */\r\n    public switchAudioModeForNormalSpeakers() {\r\n        const scene = this.scene;\r\n        this._headphone = false;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\r\n\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _cachedCameraDirection = new Vector3();\r\n    private _cachedCameraPosition = new Vector3();\r\n    private _lastCheck = 0;\r\n    private _invertMatrixTemp = new Matrix();\r\n    private _cameraDirectionTemp = new Vector3();\r\n\r\n    private _afterRender() {\r\n        const now = PrecisionDate.Now;\r\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck = now;\r\n\r\n        const scene = this.scene;\r\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\r\n            return;\r\n        }\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        if (audioEngine.audioContext) {\r\n            let listeningCamera = scene.activeCamera;\r\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\r\n                listeningCamera = scene.activeCameras[0];\r\n            }\r\n\r\n            // A custom listener position provider was set\r\n            // Use the users provided position instead of camera's\r\n            if (this.audioListenerPositionProvider) {\r\n                const position: Vector3 = this.audioListenerPositionProvider();\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // Set the listener position to the listening camera global position\r\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\r\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\r\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\r\n                }\r\n            }\r\n            // Otherwise set the listener position to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\r\n            }\r\n\r\n            // A custom listener rotation provider was set\r\n            // Use the users provided rotation instead of camera's\r\n            if (this.audioListenerRotationProvider) {\r\n                const rotation: Vector3 = this.audioListenerRotationProvider();\r\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // for VR cameras\r\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\r\n                    listeningCamera = listeningCamera.rigCameras[0];\r\n                }\r\n\r\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\r\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\r\n                this._cameraDirectionTemp.normalize();\r\n                // To avoid some errors on GearVR\r\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\r\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\r\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\r\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise set the listener rotation to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\r\n            }\r\n\r\n            let i: number;\r\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n                const sound = scene.mainSoundTrack.soundCollection[i];\r\n                if (sound.useCustomAttenuation) {\r\n                    sound.updateDistanceFromListener();\r\n                }\r\n            }\r\n            if (scene.soundTracks) {\r\n                for (i = 0; i < scene.soundTracks.length; i++) {\r\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                        const sound = scene.soundTracks[i].soundCollection[j];\r\n                        if (sound.useCustomAttenuation) {\r\n                            sound.updateDistanceFromListener();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nSound._SceneComponentInitialization = (scene: Scene) => {\r\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\r\n    if (!compo) {\r\n        compo = new AudioSceneComponent(scene);\r\n        scene._addComponent(compo);\r\n    }\r\n};\r\n", "import type { Sound } from \"../Audio/sound\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Wraps one or more Sound objects and selects one with random weight for playback.\r\n */\r\nexport class WeightedSound {\r\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\r\n    public loop: boolean = false;\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _volume: number = 1;\r\n    /** A Sound is currently playing. */\r\n    public isPlaying: boolean = false;\r\n    /** A Sound is currently paused. */\r\n    public isPaused: boolean = false;\r\n\r\n    private _sounds: Sound[] = [];\r\n    private _weights: number[] = [];\r\n    private _currentIndex?: number;\r\n\r\n    /**\r\n     * Creates a new WeightedSound from the list of sounds given.\r\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\r\n     * @param sounds Array of Sounds that will be selected from.\r\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\r\n     */\r\n    constructor(loop: boolean, sounds: Sound[], weights: number[]) {\r\n        if (sounds.length !== weights.length) {\r\n            throw new Error(\"Sounds length does not equal weights length\");\r\n        }\r\n\r\n        this.loop = loop;\r\n        this._weights = weights;\r\n        // Normalize the weights\r\n        let weightSum = 0;\r\n        for (const weight of weights) {\r\n            weightSum += weight;\r\n        }\r\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\r\n        for (let i = 0; i < this._weights.length; i++) {\r\n            this._weights[i] *= invWeightSum;\r\n        }\r\n        this._sounds = sounds;\r\n        for (const sound of this._sounds) {\r\n            sound.onEndedObservable.add(() => {\r\n                this._onended();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value !== this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value !== this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public get volume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public set volume(value: number) {\r\n        if (value !== this._volume) {\r\n            for (const sound of this._sounds) {\r\n                sound.setVolume(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].autoplay = false;\r\n        }\r\n        if (this.loop && this.isPlaying) {\r\n            this.play();\r\n        } else {\r\n            this.isPlaying = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Suspend playback\r\n     */\r\n    public pause() {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._currentIndex !== undefined) {\r\n                this._sounds[this._currentIndex].pause();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop playback\r\n     */\r\n    public stop() {\r\n        this.isPlaying = false;\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start playback.\r\n     * @param startOffset Position the clip head at a specific time in seconds.\r\n     */\r\n    public play(startOffset?: number) {\r\n        if (!this.isPaused) {\r\n            this.stop();\r\n            const randomValue = Math.random();\r\n            let total = 0;\r\n            for (let i = 0; i < this._weights.length; i++) {\r\n                total += this._weights[i];\r\n                if (randomValue <= total) {\r\n                    this._currentIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const sound = this._sounds[this._currentIndex ?? 0];\r\n        if (sound.isReady()) {\r\n            sound.play(0, this.isPaused ? undefined : startOffset);\r\n        } else {\r\n            sound.autoplay = true;\r\n        }\r\n        this.isPlaying = true;\r\n        this.isPaused = false;\r\n    }\r\n}\r\n", "import { Bone } from \"./bone\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Animatable } from \"../Animations/animatable.core\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { Animation } from \"../Animations/animation\";\r\nimport { AnimationRange } from \"../Animations/animationRange\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { DeepCopier } from \"../Misc/deepCopier\";\r\nimport type { IInspectable } from \"../Misc/iInspectable\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n/**\r\n * Class used to handle skinning animations\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\r\n */\r\nexport class Skeleton implements IAnimatable {\r\n    /**\r\n     * Defines the list of child bones\r\n     */\r\n    public bones: Bone[] = [];\r\n    /**\r\n     * Defines an estimate of the dimension of the skeleton at rest\r\n     */\r\n    public dimensionsAtRest: Vector3;\r\n    /**\r\n     * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\r\n     */\r\n    public needInitialSkinMatrix = false;\r\n\r\n    /**\r\n     * Gets the list of animations attached to this skeleton\r\n     */\r\n    public animations: Array<Animation>;\r\n\r\n    private _scene: Scene;\r\n    private _isDirty = true;\r\n    private _transformMatrices: Float32Array;\r\n    private _transformMatrixTexture: Nullable<RawTexture>;\r\n    private _meshesWithPoseMatrix = new Array<AbstractMesh>();\r\n    private _animatables: IAnimatable[];\r\n    private _identity = Matrix.Identity();\r\n    private _synchronizedWithMesh: AbstractMesh;\r\n    private _currentRenderId = -1;\r\n\r\n    private _ranges: { [name: string]: Nullable<AnimationRange> } = {};\r\n\r\n    private _absoluteTransformIsDirty = true;\r\n\r\n    private _canUseTextureForBones = false;\r\n    private _uniqueId = 0;\r\n\r\n    /** @internal */\r\n    public _numBonesWithLinkedTransformNode = 0;\r\n\r\n    /** @internal */\r\n    public _hasWaitingData: Nullable<boolean> = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Specifies if the skeleton should be serialized\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    private _useTextureToStoreBoneMatrices = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreBoneMatrices(): boolean {\r\n        return this._useTextureToStoreBoneMatrices;\r\n    }\r\n\r\n    public set useTextureToStoreBoneMatrices(value: boolean) {\r\n        this._useTextureToStoreBoneMatrices = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * List of inspectable custom properties (used by the Inspector)\r\n     * @see https://doc.babylonjs.com/toolsAndResources/inspector#extensibility\r\n     */\r\n    public inspectableCustomProperties: IInspectable[];\r\n\r\n    // Events\r\n\r\n    /**\r\n     * An observable triggered before computing the skeleton's matrices\r\n     */\r\n    public onBeforeComputeObservable = new Observable<Skeleton>();\r\n\r\n    /**\r\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\r\n     */\r\n    public get isUsingTextureForMatrices() {\r\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this skeleton\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the skeleton\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Creates a new skeleton\r\n     * @param name defines the skeleton name\r\n     * @param id defines the skeleton Id\r\n     * @param scene defines the hosting scene\r\n     */\r\n    constructor(\r\n        /** defines the skeleton name */\r\n        public name: string,\r\n        /** defines the skeleton Id */\r\n        public id: string,\r\n        scene: Scene\r\n    ) {\r\n        this.bones = [];\r\n\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this._uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addSkeleton(this);\r\n\r\n        //make sure it will recalculate the matrix next time prepare is called.\r\n        this._isDirty = true;\r\n\r\n        const engineCaps = this._scene.getEngine().getCaps();\r\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Skeleton\";\r\n    }\r\n\r\n    /**\r\n     * Returns an array containing the root bones\r\n     * @returns an array containing the root bones\r\n     */\r\n    public getChildren(): Array<Bone> {\r\n        return this.bones.filter((b) => !b.getParent());\r\n    }\r\n\r\n    // Members\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a Float32Array containing matrices data\r\n     */\r\n    public getTransformMatrices(mesh: Nullable<AbstractMesh>): Float32Array {\r\n        if (this.needInitialSkinMatrix) {\r\n            if (!mesh) {\r\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\r\n            }\r\n            if (!mesh._bonesTransformMatrices) {\r\n                this.prepare(true);\r\n            }\r\n\r\n            return mesh._bonesTransformMatrices!;\r\n        }\r\n\r\n        if (!this._transformMatrices || this._isDirty) {\r\n            this.prepare(!this._transformMatrices);\r\n        }\r\n\r\n        return this._transformMatrices;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\r\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\r\n     * @returns a raw texture containing the data\r\n     */\r\n    public getTransformMatrixTexture(mesh: AbstractMesh): Nullable<RawTexture> {\r\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\r\n            return mesh._transformMatrixTexture;\r\n        }\r\n\r\n        return this._transformMatrixTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the current hosting scene\r\n     * @returns a scene object\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Gets a string representing the current skeleton data\r\n     * @param fullDetails defines a boolean indicating if we want a verbose version\r\n     * @returns a string representing the current skeleton data\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\r\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\r\n        if (fullDetails) {\r\n            ret += \", Ranges: {\";\r\n            let first = true;\r\n            for (const name in this._ranges) {\r\n                if (first) {\r\n                    ret += \", \";\r\n                    first = false;\r\n                }\r\n                ret += name;\r\n            }\r\n            ret += \"}\";\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get bone's index searching by name\r\n     * @param name defines bone's name to search for\r\n     * @returns the indice of the bone. Returns -1 if not found\r\n     */\r\n    public getBoneIndexByName(name: string): number {\r\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\r\n            if (this.bones[boneIndex].name === name) {\r\n                return boneIndex;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Create a new animation range\r\n     * @param name defines the name of the range\r\n     * @param from defines the start key\r\n     * @param to defines the end key\r\n     */\r\n    public createAnimationRange(name: string, from: number, to: number): void {\r\n        // check name not already in use\r\n        if (!this._ranges[name]) {\r\n            this._ranges[name] = new AnimationRange(name, from, to);\r\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n                if (this.bones[i].animations[0]) {\r\n                    this.bones[i].animations[0].createRange(name, from, to);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete a specific animation range\r\n     * @param name defines the name of the range\r\n     * @param deleteFrames defines if frames must be removed as well\r\n     */\r\n    public deleteAnimationRange(name: string, deleteFrames = true): void {\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\r\n            }\r\n        }\r\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\r\n    }\r\n\r\n    /**\r\n     * Gets a specific animation range\r\n     * @param name defines the name of the range to look for\r\n     * @returns the requested animation range or null if not found\r\n     */\r\n    public getAnimationRange(name: string): Nullable<AnimationRange> {\r\n        return this._ranges[name] || null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of all animation ranges defined on this skeleton\r\n     * @returns an array\r\n     */\r\n    public getAnimationRanges(): Nullable<AnimationRange>[] {\r\n        const animationRanges: Nullable<AnimationRange>[] = [];\r\n        let name: string;\r\n        for (name in this._ranges) {\r\n            animationRanges.push(this._ranges[name]);\r\n        }\r\n        return animationRanges;\r\n    }\r\n\r\n    /**\r\n     * Copy animation range from a source skeleton.\r\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\r\n     * @param source defines the source skeleton\r\n     * @param name defines the name of the range to copy\r\n     * @param rescaleAsRequired defines if rescaling must be applied if required\r\n     * @returns true if operation was successful\r\n     */\r\n    public copyAnimationRange(source: Skeleton, name: string, rescaleAsRequired = false): boolean {\r\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\r\n            return false;\r\n        }\r\n        let ret = true;\r\n        const frameOffset = this._getHighestAnimationFrame() + 1;\r\n\r\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\r\n        const boneDict: { [key: string]: Bone } = {};\r\n        const sourceBones = source.bones;\r\n        let nBones: number;\r\n        let i: number;\r\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\r\n            boneDict[sourceBones[i].name] = sourceBones[i];\r\n        }\r\n\r\n        if (this.bones.length !== sourceBones.length) {\r\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\r\n            ret = false;\r\n        }\r\n\r\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\r\n\r\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            const boneName = this.bones[i].name;\r\n            const sourceBone = boneDict[boneName];\r\n            if (sourceBone) {\r\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\r\n            } else {\r\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\r\n                ret = false;\r\n            }\r\n        }\r\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\r\n        const range = source.getAnimationRange(name);\r\n        if (range) {\r\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Forces the skeleton to go to rest pose\r\n     */\r\n    public returnToRest(): void {\r\n        for (const bone of this.bones) {\r\n            if (bone._index !== -1) {\r\n                bone.returnToRest();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getHighestAnimationFrame(): number {\r\n        let ret = 0;\r\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\r\n            if (this.bones[i].animations[0]) {\r\n                const highest = this.bones[i].animations[0].getHighestFrame();\r\n                if (ret < highest) {\r\n                    ret = highest;\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Begin a specific animation range\r\n     * @param name defines the name of the range to start\r\n     * @param loop defines if looping must be turned on (false by default)\r\n     * @param speedRatio defines the speed ratio to apply (1 by default)\r\n     * @param onAnimationEnd defines a callback which will be called when animation will end\r\n     * @returns a new animatable\r\n     */\r\n    public beginAnimation(name: string, loop?: boolean, speedRatio?: number, onAnimationEnd?: () => void): Nullable<Animatable> {\r\n        const range = this.getAnimationRange(name);\r\n\r\n        if (!range) {\r\n            return null;\r\n        }\r\n\r\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\r\n     * @param skeleton defines the Skeleton containing the animation range to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\r\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\r\n     * @returns the original skeleton\r\n     */\r\n    public static MakeAnimationAdditive(skeleton: Skeleton, referenceFrame = 0, range: string): Nullable<Skeleton> {\r\n        const rangeValue = skeleton.getAnimationRange(range);\r\n\r\n        // We can't make a range additive if it doesn't exist\r\n        if (!rangeValue) {\r\n            return null;\r\n        }\r\n\r\n        // Find any current scene-level animatable belonging to the target that matches the range\r\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\r\n        let rangeAnimatable: Nullable<Animatable> = null;\r\n\r\n        for (let index = 0; index < sceneAnimatables.length; index++) {\r\n            const sceneAnimatable = sceneAnimatables[index];\r\n\r\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\r\n                rangeAnimatable = sceneAnimatable;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Convert the animations belonging to the skeleton to additive keyframes\r\n        const animatables = skeleton.getAnimatables();\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n            const animations = animatable.animations;\r\n\r\n            if (!animations) {\r\n                continue;\r\n            }\r\n\r\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\r\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\r\n            }\r\n        }\r\n\r\n        // Mark the scene-level animatable as additive\r\n        if (rangeAnimatable) {\r\n            rangeAnimatable.isAdditive = true;\r\n        }\r\n\r\n        return skeleton;\r\n    }\r\n\r\n    /** @internal */\r\n    public _markAsDirty(): void {\r\n        this._isDirty = true;\r\n        this._absoluteTransformIsDirty = true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        this._meshesWithPoseMatrix.push(mesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _unregisterMeshWithPoseMatrix(mesh: AbstractMesh): void {\r\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\r\n\r\n        if (index > -1) {\r\n            this._meshesWithPoseMatrix.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    private _computeTransformMatrices(targetMatrix: Float32Array, initialSkinMatrix: Nullable<Matrix>): void {\r\n        this.onBeforeComputeObservable.notifyObservers(this);\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            bone._childUpdateId++;\r\n            const parentBone = bone.getParent();\r\n\r\n            if (parentBone) {\r\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\r\n            } else {\r\n                if (initialSkinMatrix) {\r\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\r\n                } else {\r\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\r\n                }\r\n            }\r\n\r\n            if (bone._index !== -1) {\r\n                const mappedIndex = bone._index === null ? index : bone._index;\r\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\r\n            }\r\n        }\r\n\r\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\r\n    }\r\n\r\n    /**\r\n     * Build all resources required to render a skeleton\r\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\r\n     */\r\n    public prepare(dontCheckFrameId = false): void {\r\n        if (!dontCheckFrameId) {\r\n            const currentRenderId = this.getScene().getRenderId();\r\n            if (this._currentRenderId === currentRenderId) {\r\n                return;\r\n            }\r\n            this._currentRenderId = currentRenderId;\r\n        }\r\n\r\n        // Update the local matrix of bones with linked transform nodes.\r\n        if (this._numBonesWithLinkedTransformNode > 0) {\r\n            for (const bone of this.bones) {\r\n                if (bone._linkedTransformNode) {\r\n                    const node = bone._linkedTransformNode;\r\n                    bone.position = node.position;\r\n                    if (node.rotationQuaternion) {\r\n                        bone.rotationQuaternion = node.rotationQuaternion;\r\n                    } else {\r\n                        bone.rotation = node.rotation;\r\n                    }\r\n                    bone.scaling = node.scaling;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (this.needInitialSkinMatrix) {\r\n            for (const mesh of this._meshesWithPoseMatrix) {\r\n                const poseMatrix = mesh.getPoseMatrix();\r\n\r\n                let needsUpdate = this._isDirty;\r\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n                    needsUpdate = true;\r\n                }\r\n\r\n                if (!needsUpdate) {\r\n                    continue;\r\n                }\r\n\r\n                if (this._synchronizedWithMesh !== mesh) {\r\n                    this._synchronizedWithMesh = mesh;\r\n\r\n                    // Prepare bones\r\n                    for (const bone of this.bones) {\r\n                        if (!bone.getParent()) {\r\n                            const matrix = bone.getBindMatrix();\r\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\r\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\r\n                        }\r\n                    }\r\n\r\n                    if (this.isUsingTextureForMatrices) {\r\n                        const textureWidth = (this.bones.length + 1) * 4;\r\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\r\n                            if (mesh._transformMatrixTexture) {\r\n                                mesh._transformMatrixTexture.dispose();\r\n                            }\r\n\r\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                                mesh._bonesTransformMatrices,\r\n                                (this.bones.length + 1) * 4,\r\n                                1,\r\n                                this._scene,\r\n                                false,\r\n                                false,\r\n                                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                                Constants.TEXTURETYPE_FLOAT\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\r\n\r\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\r\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\r\n                }\r\n            }\r\n        } else {\r\n            if (!this._isDirty) {\r\n                return;\r\n            }\r\n\r\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\r\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\r\n\r\n                if (this.isUsingTextureForMatrices) {\r\n                    if (this._transformMatrixTexture) {\r\n                        this._transformMatrixTexture.dispose();\r\n                    }\r\n\r\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(\r\n                        this._transformMatrices,\r\n                        (this.bones.length + 1) * 4,\r\n                        1,\r\n                        this._scene,\r\n                        false,\r\n                        false,\r\n                        Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                        Constants.TEXTURETYPE_FLOAT\r\n                    );\r\n                }\r\n            }\r\n\r\n            this._computeTransformMatrices(this._transformMatrices, null);\r\n\r\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\r\n                this._transformMatrixTexture.update(this._transformMatrices);\r\n            }\r\n        }\r\n\r\n        this._isDirty = false;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of animatables currently running for this skeleton\r\n     * @returns an array of animatables\r\n     */\r\n    public getAnimatables(): IAnimatable[] {\r\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\r\n            this._animatables = [];\r\n\r\n            for (let index = 0; index < this.bones.length; index++) {\r\n                this._animatables.push(this.bones[index]);\r\n            }\r\n        }\r\n\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Clone the current skeleton\r\n     * @param name defines the name of the new skeleton\r\n     * @param id defines the id of the new skeleton\r\n     * @returns the new skeleton\r\n     */\r\n    public clone(name: string, id?: string): Skeleton {\r\n        const result = new Skeleton(name, id || name, this._scene);\r\n\r\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n        result.metadata = this.metadata;\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const source = this.bones[index];\r\n            let parentBone = null;\r\n\r\n            const parent = source.getParent();\r\n            if (parent) {\r\n                const parentIndex = this.bones.indexOf(parent);\r\n                parentBone = result.bones[parentIndex];\r\n            }\r\n\r\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\r\n            bone._index = source._index;\r\n\r\n            if (source._linkedTransformNode) {\r\n                bone.linkTransformNode(source._linkedTransformNode);\r\n            }\r\n\r\n            DeepCopier.DeepCopy(source.animations, bone.animations);\r\n        }\r\n\r\n        if (this._ranges) {\r\n            result._ranges = {};\r\n            for (const rangeName in this._ranges) {\r\n                const range = this._ranges[rangeName];\r\n\r\n                if (range) {\r\n                    result._ranges[rangeName] = range.clone();\r\n                }\r\n            }\r\n        }\r\n\r\n        this._isDirty = true;\r\n\r\n        result.prepare(true);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Enable animation blending for this skeleton\r\n     * @param blendingSpeed defines the blending speed to apply\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public enableBlending(blendingSpeed = 0.01) {\r\n        for (const bone of this.bones) {\r\n            for (const animation of bone.animations) {\r\n                animation.enableBlending = true;\r\n                animation.blendingSpeed = blendingSpeed;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Releases all resources associated with the current skeleton\r\n     */\r\n    public dispose() {\r\n        this._meshesWithPoseMatrix.length = 0;\r\n        this.metadata = null;\r\n\r\n        // Animations\r\n        this.getScene().stopAnimation(this);\r\n\r\n        // Remove from scene\r\n        this.getScene().removeSkeleton(this);\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.skeletons.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.skeletons.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._transformMatrixTexture) {\r\n            this._transformMatrixTexture.dispose();\r\n            this._transformMatrixTexture = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize the skeleton in a JSON object\r\n     * @returns a JSON object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.id = this.id;\r\n\r\n        if (this.dimensionsAtRest) {\r\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\r\n        }\r\n\r\n        serializationObject.bones = [];\r\n\r\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            const bone = this.bones[index];\r\n            const parent = bone.getParent();\r\n\r\n            const serializedBone: any = {\r\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\r\n                index: bone.getIndex(),\r\n                name: bone.name,\r\n                id: bone.id,\r\n                matrix: bone.getBindMatrix().asArray(),\r\n                rest: bone.getRestMatrix().asArray(),\r\n                linkedTransformNodeId: bone.getTransformNode()?.id,\r\n            };\r\n\r\n            serializationObject.bones.push(serializedBone);\r\n\r\n            if (bone.length) {\r\n                serializedBone.length = bone.length;\r\n            }\r\n\r\n            if (bone.metadata) {\r\n                serializedBone.metadata = bone.metadata;\r\n            }\r\n\r\n            if (bone.animations && bone.animations.length > 0) {\r\n                serializedBone.animation = bone.animations[0].serialize();\r\n            }\r\n\r\n            serializationObject.ranges = [];\r\n            for (const name in this._ranges) {\r\n                const source = this._ranges[name];\r\n\r\n                if (!source) {\r\n                    continue;\r\n                }\r\n\r\n                const range: any = {};\r\n                range.name = name;\r\n                range.from = source.from;\r\n                range.to = source.to;\r\n                serializationObject.ranges.push(range);\r\n            }\r\n        }\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a new skeleton from serialized data\r\n     * @param parsedSkeleton defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns a new skeleton\r\n     */\r\n    public static Parse(parsedSkeleton: any, scene: Scene): Skeleton {\r\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\r\n        if (parsedSkeleton.dimensionsAtRest) {\r\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\r\n        }\r\n\r\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\r\n\r\n        if (parsedSkeleton.metadata) {\r\n            skeleton.metadata = parsedSkeleton.metadata;\r\n        }\r\n\r\n        let index: number;\r\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\r\n            const parsedBone = parsedSkeleton.bones[index];\r\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\r\n            let parentBone = null;\r\n            if (parsedBone.parentBoneIndex > -1) {\r\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\r\n            }\r\n\r\n            const rest: Nullable<Matrix> = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\r\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\r\n\r\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\r\n                bone.id = parsedBone.id;\r\n            }\r\n\r\n            if (parsedBone.length) {\r\n                bone.length = parsedBone.length;\r\n            }\r\n\r\n            if (parsedBone.metadata) {\r\n                bone.metadata = parsedBone.metadata;\r\n            }\r\n\r\n            if (parsedBone.animation) {\r\n                bone.animations.push(Animation.Parse(parsedBone.animation));\r\n            }\r\n\r\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\r\n                skeleton._hasWaitingData = true;\r\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\r\n            }\r\n        }\r\n\r\n        // placed after bones, so createAnimationRange can cascade down\r\n        if (parsedSkeleton.ranges) {\r\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\r\n                const data = parsedSkeleton.ranges[index];\r\n                skeleton.createAnimationRange(data.name, data.from, data.to);\r\n            }\r\n        }\r\n        return skeleton;\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     */\r\n    public computeAbsoluteMatrices(forceUpdate = false): void {\r\n        if (this._absoluteTransformIsDirty || forceUpdate) {\r\n            this.bones[0].computeAbsoluteMatrices();\r\n            this._absoluteTransformIsDirty = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute all node absolute matrices\r\n     * @param forceUpdate defines if computation must be done even if cache is up to date\r\n     * @deprecated Please use computeAbsoluteMatrices instead\r\n     */\r\n    public computeAbsoluteTransforms(forceUpdate = false): void {\r\n        this.computeAbsoluteMatrices(forceUpdate);\r\n    }\r\n\r\n    /**\r\n     * Gets the root pose matrix\r\n     * @returns a matrix\r\n     */\r\n    public getPoseMatrix(): Nullable<Matrix> {\r\n        let poseMatrix: Nullable<Matrix> = null;\r\n\r\n        if (this._meshesWithPoseMatrix.length > 0) {\r\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\r\n        }\r\n\r\n        return poseMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sorts bones per internal index\r\n     */\r\n    public sortBones(): void {\r\n        const bones: Bone[] = [];\r\n        const visited = new Array<boolean>(this.bones.length);\r\n        for (let index = 0; index < this.bones.length; index++) {\r\n            this._sortBones(index, bones, visited);\r\n        }\r\n\r\n        this.bones = bones;\r\n    }\r\n\r\n    private _sortBones(index: number, bones: Bone[], visited: boolean[]): void {\r\n        if (visited[index]) {\r\n            return;\r\n        }\r\n\r\n        visited[index] = true;\r\n\r\n        const bone = this.bones[index];\r\n        if (!bone) {\r\n            return;\r\n        }\r\n\r\n        if (bone._index === undefined) {\r\n            bone._index = index;\r\n        }\r\n\r\n        const parentBone = bone.getParent();\r\n        if (parentBone) {\r\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\r\n        }\r\n\r\n        bones.push(bone);\r\n    }\r\n\r\n    /**\r\n     * Set the current local matrix as the restPose for all bones in the skeleton.\r\n     */\r\n    public setCurrentPoseAsRest(): void {\r\n        for (const b of this.bones) {\r\n            b.setCurrentPoseAsRest();\r\n        }\r\n    }\r\n}\r\n", "import { Epsilon } from \"core/Maths/math.constants\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport { BuildArray } from \"core/Misc/arrayTools\";\r\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\r\nimport type { BoundingBox } from \"./boundingBox\";\r\nimport type { BoundingSphere } from \"./boundingSphere\";\r\nimport type { DeepImmutable, float, Nullable } from \"core/types\";\r\nimport type { Plane } from \"core/Maths/math.plane\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { PickingInfo } from \"core/Collisions/pickingInfo\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { _ImportHelper } from \"core/import.helper\";\r\n\r\n/**\r\n * Type used to define predicate for selecting meshes and instances (if exist)\r\n */\r\nexport type MeshPredicate = (mesh: AbstractMesh, thinInstanceIndex: number) => boolean;\r\n\r\n/**\r\n * Type used to define predicate used to select faces when a mesh intersection is detected\r\n */\r\nexport type TrianglePickingPredicate = (p0: Vector3, p1: Vector3, p2: Vector3, ray: Ray, i0: number, i1: number, i2: number) => boolean;\r\n\r\n/**\r\n * This class allows user to customize internal picking mechanism\r\n */\r\nexport interface IPickingCustomization {\r\n    /**\r\n     * Predicate to select faces when a mesh intersection is detected\r\n     */\r\n    internalPickerForMesh?: (\r\n        pickingInfo: Nullable<PickingInfo>,\r\n        rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n        mesh: AbstractMesh,\r\n        world: Matrix,\r\n        fastCheck?: boolean,\r\n        onlyBoundingInfo?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        skipBoundingInfo?: boolean\r\n    ) => PickingInfo;\r\n}\r\n\r\n/**\r\n * Use this object to customize mesh picking behavior\r\n */\r\nexport const PickingCustomization: IPickingCustomization = {\r\n    internalPickerForMesh: undefined,\r\n};\r\n\r\n/**\r\n * Class representing a ray with position and direction\r\n */\r\nexport class Ray {\r\n    private static readonly _TmpVector3 = BuildArray(6, Vector3.Zero);\r\n    private static _RayDistant = Ray.Zero();\r\n    private _tmpRay: Ray;\r\n\r\n    /**\r\n     * Creates a new ray\r\n     * @param origin origin point\r\n     * @param direction direction\r\n     * @param length length of the ray\r\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants)\r\n     */\r\n    constructor(\r\n        /** origin point */\r\n        public origin: Vector3,\r\n        /** direction */\r\n        public direction: Vector3,\r\n        /** [Number.MAX_VALUE] length of the ray */\r\n        public length: number = Number.MAX_VALUE,\r\n        /** [Epsilon] The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\r\n        public epsilon: number = Epsilon\r\n    ) {}\r\n\r\n    // Methods\r\n\r\n    /**\r\n     * Clone the current ray\r\n     * @returns a new ray\r\n     */\r\n    public clone(): Ray {\r\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param minimum bound of the box\r\n     * @param maximum bound of the box\r\n     * @param intersectionTreshold extra extend to be added to the box in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBoxMinMax(minimum: DeepImmutable<Vector3>, maximum: DeepImmutable<Vector3>, intersectionTreshold: number = 0): boolean {\r\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\r\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\r\n        let d = 0.0;\r\n        let maxValue = Number.MAX_VALUE;\r\n        let inv: number;\r\n        let min: number;\r\n        let max: number;\r\n        let temp: number;\r\n        if (Math.abs(this.direction.x) < 0.0000001) {\r\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.x;\r\n            min = (newMinimum.x - this.origin.x) * inv;\r\n            max = (newMaximum.x - this.origin.x) * inv;\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.y) < 0.0000001) {\r\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.y;\r\n            min = (newMinimum.y - this.origin.y) * inv;\r\n            max = (newMaximum.y - this.origin.y) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (Math.abs(this.direction.z) < 0.0000001) {\r\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\r\n                return false;\r\n            }\r\n        } else {\r\n            inv = 1.0 / this.direction.z;\r\n            min = (newMinimum.z - this.origin.z) * inv;\r\n            max = (newMaximum.z - this.origin.z) * inv;\r\n\r\n            if (max === -Infinity) {\r\n                max = Infinity;\r\n            }\r\n\r\n            if (min > max) {\r\n                temp = min;\r\n                min = max;\r\n                max = temp;\r\n            }\r\n\r\n            d = Math.max(min, d);\r\n            maxValue = Math.min(max, maxValue);\r\n\r\n            if (d > maxValue) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the ray intersects a box\r\n     * This does not account for the ray length by design to improve perfs.\r\n     * @param box the bounding box to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\r\n     * @returns if the box was hit\r\n     */\r\n    public intersectsBox(box: DeepImmutable<BoundingBox>, intersectionTreshold: number = 0): boolean {\r\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a sphere\r\n     * @param sphere the bounding sphere to check\r\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\r\n     * @returns true if it hits the sphere\r\n     */\r\n    public intersectsSphere(sphere: DeepImmutable<BoundingSphere>, intersectionTreshold: number = 0): boolean {\r\n        const x = sphere.center.x - this.origin.x;\r\n        const y = sphere.center.y - this.origin.y;\r\n        const z = sphere.center.z - this.origin.z;\r\n        const pyth = x * x + y * y + z * z;\r\n        const radius = sphere.radius + intersectionTreshold;\r\n        const rr = radius * radius;\r\n\r\n        if (pyth <= rr) {\r\n            return true;\r\n        }\r\n\r\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\r\n        if (dot < 0.0) {\r\n            return false;\r\n        }\r\n\r\n        const temp = pyth - dot * dot;\r\n\r\n        return temp <= rr;\r\n    }\r\n\r\n    /**\r\n     * If the ray hits a triange\r\n     * @param vertex0 triangle vertex\r\n     * @param vertex1 triangle vertex\r\n     * @param vertex2 triangle vertex\r\n     * @returns intersection information if hit\r\n     */\r\n    public intersectsTriangle(vertex0: DeepImmutable<Vector3>, vertex1: DeepImmutable<Vector3>, vertex2: DeepImmutable<Vector3>): Nullable<IntersectionInfo> {\r\n        const edge1 = Ray._TmpVector3[0];\r\n        const edge2 = Ray._TmpVector3[1];\r\n        const pvec = Ray._TmpVector3[2];\r\n        const tvec = Ray._TmpVector3[3];\r\n        const qvec = Ray._TmpVector3[4];\r\n\r\n        vertex1.subtractToRef(vertex0, edge1);\r\n        vertex2.subtractToRef(vertex0, edge2);\r\n        Vector3.CrossToRef(this.direction, edge2, pvec);\r\n        const det = Vector3.Dot(edge1, pvec);\r\n\r\n        if (det === 0) {\r\n            return null;\r\n        }\r\n\r\n        const invdet = 1 / det;\r\n\r\n        this.origin.subtractToRef(vertex0, tvec);\r\n\r\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\r\n\r\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        Vector3.CrossToRef(tvec, edge1, qvec);\r\n\r\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\r\n\r\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\r\n            return null;\r\n        }\r\n\r\n        //check if the distance is longer than the predefined length.\r\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\r\n        if (distance > this.length) {\r\n            return null;\r\n        }\r\n\r\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a plane\r\n     * @param plane the plane to check\r\n     * @returns the distance away it was hit\r\n     */\r\n    public intersectsPlane(plane: DeepImmutable<Plane>): Nullable<number> {\r\n        let distance: number;\r\n        const result1 = Vector3.Dot(plane.normal, this.direction);\r\n        if (Math.abs(result1) < 9.99999997475243e-7) {\r\n            return null;\r\n        } else {\r\n            const result2 = Vector3.Dot(plane.normal, this.origin);\r\n            distance = (-plane.d - result2) / result1;\r\n            if (distance < 0.0) {\r\n                if (distance < -9.99999997475243e-7) {\r\n                    return null;\r\n                } else {\r\n                    return 0;\r\n                }\r\n            }\r\n\r\n            return distance;\r\n        }\r\n    }\r\n    /**\r\n     * Calculate the intercept of a ray on a given axis\r\n     * @param axis to check 'x' | 'y' | 'z'\r\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\r\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\r\n     */\r\n    public intersectsAxis(axis: string, offset: number = 0): Nullable<Vector3> {\r\n        switch (axis) {\r\n            case \"y\": {\r\n                const t = (this.origin.y - offset) / this.direction.y;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"x\": {\r\n                const t = (this.origin.x - offset) / this.direction.x;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\r\n            }\r\n            case \"z\": {\r\n                const t = (this.origin.z - offset) / this.direction.z;\r\n                if (t > 0) {\r\n                    return null;\r\n                }\r\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\r\n     * irrespective of orientation.\r\n     * @param mesh the mesh to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\r\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\r\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\r\n     * @returns picking info of the intersection\r\n     */\r\n    public intersectsMesh(\r\n        mesh: DeepImmutable<AbstractMesh>,\r\n        fastCheck?: boolean,\r\n        trianglePredicate?: TrianglePickingPredicate,\r\n        onlyBoundingInfo = false,\r\n        worldToUse?: Matrix,\r\n        skipBoundingInfo = false\r\n    ): PickingInfo {\r\n        const tm = TmpVectors.Matrix[0];\r\n\r\n        mesh.getWorldMatrix().invertToRef(tm);\r\n\r\n        if (this._tmpRay) {\r\n            Ray.TransformToRef(this, tm, this._tmpRay);\r\n        } else {\r\n            this._tmpRay = Ray.Transform(this, tm);\r\n        }\r\n\r\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\r\n    }\r\n\r\n    /**\r\n     * Checks if ray intersects a mesh\r\n     * @param meshes the meshes to check\r\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n     * @param results array to store result in\r\n     * @returns Array of picking infos\r\n     */\r\n    public intersectsMeshes(meshes: Array<DeepImmutable<AbstractMesh>>, fastCheck?: boolean, results?: Array<PickingInfo>): Array<PickingInfo> {\r\n        if (results) {\r\n            results.length = 0;\r\n        } else {\r\n            results = [];\r\n        }\r\n\r\n        for (let i = 0; i < meshes.length; i++) {\r\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\r\n\r\n            if (pickInfo.hit) {\r\n                results.push(pickInfo);\r\n            }\r\n        }\r\n\r\n        results.sort(this._comparePickingInfo);\r\n\r\n        return results;\r\n    }\r\n\r\n    private _comparePickingInfo(pickingInfoA: DeepImmutable<PickingInfo>, pickingInfoB: DeepImmutable<PickingInfo>): number {\r\n        if (pickingInfoA.distance < pickingInfoB.distance) {\r\n            return -1;\r\n        } else if (pickingInfoA.distance > pickingInfoB.distance) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    private static _Smallnum = 0.00000001;\r\n    private static _Rayl = 10e8;\r\n\r\n    /**\r\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\r\n     * @param sega the first point of the segment to test the intersection against\r\n     * @param segb the second point of the segment to test the intersection against\r\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\r\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\r\n     */\r\n    intersectionSegment(sega: DeepImmutable<Vector3>, segb: DeepImmutable<Vector3>, threshold: number): number {\r\n        const o = this.origin;\r\n        const u = TmpVectors.Vector3[0];\r\n        const rsegb = TmpVectors.Vector3[1];\r\n        const v = TmpVectors.Vector3[2];\r\n        const w = TmpVectors.Vector3[3];\r\n\r\n        segb.subtractToRef(sega, u);\r\n\r\n        this.direction.scaleToRef(Ray._Rayl, v);\r\n        o.addToRef(v, rsegb);\r\n\r\n        sega.subtractToRef(o, w);\r\n\r\n        const a = Vector3.Dot(u, u); // always >= 0\r\n        const b = Vector3.Dot(u, v);\r\n        const c = Vector3.Dot(v, v); // always >= 0\r\n        const d = Vector3.Dot(u, w);\r\n        const e = Vector3.Dot(v, w);\r\n        const discriminant = a * c - b * b; // always >= 0\r\n        let sN: number,\r\n            sD = discriminant; // sc = sN / sD, default sD = D >= 0\r\n        let tN: number,\r\n            tD = discriminant; // tc = tN / tD, default tD = D >= 0\r\n\r\n        // compute the line parameters of the two closest points\r\n        if (discriminant < Ray._Smallnum) {\r\n            // the lines are almost parallel\r\n            sN = 0.0; // force using point P0 on segment S1\r\n            sD = 1.0; // to prevent possible division by 0.0 later\r\n            tN = e;\r\n            tD = c;\r\n        } else {\r\n            // get the closest points on the infinite lines\r\n            sN = b * e - c * d;\r\n            tN = a * e - b * d;\r\n            if (sN < 0.0) {\r\n                // sc < 0 => the s=0 edge is visible\r\n                sN = 0.0;\r\n                tN = e;\r\n                tD = c;\r\n            } else if (sN > sD) {\r\n                // sc > 1 => the s=1 edge is visible\r\n                sN = sD;\r\n                tN = e + b;\r\n                tD = c;\r\n            }\r\n        }\r\n\r\n        if (tN < 0.0) {\r\n            // tc < 0 => the t=0 edge is visible\r\n            tN = 0.0;\r\n            // recompute sc for this edge\r\n            if (-d < 0.0) {\r\n                sN = 0.0;\r\n            } else if (-d > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d;\r\n                sD = a;\r\n            }\r\n        } else if (tN > tD) {\r\n            // tc > 1 => the t=1 edge is visible\r\n            tN = tD;\r\n            // recompute sc for this edge\r\n            if (-d + b < 0.0) {\r\n                sN = 0;\r\n            } else if (-d + b > a) {\r\n                sN = sD;\r\n            } else {\r\n                sN = -d + b;\r\n                sD = a;\r\n            }\r\n        }\r\n        // finally do the division to get sc and tc\r\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\r\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\r\n\r\n        // get the difference of the two closest points\r\n        const qtc = TmpVectors.Vector3[4];\r\n        v.scaleToRef(tc, qtc);\r\n        const qsc = TmpVectors.Vector3[5];\r\n        u.scaleToRef(sc, qsc);\r\n        qsc.addInPlace(w);\r\n        const dP = TmpVectors.Vector3[6];\r\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\r\n\r\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\r\n\r\n        if (isIntersected) {\r\n            return qsc.length();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Update the ray from viewport position\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n     * @returns this ray updated\r\n     */\r\n    public update(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>,\r\n        enableDistantPicking: boolean = false\r\n    ): Ray {\r\n        if (enableDistantPicking) {\r\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\r\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\r\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\r\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\r\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\r\n            if (!Ray._RayDistant) {\r\n                Ray._RayDistant = Ray.Zero();\r\n            }\r\n\r\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\r\n\r\n            const tm = TmpVectors.Matrix[0];\r\n            world.invertToRef(tm);\r\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\r\n        } else {\r\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Creates a ray with origin and direction of 0,0,0\r\n     * @returns the new ray\r\n     */\r\n    public static Zero(): Ray {\r\n        return new Ray(Vector3.Zero(), Vector3.Zero());\r\n    }\r\n\r\n    /**\r\n     * Creates a new ray from screen space and viewport\r\n     * @param x position\r\n     * @param y y position\r\n     * @param viewportWidth viewport width\r\n     * @param viewportHeight viewport height\r\n     * @param world world matrix\r\n     * @param view view matrix\r\n     * @param projection projection matrix\r\n     * @returns new ray\r\n     */\r\n    public static CreateNew(\r\n        x: number,\r\n        y: number,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): Ray {\r\n        const result = Ray.Zero();\r\n\r\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\r\n    }\r\n\r\n    /**\r\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the new ray\r\n     */\r\n    public static CreateNewFromTo(origin: Vector3, end: Vector3, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        return Ray.CreateFromToToRef(origin, end, result, world);\r\n    }\r\n\r\n    /**\r\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\r\n     * transformed to the given world matrix.\r\n     * @param origin The origin point\r\n     * @param end The end point\r\n     * @param result the object to store the result\r\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\r\n     * @returns the ref ray\r\n     */\r\n    public static CreateFromToToRef(origin: Vector3, end: Vector3, result: Ray, world: DeepImmutable<Matrix> = Matrix.IdentityReadOnly): Ray {\r\n        result.origin.copyFrom(origin);\r\n        const direction = end.subtractToRef(origin, result.direction);\r\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\r\n        result.length = length;\r\n        result.direction.normalize();\r\n\r\n        return Ray.TransformToRef(result, world, result);\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @returns the resulting new ray\r\n     */\r\n    public static Transform(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>): Ray {\r\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\r\n        Ray.TransformToRef(ray, matrix, result);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Transforms a ray by a matrix\r\n     * @param ray ray to transform\r\n     * @param matrix matrix to apply\r\n     * @param result ray to store result in\r\n     * @returns the updated result ray\r\n     */\r\n    public static TransformToRef(ray: DeepImmutable<Ray>, matrix: DeepImmutable<Matrix>, result: Ray): Ray {\r\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\r\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\r\n        result.length = ray.length;\r\n        result.epsilon = ray.epsilon;\r\n\r\n        const dir = result.direction;\r\n        const len = dir.length();\r\n\r\n        if (!(len === 0 || len === 1)) {\r\n            const num = 1.0 / len;\r\n            dir.x *= num;\r\n            dir.y *= num;\r\n            dir.z *= num;\r\n            result.length *= len;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Unproject a ray from screen space to object space\r\n     * @param sourceX defines the screen space x coordinate to use\r\n     * @param sourceY defines the screen space y coordinate to use\r\n     * @param viewportWidth defines the current width of the viewport\r\n     * @param viewportHeight defines the current height of the viewport\r\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\r\n     * @param view defines the view matrix to use\r\n     * @param projection defines the projection matrix to use\r\n     */\r\n    public unprojectRayToRef(\r\n        sourceX: float,\r\n        sourceY: float,\r\n        viewportWidth: number,\r\n        viewportHeight: number,\r\n        world: DeepImmutable<Matrix>,\r\n        view: DeepImmutable<Matrix>,\r\n        projection: DeepImmutable<Matrix>\r\n    ): void {\r\n        const matrix = TmpVectors.Matrix[0];\r\n        world.multiplyToRef(view, matrix);\r\n        matrix.multiplyToRef(projection, matrix);\r\n        matrix.invert();\r\n\r\n        const engine = EngineStore.LastCreatedEngine;\r\n        const nearScreenSource = TmpVectors.Vector3[0];\r\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\r\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\r\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\r\n\r\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\r\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\r\n        const nearVec3 = TmpVectors.Vector3[2];\r\n        const farVec3 = TmpVectors.Vector3[3];\r\n        Vector3.TransformCoordinatesToRef(nearScreenSource, matrix, nearVec3);\r\n        Vector3.TransformCoordinatesToRef(farScreenSource, matrix, farVec3);\r\n\r\n        this.origin.copyFrom(nearVec3);\r\n        farVec3.subtractToRef(nearVec3, this.direction);\r\n        this.direction.normalize();\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRay(scene: Scene, x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\r\n * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayToRef(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        return scene;\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n\r\n    result.update(\r\n        x,\r\n        y,\r\n        width,\r\n        height,\r\n        world ? world : Matrix.IdentityReadOnly,\r\n        cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(),\r\n        camera.getProjectionMatrix(),\r\n        enableDistantPicking\r\n    );\r\n    return scene;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param camera defines the camera to use for the picking\r\n * @returns a Ray\r\n */\r\nexport function CreatePickingRayInCameraSpace(scene: Scene, x: number, y: number, camera?: Camera): Ray {\r\n    const result = Ray.Zero();\r\n\r\n    CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a ray that can be used to pick in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x defines the x coordinate of the origin (on-screen)\r\n * @param y defines the y coordinate of the origin (on-screen)\r\n * @param result defines the ray where to store the picking ray\r\n * @param camera defines the camera to use for the picking\r\n * @returns the current scene\r\n */\r\nexport function CreatePickingRayInCameraSpaceToRef(scene: Scene, x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    if (!PickingInfo) {\r\n        return scene;\r\n    }\r\n\r\n    const engine = scene.getEngine();\r\n\r\n    if (!camera && !(camera = scene.activeCamera!)) {\r\n        throw new Error(\"Active camera not set\");\r\n    }\r\n\r\n    const cameraViewport = camera.viewport;\r\n    const renderHeight = engine.getRenderHeight();\r\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\r\n    const identity = Matrix.Identity();\r\n\r\n    // Moving coordinates to local viewport world\r\n    const levelInv = 1 / engine.getHardwareScalingLevel();\r\n    x = x * levelInv - vx;\r\n    y = y * levelInv - (renderHeight - vy - height);\r\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\r\n    return scene;\r\n}\r\n\r\nfunction InternalPickForMesh(\r\n    pickingInfo: Nullable<PickingInfo>,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    mesh: AbstractMesh,\r\n    world: Matrix,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    skipBoundingInfo?: boolean\r\n) {\r\n    const ray = rayFunction(world, mesh.enableDistantPicking);\r\n\r\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\r\n    if (!result || !result.hit) {\r\n        return null;\r\n    }\r\n\r\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\r\n        return null;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction InternalPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    onlyBoundingInfo?: boolean,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): PickingInfo {\r\n    let pickingInfo = null;\r\n\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                if (onlyBoundingInfo) {\r\n                    // the user only asked for a bounding info check so we can return\r\n                    return result;\r\n                }\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        pickingInfo = result;\r\n                        pickingInfo.thinInstanceIndex = index;\r\n\r\n                        if (fastCheck) {\r\n                            return pickingInfo;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfo = result;\r\n\r\n                if (fastCheck) {\r\n                    return pickingInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfo || new PickingInfo();\r\n}\r\n\r\nfunction InternalMultiPick(\r\n    scene: Scene,\r\n    rayFunction: (world: Matrix, enableDistantPicking: boolean) => Ray,\r\n    predicate?: MeshPredicate,\r\n    trianglePredicate?: TrianglePickingPredicate\r\n): Nullable<PickingInfo[]> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const pickingInfos: PickingInfo[] = [];\r\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\r\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\r\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\r\n\r\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\r\n        const mesh = scene.meshes[meshIndex];\r\n\r\n        if (predicate) {\r\n            if (!predicate(mesh, -1)) {\r\n                continue;\r\n            }\r\n        } else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\r\n            continue;\r\n        }\r\n\r\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\r\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\r\n\r\n        if (mesh.hasThinInstances && (mesh as Mesh).thinInstanceEnablePicking) {\r\n            const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);\r\n            if (result) {\r\n                const tmpMatrix = TmpVectors.Matrix[1];\r\n                const thinMatrices = (mesh as Mesh).thinInstanceGetWorldMatrices();\r\n                for (let index = 0; index < thinMatrices.length; index++) {\r\n                    if (predicate && !predicate(mesh, index)) {\r\n                        continue;\r\n                    }\r\n                    const thinMatrix = thinMatrices[index];\r\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\r\n                    const result = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\r\n\r\n                    if (result) {\r\n                        result.thinInstanceIndex = index;\r\n                        pickingInfos.push(result);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);\r\n\r\n            if (result) {\r\n                pickingInfos.push(result);\r\n            }\r\n        }\r\n    }\r\n\r\n    return pickingInfos;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\r\n */\r\nexport function PickWithBoundingInfo(scene: Scene, x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    if (!PickingInfo) {\r\n        return null;\r\n    }\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        true\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/** Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param x position on screen\r\n * @param y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @param _enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\r\n * @returns a PickingInfo\r\n */\r\nexport function Pick(\r\n    scene: Scene,\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world, enableDistantPicking) => {\r\n            if (!scene._tempPickingRay) {\r\n                scene._tempPickingRay = Ray.Zero();\r\n            }\r\n\r\n            CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);\r\n            return scene._tempPickingRay;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param ray The ray to use to pick meshes\r\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param fastCheck defines if the first intersection will be used (and not the closest)\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns a PickingInfo\r\n */\r\nexport function PickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    const result = InternalPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        fastCheck,\r\n        false,\r\n        trianglePredicate\r\n    );\r\n    if (result) {\r\n        result.ray = ray;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\r\n * irrespective of orientation.\r\n * @param scene defines the scene to use for the picking\r\n * @param x X position on screen\r\n * @param y Y position on screen\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPick(scene: Scene, x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);\r\n}\r\n\r\n/**\r\n * Launch a ray to try to pick a mesh in the scene\r\n * @param scene defines the scene to use for the picking\r\n * @param ray Ray to use\r\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\r\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\r\n * @returns an array of PickingInfo\r\n */\r\nexport function MultiPickWithRay(scene: Scene, ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return InternalMultiPick(\r\n        scene,\r\n        (world) => {\r\n            if (!scene._pickWithRayInverseMatrix) {\r\n                scene._pickWithRayInverseMatrix = Matrix.Identity();\r\n            }\r\n            world.invertToRef(scene._pickWithRayInverseMatrix);\r\n\r\n            if (!scene._cachedRayForTransform) {\r\n                scene._cachedRayForTransform = Ray.Zero();\r\n            }\r\n\r\n            Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\r\n            return scene._cachedRayForTransform;\r\n        },\r\n        predicate,\r\n        trianglePredicate\r\n    );\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRay(camera: Camera, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n}\r\n\r\n/**\r\n * Gets a ray in the forward direction from the camera.\r\n * @param camera Defines the camera to use to get the ray from\r\n * @param refRay the ray to (re)use when setting the values\r\n * @param length Defines the length of the ray to create\r\n * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\r\n * @param origin Defines the start point of the ray which defaults to the camera position\r\n * @returns the forward ray\r\n */\r\nexport function GetForwardRayToRef(camera: Camera, refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n    if (!transform) {\r\n        transform = camera.getWorldMatrix();\r\n    }\r\n    refRay.length = length;\r\n\r\n    if (origin) {\r\n        refRay.origin.copyFrom(origin);\r\n    } else {\r\n        refRay.origin.copyFrom(camera.position);\r\n    }\r\n    const forward = TmpVectors.Vector3[2];\r\n    forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);\r\n    const worldForward = TmpVectors.Vector3[3];\r\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\r\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\r\n\r\n    return refRay;\r\n}\r\n\r\n/**\r\n * Initialize the minimal interdependecies between the Ray and Scene and Camera\r\n * @param sceneClass defines the scene prototype to use\r\n * @param cameraClass defines the camera prototype to use\r\n */\r\nexport function AddRayExtensions(sceneClass: typeof Scene, cameraClass: typeof Camera): void {\r\n    if (cameraClass) {\r\n        cameraClass.prototype.getForwardRay = function (length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\r\n        };\r\n\r\n        cameraClass.prototype.getForwardRayToRef = function (refRay: Ray, length = 100, transform?: Matrix, origin?: Vector3): Ray {\r\n            return GetForwardRayToRef(this, refRay, length, transform, origin);\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    _ImportHelper._IsPickingAvailable = true;\r\n\r\n    sceneClass.prototype.createPickingRay = function (x: number, y: number, world: Nullable<Matrix>, camera: Nullable<Camera>, cameraViewSpace = false): Ray {\r\n        return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);\r\n    };\r\n}\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport type { Camera } from \"../../Cameras/camera\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport type { IWheelEvent } from \"../../Events/deviceInputEvents\";\r\nimport { EventConstants } from \"../../Events/deviceInputEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\n\r\n/**\r\n * Base class for mouse wheel input..\r\n * See FollowCameraMouseWheelInput in src/Cameras/Inputs/freeCameraMouseWheelInput.ts\r\n * for example usage.\r\n */\r\nexport abstract class BaseCameraMouseWheelInput implements ICameraInput<Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public abstract camera: Camera;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to X axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionX = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Y axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionY = 3.0;\r\n\r\n    /**\r\n     * How fast is the camera moves in relation to Z axis mouseWheel events.\r\n     * Use negative value to reverse direction.\r\n     */\r\n    @serialize()\r\n    public wheelPrecisionZ = 3.0;\r\n\r\n    /**\r\n     * Observable for when a mouse wheel move event occurs.\r\n     */\r\n    public onChangedObservable = new Observable<{ wheelDeltaX: number; wheelDeltaY: number; wheelDeltaZ: number }>();\r\n\r\n    private _wheel: Nullable<(pointer: PointerInfo) => void>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls\r\n     *   should call preventdefault().\r\n     *   (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n\r\n        this._wheel = (pointer) => {\r\n            // sanity check - this should be a PointerWheel event.\r\n            if (pointer.type !== PointerEventTypes.POINTERWHEEL) {\r\n                return;\r\n            }\r\n\r\n            const event = <IWheelEvent>pointer.event;\r\n\r\n            const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1; // If this happens to be set to DOM_DELTA_LINE, adjust accordingly\r\n\r\n            this._wheelDeltaX += (this.wheelPrecisionX * platformScale * event.deltaX) / this._normalize;\r\n            this._wheelDeltaY -= (this.wheelPrecisionY * platformScale * event.deltaY) / this._normalize;\r\n            this._wheelDeltaZ += (this.wheelPrecisionZ * platformScale * event.deltaZ) / this._normalize;\r\n\r\n            if (event.preventDefault) {\r\n                if (!noPreventDefault) {\r\n                    event.preventDefault();\r\n                }\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n            this._observer = null;\r\n            this._wheel = null;\r\n        }\r\n        if (this.onChangedObservable) {\r\n            this.onChangedObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public checkInputs(): void {\r\n        this.onChangedObservable.notifyObservers({\r\n            wheelDeltaX: this._wheelDeltaX,\r\n            wheelDeltaY: this._wheelDeltaY,\r\n            wheelDeltaZ: this._wheelDeltaZ,\r\n        });\r\n\r\n        // Clear deltas.\r\n        this._wheelDeltaX = 0;\r\n        this._wheelDeltaY = 0;\r\n        this._wheelDeltaZ = 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"BaseCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mousewheel\";\r\n    }\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the X axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaX: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Y axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaY: number = 0;\r\n\r\n    /**\r\n     * Incremental value of multiple mouse wheel movements of the Z axis.\r\n     * Should be zero-ed when read.\r\n     */\r\n    protected _wheelDeltaZ: number = 0;\r\n\r\n    /**\r\n     * Firefox uses a different scheme to report scroll distances to other\r\n     * browsers. Rather than use complicated methods to calculate the exact\r\n     * multiple we need to apply, let's just cheat and use a constant.\r\n     * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaMode\r\n     * https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line\r\n     */\r\n    private readonly _ffMultiplier = 12;\r\n\r\n    /**\r\n     * Different event attributes for wheel data fall into a few set ranges.\r\n     * Some relevant but dated date here:\r\n     * https://stackoverflow.com/questions/5527601/normalizing-mousewheel-speed-across-browsers\r\n     */\r\n    private readonly _normalize = 120;\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\n/**\r\n * @ignore\r\n * This is a list of all the different input types that are available in the application.\r\n * Fo instance: ArcRotateCameraGamepadInput...\r\n */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var CameraInputTypes = {};\r\n\r\n/**\r\n * This is the contract to implement in order to create a new input class.\r\n * Inputs are dealing with listening to user actions and moving the camera accordingly.\r\n */\r\nexport interface ICameraInput<Tcamera extends Camera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    camera: Nullable<Tcamera>;\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    getClassName(): string;\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    getSimpleName(): string;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    detachControl(): void;\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    checkInputs?: () => void;\r\n}\r\n\r\n/**\r\n * Represents a map of input types to input instance or input index to input instance.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface CameraInputsMap<Tcamera extends Camera> {\r\n    /**\r\n     * Accessor to the input by input type.\r\n     */\r\n    [name: string]: ICameraInput<Tcamera>;\r\n    /**\r\n     * Accessor to the input by input index.\r\n     */\r\n    [idx: number]: ICameraInput<Tcamera>;\r\n}\r\n\r\n/**\r\n * This represents the input manager used within a camera.\r\n * It helps dealing with all the different kind of input attached to a camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class CameraInputsManager<Tcamera extends Camera> {\r\n    /**\r\n     * Defines the list of inputs attached to the camera.\r\n     */\r\n    public attached: CameraInputsMap<Tcamera>;\r\n\r\n    /**\r\n     * Defines the dom element the camera is collecting inputs from.\r\n     * This is null if the controls have not been attached.\r\n     */\r\n    public attachedToElement: boolean = false;\r\n\r\n    /**\r\n     * Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public noPreventDefault: boolean;\r\n\r\n    /**\r\n     * Defined the camera the input manager belongs to.\r\n     */\r\n    public camera: Tcamera;\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs: () => void;\r\n\r\n    /**\r\n     * Instantiate a new Camera Input Manager.\r\n     * @param camera Defines the camera the input manager belongs to\r\n     */\r\n    constructor(camera: Tcamera) {\r\n        this.attached = {};\r\n        this.camera = camera;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Add an input method to a camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param input Camera input method\r\n     */\r\n    public add(input: ICameraInput<Tcamera>): void {\r\n        const type = input.getSimpleName();\r\n        if (this.attached[type]) {\r\n            Logger.Warn(\"camera input of type \" + type + \" already exists on camera\");\r\n            return;\r\n        }\r\n\r\n        this.attached[type] = input;\r\n\r\n        input.camera = this.camera;\r\n\r\n        // for checkInputs, we are dynamically creating a function\r\n        // the goal is to avoid the performance penalty of looping for inputs in the render loop\r\n        if (input.checkInputs) {\r\n            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n        }\r\n\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input method from a camera\r\n     * example: camera.inputs.remove(camera.inputs.attached.mouse);\r\n     * @param inputToRemove camera input method\r\n     */\r\n    public remove(inputToRemove: ICameraInput<Tcamera>): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input === inputToRemove) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a specific input type from a camera\r\n     * example: camera.inputs.remove(\"ArcRotateCameraGamepadInput\");\r\n     * @param inputType the type of the input to remove\r\n     */\r\n    public removeByType(inputType: string): void {\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.getClassName() === inputType) {\r\n                input.detachControl();\r\n                input.camera = null;\r\n                delete this.attached[cam];\r\n                this.rebuildInputCheck();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addCheckInputs(fn: () => void) {\r\n        const current = this.checkInputs;\r\n        return () => {\r\n            current();\r\n            fn();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to the currently attached dom element to listen the events from.\r\n     * @param input Defines the input to attach\r\n     */\r\n    public attachInput(input: ICameraInput<Tcamera>): void {\r\n        if (this.attachedToElement) {\r\n            input.attachControl(this.noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the current manager inputs controls to a specific dom element to listen the events from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachElement(noPreventDefault: boolean = false): void {\r\n        if (this.attachedToElement) {\r\n            return;\r\n        }\r\n\r\n        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;\r\n        this.attachedToElement = true;\r\n        this.noPreventDefault = noPreventDefault;\r\n\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].attachControl(noPreventDefault);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current manager inputs controls from a specific dom element.\r\n     * @param disconnect Defines whether the input should be removed from the current list of attached inputs\r\n     */\r\n    public detachElement(disconnect = false): void {\r\n        for (const cam in this.attached) {\r\n            this.attached[cam].detachControl();\r\n\r\n            if (disconnect) {\r\n                this.attached[cam].camera = null;\r\n            }\r\n        }\r\n        this.attachedToElement = false;\r\n    }\r\n\r\n    /**\r\n     * Rebuild the dynamic inputCheck function from the current list of\r\n     * defined inputs in the manager.\r\n     */\r\n    public rebuildInputCheck(): void {\r\n        this.checkInputs = () => {};\r\n\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            if (input.checkInputs) {\r\n                this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public clear(): void {\r\n        if (this.attachedToElement) {\r\n            this.detachElement(true);\r\n        }\r\n        this.attached = {};\r\n        this.attachedToElement = false;\r\n        this.checkInputs = () => {};\r\n    }\r\n\r\n    /**\r\n     * Serialize the current input manager attached to a camera.\r\n     * This ensures than once parsed,\r\n     * the input associated to the camera will be identical to the current ones\r\n     * @param serializedCamera Defines the camera serialization JSON the input serialization should write to\r\n     */\r\n    public serialize(serializedCamera: any): void {\r\n        const inputs: { [key: string]: any } = {};\r\n        for (const cam in this.attached) {\r\n            const input = this.attached[cam];\r\n            const res = SerializationHelper.Serialize(input);\r\n            inputs[input.getClassName()] = res;\r\n        }\r\n\r\n        serializedCamera.inputsmgr = inputs;\r\n    }\r\n\r\n    /**\r\n     * Parses an input manager serialized JSON to restore the previous list of inputs\r\n     * and states associated to a camera.\r\n     * @param parsedCamera Defines the JSON to parse\r\n     */\r\n    public parse(parsedCamera: any): void {\r\n        const parsedInputs = parsedCamera.inputsmgr;\r\n        if (parsedInputs) {\r\n            this.clear();\r\n\r\n            for (const n in parsedInputs) {\r\n                const construct = (<any>CameraInputTypes)[n];\r\n                if (construct) {\r\n                    const parsedinput = parsedInputs[n];\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedinput,\r\n                        null\r\n                    );\r\n                    this.add(input);\r\n                }\r\n            }\r\n        } else {\r\n            //2016-03-08 this part is for managing backward compatibility\r\n            for (const n in this.attached) {\r\n                const construct = (<any>CameraInputTypes)[this.attached[n].getClassName()];\r\n                if (construct) {\r\n                    const input = SerializationHelper.Parse(\r\n                        () => {\r\n                            return new construct();\r\n                        },\r\n                        parsedCamera,\r\n                        null\r\n                    );\r\n                    this.remove(this.attached[n]);\r\n                    this.add(input);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { KeyboardInfo } from \"../../Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"../../Events/keyboardEvents\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n/**\r\n * Manage the keyboard inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraKeyboardMoveInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUp = [38];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysUpward = [33];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDown = [40];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysDownward = [34];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysLeft = [37];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRight = [39];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public rotationSpeed = 0.5;\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateLeft: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateRight: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateUp: number[] = [];\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    @serialize()\r\n    public keysRotateDown: number[] = [];\r\n\r\n    private _keys = new Array<number>();\r\n    private _onCanvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _onKeyboardObserver: Nullable<Observer<KeyboardInfo>>;\r\n    private _engine: AbstractEngine;\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        if (this._onCanvasBlurObserver) {\r\n            return;\r\n        }\r\n\r\n        this._scene = this.camera.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {\r\n            this._keys.length = 0;\r\n        });\r\n\r\n        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {\r\n            const evt = info.event;\r\n            if (!evt.metaKey) {\r\n                if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index === -1) {\r\n                            this._keys.push(evt.keyCode);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (\r\n                        this.keysUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDown.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysUpward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysDownward.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateLeft.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateRight.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateUp.indexOf(evt.keyCode) !== -1 ||\r\n                        this.keysRotateDown.indexOf(evt.keyCode) !== -1\r\n                    ) {\r\n                        const index = this._keys.indexOf(evt.keyCode);\r\n\r\n                        if (index >= 0) {\r\n                            this._keys.splice(index, 1);\r\n                        }\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._scene) {\r\n            if (this._onKeyboardObserver) {\r\n                this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);\r\n            }\r\n\r\n            if (this._onCanvasBlurObserver) {\r\n                this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);\r\n            }\r\n            this._onKeyboardObserver = null;\r\n            this._onCanvasBlurObserver = null;\r\n        }\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._onKeyboardObserver) {\r\n            const camera = this.camera;\r\n            // Keyboard\r\n            for (let index = 0; index < this._keys.length; index++) {\r\n                const keyCode = this._keys[index];\r\n                const speed = camera._computeLocalCameraSpeed();\r\n\r\n                if (this.keysLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(-speed, 0, 0);\r\n                } else if (this.keysUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, speed);\r\n                } else if (this.keysRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(speed, 0, 0);\r\n                } else if (this.keysDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, -speed);\r\n                } else if (this.keysUpward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, speed, 0);\r\n                } else if (this.keysDownward.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, -speed, 0);\r\n                } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y -= this._getLocalRotation();\r\n                } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.y += this._getLocalRotation();\r\n                } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x -= this._getLocalRotation();\r\n                } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {\r\n                    camera._localDirection.copyFromFloats(0, 0, 0);\r\n                    camera.cameraRotation.x += this._getLocalRotation();\r\n                }\r\n\r\n                if (camera.getScene().useRightHandedSystem) {\r\n                    camera._localDirection.z *= -1;\r\n                }\r\n\r\n                camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);\r\n                Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);\r\n                camera.cameraDirection.addInPlace(camera._transformedDirection);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraKeyboardMoveInput\";\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLostFocus(): void {\r\n        this._keys.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"keyboard\";\r\n    }\r\n\r\n    private _getLocalRotation(): number {\r\n        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n        const rotation = ((this.rotationSpeed * this._engine.getDeltaTime()) / 1000) * handednessMultiplier;\r\n\r\n        return rotation;\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraKeyboardMoveInput\"] = FreeCameraKeyboardMoveInput;\r\n", "import type { Observer, EventState } from \"../../Misc/observable\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IMouseEvent, IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the mouse inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X and Y axis or how fast is the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibility = 2000.0;\r\n\r\n    private _pointerInput: (p: PointerInfo, s: EventState) => void;\r\n    private _onMouseMove: Nullable<(e: IMouseEvent) => any>;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n    /**\r\n     * Observable for when a pointer move event occurs containing the move offset\r\n     */\r\n    public onPointerMovedObservable = new Observable<{ offsetX: number; offsetY: number }>();\r\n    /**\r\n     * @internal\r\n     * If the camera should be rotated automatically based on pointer movement\r\n     */\r\n    public _allowCameraRotation = true;\r\n\r\n    private _currentActiveButton: number = -1;\r\n    private _activePointerId: number = -1;\r\n    private _contextMenuBind: (evt: MouseEvent) => void;\r\n\r\n    /**\r\n     * Manage the mouse inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param touchEnabled Defines if touch is enabled or not\r\n     */\r\n    constructor(\r\n        /**\r\n         * [true] Define if touch is enabled in the mouse input\r\n         */\r\n        public touchEnabled = true\r\n    ) {}\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        const engine = this.camera.getEngine();\r\n        const element = engine.getInputElement();\r\n\r\n        if (!this._pointerInput) {\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n                const isTouch = evt.pointerType === \"touch\";\r\n\r\n                if (!this.touchEnabled && isTouch) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {\r\n                    return;\r\n                }\r\n\r\n                const srcElement = <HTMLElement>evt.target;\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    // If the input is touch with more than one touch OR if the input is mouse and there is already an active button, return\r\n                    if ((isTouch && this._activePointerId !== -1) || (!isTouch && this._currentActiveButton !== -1)) {\r\n                        return;\r\n                    }\r\n\r\n                    this._activePointerId = evt.pointerId;\r\n                    try {\r\n                        srcElement?.setPointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error. Execution will continue.\r\n                    }\r\n\r\n                    if (this._currentActiveButton === -1) {\r\n                        this._currentActiveButton = evt.button;\r\n                    }\r\n\r\n                    this._previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                        if (element) {\r\n                            element.focus();\r\n                        }\r\n                    }\r\n\r\n                    // This is required to move while pointer button is down\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    }\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    // If input is touch with a different touch id OR if input is mouse with a different button, return\r\n                    if ((isTouch && this._activePointerId !== evt.pointerId) || (!isTouch && this._currentActiveButton !== evt.button)) {\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        srcElement?.releasePointerCapture(evt.pointerId);\r\n                    } catch (e) {\r\n                        //Nothing to do with the error.\r\n                    }\r\n                    this._currentActiveButton = -1;\r\n\r\n                    this._previousPosition = null;\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._activePointerId = -1;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {\r\n                    if (engine.isPointerLock && this._onMouseMove) {\r\n                        this._onMouseMove(p.event);\r\n                    } else if (this._previousPosition) {\r\n                        const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n                        const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;\r\n                        const offsetY = (evt.clientY - this._previousPosition.y) * handednessMultiplier;\r\n\r\n                        if (this._allowCameraRotation) {\r\n                            this.camera.cameraRotation.y += offsetX / this.angularSensibility;\r\n                            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\r\n                        }\r\n                        this.onPointerMovedObservable.notifyObservers({ offsetX: offsetX, offsetY: offsetY });\r\n\r\n                        this._previousPosition = {\r\n                            x: evt.clientX,\r\n                            y: evt.clientY,\r\n                        };\r\n\r\n                        if (!noPreventDefault) {\r\n                            evt.preventDefault();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n        }\r\n\r\n        this._onMouseMove = (evt) => {\r\n            if (!engine.isPointerLock) {\r\n                return;\r\n            }\r\n\r\n            const handednessMultiplier = this.camera._calculateHandednessMultiplier();\r\n            this.camera.cameraRotation.y += (evt.movementX * handednessMultiplier) / this.angularSensibility;\r\n            this.camera.cameraRotation.x += (evt.movementY * handednessMultiplier) / this.angularSensibility;\r\n\r\n            this._previousPosition = null;\r\n\r\n            if (!noPreventDefault) {\r\n                evt.preventDefault();\r\n            }\r\n        };\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (element) {\r\n            this._contextMenuBind = (evt: MouseEvent) => this.onContextMenu(evt as PointerEvent);\r\n            element.addEventListener(\"contextmenu\", this._contextMenuBind, false); // TODO: We need to figure out how to handle this for Native\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on JS contextmenu event.\r\n     * Override this method to provide functionality.\r\n     * @param evt the context menu event\r\n     */\r\n    public onContextMenu(evt: PointerEvent): void {\r\n        evt.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._observer) {\r\n            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n\r\n            if (this._contextMenuBind) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                if (element) {\r\n                    element.removeEventListener(\"contextmenu\", this._contextMenuBind);\r\n                }\r\n            }\r\n\r\n            if (this.onPointerMovedObservable) {\r\n                this.onPointerMovedObservable.clear();\r\n            }\r\n\r\n            this._observer = null;\r\n            this._onMouseMove = null;\r\n            this._previousPosition = null;\r\n        }\r\n\r\n        this._activePointerId = -1;\r\n        this._currentActiveButton = -1;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraMouseInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"mouse\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseInput\"] = FreeCameraMouseInput;\r\n", "import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { BaseCameraMouseWheelInput } from \"../../Cameras/Inputs/BaseCameraMouseWheelInput\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Coordinate } from \"../../Maths/math.axis\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _CameraProperty {\r\n    MoveRelative,\r\n    RotateRelative,\r\n    MoveScene,\r\n}\r\n\r\n/**\r\n * Manage the mouse wheel inputs to control a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraMouseWheelInput extends BaseCameraMouseWheelInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCameraMouseWheelInput\";\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's X axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.RotateRelative;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Y axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.RotateRelative;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which rotation axis (relative to camera's orientation) the mouse\r\n     * wheel's Z axis controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZRotateRelative(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.RotateRelative;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured rotation axis (relative to camera's orientation) the\r\n     * mouse wheel's Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZRotateRelative(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.RotateRelative) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's X axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelXMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelXAction.\r\n            return;\r\n        }\r\n        this._wheelXAction = _CameraProperty.MoveScene;\r\n        this._wheelXActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * X axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelXMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelXAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelXActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Y axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelYMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelYAction.\r\n            return;\r\n        }\r\n        this._wheelYAction = _CameraProperty.MoveScene;\r\n        this._wheelYActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Y axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelYMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelYAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelYActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Set which movement axis (relative to the scene) the mouse wheel's Z axis\r\n     * controls.\r\n     * @param axis The axis to be moved. Set null to clear.\r\n     */\r\n    @serialize()\r\n    public set wheelZMoveScene(axis: Nullable<Coordinate>) {\r\n        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            // Attempting to clear different _wheelZAction.\r\n            return;\r\n        }\r\n        this._wheelZAction = _CameraProperty.MoveScene;\r\n        this._wheelZActionCoordinate = axis;\r\n    }\r\n\r\n    /**\r\n     * Get the configured movement axis (relative to the scene) the mouse wheel's\r\n     * Z axis controls.\r\n     * @returns The configured axis or null if none.\r\n     */\r\n    public get wheelZMoveScene(): Nullable<Coordinate> {\r\n        if (this._wheelZAction !== _CameraProperty.MoveScene) {\r\n            return null;\r\n        }\r\n        return this._wheelZActionCoordinate;\r\n    }\r\n\r\n    /**\r\n     * Called for each rendered frame.\r\n     */\r\n    public override checkInputs(): void {\r\n        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {\r\n            return;\r\n        }\r\n\r\n        // Clear the camera properties that we might be updating.\r\n        this._moveRelative.setAll(0);\r\n        this._rotateRelative.setAll(0);\r\n        this._moveScene.setAll(0);\r\n\r\n        // Set the camera properties that are to be updated.\r\n        this._updateCamera();\r\n\r\n        if (this.camera.getScene().useRightHandedSystem) {\r\n            // TODO: Does this need done for worldUpdate too?\r\n            this._moveRelative.z *= -1;\r\n        }\r\n\r\n        // Convert updates relative to camera to world position update.\r\n        const cameraTransformMatrix = Matrix.Zero();\r\n        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);\r\n\r\n        const transformedDirection = Vector3.Zero();\r\n        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);\r\n\r\n        // Apply updates to camera position.\r\n        this.camera.cameraRotation.x += this._rotateRelative.x / 200;\r\n        this.camera.cameraRotation.y += this._rotateRelative.y / 200;\r\n        this.camera.cameraDirection.addInPlace(transformedDirection);\r\n        this.camera.cameraDirection.addInPlace(this._moveScene);\r\n\r\n        // Call the base class implementation to handle observers and do cleanup.\r\n        super.checkInputs();\r\n    }\r\n\r\n    private _moveRelative = Vector3.Zero();\r\n    private _rotateRelative = Vector3.Zero();\r\n    private _moveScene = Vector3.Zero();\r\n\r\n    /**\r\n     * These are set to the desired default behaviour.\r\n     */\r\n    private _wheelXAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelXActionCoordinate: Nullable<Coordinate> = Coordinate.X;\r\n    private _wheelYAction: Nullable<_CameraProperty> = _CameraProperty.MoveRelative;\r\n    private _wheelYActionCoordinate: Nullable<Coordinate> = Coordinate.Z;\r\n    private _wheelZAction: Nullable<_CameraProperty> = null;\r\n    private _wheelZActionCoordinate: Nullable<Coordinate> = null;\r\n\r\n    /**\r\n     * Update the camera according to any configured properties for the 3\r\n     * mouse-wheel axis.\r\n     */\r\n    private _updateCamera(): void {\r\n        // Do the camera updates for each of the 3 touch-wheel axis.\r\n        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);\r\n        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);\r\n    }\r\n\r\n    /**\r\n     * Update one property of the camera.\r\n     * @param value\r\n     * @param cameraProperty\r\n     * @param coordinate\r\n     */\r\n    private _updateCameraProperty(\r\n        /* Mouse-wheel delta. */\r\n        value: number,\r\n        /* Camera property to be changed. */\r\n        cameraProperty: Nullable<_CameraProperty>,\r\n        /* Axis of Camera property to be changed. */\r\n        coordinate: Nullable<Coordinate>\r\n    ): void {\r\n        if (value === 0) {\r\n            // Mouse wheel has not moved.\r\n            return;\r\n        }\r\n        if (cameraProperty === null || coordinate === null) {\r\n            // Mouse wheel axis not configured.\r\n            return;\r\n        }\r\n\r\n        let action = null;\r\n        switch (cameraProperty) {\r\n            case _CameraProperty.MoveRelative:\r\n                action = this._moveRelative;\r\n                break;\r\n            case _CameraProperty.RotateRelative:\r\n                action = this._rotateRelative;\r\n                break;\r\n            case _CameraProperty.MoveScene:\r\n                action = this._moveScene;\r\n                break;\r\n        }\r\n\r\n        switch (coordinate) {\r\n            case Coordinate.X:\r\n                action.set(value, 0, 0);\r\n                break;\r\n            case Coordinate.Y:\r\n                action.set(0, value, 0);\r\n                break;\r\n            case Coordinate.Z:\r\n                action.set(0, 0, value);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraMouseWheelInput\"] = FreeCameraMouseWheelInput;\r\n", "import { serialize } from \"../../Misc/decorators\";\r\nimport type { Observer, EventState } from \"../../Misc/observable\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { ICameraInput } from \"../../Cameras/cameraInputsManager\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport type { FreeCamera } from \"../../Cameras/freeCamera\";\r\nimport type { PointerInfo } from \"../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../Events/pointerEvents\";\r\nimport { Matrix, Vector3 } from \"../../Maths/math.vector\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n/**\r\n * Manage the touch inputs to control the movement of a free camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraTouchInput implements ICameraInput<FreeCamera> {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: FreeCamera;\r\n\r\n    /**\r\n     * Defines the touch sensibility for rotation.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchAngularSensibility: number = 200000.0;\r\n\r\n    /**\r\n     * Defines the touch sensibility for move.\r\n     * The lower the faster.\r\n     */\r\n    @serialize()\r\n    public touchMoveSensibility: number = 250.0;\r\n\r\n    /**\r\n     * Swap touch actions so that one touch is used for rotation and multiple for movement\r\n     */\r\n    public singleFingerRotate: boolean = false;\r\n\r\n    private _offsetX: Nullable<number> = null;\r\n    private _offsetY: Nullable<number> = null;\r\n\r\n    private _pointerPressed = new Array<number>();\r\n    private _pointerInput?: (p: PointerInfo, s: EventState) => void;\r\n    private _observer: Nullable<Observer<PointerInfo>>;\r\n    private _onLostFocus: Nullable<(e: FocusEvent) => any>;\r\n    private _isSafari: boolean;\r\n\r\n    /**\r\n     * Manage the touch inputs to control the movement of a free camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n     * @param allowMouse Defines if mouse events can be treated as touch events\r\n     */\r\n    constructor(\r\n        /**\r\n         * [false] Define if mouse events can be treated as touch events\r\n         */\r\n        public allowMouse = false\r\n    ) {\r\n        this._isSafari = Tools.IsSafari();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public attachControl(noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        let previousPosition: Nullable<{ x: number; y: number }> = null;\r\n\r\n        if (this._pointerInput === undefined) {\r\n            this._onLostFocus = () => {\r\n                this._offsetX = null;\r\n                this._offsetY = null;\r\n            };\r\n\r\n            this._pointerInput = (p) => {\r\n                const evt = <IPointerEvent>p.event;\r\n\r\n                const isMouseEvent = evt.pointerType === \"mouse\" || (this._isSafari && typeof evt.pointerType === \"undefined\");\r\n\r\n                if (!this.allowMouse && isMouseEvent) {\r\n                    return;\r\n                }\r\n\r\n                if (p.type === PointerEventTypes.POINTERDOWN) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    this._pointerPressed.push(evt.pointerId);\r\n\r\n                    if (this._pointerPressed.length !== 1) {\r\n                        return;\r\n                    }\r\n\r\n                    previousPosition = {\r\n                        x: evt.clientX,\r\n                        y: evt.clientY,\r\n                    };\r\n                } else if (p.type === PointerEventTypes.POINTERUP) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index === -1) {\r\n                        return;\r\n                    }\r\n                    this._pointerPressed.splice(index, 1);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n                    previousPosition = null;\r\n                    this._offsetX = null;\r\n                    this._offsetY = null;\r\n                } else if (p.type === PointerEventTypes.POINTERMOVE) {\r\n                    if (!noPreventDefault) {\r\n                        evt.preventDefault();\r\n                    }\r\n\r\n                    if (!previousPosition) {\r\n                        return;\r\n                    }\r\n\r\n                    const index: number = this._pointerPressed.indexOf(evt.pointerId);\r\n\r\n                    if (index != 0) {\r\n                        return;\r\n                    }\r\n\r\n                    this._offsetX = evt.clientX - previousPosition.x;\r\n                    this._offsetY = -(evt.clientY - previousPosition.y);\r\n                }\r\n            };\r\n        }\r\n\r\n        this._observer = this.camera\r\n            .getScene()\r\n            ._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);\r\n\r\n        if (this._onLostFocus) {\r\n            const engine = this.camera.getEngine();\r\n            const element = engine.getInputElement();\r\n            if (element) {\r\n                element.addEventListener(\"blur\", this._onLostFocus);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public detachControl(): void {\r\n        if (this._pointerInput) {\r\n            if (this._observer) {\r\n                this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);\r\n                this._observer = null;\r\n            }\r\n\r\n            if (this._onLostFocus) {\r\n                const engine = this.camera.getEngine();\r\n                const element = engine.getInputElement();\r\n                if (element) {\r\n                    element.removeEventListener(\"blur\", this._onLostFocus);\r\n                }\r\n\r\n                this._onLostFocus = null;\r\n            }\r\n            this._pointerPressed.length = 0;\r\n            this._offsetX = null;\r\n            this._offsetY = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the current camera state depending on the inputs that have been used this frame.\r\n     * This is a dynamically created lambda to avoid the performance penalty of looping for inputs in the render loop.\r\n     */\r\n    public checkInputs(): void {\r\n        if (this._offsetX === null || this._offsetY === null) {\r\n            return;\r\n        }\r\n        if (this._offsetX === 0 && this._offsetY === 0) {\r\n            return;\r\n        }\r\n\r\n        const camera = this.camera;\r\n        const handednessMultiplier = camera._calculateHandednessMultiplier();\r\n        camera.cameraRotation.y = (this._offsetX * handednessMultiplier) / this.touchAngularSensibility;\r\n\r\n        const rotateCamera = (this.singleFingerRotate && this._pointerPressed.length === 1) || (!this.singleFingerRotate && this._pointerPressed.length > 1);\r\n\r\n        if (rotateCamera) {\r\n            camera.cameraRotation.x = -(this._offsetY * handednessMultiplier) / this.touchAngularSensibility;\r\n        } else {\r\n            const speed = camera._computeLocalCameraSpeed();\r\n            const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\r\n\r\n            Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\r\n            camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"FreeCameraTouchInput\";\r\n    }\r\n\r\n    /**\r\n     * Get the friendly name associated with the input class.\r\n     * @returns the input friendly name\r\n     */\r\n    public getSimpleName(): string {\r\n        return \"touch\";\r\n    }\r\n}\r\n\r\n(<any>CameraInputTypes)[\"FreeCameraTouchInput\"] = FreeCameraTouchInput;\r\n", "import type { FreeCamera } from \"./freeCamera\";\r\nimport { CameraInputsManager } from \"./cameraInputsManager\";\r\nimport { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport { FreeCameraMouseWheelInput } from \"../Cameras/Inputs/freeCameraMouseWheelInput\";\r\nimport { FreeCameraTouchInput } from \"../Cameras/Inputs/freeCameraTouchInput\";\r\nimport type { Nullable } from \"../types\";\r\n\r\n/**\r\n * Default Inputs manager for the FreeCamera.\r\n * It groups all the default supported inputs for ease of use.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class FreeCameraInputsManager extends CameraInputsManager<FreeCamera> {\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseInput: Nullable<FreeCameraMouseInput> = null;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _mouseWheelInput: Nullable<FreeCameraMouseWheelInput> = null;\r\n    /**\r\n     * Instantiates a new FreeCameraInputsManager.\r\n     * @param camera Defines the camera the inputs belong to\r\n     */\r\n    constructor(camera: FreeCamera) {\r\n        super(camera);\r\n    }\r\n\r\n    /**\r\n     * Add keyboard input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addKeyboard(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraKeyboardMoveInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse input support to the input manager.\r\n     * @param touchEnabled if the FreeCameraMouseInput should support touch (default: true)\r\n     * @returns the current input manager\r\n     */\r\n    addMouse(touchEnabled = true): FreeCameraInputsManager {\r\n        if (!this._mouseInput) {\r\n            this._mouseInput = new FreeCameraMouseInput(touchEnabled);\r\n            this.add(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouse(): FreeCameraInputsManager {\r\n        if (this._mouseInput) {\r\n            this.remove(this._mouseInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add mouse wheel input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addMouseWheel(): FreeCameraInputsManager {\r\n        if (!this._mouseWheelInput) {\r\n            this._mouseWheelInput = new FreeCameraMouseWheelInput();\r\n            this.add(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes the mouse wheel input support from the manager\r\n     * @returns the current input manager\r\n     */\r\n    removeMouseWheel(): FreeCameraInputsManager {\r\n        if (this._mouseWheelInput) {\r\n            this.remove(this._mouseWheelInput);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add touch input support to the input manager.\r\n     * @returns the current input manager\r\n     */\r\n    addTouch(): FreeCameraInputsManager {\r\n        this.add(new FreeCameraTouchInput());\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Remove all attached input methods from a camera\r\n     */\r\n    public override clear(): void {\r\n        super.clear();\r\n        this._mouseInput = null;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { serializeAsVector3, serialize } from \"../Misc/decorators\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Scene } from \"../scene\";\r\nimport { TargetCamera } from \"./targetCamera\";\r\nimport { FreeCameraInputsManager } from \"./freeCameraInputsManager\";\r\nimport type { FreeCameraMouseInput } from \"../Cameras/Inputs/freeCameraMouseInput\";\r\nimport type { FreeCameraKeyboardMoveInput } from \"../Cameras/Inputs/freeCameraKeyboardMoveInput\";\r\nimport { Tools } from \"../Misc/tools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Collider } from \"../Collisions/collider\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n * Please consider using the new UniversalCamera instead as it adds more functionality like the gamepad.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n */\r\nexport class FreeCamera extends TargetCamera {\r\n    /**\r\n     * Define the collision ellipsoid of the camera.\r\n     * This is helpful to simulate a camera body like the player body around the camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_collisions#arcrotatecamera\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoid = new Vector3(0.5, 1, 0.5);\r\n\r\n    /**\r\n     * Define an offset for the position of the ellipsoid around the camera.\r\n     * This can be helpful to determine the center of the body near the gravity center of the body\r\n     * instead of its head.\r\n     */\r\n    @serializeAsVector3()\r\n    public ellipsoidOffset = new Vector3(0, 0, 0);\r\n\r\n    /**\r\n     * Enable or disable collisions of the camera with the rest of the scene objects.\r\n     */\r\n    @serialize()\r\n    public checkCollisions = false;\r\n\r\n    /**\r\n     * Enable or disable gravity on the camera.\r\n     */\r\n    @serialize()\r\n    public applyGravity = false;\r\n\r\n    /**\r\n     * Define the input manager associated to the camera.\r\n     */\r\n    public override inputs: FreeCameraInputsManager;\r\n\r\n    /**\r\n     * Gets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public get angularSensibility(): number {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            return mouse.angularSensibility;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Sets the input sensibility for a mouse input. (default is 2000.0)\r\n     * Higher values reduce sensitivity.\r\n     */\r\n    public set angularSensibility(value: number) {\r\n        const mouse = <FreeCameraMouseInput>this.inputs.attached[\"mouse\"];\r\n        if (mouse) {\r\n            mouse.angularSensibility = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the forward move of the camera.\r\n     */\r\n    public get keysUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the upward move of the camera.\r\n     */\r\n    public get keysUpward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysUpward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysUpward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysUpward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the backward move of the camera.\r\n     */\r\n    public get keysDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the downward move of the camera.\r\n     */\r\n    public get keysDownward(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysDownward;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysDownward(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysDownward = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left strafe move of the camera.\r\n     */\r\n    public get keysLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right strafe move of the camera.\r\n     */\r\n    public get keysRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the left rotation move of the camera.\r\n     */\r\n    public get keysRotateLeft(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateLeft;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateLeft(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateLeft = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the right rotation move of the camera.\r\n     */\r\n    public get keysRotateRight(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateRight;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateRight(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateRight = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the up rotation move of the camera.\r\n     */\r\n    public get keysRotateUp(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateUp;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateUp(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateUp = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or Set the list of keyboard keys used to control the down rotation move of the camera.\r\n     */\r\n    public get keysRotateDown(): number[] {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            return keyboard.keysRotateDown;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public set keysRotateDown(value: number[]) {\r\n        const keyboard = <FreeCameraKeyboardMoveInput>this.inputs.attached[\"keyboard\"];\r\n        if (keyboard) {\r\n            keyboard.keysRotateDown = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event raised when the camera collide with a mesh in the scene.\r\n     */\r\n    public onCollide: (collidedMesh: AbstractMesh) => void;\r\n\r\n    private _collider: Collider;\r\n    private _needMoveForGravity = false;\r\n    private _oldPosition = Vector3.Zero();\r\n    private _diffPosition = Vector3.Zero();\r\n    private _newPosition = Vector3.Zero();\r\n\r\n    /** @internal */\r\n    public _localDirection: Vector3;\r\n    /** @internal */\r\n    public _transformedDirection: Vector3;\r\n\r\n    /**\r\n     * Instantiates a Free Camera.\r\n     * This represents a free type of camera. It can be useful in First Person Shooter game for instance.\r\n     * Please consider using the new UniversalCamera instead as it adds more functionality like touch to this camera.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/camera_introduction#universal-camera\r\n     * @param name Define the name of the camera in the scene\r\n     * @param position Define the start position of the camera in the scene\r\n     * @param scene Define the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n        this.inputs = new FreeCameraInputsManager(this);\r\n        this.inputs.addKeyboard().addMouse();\r\n    }\r\n\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attach the input controls to a specific dom element to get the input from.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     * BACK COMPAT SIGNATURE ONLY.\r\n     */\r\n    public override attachControl(ignored: any, noPreventDefault?: boolean): void;\r\n    /**\r\n     * Attached controls to the current camera.\r\n     * @param ignored defines an ignored parameter kept for backward compatibility.\r\n     * @param noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)\r\n     */\r\n    public override attachControl(ignored?: any, noPreventDefault?: boolean): void {\r\n        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    /**\r\n     * Detach the current controls from the specified dom element.\r\n     */\r\n    public override detachControl(): void {\r\n        this.inputs.detachElement();\r\n\r\n        this.cameraDirection = new Vector3(0, 0, 0);\r\n        this.cameraRotation = new Vector2(0, 0);\r\n    }\r\n\r\n    // Collisions\r\n    private _collisionMask = -1;\r\n\r\n    /**\r\n     * Define a collision mask to limit the list of object the camera can collide with\r\n     */\r\n    public get collisionMask(): number {\r\n        return this._collisionMask;\r\n    }\r\n\r\n    public set collisionMask(mask: number) {\r\n        this._collisionMask = !isNaN(mask) ? mask : -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _collideWithWorld(displacement: Vector3): void {\r\n        let globalPosition: Vector3;\r\n\r\n        if (this.parent) {\r\n            globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());\r\n        } else {\r\n            globalPosition = this.position;\r\n        }\r\n\r\n        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);\r\n        this._oldPosition.addInPlace(this.ellipsoidOffset);\r\n\r\n        const coordinator = this.getScene().collisionCoordinator;\r\n        if (!this._collider) {\r\n            this._collider = coordinator.createCollider();\r\n        }\r\n\r\n        this._collider._radius = this.ellipsoid;\r\n        this._collider.collisionMask = this._collisionMask;\r\n\r\n        //no need for clone, as long as gravity is not on.\r\n        let actualDisplacement = displacement;\r\n\r\n        //add gravity to the direction to prevent the dual-collision checking\r\n        if (this.applyGravity) {\r\n            //this prevents mending with cameraDirection, a global variable of the free camera class.\r\n            actualDisplacement = displacement.add(this.getScene().gravity);\r\n        }\r\n\r\n        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);\r\n    }\r\n\r\n    private _onCollisionPositionChange = (collisionId: number, newPosition: Vector3, collidedMesh: Nullable<AbstractMesh> = null) => {\r\n        this._newPosition.copyFrom(newPosition);\r\n\r\n        this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);\r\n\r\n        if (this._diffPosition.length() > AbstractEngine.CollisionsEpsilon) {\r\n            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            // call onCollide, if defined. Note that in case of deferred update, the actual position change might happen in the next frame.\r\n            if (this.onCollide && collidedMesh) {\r\n                this.onCollide(collidedMesh);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        if (!this._localDirection) {\r\n            this._localDirection = Vector3.Zero();\r\n            this._transformedDirection = Vector3.Zero();\r\n        }\r\n\r\n        this.inputs.checkInputs();\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    /**\r\n     * Enable movement without a user input. This allows gravity to always be applied.\r\n     */\r\n    public set needMoveForGravity(value: boolean) {\r\n        this._needMoveForGravity = value;\r\n    }\r\n\r\n    /**\r\n     * When true, gravity is applied whether there is user input or not.\r\n     */\r\n    public get needMoveForGravity(): boolean {\r\n        return this._needMoveForGravity;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _decideIfNeedsToMove(): boolean {\r\n        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _updatePosition(): void {\r\n        if (this.checkCollisions && this.getScene().collisionsEnabled) {\r\n            this._collideWithWorld(this.cameraDirection);\r\n        } else {\r\n            super._updatePosition();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy the camera and release the current resources hold by it.\r\n     */\r\n    public override dispose(): void {\r\n        this.inputs.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FreeCamera\";\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.FreeCamera\", FreeCamera);\r\n", "import { serializeAsColor3, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Node } from \"../node\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Light } from \"./light\";\r\nimport type { IShadowGenerator } from \"./Shadows/shadowGenerator\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_3\", (name, scene) => {\r\n    return () => new HemisphericLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * The HemisphericLight simulates the ambient environment light,\r\n * so the passed direction is the light reflection direction, not the incoming direction.\r\n */\r\nexport class HemisphericLight extends Light {\r\n    /**\r\n     * The groundColor is the light in the opposite direction to the one specified during creation.\r\n     * You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.\r\n     */\r\n    @serializeAsColor3()\r\n    public groundColor = new Color3(0.0, 0.0, 0.0);\r\n\r\n    /**\r\n     * The light reflection direction, not the incoming direction.\r\n     */\r\n    @serializeAsVector3()\r\n    public direction: Vector3;\r\n\r\n    /**\r\n     * Creates a HemisphericLight object in the scene according to the passed direction (Vector3).\r\n     * The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.\r\n     * The HemisphericLight can't cast shadows.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param direction The direction of the light reflection\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, direction: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.direction = direction || Vector3.Up();\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightGround\", 3);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"HemisphericLight\".\r\n     * @returns The class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"HemisphericLight\";\r\n    }\r\n\r\n    /**\r\n     * Sets the HemisphericLight direction towards the passed target (Vector3).\r\n     * Returns the updated direction.\r\n     * @param target The target the direction should point to\r\n     * @returns The computed direction\r\n     */\r\n    public setDirectionToTarget(target: Vector3): Vector3 {\r\n        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));\r\n        return this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns the shadow generator associated to the light.\r\n     * @returns Always null for hemispheric lights because it does not support shadows.\r\n     */\r\n    public override getShadowGenerator(): Nullable<IShadowGenerator> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).\r\n     * @param _effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The hemispheric light\r\n     */\r\n    public transferToEffect(_effect: Effect, lightIndex: string): HemisphericLight {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        this._uniformBuffer.updateFloat4(\"vLightData\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0.0, lightIndex);\r\n        this._uniformBuffer.updateColor3(\"vLightGround\", this.groundColor.scale(this.intensity), lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const normalizeDirection = Vector3.Normalize(this.direction);\r\n        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the world matrix of the node\r\n     * @returns the world matrix\r\n     */\r\n    public override computeWorldMatrix(): Matrix {\r\n        if (!this._worldMatrix) {\r\n            this._worldMatrix = Matrix.Identity();\r\n        }\r\n        return this._worldMatrix;\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 3.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"HEMILIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.HemisphericLight\", HemisphericLight);\r\n", "import type { FlowGraphBlock } from \"../flowGraphBlock\";\nimport { FlowGraphBlockNames } from \"./flowGraphBlockNames\";\n\n/**\n * Any external module that wishes to add a new block to the flow graph can add to this object using the helper function.\n */\nconst CustomBlocks: Record<string, () => Promise<typeof FlowGraphBlock>> = {};\n\n/**\n * If you want to add a new block to the block factory, you should use this function.\n * Please be sure to choose a unique name and define the responsible module.\n * @param module the name of the module that is responsible for the block\n * @param blockName the name of the block. This should be unique.\n * @param factory an async factory function to generate the block\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function addToBlockFactory(module: string, blockName: string, factory: () => Promise<typeof FlowGraphBlock>): void {\n    CustomBlocks[`${module}/${blockName}`] = factory;\n}\n\n/**\n * a function to get a factory function for a block.\n * @param blockName the block name to initialize. If the block comes from an external module, the name should be in the format \"module/blockName\"\n * @returns an async factory function that will return the block class when called.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function blockFactory(blockName: FlowGraphBlockNames | string): () => Promise<typeof FlowGraphBlock> {\n    switch (blockName) {\n        case FlowGraphBlockNames.PlayAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPlayAnimationBlock\")).FlowGraphPlayAnimationBlock;\n        case FlowGraphBlockNames.StopAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphStopAnimationBlock\")).FlowGraphStopAnimationBlock;\n        case FlowGraphBlockNames.PauseAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPauseAnimationBlock\")).FlowGraphPauseAnimationBlock;\n        case FlowGraphBlockNames.ValueInterpolation:\n            return async () => (await import(\"./Execution/Animation/flowGraphInterpolationBlock\")).FlowGraphInterpolationBlock;\n        case FlowGraphBlockNames.SceneReadyEvent:\n            return async () => (await import(\"./Event/flowGraphSceneReadyEventBlock\")).FlowGraphSceneReadyEventBlock;\n        case FlowGraphBlockNames.SceneTickEvent:\n            return async () => (await import(\"./Event/flowGraphSceneTickEventBlock\")).FlowGraphSceneTickEventBlock;\n        case FlowGraphBlockNames.SendCustomEvent:\n            return async () => (await import(\"./Event/flowGraphSendCustomEventBlock\")).FlowGraphSendCustomEventBlock;\n        case FlowGraphBlockNames.ReceiveCustomEvent:\n            return async () => (await import(\"./Event/flowGraphReceiveCustomEventBlock\")).FlowGraphReceiveCustomEventBlock;\n        case FlowGraphBlockNames.MeshPickEvent:\n            return async () => (await import(\"./Event/flowGraphMeshPickEventBlock\")).FlowGraphMeshPickEventBlock;\n        case FlowGraphBlockNames.E:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEBlock;\n        case FlowGraphBlockNames.PI:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPiBlock;\n        case FlowGraphBlockNames.Inf:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphInfBlock;\n        case FlowGraphBlockNames.NaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNaNBlock;\n        case FlowGraphBlockNames.Random:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRandomBlock;\n        case FlowGraphBlockNames.Add:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAddBlock;\n        case FlowGraphBlockNames.Subtract:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSubtractBlock;\n        case FlowGraphBlockNames.Multiply:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMultiplyBlock;\n        case FlowGraphBlockNames.Divide:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDivideBlock;\n        case FlowGraphBlockNames.Abs:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAbsBlock;\n        case FlowGraphBlockNames.Sign:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSignBlock;\n        case FlowGraphBlockNames.Trunc:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTruncBlock;\n        case FlowGraphBlockNames.Floor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFloorBlock;\n        case FlowGraphBlockNames.Ceil:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCeilBlock;\n        case FlowGraphBlockNames.Round:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRoundBlock;\n        case FlowGraphBlockNames.Fraction:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFractionBlock;\n        case FlowGraphBlockNames.Negation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNegationBlock;\n        case FlowGraphBlockNames.Modulo:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphModuloBlock;\n        case FlowGraphBlockNames.Min:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMinBlock;\n        case FlowGraphBlockNames.Max:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMaxBlock;\n        case FlowGraphBlockNames.Clamp:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphClampBlock;\n        case FlowGraphBlockNames.Saturate:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSaturateBlock;\n        case FlowGraphBlockNames.MathInterpolation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMathInterpolationBlock;\n        case FlowGraphBlockNames.Equality:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEqualityBlock;\n        case FlowGraphBlockNames.LessThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanBlock;\n        case FlowGraphBlockNames.LessThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanOrEqualBlock;\n        case FlowGraphBlockNames.GreaterThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanBlock;\n        case FlowGraphBlockNames.GreaterThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanOrEqualBlock;\n        case FlowGraphBlockNames.IsNaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsNanBlock;\n        case FlowGraphBlockNames.IsInfinity:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsInfinityBlock;\n        case FlowGraphBlockNames.DegToRad:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDegToRadBlock;\n        case FlowGraphBlockNames.RadToDeg:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRadToDegBlock;\n        case FlowGraphBlockNames.Sin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinBlock;\n        case FlowGraphBlockNames.Cos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCosBlock;\n        case FlowGraphBlockNames.Tan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanBlock;\n        case FlowGraphBlockNames.Asin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinBlock;\n        case FlowGraphBlockNames.Acos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcosBlock;\n        case FlowGraphBlockNames.Atan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanBlock;\n        case FlowGraphBlockNames.Atan2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtan2Block;\n        case FlowGraphBlockNames.Sinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinhBlock;\n        case FlowGraphBlockNames.Cosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCoshBlock;\n        case FlowGraphBlockNames.Tanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanhBlock;\n        case FlowGraphBlockNames.Asinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinhBlock;\n        case FlowGraphBlockNames.Acosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcoshBlock;\n        case FlowGraphBlockNames.Atanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanhBlock;\n        case FlowGraphBlockNames.Exponential:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphExpBlock;\n        case FlowGraphBlockNames.Log:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLogBlock;\n        case FlowGraphBlockNames.Log2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog2Block;\n        case FlowGraphBlockNames.Log10:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog10Block;\n        case FlowGraphBlockNames.SquareRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSquareRootBlock;\n        case FlowGraphBlockNames.Power:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPowerBlock;\n        case FlowGraphBlockNames.CubeRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCubeRootBlock;\n        case FlowGraphBlockNames.BitwiseAnd:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseAndBlock;\n        case FlowGraphBlockNames.BitwiseOr:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseOrBlock;\n        case FlowGraphBlockNames.BitwiseNot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseNotBlock;\n        case FlowGraphBlockNames.BitwiseXor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseXorBlock;\n        case FlowGraphBlockNames.BitwiseLeftShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseLeftShiftBlock;\n        case FlowGraphBlockNames.BitwiseRightShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseRightShiftBlock;\n        case FlowGraphBlockNames.Length:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphLengthBlock;\n        case FlowGraphBlockNames.Normalize:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphNormalizeBlock;\n        case FlowGraphBlockNames.Dot:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphDotBlock;\n        case FlowGraphBlockNames.Cross:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphCrossBlock;\n        case FlowGraphBlockNames.Rotate2D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate2DBlock;\n        case FlowGraphBlockNames.Rotate3D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate3DBlock;\n        case FlowGraphBlockNames.Transpose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphTransposeBlock;\n        case FlowGraphBlockNames.Determinant:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphDeterminantBlock;\n        case FlowGraphBlockNames.InvertMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphInvertMatrixBlock;\n        case FlowGraphBlockNames.MatrixMultiplication:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixMultiplicationBlock;\n        case FlowGraphBlockNames.Branch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphBranchBlock\")).FlowGraphBranchBlock;\n        case FlowGraphBlockNames.SetDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSetDelayBlock\")).FlowGraphSetDelayBlock;\n        case FlowGraphBlockNames.CancelDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCancelDelayBlock\")).FlowGraphCancelDelayBlock;\n        case FlowGraphBlockNames.CallCounter:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCounterBlock\")).FlowGraphCallCounterBlock;\n        case FlowGraphBlockNames.Debounce:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDebounceBlock\")).FlowGraphDebounceBlock;\n        case FlowGraphBlockNames.Throttle:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphThrottleBlock\")).FlowGraphThrottleBlock;\n        case FlowGraphBlockNames.DoN:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDoNBlock\")).FlowGraphDoNBlock;\n        case FlowGraphBlockNames.FlipFlop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphFlipFlopBlock\")).FlowGraphFlipFlopBlock;\n        case FlowGraphBlockNames.ForLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphForLoopBlock\")).FlowGraphForLoopBlock;\n        case FlowGraphBlockNames.MultiGate:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphMultiGateBlock\")).FlowGraphMultiGateBlock;\n        case FlowGraphBlockNames.Sequence:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSequenceBlock\")).FlowGraphSequenceBlock;\n        case FlowGraphBlockNames.Switch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSwitchBlock\")).FlowGraphSwitchBlock;\n        case FlowGraphBlockNames.WaitAll:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWaitAllBlock\")).FlowGraphWaitAllBlock;\n        case FlowGraphBlockNames.WhileLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWhileLoopBlock\")).FlowGraphWhileLoopBlock;\n        case FlowGraphBlockNames.ConsoleLog:\n            return async () => (await import(\"./Execution/flowGraphConsoleLogBlock\")).FlowGraphConsoleLogBlock;\n        case FlowGraphBlockNames.Conditional:\n            return async () => (await import(\"./Data/flowGraphConditionalDataBlock\")).FlowGraphConditionalDataBlock;\n        case FlowGraphBlockNames.Constant:\n            return async () => (await import(\"./Data/flowGraphConstantBlock\")).FlowGraphConstantBlock;\n        case FlowGraphBlockNames.TransformCoordinatesSystem:\n            return async () => (await import(\"./Data/flowGraphTransformCoordinatesSystemBlock\")).FlowGraphTransformCoordinatesSystemBlock;\n        case FlowGraphBlockNames.GetAsset:\n            return async () => (await import(\"./Data/flowGraphGetAssetBlock\")).FlowGraphGetAssetBlock;\n        case FlowGraphBlockNames.GetProperty:\n            return async () => (await import(\"./Data/flowGraphGetPropertyBlock\")).FlowGraphGetPropertyBlock;\n        case FlowGraphBlockNames.SetProperty:\n            return async () => (await import(\"./Execution/flowGraphSetPropertyBlock\")).FlowGraphSetPropertyBlock;\n        case FlowGraphBlockNames.GetVariable:\n            return async () => (await import(\"./Data/flowGraphGetVariableBlock\")).FlowGraphGetVariableBlock;\n        case FlowGraphBlockNames.SetVariable:\n            return async () => (await import(\"./Execution/flowGraphSetVariableBlock\")).FlowGraphSetVariableBlock;\n        case FlowGraphBlockNames.JsonPointerParser:\n            return async () => (await import(\"./Data/Transformers/flowGraphJsonPointerParserBlock\")).FlowGraphJsonPointerParserBlock;\n        case FlowGraphBlockNames.LeadingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLeadingZerosBlock;\n        case FlowGraphBlockNames.TrailingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTrailingZerosBlock;\n        case FlowGraphBlockNames.OneBitsCounter:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphOneBitsCounterBlock;\n        case FlowGraphBlockNames.CombineVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector2Block;\n        case FlowGraphBlockNames.CombineVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector3Block;\n        case FlowGraphBlockNames.CombineVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector4Block;\n        case FlowGraphBlockNames.CombineMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineMatrixBlock;\n        case FlowGraphBlockNames.ExtractVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector2Block;\n        case FlowGraphBlockNames.ExtractVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector3Block;\n        case FlowGraphBlockNames.ExtractVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector4Block;\n        case FlowGraphBlockNames.ExtractMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractMatrixBlock;\n        case FlowGraphBlockNames.TransformVector:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformBlock;\n        case FlowGraphBlockNames.TransformCoordinates:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformCoordinatesBlock;\n        case FlowGraphBlockNames.Conjugate:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphConjugateBlock;\n        case FlowGraphBlockNames.AngleBetween:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAngleBetweenBlock;\n        case FlowGraphBlockNames.QuaternionFromAxisAngle:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromAxisAngleBlock;\n        case FlowGraphBlockNames.AxisAngleFromQuaternion:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAxisAngleFromQuaternionBlock;\n        case FlowGraphBlockNames.QuaternionFromDirections:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromDirectionsBlock;\n        case FlowGraphBlockNames.MatrixDecompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixDecomposeBlock;\n        case FlowGraphBlockNames.MatrixCompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixComposeBlock;\n        case FlowGraphBlockNames.BooleanToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToFloat;\n        case FlowGraphBlockNames.BooleanToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToInt;\n        case FlowGraphBlockNames.FloatToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToBoolean;\n        case FlowGraphBlockNames.IntToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToBoolean;\n        case FlowGraphBlockNames.IntToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToFloat;\n        case FlowGraphBlockNames.FloatToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToInt;\n        case FlowGraphBlockNames.Easing:\n            return async () => (await import(\"./Execution/Animation/flowGraphEasingBlock\")).FlowGraphEasingBlock;\n        case FlowGraphBlockNames.BezierCurveEasing:\n            return async () => (await import(\"./Execution/Animation/flowGraphBezierCurveEasingBlock\")).FlowGraphBezierCurveEasingBlock;\n        case FlowGraphBlockNames.PointerOverEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOverEventBlock\")).FlowGraphPointerOverEventBlock;\n        case FlowGraphBlockNames.PointerOutEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOutEventBlock\")).FlowGraphPointerOutEventBlock;\n        case FlowGraphBlockNames.Context:\n            return async () => (await import(\"./Data/Utils/flowGraphContextBlock\")).FlowGraphContextBlock;\n        case FlowGraphBlockNames.ArrayIndex:\n            return async () => (await import(\"./Data/Utils/flowGraphArrayIndexBlock\")).FlowGraphArrayIndexBlock;\n        case FlowGraphBlockNames.CodeExecution:\n            return async () => (await import(\"./Data/Utils/flowGraphCodeExecutionBlock\")).FlowGraphCodeExecutionBlock;\n        case FlowGraphBlockNames.IndexOf:\n            return async () => (await import(\"./Data/Utils/flowGraphIndexOfBlock\")).FlowGraphIndexOfBlock;\n        case FlowGraphBlockNames.FunctionReference:\n            return async () => (await import(\"./Data/Utils/flowGraphFunctionReferenceBlock\")).FlowGraphFunctionReferenceBlock;\n        case FlowGraphBlockNames.DataSwitch:\n            return async () => (await import(\"./Data/flowGraphDataSwitchBlock\")).FlowGraphDataSwitchBlock;\n        default:\n            // check if the block is a custom block\n            if (CustomBlocks[blockName]) {\n                return CustomBlocks[blockName];\n            }\n            throw new Error(`Unknown block name ${blockName}`);\n    }\n}\n", "import type { IAssetContainer } from \"core/IAssetContainer\";\nimport { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport type { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\nimport type { FlowGraph, IFlowGraphParseOptions } from \"./flowGraph\";\nimport type { FlowGraphBlock, IFlowGraphBlockParseOptions } from \"./flowGraphBlock\";\nimport type { FlowGraphContext, IFlowGraphContextParseOptions } from \"./flowGraphContext\";\nimport type { IFlowGraphCoordinatorParseOptions } from \"./flowGraphCoordinator\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"./typeDefinitions\";\nimport type { Node } from \"core/node\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\nimport type { FlowGraphConnection } from \"./flowGraphConnection\";\n\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject: any, options: IFlowGraphCoordinatorParseOptions) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(\n        serializedObject._flowGraphs?.map(\n            async (serializedGraph: any) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })\n        )\n    );\n    return coordinator;\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions): Promise<FlowGraph> {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(\n        serializationObject.allBlocks.map(async (serializedBlock) => {\n            const classFactory = blockFactory(serializedBlock.className as FlowGraphBlockNames);\n            return await classFactory();\n        })\n    );\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions, resolvedClasses: (typeof FlowGraphBlock)[]) {\n    const graph = options.coordinator.createGraph();\n    const blocks: FlowGraphBlock[] = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(\n            serializedBlock,\n            { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction },\n            resolvedClasses[i]\n        );\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject: ISerializedFlowGraphContext, options: IFlowGraphContextParseOptions, rightHanded?: boolean): FlowGraphContext {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext: IAssetContainer = {\n            meshes: ac.meshes?.map((m: string) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l: string) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c: string) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m: string) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t: string) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a: string) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s: string) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps: string) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag: string) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn: string) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function (): Array<Node> {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n\n    return result;\n}\n\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject: ISerializedFlowGraphBlock, parseOptions: IFlowGraphBlockParseOptions): Promise<FlowGraphBlock> {\n    const classFactory = blockFactory(serializationObject.className as FlowGraphBlockNames);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(\n    serializationObject: ISerializedFlowGraphBlock,\n    parseOptions: IFlowGraphBlockParseOptions,\n    classType: typeof FlowGraphBlock\n): FlowGraphBlock {\n    const parsedConfig: any = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        } else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        } else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType<BlockT extends FlowGraphBlock>(serializationObject: any = {}, ownerBlock: BlockT, classType: typeof FlowGraphConnection) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject: any, ownerBlock: FlowGraphBlock, classType: typeof FlowGraphDataConnection): FlowGraphDataConnection<any> {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject: any): RichType<any> {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n", "import { serialize, serializeAsMatrix, serializeAsVector3 } from \"../../Misc/decorators\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { Observable } from \"../../Misc/observable\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\n\r\nimport \"../../Engines/AbstractEngine/abstractEngine.cubeTexture\";\r\n\r\n/**\r\n * Defines the available options when creating a cube texture\r\n */\r\nexport interface ICubeTextureCreationOptions {\r\n    /** Defines the suffixes add to the picture name in case six images are in use like _px.jpg */\r\n    extensions?: string[];\r\n\r\n    /** noMipmap defines if mipmaps should be created or not */\r\n    noMipmap?: boolean;\r\n\r\n    /** files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz */\r\n    files?: string[];\r\n\r\n    /** buffer to load instead of loading the data from the url */\r\n    buffer?: ArrayBufferView;\r\n\r\n    /** onLoad defines a callback triggered at the end of the file load if no errors occurred */\r\n    onLoad?: () => void;\r\n\r\n    /** onError defines a callback triggered in case of error during load */\r\n    onError?: (message?: string, exception?: any) => void;\r\n\r\n    /** format defines the internal format to use for the texture once loaded */\r\n    format?: number;\r\n\r\n    /** prefiltered defines whether or not the texture is created from prefiltered data */\r\n    prefiltered?: boolean;\r\n\r\n    /** forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name */\r\n    forcedExtension?: any;\r\n\r\n    /** createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary */\r\n    createPolynomials?: boolean;\r\n\r\n    /** lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness */\r\n    lodScale?: number;\r\n\r\n    /** lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness */\r\n    lodOffset?: number;\r\n\r\n    /** loaderOptions options to be passed to the loader */\r\n    loaderOptions?: any;\r\n\r\n    /** useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false) */\r\n    useSRGBBuffer?: boolean;\r\n}\r\n\r\n// The default scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\nconst DefaultLodScale = 0.8;\r\n\r\n/**\r\n * Class for creating a cube texture\r\n */\r\nexport class CubeTexture extends BaseTexture {\r\n    private _delayedOnLoad: Nullable<() => void>;\r\n    private _delayedOnError: Nullable<(message?: string, exception?: any) => void>;\r\n    private _lodScale: number;\r\n    private _lodOffset: number;\r\n\r\n    /**\r\n     * Observable triggered once the texture has been loaded.\r\n     */\r\n    public onLoadObservable: Observable<CubeTexture> = new Observable<CubeTexture>();\r\n\r\n    /**\r\n     * The url of the texture\r\n     */\r\n    @serialize()\r\n    public url: string;\r\n\r\n    /**\r\n     * Gets or sets the center of the bounding box associated with the cube texture.\r\n     * It must define where the camera used to render the texture was set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public boundingBoxPosition = Vector3.Zero();\r\n\r\n    private _boundingBoxSize: Vector3;\r\n\r\n    /**\r\n     * Gets or sets the size of the bounding box associated with the cube texture\r\n     * When defined, the cubemap will switch to local mode\r\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\r\n     * @example https://www.babylonjs-playground.com/#RNASML\r\n     */\r\n    public set boundingBoxSize(value: Vector3) {\r\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\r\n            return;\r\n        }\r\n        this._boundingBoxSize = value;\r\n        const scene = this.getScene();\r\n        if (scene) {\r\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the bounding box size\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\r\n     */\r\n    @serializeAsVector3()\r\n    public get boundingBoxSize(): Vector3 {\r\n        return this._boundingBoxSize;\r\n    }\r\n\r\n    protected _rotationY: number = 0;\r\n\r\n    /**\r\n     * Sets texture matrix rotation angle around Y axis in radians.\r\n     */\r\n    @serialize(\"rotationY\")\r\n    public set rotationY(value: number) {\r\n        this._rotationY = value;\r\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\r\n    }\r\n    /**\r\n     * Gets texture matrix rotation angle around Y axis radians.\r\n     */\r\n    public get rotationY(): number {\r\n        return this._rotationY;\r\n    }\r\n\r\n    /**\r\n     * Are mip maps generated for this texture or not.\r\n     */\r\n    public override get noMipmap(): boolean {\r\n        return this._noMipmap;\r\n    }\r\n\r\n    private _noMipmap: boolean;\r\n\r\n    /** @internal */\r\n    @serialize(\"files\")\r\n    public _files: Nullable<string[]> = null;\r\n\r\n    @serialize(\"forcedExtension\")\r\n    protected _forcedExtension: Nullable<string> = null;\r\n\r\n    /**\r\n     * Gets the forced extension (if any)\r\n     */\r\n    public get forcedExtension(): Nullable<string> {\r\n        return this._forcedExtension;\r\n    }\r\n\r\n    @serialize(\"extensions\")\r\n    private _extensions: Nullable<string[]> = null;\r\n\r\n    @serializeAsMatrix(\"textureMatrix\")\r\n    private _textureMatrix: Matrix;\r\n\r\n    @serializeAsMatrix(\"textureMatrixRefraction\")\r\n    private _textureMatrixRefraction: Matrix = new Matrix();\r\n\r\n    private _format: number;\r\n    private _createPolynomials: boolean;\r\n    private _loaderOptions: any;\r\n    private _useSRGBBuffer?: boolean;\r\n    private _buffer: Nullable<ArrayBufferView> = null;\r\n\r\n    /**\r\n     * Creates a cube texture from an array of image urls\r\n     * @param files defines an array of image urls\r\n     * @param scene defines the hosting scene\r\n     * @param noMipmap specifies if mip maps are not used\r\n     * @returns a cube texture\r\n     */\r\n    public static CreateFromImages(files: string[], scene: Scene, noMipmap?: boolean): CubeTexture {\r\n        let rootUrlKey = \"\";\r\n\r\n        for (const url of files) {\r\n            rootUrlKey += url;\r\n        }\r\n\r\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\r\n    }\r\n\r\n    /**\r\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\r\n     * @param url defines the url of the prefiltered texture\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param forcedExtension defines the extension of the file if different from the url\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @returns the prefiltered texture\r\n     */\r\n    public static CreateFromPrefilteredData(url: string, scene: Scene, forcedExtension: any = null, createPolynomials: boolean = true) {\r\n        const oldValue = scene.useDelayedTextureLoading;\r\n        scene.useDelayedTextureLoading = false;\r\n\r\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\r\n\r\n        scene.useDelayedTextureLoading = oldValue;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\r\n     * as prefiltered data.\r\n     * @param rootUrl defines the url of the texture or the root name of the six images\r\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\r\n     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture\r\n     * @param noMipmap defines if mipmaps should be created or not\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\r\n     * @param onError defines a callback triggered in case of error during load\r\n     * @param format defines the internal format to use for the texture once loaded\r\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\r\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\r\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @param loaderOptions options to be passed to the loader\r\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\r\n     * @returns the cube texture\r\n     */\r\n    constructor(\r\n        rootUrl: string,\r\n        sceneOrEngine: Scene | AbstractEngine,\r\n        extensionsOrOptions: Nullable<string[] | ICubeTextureCreationOptions> = null,\r\n        noMipmap: boolean = false,\r\n        files: Nullable<string[]> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        prefiltered = false,\r\n        forcedExtension: any = null,\r\n        createPolynomials: boolean = false,\r\n        lodScale: number = DefaultLodScale,\r\n        lodOffset: number = 0,\r\n        loaderOptions?: any,\r\n        useSRGBBuffer?: boolean\r\n    ) {\r\n        super(sceneOrEngine);\r\n\r\n        this.name = rootUrl;\r\n        this.url = rootUrl;\r\n        this._noMipmap = noMipmap;\r\n        this.hasAlpha = false;\r\n        this.isCube = true;\r\n        this._textureMatrix = Matrix.Identity();\r\n        this.coordinatesMode = Texture.CUBIC_MODE;\r\n\r\n        let extensions: Nullable<string[]> = null;\r\n        let buffer: Nullable<ArrayBufferView> = null;\r\n\r\n        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {\r\n            extensions = extensionsOrOptions.extensions ?? null;\r\n            this._noMipmap = extensionsOrOptions.noMipmap ?? false;\r\n            files = extensionsOrOptions.files ?? null;\r\n            buffer = extensionsOrOptions.buffer ?? null;\r\n            this._format = extensionsOrOptions.format ?? Constants.TEXTUREFORMAT_RGBA;\r\n            prefiltered = extensionsOrOptions.prefiltered ?? false;\r\n            forcedExtension = extensionsOrOptions.forcedExtension ?? null;\r\n            this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;\r\n            this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;\r\n            this._lodOffset = extensionsOrOptions.lodOffset ?? 0;\r\n            this._loaderOptions = extensionsOrOptions.loaderOptions;\r\n            this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;\r\n            onLoad = extensionsOrOptions.onLoad ?? null;\r\n            onError = extensionsOrOptions.onError ?? null;\r\n        } else {\r\n            this._noMipmap = noMipmap;\r\n            this._format = format;\r\n            this._createPolynomials = createPolynomials;\r\n            extensions = extensionsOrOptions;\r\n            this._loaderOptions = loaderOptions;\r\n            this._useSRGBBuffer = useSRGBBuffer;\r\n            this._lodScale = lodScale;\r\n            this._lodOffset = lodOffset;\r\n        }\r\n\r\n        if (!rootUrl && !files) {\r\n            return;\r\n        }\r\n\r\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"CubeTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"CubeTexture\";\r\n    }\r\n\r\n    /**\r\n     * Update the url (and optional buffer) of this texture if url was null during construction.\r\n     * @param url the url of the texture\r\n     * @param forcedExtension defines the extension to use\r\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\r\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\r\n     * @param onError callback called if there was an error during the loading process (defaults to null)\r\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\r\n     * @param delayLoad defines if the texture should be loaded now (false by default)\r\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\r\n     * @param buffer the buffer to use instead of loading from the url\r\n     */\r\n    public updateURL(\r\n        url: string,\r\n        forcedExtension: Nullable<string> = null,\r\n        onLoad: Nullable<() => void> = null,\r\n        prefiltered: boolean = false,\r\n        onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n        extensions: Nullable<string[]> = null,\r\n        delayLoad = false,\r\n        files: Nullable<string[]> = null,\r\n        buffer: Nullable<ArrayBufferView> = null\r\n    ): void {\r\n        if (!this.name || this.name.startsWith(\"data:\")) {\r\n            this.name = url;\r\n        }\r\n        this.url = url;\r\n\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        const lastDot = url.lastIndexOf(\".\");\r\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\r\n        const isDDS = extension.indexOf(\".dds\") === 0;\r\n        const isEnv = extension.indexOf(\".env\") === 0;\r\n        const isBasis = extension.indexOf(\".basis\") === 0;\r\n\r\n        if (isEnv) {\r\n            this.gammaSpace = false;\r\n            this._prefiltered = false;\r\n            this.anisotropicFilteringLevel = 1;\r\n        } else {\r\n            this._prefiltered = prefiltered;\r\n\r\n            if (prefiltered) {\r\n                this.gammaSpace = false;\r\n                this.anisotropicFilteringLevel = 1;\r\n            }\r\n        }\r\n\r\n        if (files) {\r\n            this._files = files;\r\n        } else {\r\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\r\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\r\n            }\r\n\r\n            this._files = this._files || [];\r\n            this._files.length = 0;\r\n\r\n            if (extensions) {\r\n                for (let index = 0; index < extensions.length; index++) {\r\n                    this._files.push(url + extensions[index]);\r\n                }\r\n                this._extensions = extensions;\r\n            }\r\n        }\r\n\r\n        this._buffer = buffer;\r\n\r\n        if (delayLoad) {\r\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\r\n            this._delayedOnLoad = onLoad;\r\n            this._delayedOnError = onError;\r\n        } else {\r\n            this._loadTexture(onLoad, onError);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delays loading of the cube texture\r\n     * @param forcedExtension defines the extension to use\r\n     */\r\n    public override delayLoad(forcedExtension?: string): void {\r\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\r\n            return;\r\n        }\r\n        if (forcedExtension) {\r\n            this._forcedExtension = forcedExtension;\r\n        }\r\n\r\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\r\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\r\n    }\r\n\r\n    /**\r\n     * Returns the reflection texture matrix\r\n     * @returns the reflection texture matrix\r\n     */\r\n    public override getReflectionTextureMatrix(): Matrix {\r\n        return this._textureMatrix;\r\n    }\r\n\r\n    /**\r\n     * Sets the reflection texture matrix\r\n     * @param value Reflection texture matrix\r\n     */\r\n    public setReflectionTextureMatrix(value: Matrix): void {\r\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\r\n            return;\r\n        }\r\n\r\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\r\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\r\n        }\r\n\r\n        this._textureMatrix = value;\r\n\r\n        if (!this.getScene()?.useRightHandedSystem) {\r\n            return;\r\n        }\r\n\r\n        const scale = TmpVectors.Vector3[0];\r\n        const quat = TmpVectors.Quaternion[0];\r\n        const trans = TmpVectors.Vector3[1];\r\n\r\n        this._textureMatrix.decompose(scale, quat, trans);\r\n\r\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\r\n        quat.w *= -1;\r\n\r\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\r\n    }\r\n\r\n    /**\r\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\r\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\r\n     * @returns The refraction matrix\r\n     */\r\n    public override getRefractionTextureMatrix(): Matrix {\r\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\r\n    }\r\n\r\n    private _loadTexture(onLoad: Nullable<() => void> = null, onError: Nullable<(message?: string, exception?: any) => void> = null) {\r\n        const scene = this.getScene();\r\n        const oldTexture = this._texture;\r\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\r\n\r\n        const onLoadProcessing = () => {\r\n            this.onLoadObservable.notifyObservers(this);\r\n            if (oldTexture) {\r\n                oldTexture.dispose();\r\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n            }\r\n            if (onLoad) {\r\n                onLoad();\r\n            }\r\n        };\r\n\r\n        const errorHandler = (message?: string, exception?: any) => {\r\n            this._loadingError = true;\r\n            this._errorObject = { message, exception };\r\n            if (onError) {\r\n                onError(message, exception);\r\n            }\r\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\r\n        };\r\n\r\n        if (!this._texture) {\r\n            if (this._prefiltered) {\r\n                this._texture = this._getEngine()!.createPrefilteredCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    this._createPolynomials\r\n                );\r\n            } else {\r\n                this._texture = this._getEngine()!.createCubeTexture(\r\n                    this.url,\r\n                    scene,\r\n                    this._files,\r\n                    this._noMipmap,\r\n                    onLoad,\r\n                    errorHandler,\r\n                    this._format,\r\n                    this._forcedExtension,\r\n                    false,\r\n                    this._lodScale,\r\n                    this._lodOffset,\r\n                    null,\r\n                    this._loaderOptions,\r\n                    !!this._useSRGBBuffer,\r\n                    this._buffer\r\n                );\r\n            }\r\n\r\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\r\n        } else {\r\n            if (this._texture.isReady) {\r\n                Tools.SetImmediate(() => onLoadProcessing());\r\n            } else {\r\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses text to create a cube texture\r\n     * @param parsedTexture define the serialized text to read from\r\n     * @param scene defines the hosting scene\r\n     * @param rootUrl defines the root url of the cube texture\r\n     * @returns a cube texture\r\n     */\r\n    public static Parse(parsedTexture: any, scene: Scene, rootUrl: string): CubeTexture {\r\n        const texture = SerializationHelper.Parse(\r\n            () => {\r\n                let prefiltered: boolean = false;\r\n                if (parsedTexture.prefiltered) {\r\n                    prefiltered = parsedTexture.prefiltered;\r\n                }\r\n                return new CubeTexture(\r\n                    rootUrl + (parsedTexture.url ?? parsedTexture.name),\r\n                    scene,\r\n                    parsedTexture.extensions,\r\n                    false,\r\n                    parsedTexture.files || null,\r\n                    null,\r\n                    null,\r\n                    undefined,\r\n                    prefiltered,\r\n                    parsedTexture.forcedExtension\r\n                );\r\n            },\r\n            parsedTexture,\r\n            scene\r\n        );\r\n\r\n        // Local Cubemaps\r\n        if (parsedTexture.boundingBoxPosition) {\r\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\r\n        }\r\n        if (parsedTexture.boundingBoxSize) {\r\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\r\n        }\r\n\r\n        // Animations\r\n        if (parsedTexture.animations) {\r\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\r\n                const parsedAnimation = parsedTexture.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n        }\r\n\r\n        return texture;\r\n    }\r\n\r\n    /**\r\n     * Makes a clone, or deep copy, of the cube texture\r\n     * @returns a new cube texture\r\n     */\r\n    public override clone(): CubeTexture {\r\n        let uniqueId = 0;\r\n\r\n        const newCubeTexture = SerializationHelper.Clone(() => {\r\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine()!, this._extensions, this._noMipmap, this._files);\r\n            uniqueId = cubeTexture.uniqueId;\r\n\r\n            return cubeTexture;\r\n        }, this);\r\n\r\n        newCubeTexture.uniqueId = uniqueId;\r\n\r\n        return newCubeTexture;\r\n    }\r\n}\r\n\r\nTexture._CubeTextureParser = CubeTexture.Parse;\r\n// Some exporters relies on Tools.Instantiate\r\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { Node } from \"../node\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Light } from \"./light\";\r\nimport { ShadowLight } from \"./shadowLight\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nNode.AddNodeConstructor(\"Light_Type_0\", (name, scene) => {\r\n    return () => new PointLight(name, Vector3.Zero(), scene);\r\n});\r\n\r\n/**\r\n * A point light is a light defined by an unique point in world space.\r\n * The light is emitted in every direction from this point.\r\n * A good example of a point light is a standard light bulb.\r\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n */\r\nexport class PointLight extends ShadowLight {\r\n    private _shadowAngle = Math.PI / 2;\r\n    /**\r\n     * Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    @serialize()\r\n    public get shadowAngle(): number {\r\n        return this._shadowAngle;\r\n    }\r\n    /**\r\n     * Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     * This specifies what angle the shadow will use to be created.\r\n     *\r\n     * It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.\r\n     */\r\n    public set shadowAngle(value: number) {\r\n        this._shadowAngle = value;\r\n        this.forceProjectionMatrixCompute();\r\n    }\r\n\r\n    /**\r\n     * Gets the direction if it has been set.\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override get direction(): Vector3 {\r\n        return this._direction;\r\n    }\r\n\r\n    /**\r\n     * In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback\r\n     */\r\n    public override set direction(value: Vector3) {\r\n        const previousNeedCube = this.needCube();\r\n        this._direction = value;\r\n        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {\r\n            const iterator = this._shadowGenerators.values();\r\n            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                const shadowGenerator = key.value;\r\n                shadowGenerator.recreateShadowMap();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.\r\n     * A PointLight emits the light in every direction.\r\n     * It can cast shadows.\r\n     * If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :\r\n     * ```javascript\r\n     * var pointLight = new PointLight(\"pl\", camera.position, scene);\r\n     * ```\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The light friendly name\r\n     * @param position The position of the point light in the scene\r\n     * @param scene The scene the lights belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = position;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"PointLight\"\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PointLight\";\r\n    }\r\n\r\n    /**\r\n     * Returns the integer 0.\r\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public override getTypeID(): number {\r\n        return Light.LIGHTTYPEID_POINTLIGHT;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the shadowmap should be a cube texture.\r\n     * @returns true if the shadowmap needs to be a cube texture.\r\n     */\r\n    public override needCube(): boolean {\r\n        return !this.direction;\r\n    }\r\n\r\n    /**\r\n     * Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).\r\n     * @param faceIndex The index of the face we are computed the direction to generate shadow\r\n     * @returns The set direction in 2d mode otherwise the direction to the cubemap face if needCube() is true\r\n     */\r\n    public override getShadowDirection(faceIndex?: number): Vector3 {\r\n        if (this.direction) {\r\n            return super.getShadowDirection(faceIndex);\r\n        } else {\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    return new Vector3(1.0, 0.0, 0.0);\r\n                case 1:\r\n                    return new Vector3(-1.0, 0.0, 0.0);\r\n                case 2:\r\n                    return new Vector3(0.0, -1.0, 0.0);\r\n                case 3:\r\n                    return new Vector3(0.0, 1.0, 0.0);\r\n                case 4:\r\n                    return new Vector3(0.0, 0.0, 1.0);\r\n                case 5:\r\n                    return new Vector3(0.0, 0.0, -1.0);\r\n            }\r\n        }\r\n\r\n        return Vector3.Zero();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed matrix \"matrix\" as a left-handed perspective projection matrix with the following settings :\r\n     * - fov = PI / 2\r\n     * - aspect ratio : 1.0\r\n     * - z-near and far equal to the active camera minZ and maxZ.\r\n     * Returns the PointLight.\r\n     * @param matrix\r\n     * @param viewMatrix\r\n     * @param renderList\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected _setDefaultShadowProjectionMatrix(matrix: Matrix, viewMatrix: Matrix, renderList: Array<AbstractMesh>): void {\r\n        const activeCamera = this.getScene().activeCamera;\r\n\r\n        if (!activeCamera) {\r\n            return;\r\n        }\r\n\r\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\r\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\r\n\r\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\r\n\r\n        Matrix.PerspectiveFovLHToRef(\r\n            this.shadowAngle,\r\n            1.0,\r\n            useReverseDepthBuffer ? maxZ : minZ,\r\n            useReverseDepthBuffer ? minZ : maxZ,\r\n            matrix,\r\n            true,\r\n            this._scene.getEngine().isNDCHalfZRange,\r\n            undefined,\r\n            useReverseDepthBuffer\r\n        );\r\n    }\r\n\r\n    protected _buildUniformLayout(): void {\r\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\r\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\r\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\r\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\r\n        this._uniformBuffer.create();\r\n    }\r\n\r\n    /**\r\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\r\n     * @param effect The effect to update\r\n     * @param lightIndex The index of the light in the effect to update\r\n     * @returns The point light\r\n     */\r\n    public transferToEffect(effect: Effect, lightIndex: string): PointLight {\r\n        const offset = this._scene.floatingOriginOffset;\r\n        if (this.computeTransformedInformation()) {\r\n            this._uniformBuffer.updateFloat4(\r\n                \"vLightData\",\r\n                this.transformedPosition.x - offset.x,\r\n                this.transformedPosition.y - offset.y,\r\n                this.transformedPosition.z - offset.z,\r\n                0.0,\r\n                lightIndex\r\n            );\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);\r\n        }\r\n\r\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, 0, 0, lightIndex);\r\n        return this;\r\n    }\r\n\r\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\r\n        const offset = this._scene.floatingOriginOffset;\r\n        if (this.computeTransformedInformation()) {\r\n            effect.setFloat3(lightDataUniformName, this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z);\r\n        } else {\r\n            effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"POINTLIGHT\" + lightIndex] = true;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.PointLight\", PointLight);\r\n", "import type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Tuple } from \"core/types\";\r\n\r\n/**\r\n * Linearly transformed cosine textures that are used in the Area Lights shaders.\r\n */\r\nexport type ILTCTextures = {\r\n    /**\r\n     * Linearly transformed cosine texture BRDF Approximation.\r\n     */\r\n    LTC1: BaseTexture;\r\n\r\n    /**\r\n     * Linearly transformed cosine texture Fresnel Approximation.\r\n     */\r\n    LTC2: BaseTexture;\r\n};\r\n\r\n/**\r\n * Loads LTC texture data from Babylon.js CDN.\r\n * @returns Promise with data for LTC1 and LTC2 textures for area lights.\r\n */\r\nexport async function DecodeLTCTextureDataAsync(): Promise<Tuple<Uint16Array, 2>> {\r\n    const ltc1 = new Uint16Array(64 * 64 * 4);\r\n    const ltc2 = new Uint16Array(64 * 64 * 4);\r\n    const file = await Tools.LoadFileAsync(Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin\"));\r\n    const ltcEncoded = new Uint16Array(file);\r\n\r\n    const pixelCount = ltcEncoded.length / 8;\r\n\r\n    for (let pixelIndex = 0; pixelIndex < pixelCount; pixelIndex++) {\r\n        ltc1[pixelIndex * 4] = ltcEncoded[pixelIndex * 8];\r\n        ltc1[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 1];\r\n        ltc1[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 2];\r\n        ltc1[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 3];\r\n\r\n        ltc2[pixelIndex * 4] = ltcEncoded[pixelIndex * 8 + 4];\r\n        ltc2[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 5];\r\n        ltc2[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 6];\r\n        ltc2[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 7];\r\n    }\r\n\r\n    return [ltc1, ltc2];\r\n}\r\n", "import type { Vector3 } from \"core/Maths/math.vector\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Effect } from \"core/Materials/effect\";\r\nimport type { ILTCTextures } from \"core/Lights/LTC/ltcTextureTool\";\r\nimport { DecodeLTCTextureDataAsync } from \"core/Lights/LTC/ltcTextureTool\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         */\r\n        _ltcTextures?: ILTCTextures;\r\n    }\r\n}\r\n\r\nfunction CreateSceneLTCTextures(scene: Scene): void {\r\n    const useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n    scene.useDelayedTextureLoading = false;\r\n\r\n    const previousState = scene._blockEntityCollection;\r\n    scene._blockEntityCollection = false;\r\n\r\n    scene._ltcTextures = {\r\n        LTC1: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, Constants.TEXTURE_LINEAR_LINEAR, Constants.TEXTURETYPE_HALF_FLOAT, 0, false, true),\r\n        LTC2: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, Constants.TEXTURE_LINEAR_LINEAR, Constants.TEXTURETYPE_HALF_FLOAT, 0, false, true),\r\n    };\r\n\r\n    scene._blockEntityCollection = previousState;\r\n\r\n    scene._ltcTextures.LTC1.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    scene._ltcTextures.LTC1.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    scene._ltcTextures.LTC2.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    scene._ltcTextures.LTC2.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    scene.useDelayedTextureLoading = useDelayedTextureLoading;\r\n\r\n    DecodeLTCTextureDataAsync()\r\n        // eslint-disable-next-line github/no-then\r\n        .then((textureData) => {\r\n            if (scene._ltcTextures) {\r\n                const ltc1 = scene._ltcTextures?.LTC1 as RawTexture;\r\n                ltc1.update(textureData[0]);\r\n\r\n                const ltc2 = scene._ltcTextures?.LTC2 as RawTexture;\r\n                ltc2.update(textureData[1]);\r\n\r\n                scene.onDisposeObservable.addOnce(() => {\r\n                    scene._ltcTextures?.LTC1.dispose();\r\n                    scene._ltcTextures?.LTC2.dispose();\r\n                });\r\n            }\r\n        })\r\n        // eslint-disable-next-line github/no-then\r\n        .catch((error) => {\r\n            Logger.Error(`Area Light fail to get LTC textures data. Error: ${error}`);\r\n        });\r\n}\r\n\r\n/**\r\n * Abstract Area Light class that servers as parent for all Area Lights implementations.\r\n * The light is emitted from the area in the -Z direction.\r\n */\r\nexport abstract class AreaLight extends Light {\r\n    /**\r\n     * Area Light position.\r\n     */\r\n    public position: Vector3;\r\n\r\n    /**\r\n     * Creates a area light object.\r\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\r\n     * @param name The friendly name of the light\r\n     * @param position The position of the area light.\r\n     * @param scene The scene the light belongs to\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene) {\r\n        super(name, scene);\r\n        this.position = position;\r\n\r\n        if (!this._scene._ltcTextures) {\r\n            CreateSceneLTCTextures(this._scene);\r\n        }\r\n    }\r\n\r\n    public override transferTexturesToEffect(effect: Effect): Light {\r\n        if (this._scene._ltcTextures) {\r\n            effect.setTexture(\"areaLightsLTC1Sampler\", this._scene._ltcTextures.LTC1);\r\n            effect.setTexture(\"areaLightsLTC2Sampler\", this._scene._ltcTextures.LTC2);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Prepares the list of defines specific to the light type.\r\n     * @param defines the list of defines\r\n     * @param lightIndex defines the index of the light for the effect\r\n     */\r\n    public prepareLightSpecificDefines(defines: any, lightIndex: number): void {\r\n        defines[\"AREALIGHT\" + lightIndex] = true;\r\n        defines[\"AREALIGHTUSED\"] = true;\r\n    }\r\n\r\n    public override _isReady(): boolean {\r\n        if (this._scene._ltcTextures) {\r\n            return this._scene._ltcTextures.LTC1.isReady() && this._scene._ltcTextures.LTC2.isReady();\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n", "import { Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport type { Effect } from \"core/Materials/effect\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { serialize } from \"../Misc/decorators\";\nimport type { Scene } from \"core/scene\";\nimport { AreaLight } from \"./areaLight\";\n\nNode.AddNodeConstructor(\"Light_Type_4\", (name, scene) => {\n    return () => new RectAreaLight(name, Vector3.Zero(), 1, 1, scene);\n});\n\n/**\n * A rectangular area light defined by an unique point in world space, a width and a height.\n * The light is emitted from the rectangular area in the -Z direction.\n */\nexport class RectAreaLight extends AreaLight {\n    private readonly _width: Vector3;\n    private readonly _height: Vector3;\n    protected readonly _pointTransformedPosition: Vector3;\n    protected readonly _pointTransformedWidth: Vector3;\n    protected readonly _pointTransformedHeight: Vector3;\n\n    /**\n     * Rect Area Light width.\n     */\n    @serialize()\n    public get width(): number {\n        return this._width.x;\n    }\n    /**\n     * Rect Area Light width.\n     */\n    public set width(value: number) {\n        this._width.x = value;\n    }\n\n    /**\n     * Rect Area Light height.\n     */\n    @serialize()\n    public get height(): number {\n        return this._height.y;\n    }\n    /**\n     * Rect Area Light height.\n     */\n    public set height(value: number) {\n        this._height.y = value;\n    }\n\n    /**\n     * Creates a rectangular area light object.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param position The position of the area light.\n     * @param width The width of the area light.\n     * @param height The height of the area light.\n     * @param scene The scene the light belongs to\n     */\n    constructor(name: string, position: Vector3, width: number, height: number, scene?: Scene) {\n        super(name, position, scene);\n        this._width = new Vector3(width, 0, 0);\n        this._height = new Vector3(0, height, 0);\n        this._pointTransformedPosition = Vector3.Zero();\n        this._pointTransformedWidth = Vector3.Zero();\n        this._pointTransformedHeight = Vector3.Zero();\n    }\n\n    /**\n     * Returns the string \"RectAreaLight\"\n     * @returns the class name\n     */\n    public override getClassName(): string {\n        return \"RectAreaLight\";\n    }\n\n    /**\n     * Returns the integer 4.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    public override getTypeID(): number {\n        return Light.LIGHTTYPEID_RECT_AREALIGHT;\n    }\n\n    protected _buildUniformLayout(): void {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightWidth\", 4);\n        this._uniformBuffer.addUniform(\"vLightHeight\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n\n    protected _computeTransformedInformation(): boolean {\n        if (this.parent && this.parent.getWorldMatrix) {\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this._pointTransformedPosition);\n            Vector3.TransformNormalToRef(this._width, this.parent.getWorldMatrix(), this._pointTransformedWidth);\n            Vector3.TransformNormalToRef(this._height, this.parent.getWorldMatrix(), this._pointTransformedHeight);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    public transferToEffect(effect: Effect, lightIndex: string): RectAreaLight {\n        const offset = this._scene.floatingOriginOffset;\n\n        if (this._computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\n                \"vLightData\",\n                this._pointTransformedPosition.x - offset.x,\n                this._pointTransformedPosition.y - offset.y,\n                this._pointTransformedPosition.z - offset.z,\n                0,\n                lightIndex\n            );\n            this._uniformBuffer.updateFloat4(\"vLightWidth\", this._pointTransformedWidth.x / 2, this._pointTransformedWidth.y / 2, this._pointTransformedWidth.z / 2, 0, lightIndex);\n            this._uniformBuffer.updateFloat4(\n                \"vLightHeight\",\n                this._pointTransformedHeight.x / 2,\n                this._pointTransformedHeight.y / 2,\n                this._pointTransformedHeight.z / 2,\n                0,\n                lightIndex\n            );\n        } else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightWidth\", this._width.x / 2, this._width.y / 2, this._width.z / 2, 0.0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightHeight\", this._height.x / 2, this._height.y / 2, this._height.z / 2, 0.0, lightIndex);\n        }\n        return this;\n    }\n\n    public transferToNodeMaterialEffect(effect: Effect, lightDataUniformName: string) {\n        const offset = this._scene.floatingOriginOffset;\n\n        if (this._computeTransformedInformation()) {\n            effect.setFloat3(\n                lightDataUniformName,\n                this._pointTransformedPosition.x - offset.x,\n                this._pointTransformedPosition.y - offset.y,\n                this._pointTransformedPosition.z - offset.z\n            );\n        } else {\n            effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);\n        }\n        return this;\n    }\n}\n\n// Register Class Name\nRegisterClass(\"BABYLON.RectAreaLight\", RectAreaLight);\n", "import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Class used to store 2D array textures containing user data\r\n */\r\nexport class RawTexture2DArray extends Texture {\r\n    private _depth: number;\r\n\r\n    /**\r\n     * Gets the number of layers of the texture\r\n     */\r\n    public get depth() {\r\n        return this._depth;\r\n    }\r\n\r\n    /**\r\n     * Create a new RawTexture2DArray\r\n     * @param data defines the data of the texture\r\n     * @param width defines the width of the texture\r\n     * @param height defines the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param format defines the texture format to use\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\r\n     * @param invertY defines if texture must be stored with Y axis inverted\r\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        /** Gets or sets the texture format to use */\r\n        public format: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags?: number\r\n    ) {\r\n        super(null, scene, !generateMipMaps, invertY);\r\n\r\n        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\r\n\r\n        this._depth = depth;\r\n        this.is2DArray = true;\r\n    }\r\n\r\n    /**\r\n     * Update the texture with new data\r\n     * @param data defines the data to store in the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n        this._getEngine()!.updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param depth defines the number of layers of the texture\r\n     * @param scene defines the scene the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: ArrayBufferView,\r\n        width: number,\r\n        height: number,\r\n        depth: number,\r\n        scene: Scene,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ): RawTexture2DArray {\r\n        return new RawTexture2DArray(data, width, height, depth, Constants.TEXTUREFORMAT_RGBA, scene, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTargetManager implements IDisposable {\r\n    /** Enable storing morph target data into textures when set to true (true by default) */\r\n    public static EnableTextureStorage = true;\r\n\r\n    /** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\r\n    public static MaxActiveMorphTargetsInVertexAttributeMode = 8;\r\n\r\n    /**\r\n     * When used in texture mode, if greather than 0, this will override the the morph manager numMaxInfluencers value.\r\n     */\r\n    public static ConstantTargetCountForTextureMode = 0;\r\n\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _supportsPositions = false;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _supportsUV2s = false;\r\n    private _supportsColors = false;\r\n    private _vertexCount = 0;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n    private _canUseTextureForTargets = false;\r\n    private _blockCounter = 0;\r\n    private _mustSynchronize = true;\r\n    private _forceUpdateWhenUnfrozen = false;\r\n\r\n    /** @internal */\r\n    public _textureVertexStride = 0;\r\n\r\n    /** @internal */\r\n    public _textureWidth = 0;\r\n\r\n    /** @internal */\r\n    public _textureHeight = 1;\r\n\r\n    /** @internal */\r\n    public _morphTargetTextureIndices: Float32Array;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _targetStoreTexture: Nullable<RawTexture2DArray>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\r\n     */\r\n    public optimizeInfluencers = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if positions must be morphed\r\n     */\r\n    public enablePositionMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV2 must be morphed\r\n     */\r\n    public enableUV2Morphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if colors must be morphed\r\n     */\r\n    public enableColorMorphing = true;\r\n\r\n    /**\r\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\r\n     */\r\n    public set areUpdatesFrozen(block: boolean) {\r\n        if (block) {\r\n            this._blockCounter++;\r\n        } else {\r\n            this._blockCounter--;\r\n            if (this._blockCounter <= 0) {\r\n                this._blockCounter = 0;\r\n\r\n                this._syncActiveTargets(this._forceUpdateWhenUnfrozen);\r\n                this._forceUpdateWhenUnfrozen = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public get areUpdatesFrozen() {\r\n        return this._blockCounter > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.addMorphTargetManager(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n\r\n            const engineCaps = this._scene.getEngine().getCaps();\r\n            this._canUseTextureForTargets =\r\n                engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\r\n        }\r\n    }\r\n\r\n    private _numMaxInfluencers = 0;\r\n\r\n    /**\r\n     * Gets or sets the maximum number of influencers (targets) (default value: 0).\r\n     * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.\r\n     * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.\r\n     * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.\r\n     * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.\r\n     * Note that this property has no effect if \"useTextureToStoreTargets\" is false.\r\n     * Note as well that if MorphTargetManager.ConstantTargetCountForTextureMode is greater than 0, this property will be ignored and the constant value will be used instead.\r\n     */\r\n    public get numMaxInfluencers(): number {\r\n        if (MorphTargetManager.ConstantTargetCountForTextureMode > 0 && this.isUsingTextureForTargets) {\r\n            return MorphTargetManager.ConstantTargetCountForTextureMode;\r\n        }\r\n        return this._numMaxInfluencers;\r\n    }\r\n\r\n    public set numMaxInfluencers(value: number) {\r\n        if (this._numMaxInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._numMaxInfluencers = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of positions\r\n     */\r\n    public get supportsPositions(): boolean {\r\n        return this._supportsPositions && this.enablePositionMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates 2\r\n     */\r\n    public get supportsUV2s(): boolean {\r\n        return this._supportsUV2s && this.enableUV2Morphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of colors\r\n     */\r\n    public get supportsColors(): boolean {\r\n        return this._supportsColors && this.enableColorMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing positions\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return this._supportsPositions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing normals\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return this._supportsNormals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing tangents\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return this._supportsTangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return this._supportsUVs;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates 2\r\n     */\r\n    public get hasUV2s(): boolean {\r\n        return this._supportsUV2s;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing colors\r\n     */\r\n    public get hasColors(): boolean {\r\n        return this._supportsColors;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._influences;\r\n    }\r\n\r\n    private _useTextureToStoreTargets = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreTargets(): boolean {\r\n        return this._useTextureToStoreTargets;\r\n    }\r\n\r\n    public set useTextureToStoreTargets(value: boolean) {\r\n        if (this._useTextureToStoreTargets === value) {\r\n            return;\r\n        }\r\n        this._useTextureToStoreTargets = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\r\n     */\r\n    public get isUsingTextureForTargets() {\r\n        return (\r\n            MorphTargetManager.EnableTextureStorage &&\r\n            this.useTextureToStoreTargets &&\r\n            this._canUseTextureForTargets &&\r\n            !this._scene?.getEngine().getCaps().disableMorphTargetTexture\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the MorphTargetManager\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the first target with the specified name\r\n     * @param name defines the name to check\r\n     * @returns the requested target\r\n     */\r\n    public getTargetByName(name: string): Nullable<MorphTarget> {\r\n        for (const target of this._targets) {\r\n            if (target.name === name) {\r\n                return target;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _influencesAreDirty = false;\r\n    private _needUpdateInfluences = false;\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(\r\n            target.onInfluenceChanged.add((needUpdate) => {\r\n                if (this.areUpdatesFrozen && needUpdate) {\r\n                    this._forceUpdateWhenUnfrozen = true;\r\n                }\r\n                this._influencesAreDirty = true;\r\n                this._needUpdateInfluences = this._needUpdateInfluences || needUpdate;\r\n            })\r\n        );\r\n        this._targetDataLayoutChangedObservers.push(\r\n            target._onDataLayoutChanged.add(() => {\r\n                this._mustSynchronize = true;\r\n                this._syncActiveTargets();\r\n            })\r\n        );\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        const index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._mustSynchronize = true;\r\n            this._syncActiveTargets();\r\n        }\r\n\r\n        if (this._scene) {\r\n            this._scene.stopAnimation(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(effect: Effect) {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\r\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\r\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\r\n        effect.setFloat(\"morphTargetCount\", this.numInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        const copy = new MorphTargetManager(this._scene);\r\n        copy.areUpdatesFrozen = true;\r\n\r\n        for (const target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n        copy.areUpdatesFrozen = false;\r\n\r\n        copy.enablePositionMorphing = this.enablePositionMorphing;\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n        copy.enableUV2Morphing = this.enableUV2Morphing;\r\n        copy.enableColorMorphing = this.enableColorMorphing;\r\n        copy.metadata = this.metadata;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (const target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate = false): void {\r\n        if (this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        needUpdate = needUpdate || this._needUpdateInfluences;\r\n\r\n        this._needUpdateInfluences = false;\r\n        this._influencesAreDirty = false;\r\n\r\n        const wasUsingTextureForTargets = !!this._targetStoreTexture;\r\n        const isUsingTextureForTargets = this.isUsingTextureForTargets;\r\n\r\n        if (this._mustSynchronize || wasUsingTextureForTargets !== isUsingTextureForTargets) {\r\n            this._mustSynchronize = false;\r\n            this.synchronize();\r\n        }\r\n\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n\r\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\r\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\r\n        }\r\n\r\n        let targetIndex = -1;\r\n        for (const target of this._targets) {\r\n            targetIndex++;\r\n            if (target.influence === 0 && this.optimizeInfluencers) {\r\n                continue;\r\n            }\r\n\r\n            if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\r\n                break;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n        }\r\n\r\n        if (this._morphTargetTextureIndices.length !== influenceCount) {\r\n            this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (let index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate && this._scene) {\r\n            for (const mesh of this._scene.meshes) {\r\n                if ((<any>mesh).morphTargetManager === this) {\r\n                    if (isUsingTextureForTargets) {\r\n                        mesh._markSubMeshesAsAttributesDirty();\r\n                    } else {\r\n                        (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene || this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._supportsPositions = true;\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._supportsUV2s = true;\r\n        this._supportsColors = true;\r\n        this._vertexCount = 0;\r\n\r\n        this._targetStoreTexture?.dispose();\r\n        this._targetStoreTexture = null;\r\n\r\n        if (this.isUsingTextureForTargets && this._targets.length > engine.getCaps().texture2DArrayMaxLayerCount) {\r\n            this.useTextureToStoreTargets = false;\r\n        }\r\n\r\n        for (const target of this._targets) {\r\n            this._supportsPositions = this._supportsPositions && target.hasPositions;\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n            this._supportsUV2s = this._supportsUV2s && target.hasUV2s;\r\n            this._supportsColors = this._supportsColors && target.hasColors;\r\n\r\n            const vertexCount = target.vertexCount;\r\n            if (this._vertexCount === 0) {\r\n                this._vertexCount = vertexCount;\r\n            } else if (this._vertexCount !== vertexCount) {\r\n                Logger.Error(\r\n                    `Incompatible target. Targets must all have the same vertices count. Current vertex count: ${this._vertexCount}, vertex count for target \"${target.name}\": ${vertexCount}`\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this.isUsingTextureForTargets) {\r\n            this._textureVertexStride = 0;\r\n\r\n            this._supportsPositions && this._textureVertexStride++;\r\n            this._supportsNormals && this._textureVertexStride++;\r\n            this._supportsTangents && this._textureVertexStride++;\r\n            this._supportsUVs && this._textureVertexStride++;\r\n            this._supportsUV2s && this._textureVertexStride++;\r\n            this._supportsColors && this._textureVertexStride++;\r\n\r\n            this._textureWidth = this._vertexCount * this._textureVertexStride || 1;\r\n            this._textureHeight = 1;\r\n\r\n            const maxTextureSize = engine.getCaps().maxTextureSize;\r\n            if (this._textureWidth > maxTextureSize) {\r\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\r\n                this._textureWidth = maxTextureSize;\r\n            }\r\n\r\n            const targetCount = this._targets.length;\r\n            const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\r\n\r\n            let offset = 0;\r\n            for (let index = 0; index < targetCount; index++) {\r\n                const target = this._targets[index];\r\n\r\n                const positions = target.getPositions();\r\n                const normals = target.getNormals();\r\n                const uvs = target.getUVs();\r\n                const tangents = target.getTangents();\r\n                const uv2s = target.getUV2s();\r\n                const colors = target.getColors();\r\n\r\n                offset = index * this._textureWidth * this._textureHeight * 4;\r\n                for (let vertex = 0; vertex < this._vertexCount; vertex++) {\r\n                    if (this._supportsPositions && positions) {\r\n                        data[offset] = positions[vertex * 3];\r\n                        data[offset + 1] = positions[vertex * 3 + 1];\r\n                        data[offset + 2] = positions[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsNormals && normals) {\r\n                        data[offset] = normals[vertex * 3];\r\n                        data[offset + 1] = normals[vertex * 3 + 1];\r\n                        data[offset + 2] = normals[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUVs && uvs) {\r\n                        data[offset] = uvs[vertex * 2];\r\n                        data[offset + 1] = uvs[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsTangents && tangents) {\r\n                        data[offset] = tangents[vertex * 3];\r\n                        data[offset + 1] = tangents[vertex * 3 + 1];\r\n                        data[offset + 2] = tangents[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUV2s && uv2s) {\r\n                        data[offset] = uv2s[vertex * 2];\r\n                        data[offset + 1] = uv2s[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsColors && colors) {\r\n                        data[offset] = colors[vertex * 4];\r\n                        data[offset + 1] = colors[vertex * 4 + 1];\r\n                        data[offset + 2] = colors[vertex * 4 + 2];\r\n                        data[offset + 3] = colors[vertex * 4 + 3];\r\n                        offset += 4;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(\r\n                data,\r\n                this._textureWidth,\r\n                this._textureHeight,\r\n                targetCount,\r\n                this._scene,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                Constants.TEXTURETYPE_FLOAT\r\n            );\r\n            this._targetStoreTexture.name = `Morph texture_${this.uniqueId}`;\r\n        }\r\n\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (const mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose() {\r\n        if (this._targetStoreTexture) {\r\n            this._targetStoreTexture.dispose();\r\n        }\r\n\r\n        this._targetStoreTexture = null;\r\n        this.metadata = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            this._scene.removeMorphTargetManager(this);\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n\r\n            for (const morph of this._targets) {\r\n                this._scene.stopAnimation(morph);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        const result = new MorphTargetManager(scene);\r\n\r\n        for (const targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData, scene));\r\n        }\r\n\r\n        if (serializationObject.metadata) {\r\n            result.metadata = serializationObject.metadata;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { _UpdateRGBDAsync as UpdateRGBDAsyncEnvTools } from \"../../Misc/environmentTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { SphericalPolynomial } from \"../../Maths/sphericalPolynomial\";\r\nimport { InternalTextureSource } from \"./internalTexture\";\r\nimport { CubeTexture } from \"./cubeTexture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\n\r\n/**\r\n * Raw cube texture where the raw buffers are passed in\r\n */\r\nexport class RawCubeTexture extends CubeTexture {\r\n    /**\r\n     * Creates a cube texture where the raw buffers are passed in.\r\n     * @param scene defines the scene the texture is attached to\r\n     * @param data defines the array of data to use to create each face\r\n     * @param size defines the size of the textures\r\n     * @param format defines the format of the data\r\n     * @param type defines the type of the data (like Engine.TEXTURETYPE_UNSIGNED_BYTE)\r\n     * @param generateMipMaps  defines if the engine should generate the mip levels\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param samplingMode defines the required sampling mode (like Texture.NEAREST_SAMPLINGMODE)\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        data: Nullable<ArrayBufferView[]>,\r\n        size: number,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        generateMipMaps: boolean = false,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        compression: Nullable<string> = null\r\n    ) {\r\n        super(\"\", scene);\r\n\r\n        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates the raw cube texture.\r\n     * @param data defines the data to store\r\n     * @param format defines the data format\r\n     * @param type defines the type fo the data (Engine.TEXTURETYPE_UNSIGNED_BYTE by default)\r\n     * @param invertY defines if data must be stored with Y axis inverted\r\n     * @param compression defines the compression used (null by default)\r\n     */\r\n    public update(data: ArrayBufferView[], format: number, type: number, invertY: boolean, compression: Nullable<string> = null): void {\r\n        this._texture!.getEngine().updateRawCubeTexture(this._texture!, data, format, type, invertY, compression);\r\n    }\r\n\r\n    /**\r\n     * Updates a raw cube texture with RGBD encoded data.\r\n     * @param data defines the array of data [mipmap][face] to use to create each face\r\n     * @param sphericalPolynomial defines the spherical polynomial for irradiance\r\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\r\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public updateRGBDAsync(data: ArrayBufferView[][], sphericalPolynomial: Nullable<SphericalPolynomial> = null, lodScale: number = 0.8, lodOffset: number = 0): Promise<void> {\r\n        // eslint-disable-next-line github/no-then\r\n        return UpdateRGBDAsyncEnvTools(this._texture!, data, sphericalPolynomial, lodScale, lodOffset).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Clones the raw cube texture.\r\n     * @returns a new cube texture\r\n     */\r\n    public override clone(): CubeTexture {\r\n        return SerializationHelper.Clone(() => {\r\n            const scene = this.getScene()!;\r\n            const internalTexture = this._texture!;\r\n\r\n            const texture = new RawCubeTexture(\r\n                scene,\r\n                internalTexture._bufferViewArray,\r\n                internalTexture.width,\r\n                internalTexture.format,\r\n                internalTexture.type,\r\n                internalTexture.generateMipMaps,\r\n                internalTexture.invertY,\r\n                internalTexture.samplingMode,\r\n                internalTexture._compression\r\n            );\r\n\r\n            if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n                texture.updateRGBDAsync(\r\n                    internalTexture._bufferViewArrayArray!,\r\n                    internalTexture._sphericalPolynomial,\r\n                    internalTexture._lodGenerationScale,\r\n                    internalTexture._lodGenerationOffset\r\n                );\r\n            }\r\n\r\n            return texture;\r\n        }, this);\r\n    }\r\n}\r\n", "import type { Observer } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { Material } from \"./material\";\r\nimport type { IEffectCreationOptions } from \"./effect\";\r\nimport { Effect } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Node } from \"../node\";\r\nimport type { ShadowGenerator } from \"../Lights/Shadows/shadowGenerator\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport { DrawWrapper } from \"./drawWrapper\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n/**\r\n * Options to be used when creating a shadow depth material\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface IIOptionShadowDepthMaterial {\r\n    /** Variables in the vertex shader code that need to have their names remapped.\r\n     * The format is: [\"var_name\", \"var_remapped_name\", \"var_name\", \"var_remapped_name\", ...]\r\n     * \"var_name\" should be either: worldPos or vNormalW\r\n     * So, if the variable holding the world position in your vertex shader is not named worldPos, you must tell the system\r\n     * the name to use instead by using: [\"worldPos\", \"myWorldPosVar\"] assuming the variable is named myWorldPosVar in your code.\r\n     * If the normal must also be remapped: [\"worldPos\", \"myWorldPosVar\", \"vNormalW\", \"myWorldNormal\"]\r\n     */\r\n    remappedVariables?: string[];\r\n\r\n    /** Set standalone to true if the base material wrapped by ShadowDepthMaterial is not used for a regular object but for depth shadow generation only */\r\n    standalone?: boolean;\r\n\r\n    /** Set doNotInjectCode if the specific shadow map generation code is already implemented by the material. That will prevent this code to be injected twice by ShadowDepthWrapper */\r\n    doNotInjectCode?: boolean;\r\n}\r\n\r\nclass MapMap<Ka, Kb, V> {\r\n    readonly mm = new Map<Ka, Map<Kb, V>>();\r\n\r\n    get(a: Ka, b: Kb): V | undefined {\r\n        const m = this.mm.get(a);\r\n        if (m !== undefined) {\r\n            return m.get(b);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    set(a: Ka, b: Kb, v: V): void {\r\n        let m = this.mm.get(a);\r\n        if (m === undefined) {\r\n            this.mm.set(a, (m = new Map()));\r\n        }\r\n        m.set(b, v);\r\n    }\r\n}\r\n\r\n/**\r\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\r\n */\r\nexport class ShadowDepthWrapper {\r\n    private _scene: Scene;\r\n    private _options?: IIOptionShadowDepthMaterial;\r\n    private _baseMaterial: Material;\r\n    private _onEffectCreatedObserver: Nullable<Observer<{ effect: Effect; subMesh: Nullable<SubMesh> }>>;\r\n    private _subMeshToEffect: Map<Nullable<SubMesh>, [Effect, number]>;\r\n    private _subMeshToDepthWrapper: MapMap<\r\n        Nullable<SubMesh>,\r\n        ShadowGenerator,\r\n        { drawWrapper: Array<Nullable<DrawWrapper>>; mainDrawWrapper: DrawWrapper; depthDefines: string; token: string }\r\n    >; // key is (subMesh + shadowGenerator)\r\n    private _meshes: Map<AbstractMesh, Nullable<Observer<Node>>>;\r\n\r\n    /** Gets the standalone status of the wrapper */\r\n    public get standalone(): boolean {\r\n        return this._options?.standalone ?? false;\r\n    }\r\n\r\n    /** Gets the base material the wrapper is built upon */\r\n    public get baseMaterial(): Material {\r\n        return this._baseMaterial;\r\n    }\r\n\r\n    /** Gets the doNotInjectCode status of the wrapper */\r\n    public get doNotInjectCode(): boolean {\r\n        return this._options?.doNotInjectCode ?? false;\r\n    }\r\n\r\n    /**\r\n     * Instantiate a new shadow depth wrapper.\r\n     * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\r\n     * generate the shadow depth map. For more information, please refer to the documentation:\r\n     * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\r\n     * @param baseMaterial Material to wrap\r\n     * @param scene Define the scene the material belongs to\r\n     * @param options Options used to create the wrapper\r\n     */\r\n    constructor(baseMaterial: Material, scene?: Scene, options?: IIOptionShadowDepthMaterial) {\r\n        this._baseMaterial = baseMaterial;\r\n        this._scene = scene ?? <Scene>EngineStore.LastCreatedScene;\r\n        this._options = options;\r\n\r\n        this._subMeshToEffect = new Map();\r\n        this._subMeshToDepthWrapper = new MapMap();\r\n        this._meshes = new Map();\r\n\r\n        // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\r\n        // to create the depth effect later on\r\n        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params: { effect: Effect; subMesh: Nullable<SubMesh> }) => {\r\n            const mesh = params.subMesh?.getMesh();\r\n\r\n            if (mesh && !this._meshes.has(mesh)) {\r\n                // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\r\n                this._meshes.set(\r\n                    mesh,\r\n                    mesh.onDisposeObservable.add((mesh: Node) => {\r\n                        const iterator = this._subMeshToEffect.keys();\r\n                        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\r\n                            const subMesh = key.value;\r\n                            if (subMesh?.getMesh() === (mesh as AbstractMesh)) {\r\n                                this._subMeshToEffect.delete(subMesh);\r\n                                this._deleteDepthWrapperEffect(subMesh);\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {\r\n                this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);\r\n                this._deleteDepthWrapperEffect(params.subMesh);\r\n            }\r\n        });\r\n    }\r\n\r\n    private _deleteDepthWrapperEffect(subMesh: Nullable<SubMesh>): void {\r\n        const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);\r\n        if (depthWrapperEntries) {\r\n            // find and release the previous depth effect\r\n            depthWrapperEntries.forEach((depthWrapper) => {\r\n                depthWrapper.mainDrawWrapper.effect?.dispose();\r\n            });\r\n            this._subMeshToDepthWrapper.mm.delete(subMesh); // trigger a depth effect recreation\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the effect to use to generate the depth map\r\n     * @param subMesh subMesh to get the effect for\r\n     * @param shadowGenerator shadow generator to get the effect for\r\n     * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from\r\n     * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\r\n     */\r\n    public getEffect(subMesh: Nullable<SubMesh>, shadowGenerator: ShadowGenerator, passIdForDrawWrapper: number): Nullable<DrawWrapper> {\r\n        const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);\r\n        if (!entry) {\r\n            return null;\r\n        }\r\n        let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];\r\n        if (!drawWrapper) {\r\n            drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());\r\n            drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);\r\n        }\r\n\r\n        return drawWrapper;\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used for depth rendering\r\n     * @param subMesh submesh to check\r\n     * @param defines the list of defines to take into account when checking the effect\r\n     * @param shadowGenerator combined with subMesh, it defines the effect to check\r\n     * @param useInstances specifies that instances should be used\r\n     * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created\r\n     * @returns a boolean indicating that the submesh is ready or not\r\n     */\r\n    public isReadyForSubMesh(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, useInstances: boolean, passIdForDrawWrapper: number): boolean {\r\n        if (this.standalone) {\r\n            // will ensure the effect is (re)created for the base material\r\n            if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources\r\n     */\r\n    public dispose(): void {\r\n        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\r\n        this._onEffectCreatedObserver = null;\r\n\r\n        const iterator = this._meshes.entries();\r\n        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\r\n            const [mesh, observer] = entry.value;\r\n\r\n            mesh.onDisposeObservable.remove(observer);\r\n        }\r\n    }\r\n\r\n    private _makeEffect(subMesh: SubMesh, defines: string[], shadowGenerator: ShadowGenerator, passIdForDrawWrapper: number): Nullable<Effect> {\r\n        const engine = this._scene.getEngine();\r\n        const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);\r\n\r\n        if (!origEffectAndRenderPassId) {\r\n            return null;\r\n        }\r\n\r\n        const [origEffect, origRenderPassId] = origEffectAndRenderPassId;\r\n\r\n        if (!origEffect.isReady()) {\r\n            return null;\r\n        }\r\n\r\n        let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);\r\n        if (!params) {\r\n            const mainDrawWrapper = new DrawWrapper(engine);\r\n            mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;\r\n\r\n            params = {\r\n                drawWrapper: [],\r\n                mainDrawWrapper,\r\n                depthDefines: \"\",\r\n                token: RandomGUID(),\r\n            };\r\n            params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;\r\n            this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);\r\n        }\r\n\r\n        const join = defines.join(\"\\n\");\r\n\r\n        if (params.mainDrawWrapper.effect) {\r\n            if (join === params.depthDefines) {\r\n                // we already created the depth effect and it is still up to date for this submesh + shadow generator\r\n                return params.mainDrawWrapper.effect;\r\n            }\r\n        }\r\n\r\n        params.depthDefines = join;\r\n\r\n        const uniforms = origEffect.getUniformNames().slice();\r\n\r\n        // the depth effect is either out of date or has not been created yet\r\n        let vertexCode = origEffect.vertexSourceCodeBeforeMigration,\r\n            fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;\r\n\r\n        if (!vertexCode && !fragmentCode) {\r\n            return null;\r\n        }\r\n\r\n        if (!this.doNotInjectCode) {\r\n            // Declare the shadow map includes\r\n            const vertexNormalBiasCode =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapVertexNormalBias>`,\r\n                vertexMetricCode =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapVertexMetric>`,\r\n                fragmentSoftTransparentShadow =\r\n                    this._options && this._options.remappedVariables\r\n                        ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})`\r\n                        : `#include<shadowMapFragmentSoftTransparentShadow>`,\r\n                fragmentBlockCode = `#include<shadowMapFragment>`,\r\n                vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;\r\n\r\n            // vertex code\r\n            if (origEffect.shaderLanguage === ShaderLanguage.GLSL) {\r\n                vertexCode = vertexCode.replace(/void\\s+?main/g, `\\n${vertexExtraDeclartion}\\nvoid main`);\r\n            } else {\r\n                vertexCode = vertexCode.replace(/@vertex/g, `\\n${vertexExtraDeclartion}\\n@vertex`);\r\n            }\r\n            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\r\n\r\n            if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\r\n                vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\r\n            } else {\r\n                vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\n}\");\r\n            }\r\n            vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\r\n\r\n            // fragment code\r\n            const hasLocationForSoftTransparentShadow =\r\n                fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\r\n            const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\r\n\r\n            let fragmentCodeToInjectAtEnd = \"\";\r\n\r\n            if (!hasLocationForSoftTransparentShadow) {\r\n                fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\n\";\r\n            } else {\r\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\r\n            }\r\n\r\n            fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentExtraDeclaration\"] + \"\\nvoid main\");\r\n\r\n            if (hasLocationForFragment) {\r\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\r\n            } else {\r\n                fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\n\";\r\n            }\r\n            if (fragmentCodeToInjectAtEnd) {\r\n                fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\r\n            }\r\n\r\n            uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\r\n        }\r\n\r\n        params.mainDrawWrapper.effect = engine.createEffect(\r\n            {\r\n                vertexSource: vertexCode,\r\n                fragmentSource: fragmentCode,\r\n                vertexToken: params.token,\r\n                fragmentToken: params.token,\r\n            },\r\n            <IEffectCreationOptions>{\r\n                attributes: origEffect.getAttributesNames(),\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: origEffect.getUniformBuffersNames(),\r\n                samplers: origEffect.getSamplers(),\r\n                defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\r\n                indexParameters: origEffect.getIndexParameters(),\r\n                shaderLanguage: origEffect.shaderLanguage,\r\n            },\r\n            engine\r\n        );\r\n\r\n        for (let id = 0; id < params.drawWrapper.length; ++id) {\r\n            if (id !== passIdForDrawWrapper) {\r\n                params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);\r\n            }\r\n        }\r\n        return params.mainDrawWrapper.effect;\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;void main(void) {float A=-dot(vPosition,vPosition);if (A<-1.) discard;}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\n\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main(void) {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPosGS=world*vec4(splat.center.xyz,1.0);vPosition=position.xy;gl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,world,view,projection);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShader = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\n\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `#include<gaussianSplattingFragmentDeclaration>\nvarying vPosition: vec2f;fn checkDiscard(inPosition: vec2f)->vec4f {var A : f32=-dot(inPosition,inPosition);if (A<-1.) {discard;}\nreturn vec4f(0.0);}\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition);}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShaderWGSL = { name, shader };\n", "// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\n\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;vertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShaderWGSL = { name, shader };\n", "import type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Matrix } from \"../../Maths/math.vector\";\r\nimport type { GaussianSplattingMesh } from \"../../Meshes\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\r\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport { Camera } from \"../../Cameras/camera\";\r\nimport { ShadowDepthWrapper } from \"../../Materials/shadowDepthWrapper\";\r\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\r\n\r\nimport \"../../Shaders/gaussianSplatting.fragment\";\r\nimport \"../../Shaders/gaussianSplatting.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\r\nimport \"../../Shaders/gaussianSplattingDepth.fragment\";\r\nimport \"../../Shaders/gaussianSplattingDepth.vertex\";\r\nimport \"../../ShadersWGSL/gaussianSplattingDepth.fragment\";\r\nimport \"../../ShadersWGSL/gaussianSplattingDepth.vertex\";\r\nimport {\r\n    BindFogParameters,\r\n    BindLogDepth,\r\n    PrepareAttributesForInstances,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForMisc,\r\n    PrepareUniformsAndSamplersList,\r\n} from \"../materialHelper.functions\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\n/**\r\n * @internal\r\n */\r\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\r\n    public FOG = false;\r\n    public THIN_INSTANCES = true;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public SH_DEGREE = 0;\r\n    public COMPENSATION = false;\r\n\r\n    /**\r\n     * Constructor of the defines.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.rebuild();\r\n    }\r\n}\r\n\r\n/**\r\n * GaussianSplattingMaterial material used to render Gaussian Splatting\r\n * @experimental\r\n */\r\nexport class GaussianSplattingMaterial extends PushMaterial {\r\n    /**\r\n     * Instantiates a Gaussian Splatting Material in the given scene\r\n     * @param name The friendly name of the material\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n\r\n        this.backFaceCulling = false;\r\n        this.shadowDepthWrapper = GaussianSplattingMaterial._MakeGaussianSplattingShadowDepthWrapper(scene!, this.shaderLanguage);\r\n    }\r\n\r\n    /**\r\n     * Point spread function (default 0.3). Can be overriden per GS material\r\n     */\r\n    public static KernelSize: number = 0.3;\r\n\r\n    /**\r\n     * Compensation\r\n     */\r\n    public static Compensation: boolean = false;\r\n\r\n    /**\r\n     * Point spread function (default 0.3). Can be overriden per GS material, otherwise, using default static `KernelSize` value\r\n     */\r\n    public kernelSize = GaussianSplattingMaterial.KernelSize;\r\n    private _compensation = GaussianSplattingMaterial.Compensation;\r\n\r\n    // set to true when material defines are dirty\r\n    private _isDirty = false;\r\n\r\n    /**\r\n     * Set compensation default value is `GaussianSplattingMaterial.Compensation`\r\n     */\r\n    public set compensation(value: boolean) {\r\n        this._isDirty = this._isDirty != value;\r\n        this._compensation = value;\r\n    }\r\n\r\n    /**\r\n     * Get compensation\r\n     */\r\n    public get compensation(): boolean {\r\n        return this._compensation;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha test mode.\r\n     * @returns false\r\n     */\r\n    public override needAlphaTesting(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not this material should be rendered in alpha blend mode.\r\n     * @returns true\r\n     */\r\n    public override needAlphaBlending(): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected static _Attribs = [VertexBuffer.PositionKind, \"splatIndex\"];\r\n    protected static _Samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\"];\r\n    protected static _UniformBuffers = [\"Scene\", \"Mesh\"];\r\n    protected static _Uniforms = [\r\n        \"world\",\r\n        \"view\",\r\n        \"projection\",\r\n        \"vFogInfos\",\r\n        \"vFogColor\",\r\n        \"logarithmicDepthConstant\",\r\n        \"invViewport\",\r\n        \"dataTextureSize\",\r\n        \"focal\",\r\n        \"eyePosition\",\r\n        \"kernelSize\",\r\n        \"viewDirectionFactor\",\r\n    ];\r\n    /**\r\n     * Checks whether the material is ready to be rendered for a given mesh.\r\n     * @param mesh The mesh to render\r\n     * @param subMesh The submesh to check against\r\n     * @returns true if all the dependencies are ready (Textures, Effects...)\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh): boolean {\r\n        const useInstances = true;\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n        let defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n\r\n        if (defines && this._isDirty) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines();\r\n        }\r\n\r\n        const scene = this.getScene();\r\n\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const engine = scene.getEngine();\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n        // Misc.\r\n        PrepareDefinesForMisc(\r\n            mesh,\r\n            scene,\r\n            this._useLogarithmicDepth,\r\n            this.pointsCloud,\r\n            this.fogEnabled,\r\n            false,\r\n            defines,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            this._isVertexOutputInvariant\r\n        );\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, false, false);\r\n\r\n        // SH is disabled for webGL1\r\n        if (engine.version > 1 || engine.isWebGPU) {\r\n            defines[\"SH_DEGREE\"] = gsMesh.shDegree;\r\n        }\r\n\r\n        // Compensation\r\n        const splatMaterial = gsMesh.material as GaussianSplattingMaterial;\r\n        defines[\"COMPENSATION\"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : GaussianSplattingMaterial.Compensation;\r\n\r\n        // Get correct effect\r\n        if (defines.isDirty) {\r\n            defines.markAsProcessed();\r\n            scene.resetCachedMaterial();\r\n\r\n            //Attributes\r\n            PrepareAttributesForInstances(GaussianSplattingMaterial._Attribs, defines);\r\n\r\n            PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n                uniformsNames: GaussianSplattingMaterial._Uniforms,\r\n                uniformBuffersNames: GaussianSplattingMaterial._UniformBuffers,\r\n                samplers: GaussianSplattingMaterial._Samplers,\r\n                defines: defines,\r\n            });\r\n\r\n            AddClipPlaneUniforms(GaussianSplattingMaterial._Uniforms);\r\n\r\n            const join = defines.toString();\r\n            const effect = scene.getEngine().createEffect(\r\n                \"gaussianSplatting\",\r\n                <IEffectCreationOptions>{\r\n                    attributes: GaussianSplattingMaterial._Attribs,\r\n                    uniformsNames: GaussianSplattingMaterial._Uniforms,\r\n                    uniformBuffersNames: GaussianSplattingMaterial._UniformBuffers,\r\n                    samplers: GaussianSplattingMaterial._Samplers,\r\n                    defines: join,\r\n                    onCompiled: this.onCompiled,\r\n                    onError: this.onError,\r\n                    indexParameters: {},\r\n                    shaderLanguage: this._shaderLanguage,\r\n                    extraInitializationsAsync: async () => {\r\n                        if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\r\n                        }\r\n                    },\r\n                },\r\n                engine\r\n            );\r\n            subMesh.setEffect(effect, defines, this._materialContext);\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = true;\r\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\r\n        this._isDirty = false;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind material effect for a specific Gaussian Splatting mesh\r\n     * @param mesh Gaussian splatting mesh\r\n     * @param effect Splatting material or node material\r\n     * @param scene scene that contains mesh and camera used for rendering\r\n     */\r\n    public static BindEffect(mesh: Mesh, effect: Effect, scene: Scene): void {\r\n        const engine = scene.getEngine();\r\n        const camera = scene.activeCamera;\r\n\r\n        const renderWidth = engine.getRenderWidth();\r\n        const renderHeight = engine.getRenderHeight();\r\n\r\n        const gsMesh = mesh as GaussianSplattingMesh;\r\n        const gsMaterial = gsMesh.material as GaussianSplattingMaterial;\r\n\r\n        // check if rigcamera, get number of rigs\r\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\r\n\r\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\r\n\r\n        let focal = 1000;\r\n\r\n        if (camera) {\r\n            /*\r\n            more explicit version:\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            const FovY = Math.atan(1.0 / t) * 2.0;\r\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\r\n            Using a shorter version here to not have tan(atan) and 2.0 factor\r\n            */\r\n            const t = camera.getProjectionMatrix().m[5];\r\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\r\n                focal = (renderHeight * t) / 2.0;\r\n            } else {\r\n                focal = (renderWidth * t) / 2.0;\r\n            }\r\n        }\r\n\r\n        effect.setFloat2(\"focal\", focal, focal);\r\n        effect.setVector3(\"viewDirectionFactor\", gsMesh.viewDirectionFactor);\r\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\r\n        scene.bindEyePosition(effect, \"eyePosition\", true);\r\n\r\n        if (gsMesh.covariancesATexture) {\r\n            const textureSize = gsMesh.covariancesATexture.getSize();\r\n\r\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\r\n\r\n            if (gsMesh.shTextures) {\r\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\r\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Binds the submesh to this material by preparing the effect and shader to draw\r\n     * @param world defines the world transformation matrix\r\n     * @param mesh defines the mesh containing the submesh\r\n     * @param subMesh defines the submesh to bind the material to\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <GaussianSplattingMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        // Bind data\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        if (mustRebind) {\r\n            this.bindView(effect);\r\n            this.bindViewProjection(effect);\r\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\r\n            // Clip plane\r\n            BindClipPlane(effect, this, scene);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        // Fog\r\n        BindFogParameters(scene, mesh, effect);\r\n\r\n        // Log. depth\r\n        if (this.useLogarithmicDepth) {\r\n            BindLogDepth(defines, effect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n    }\r\n\r\n    protected static _MakeGaussianSplattingShadowDepthWrapper(scene: Scene, shaderLanguage: ShaderLanguage): ShadowDepthWrapper {\r\n        const shaderMaterial = new ShaderMaterial(\r\n            \"gaussianSplattingDepth\",\r\n            scene,\r\n            {\r\n                vertex: \"gaussianSplattingDepth\",\r\n                fragment: \"gaussianSplattingDepth\",\r\n            },\r\n            {\r\n                attributes: GaussianSplattingMaterial._Attribs,\r\n                uniforms: GaussianSplattingMaterial._Uniforms,\r\n                samplers: GaussianSplattingMaterial._Samplers,\r\n                uniformBuffers: GaussianSplattingMaterial._UniformBuffers,\r\n                shaderLanguage: shaderLanguage,\r\n                defines: [\"#define GS_DISABLE_COLOR\"],\r\n            }\r\n        );\r\n\r\n        const shadowDepthWrapper = new ShadowDepthWrapper(shaderMaterial, scene, {\r\n            standalone: true,\r\n        });\r\n\r\n        shaderMaterial.onBindObservable.add((mesh: AbstractMesh) => {\r\n            const effect = shaderMaterial.getEffect()!;\r\n            const gsMaterial = mesh.material as GaussianSplattingMaterial;\r\n            const gsMesh = mesh as GaussianSplattingMesh;\r\n\r\n            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n            shaderMaterial.bindView(effect);\r\n            shaderMaterial.bindViewProjection(effect);\r\n\r\n            const shadowmapWidth = scene.getEngine().getRenderWidth();\r\n            const shadowmapHeight = scene.getEngine().getRenderHeight();\r\n            effect.setFloat2(\"invViewport\", 1 / shadowmapWidth, 1 / shadowmapHeight);\r\n\r\n            const projection = scene.getProjectionMatrix();\r\n            const t = projection.m[5];\r\n            const focal = (shadowmapWidth * t) / 2.0;\r\n\r\n            effect.setFloat2(\"focal\", focal, focal);\r\n            effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\r\n\r\n            if (gsMesh.covariancesATexture) {\r\n                const textureSize = gsMesh.covariancesATexture.getSize();\r\n                effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\r\n\r\n                effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\r\n                effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\r\n                effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\r\n            }\r\n        });\r\n\r\n        return shadowDepthWrapper;\r\n    }\r\n\r\n    /**\r\n     * Clones the material.\r\n     * @param name The cloned name.\r\n     * @returns The cloned material.\r\n     */\r\n    public override clone(name: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\r\n    }\r\n\r\n    /**\r\n     * Serializes the current material to its JSON representation.\r\n     * @returns The JSON representation.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the material\r\n     * @returns \"GaussianSplattingMaterial\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMaterial\";\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON input to create back a Gaussian Splatting material.\r\n     * @param source The JSON data to parse\r\n     * @param scene The scene to create the parsed material in\r\n     * @param rootUrl The root url of the assets the material depends upon\r\n     * @returns the instantiated GaussianSplattingMaterial.\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): GaussianSplattingMaterial {\r\n        return SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\r\n", "import { DracoDecoderModule } from \"draco3dgltf\";\r\nimport { _IsConfigurationAvailable, DracoCodec, type IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { Geometry } from \"../geometry\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { BoundingInfo } from \"../../Culling/boundingInfo\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { DecodeMesh, DecoderWorkerFunction } from \"./dracoCompressionWorker\";\r\nimport type { IAttributeData, MeshData, DecoderMessage } from \"./dracoDecoder.types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n\r\n/**\r\n * @experimental This class is an experimental version of `DracoCompression` and is subject to change.\r\n *\r\n * Draco Decoder (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco decoder module.\r\n *\r\n * By default, the configuration points to a copy of the Draco decoder files for glTF from the Babylon.js cdn https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoDecoder.DefaultConfiguration = {\r\n *          wasmUrl: \"<url to the WebAssembly library>\",\r\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The decoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoDecoder.DefaultAvailable` to determine if the decoder configuration is available for the current context.\r\n *\r\n * To decode Draco compressed data, get the default DracoDecoder object and call decodeMeshToGeometryAsync:\r\n * ```javascript\r\n *     var geometry = await DracoDecoder.Default.decodeMeshToGeometryAsync(data);\r\n * ```\r\n */\r\nexport class DracoDecoder extends DracoCodec {\r\n    /**\r\n     * Default configuration for the DracoDecoder. Defaults to the following:\r\n     * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\r\n     * - wasmUrl: `\"https://cdn.babylonjs.com/draco_wasm_wrapper_gltf.js\"`\r\n     * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.wasm\"`\r\n     * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_decoder_gltf.js\"`\r\n     */\r\n    public static DefaultConfiguration: IDracoCodecConfiguration = {\r\n        wasmUrl: `${Tools._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,\r\n        wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.wasm`,\r\n        fallbackUrl: `${Tools._DefaultCdnUrl}/draco_decoder_gltf.js`,\r\n    };\r\n\r\n    /**\r\n     * Returns true if the decoder's `DefaultConfiguration` is available.\r\n     */\r\n    public static get DefaultAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoDecoder.DefaultConfiguration);\r\n    }\r\n\r\n    protected static _Default: Nullable<DracoDecoder> = null;\r\n    /**\r\n     * Default instance for the DracoDecoder.\r\n     */\r\n    public static get Default(): DracoDecoder {\r\n        DracoDecoder._Default ??= new DracoDecoder();\r\n        return DracoDecoder._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default DracoDecoder object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoDecoder._Default) {\r\n            if (!skipDispose) {\r\n                DracoDecoder._Default.dispose();\r\n            }\r\n            DracoDecoder._Default = null;\r\n        }\r\n    }\r\n\r\n    protected override _isModuleAvailable(): boolean {\r\n        return typeof DracoDecoderModule !== \"undefined\";\r\n    }\r\n\r\n    protected override async _createModuleAsync(wasmBinary?: ArrayBuffer, jsModule?: unknown /** DracoDecoderModule */): Promise<{ module: unknown /** DecoderModule */ }> {\r\n        const module = await ((jsModule as DracoDecoderModule) || DracoDecoderModule)({ wasmBinary });\r\n        return { module };\r\n    }\r\n\r\n    protected override _getWorkerContent(): string {\r\n        return `${DecodeMesh}(${DecoderWorkerFunction})()`;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Draco decoder.\r\n     * @param configuration Optional override of the configuration for the DracoDecoder. If not provided, defaults to {@link DracoDecoder.DefaultConfiguration}.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration = DracoDecoder.DefaultConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to mesh data.\r\n     * @param data The ArrayBuffer or ArrayBufferView of the compressed Draco data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @param gltfNormalizedOverride A map of attributes from vertex buffer kinds to normalized flags to override the Draco normalization\r\n     * @returns A promise that resolves with the decoded mesh data\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public decodeMeshToMeshDataAsync(\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes?: { [kind: string]: number },\r\n        gltfNormalizedOverride?: { [kind: string]: boolean }\r\n    ): Promise<MeshData> {\r\n        const dataView = data instanceof ArrayBuffer ? new Int8Array(data) : new Int8Array(data.buffer, data.byteOffset, data.byteLength);\r\n\r\n        const applyGltfNormalizedOverride = (kind: string, normalized: boolean): boolean => {\r\n            if (gltfNormalizedOverride && gltfNormalizedOverride[kind] !== undefined) {\r\n                if (normalized !== gltfNormalizedOverride[kind]) {\r\n                    Logger.Warn(\r\n                        `Normalized flag from Draco data (${normalized}) does not match normalized flag from glTF accessor (${gltfNormalizedOverride[kind]}). Using flag from glTF accessor.`\r\n                    );\r\n                }\r\n\r\n                return gltfNormalizedOverride[kind];\r\n            } else {\r\n                return normalized;\r\n            }\r\n        };\r\n\r\n        if (this._workerPoolPromise) {\r\n            // eslint-disable-next-line github/no-then\r\n            return this._workerPoolPromise.then(async (workerPool) => {\r\n                return await new Promise<MeshData>((resolve, reject) => {\r\n                    workerPool.push((worker, onComplete) => {\r\n                        let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                        const resultAttributes: Array<IAttributeData> = [];\r\n\r\n                        const onError = (error: ErrorEvent) => {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(error);\r\n                            onComplete();\r\n                        };\r\n\r\n                        const onMessage = (event: MessageEvent<DecoderMessage>) => {\r\n                            const message = event.data;\r\n                            switch (message.id) {\r\n                                case \"indices\": {\r\n                                    resultIndices = message.data;\r\n                                    break;\r\n                                }\r\n                                case \"attribute\": {\r\n                                    resultAttributes.push({\r\n                                        kind: message.kind,\r\n                                        data: message.data,\r\n                                        size: message.size,\r\n                                        byteOffset: message.byteOffset,\r\n                                        byteStride: message.byteStride,\r\n                                        normalized: applyGltfNormalizedOverride(message.kind, message.normalized),\r\n                                    });\r\n                                    break;\r\n                                }\r\n                                case \"decodeMeshDone\": {\r\n                                    worker.removeEventListener(\"error\", onError);\r\n                                    worker.removeEventListener(\"message\", onMessage);\r\n                                    resolve({ indices: resultIndices!, attributes: resultAttributes, totalVertices: message.totalVertices });\r\n                                    onComplete();\r\n                                    break;\r\n                                }\r\n                            }\r\n                        };\r\n\r\n                        worker.addEventListener(\"error\", onError);\r\n                        worker.addEventListener(\"message\", onMessage);\r\n\r\n                        const dataViewCopy = dataView.slice();\r\n                        worker.postMessage({ id: \"decodeMesh\", dataView: dataViewCopy, attributes: attributes }, [dataViewCopy.buffer]);\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            // eslint-disable-next-line github/no-then\r\n            return this._modulePromise.then((decoder) => {\r\n                let resultIndices: Nullable<Uint16Array | Uint32Array> = null;\r\n                const resultAttributes: Array<IAttributeData> = [];\r\n\r\n                const numPoints = DecodeMesh(\r\n                    decoder.module,\r\n                    dataView,\r\n                    attributes,\r\n                    (indices) => {\r\n                        resultIndices = indices;\r\n                    },\r\n                    (kind, data, size, byteOffset, byteStride, normalized) => {\r\n                        resultAttributes.push({\r\n                            kind,\r\n                            data,\r\n                            size,\r\n                            byteOffset,\r\n                            byteStride,\r\n                            normalized,\r\n                        });\r\n                    }\r\n                );\r\n\r\n                return { indices: resultIndices!, attributes: resultAttributes, totalVertices: numPoints };\r\n            });\r\n        }\r\n\r\n        throw new Error(\"Draco decoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Decode Draco compressed mesh data to Babylon geometry.\r\n     * @param name The name to use when creating the geometry\r\n     * @param scene The scene to use when creating the geometry\r\n     * @param data The ArrayBuffer or ArrayBufferView of the Draco compressed data\r\n     * @param attributes A map of attributes from vertex buffer kinds to Draco unique ids\r\n     * @returns A promise that resolves with the decoded geometry\r\n     */\r\n    public async decodeMeshToGeometryAsync(name: string, scene: Scene, data: ArrayBuffer | ArrayBufferView, attributes?: { [kind: string]: number }): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes);\r\n        const geometry = new Geometry(name, scene);\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n\r\n    /** @internal */\r\n    public async _decodeMeshToGeometryForGltfAsync(\r\n        name: string,\r\n        scene: Scene,\r\n        data: ArrayBuffer | ArrayBufferView,\r\n        attributes: { [kind: string]: number },\r\n        gltfNormalizedOverride: { [kind: string]: boolean },\r\n        boundingInfo: Nullable<BoundingInfo>\r\n    ): Promise<Geometry> {\r\n        const meshData = await this.decodeMeshToMeshDataAsync(data, attributes, gltfNormalizedOverride);\r\n        const geometry = new Geometry(name, scene);\r\n        if (boundingInfo) {\r\n            geometry._boundingInfo = boundingInfo;\r\n            geometry.useBoundingInfoFromGeometry = true;\r\n        }\r\n        if (meshData.indices) {\r\n            geometry.setIndices(meshData.indices);\r\n        }\r\n        for (const attribute of meshData.attributes) {\r\n            geometry.setVerticesBuffer(\r\n                new VertexBuffer(\r\n                    scene.getEngine(),\r\n                    attribute.data,\r\n                    attribute.kind,\r\n                    false,\r\n                    undefined,\r\n                    attribute.byteStride,\r\n                    undefined,\r\n                    attribute.byteOffset,\r\n                    attribute.size,\r\n                    undefined,\r\n                    attribute.normalized,\r\n                    true\r\n                ),\r\n                meshData.totalVertices\r\n            );\r\n        }\r\n        return geometry;\r\n    }\r\n}\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let MeshoptDecoder: any;\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nlet NumberOfWorkers = 0;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nlet WorkerTimeout: Nullable<ReturnType<typeof setTimeout>> = null;\r\n\r\n/**\r\n * Configuration for meshoptimizer compression\r\n */\r\nexport interface IMeshoptCompressionConfiguration {\r\n    /**\r\n     * Configuration for the decoder.\r\n     */\r\n    decoder: {\r\n        /**\r\n         * The url to the meshopt decoder library.\r\n         */\r\n        url: string;\r\n    };\r\n}\r\n\r\n/**\r\n * Meshopt compression (https://github.com/zeux/meshoptimizer)\r\n *\r\n * This class wraps the meshopt library from https://github.com/zeux/meshoptimizer/tree/master/js.\r\n *\r\n * **Encoder**\r\n *\r\n * The encoder is not currently implemented.\r\n *\r\n * **Decoder**\r\n *\r\n * By default, the configuration points to a copy of the meshopt files on the Babylon.js preview CDN (e.g. https://preview.babylonjs.com/meshopt_decoder.js).\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     MeshoptCompression.Configuration = {\r\n *         decoder: {\r\n *             url: \"<url to the meshopt decoder library>\"\r\n *         }\r\n *     };\r\n * ```\r\n */\r\nexport class MeshoptCompression implements IDisposable {\r\n    private _decoderModulePromise?: Promise<any>;\r\n\r\n    /**\r\n     * The configuration. Defaults to the following:\r\n     * ```javascript\r\n     * decoder: {\r\n     *   url: \"https://cdn.babylonjs.com/meshopt_decoder.js\"\r\n     * }\r\n     * ```\r\n     */\r\n    public static Configuration: IMeshoptCompressionConfiguration = {\r\n        decoder: {\r\n            url: `${Tools._DefaultCdnUrl}/meshopt_decoder.js`,\r\n        },\r\n    };\r\n\r\n    private static _Default: Nullable<MeshoptCompression> = null;\r\n\r\n    /**\r\n     * Default instance for the meshoptimizer object.\r\n     */\r\n    public static get Default(): MeshoptCompression {\r\n        if (!MeshoptCompression._Default) {\r\n            MeshoptCompression._Default = new MeshoptCompression();\r\n        }\r\n\r\n        return MeshoptCompression._Default;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() {\r\n        const decoder = MeshoptCompression.Configuration.decoder;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        this._decoderModulePromise = Tools.LoadBabylonScriptAsync(decoder.url).then(() => {\r\n            // Wait for WebAssembly compilation before resolving promise\r\n            return MeshoptDecoder.ready;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        delete this._decoderModulePromise;\r\n    }\r\n\r\n    /**\r\n     * Decode meshopt data.\r\n     * @see https://github.com/zeux/meshoptimizer/tree/master/js#decoder\r\n     * @param source The input data.\r\n     * @param count The number of elements.\r\n     * @param stride The stride in bytes.\r\n     * @param mode The compression mode.\r\n     * @param filter The compression filter.\r\n     * @returns a Promise<Uint8Array> that resolves to the decoded data\r\n     */\r\n    public async decodeGltfBufferAsync(source: Uint8Array, count: number, stride: number, mode: \"ATTRIBUTES\" | \"TRIANGLES\" | \"INDICES\", filter?: string): Promise<Uint8Array> {\r\n        await this._decoderModulePromise!;\r\n        if (NumberOfWorkers === 0) {\r\n            MeshoptDecoder.useWorkers(1);\r\n            NumberOfWorkers = 1;\r\n        }\r\n        const result = await MeshoptDecoder.decodeGltfBufferAsync(count, stride, source, mode, filter);\r\n        // a simple debounce to avoid switching back and forth between workers and no workers while decoding\r\n        if (WorkerTimeout !== null) {\r\n            clearTimeout(WorkerTimeout);\r\n        }\r\n        WorkerTimeout = setTimeout(() => {\r\n            MeshoptDecoder.useWorkers(0);\r\n            NumberOfWorkers = 0;\r\n            WorkerTimeout = null;\r\n        }, 1000);\r\n        return result;\r\n    }\r\n}\r\n", "import type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { SubMesh } from \"../subMesh\";\r\nimport type { AbstractMesh } from \"../abstractMesh\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { Matrix, TmpVectors, Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Quaternion } from \"core/Maths/math.vector\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport type { ThinEngine } from \"core/Engines/thinEngine\";\r\nimport { ToHalfFloat } from \"core/Misc/textureTools\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler, type Coroutine } from \"core/Misc/coroutine\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\ninterface IDelayedTextureUpdate {\r\n    covA: Uint16Array;\r\n    covB: Uint16Array;\r\n    colors: Uint8Array;\r\n    centers: Float32Array;\r\n    sh?: Uint8Array[];\r\n}\r\n\r\n// @internal\r\nconst UnpackUnorm = (value: number, bits: number) => {\r\n    const t = (1 << bits) - 1;\r\n    return (value & t) / t;\r\n};\r\n\r\n// @internal\r\nconst Unpack111011 = (value: number, result: Vector3) => {\r\n    result.x = UnpackUnorm(value >>> 21, 11);\r\n    result.y = UnpackUnorm(value >>> 11, 10);\r\n    result.z = UnpackUnorm(value, 11);\r\n};\r\n\r\n// @internal\r\nconst Unpack8888 = (value: number, result: Uint8ClampedArray) => {\r\n    result[0] = UnpackUnorm(value >>> 24, 8) * 255;\r\n    result[1] = UnpackUnorm(value >>> 16, 8) * 255;\r\n    result[2] = UnpackUnorm(value >>> 8, 8) * 255;\r\n    result[3] = UnpackUnorm(value, 8) * 255;\r\n};\r\n\r\n// @internal\r\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\r\nconst UnpackRot = (value: number, result: Quaternion) => {\r\n    const norm = 1.0 / (Math.sqrt(2) * 0.5);\r\n    const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;\r\n    const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;\r\n    const c = (UnpackUnorm(value, 10) - 0.5) * norm;\r\n    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\r\n\r\n    switch (value >>> 30) {\r\n        case 0:\r\n            result.set(m, a, b, c);\r\n            break;\r\n        case 1:\r\n            result.set(a, m, b, c);\r\n            break;\r\n        case 2:\r\n            result.set(a, b, m, c);\r\n            break;\r\n        case 3:\r\n            result.set(a, b, c, m);\r\n            break;\r\n    }\r\n};\r\n\r\ninterface ICompressedPLYChunk {\r\n    min: Vector3;\r\n    max: Vector3;\r\n    minScale: Vector3;\r\n    maxScale: Vector3;\r\n    minColor: Vector3;\r\n    maxColor: Vector3;\r\n}\r\n\r\ninterface IPLYConversionBuffers {\r\n    buffer: ArrayBuffer;\r\n    sh?: [];\r\n}\r\n/**\r\n * Representation of the types\r\n */\r\nconst enum PLYType {\r\n    FLOAT,\r\n    INT,\r\n    UINT,\r\n    DOUBLE,\r\n    UCHAR,\r\n    UNDEFINED,\r\n}\r\n\r\n/**\r\n * Usage types of the PLY values\r\n */\r\nconst enum PLYValue {\r\n    MIN_X,\r\n    MIN_Y,\r\n    MIN_Z,\r\n    MAX_X,\r\n    MAX_Y,\r\n    MAX_Z,\r\n\r\n    MIN_SCALE_X,\r\n    MIN_SCALE_Y,\r\n    MIN_SCALE_Z,\r\n\r\n    MAX_SCALE_X,\r\n    MAX_SCALE_Y,\r\n    MAX_SCALE_Z,\r\n\r\n    PACKED_POSITION,\r\n    PACKED_ROTATION,\r\n    PACKED_SCALE,\r\n    PACKED_COLOR,\r\n    X,\r\n    Y,\r\n    Z,\r\n    SCALE_0,\r\n    SCALE_1,\r\n    SCALE_2,\r\n\r\n    DIFFUSE_RED,\r\n    DIFFUSE_GREEN,\r\n    DIFFUSE_BLUE,\r\n    OPACITY,\r\n\r\n    F_DC_0,\r\n    F_DC_1,\r\n    F_DC_2,\r\n    F_DC_3,\r\n\r\n    ROT_0,\r\n    ROT_1,\r\n    ROT_2,\r\n    ROT_3,\r\n\r\n    MIN_COLOR_R,\r\n    MIN_COLOR_G,\r\n    MIN_COLOR_B,\r\n\r\n    MAX_COLOR_R,\r\n    MAX_COLOR_G,\r\n    MAX_COLOR_B,\r\n\r\n    SH_0,\r\n    SH_1,\r\n    SH_2,\r\n    SH_3,\r\n    SH_4,\r\n    SH_5,\r\n    SH_6,\r\n    SH_7,\r\n    SH_8,\r\n    SH_9,\r\n    SH_10,\r\n    SH_11,\r\n    SH_12,\r\n    SH_13,\r\n    SH_14,\r\n    SH_15,\r\n    SH_16,\r\n    SH_17,\r\n    SH_18,\r\n    SH_19,\r\n    SH_20,\r\n    SH_21,\r\n    SH_22,\r\n    SH_23,\r\n    SH_24,\r\n    SH_25,\r\n    SH_26,\r\n    SH_27,\r\n    SH_28,\r\n    SH_29,\r\n    SH_30,\r\n    SH_31,\r\n    SH_32,\r\n    SH_33,\r\n    SH_34,\r\n    SH_35,\r\n    SH_36,\r\n    SH_37,\r\n    SH_38,\r\n    SH_39,\r\n    SH_40,\r\n    SH_41,\r\n    SH_42,\r\n    SH_43,\r\n    SH_44,\r\n\r\n    UNDEFINED,\r\n}\r\n\r\n/**\r\n * Property field found in PLY header\r\n */\r\nexport type PlyProperty = {\r\n    /**\r\n     * Value usage\r\n     */\r\n    value: PLYValue;\r\n    /**\r\n     * Value type\r\n     */\r\n    type: PLYType;\r\n    /**\r\n     * offset in byte from te beginning of the splat\r\n     */\r\n    offset: number;\r\n};\r\n\r\n/**\r\n * meta info on Splat file\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface PLYHeader {\r\n    /**\r\n     * number of splats\r\n     */\r\n    vertexCount: number;\r\n    /**\r\n     * number of spatial chunks for compressed ply\r\n     */\r\n    chunkCount: number;\r\n    /**\r\n     * length in bytes of the vertex info\r\n     */\r\n    rowVertexLength: number;\r\n    /**\r\n     * length in bytes of the chunk\r\n     */\r\n    rowChunkLength: number;\r\n    /**\r\n     * array listing properties per vertex\r\n     */\r\n    vertexProperties: PlyProperty[];\r\n    /**\r\n     * array listing properties per chunk\r\n     */\r\n    chunkProperties: PlyProperty[];\r\n    /**\r\n     * data view for parsing chunks and vertices\r\n     */\r\n    dataView: DataView;\r\n    /**\r\n     * buffer for the data view\r\n     */\r\n    buffer: ArrayBuffer;\r\n    /**\r\n     * degree of SH coefficients\r\n     */\r\n    shDegree: number;\r\n    /**\r\n     * number of coefficient per splat\r\n     */\r\n    shCoefficientCount: number;\r\n    /**\r\n     * buffer for SH coefficients\r\n     */\r\n    shBuffer: ArrayBuffer | null;\r\n}\r\n/**\r\n * Class used to render a gaussian splatting mesh\r\n */\r\nexport class GaussianSplattingMesh extends Mesh {\r\n    private _vertexCount = 0;\r\n    private _worker: Nullable<Worker> = null;\r\n    private _frameIdLastUpdate = -1;\r\n    private _modelViewMatrix = Matrix.Identity();\r\n    private _depthMix: BigInt64Array;\r\n    private _canPostToWorker = true;\r\n    private _readyToDisplay = false;\r\n    private _covariancesATexture: Nullable<BaseTexture> = null;\r\n    private _covariancesBTexture: Nullable<BaseTexture> = null;\r\n    private _centersTexture: Nullable<BaseTexture> = null;\r\n    private _colorsTexture: Nullable<BaseTexture> = null;\r\n    private _splatPositions: Nullable<Float32Array> = null;\r\n    private _splatIndex: Nullable<Float32Array> = null;\r\n    private _shTextures: Nullable<BaseTexture[]> = null;\r\n    private _splatsData: Nullable<ArrayBuffer> = null;\r\n    private _sh: Nullable<Uint8Array[]> = null;\r\n    private readonly _keepInRam: boolean = false;\r\n\r\n    private _delayedTextureUpdate: Nullable<IDelayedTextureUpdate> = null;\r\n    private _oldDirection = new Vector3();\r\n    private _useRGBACovariants = false;\r\n    private _material: Nullable<Material> = null;\r\n\r\n    private _tmpCovariances = [0, 0, 0, 0, 0, 0];\r\n    private _sortIsDirty = false;\r\n\r\n    private static _RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha\r\n    private static _SH_C0 = 0.28209479177387814;\r\n    // batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups\r\n    // This step is faster the PLY conversion. So batch size can be bigger\r\n    private static _SplatBatchSize = 327680;\r\n    // batch size between 2 yield calls during the PLY to splat conversion.\r\n    private static _PlyConversionBatchSize = 32768;\r\n    private _shDegree = 0;\r\n    private _viewDirectionFactor = new Vector3(1, 1, -1);\r\n\r\n    /**\r\n     * View direction factor used to compute the SH view direction in the shader.\r\n     */\r\n    public get viewDirectionFactor() {\r\n        return this._viewDirectionFactor;\r\n    }\r\n\r\n    /**\r\n     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.\r\n     */\r\n    public get shDegree() {\r\n        return this._shDegree;\r\n    }\r\n\r\n    /**\r\n     * Number of splats in the mesh\r\n     */\r\n    public get splatCount() {\r\n        return this._splatIndex?.length;\r\n    }\r\n\r\n    /**\r\n     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)\r\n     */\r\n    public get splatsData() {\r\n        return this._splatsData;\r\n    }\r\n\r\n    /**\r\n     * Set the number of batch (a batch is 16384 splats) after which a display update is performed\r\n     * A value of 0 (default) means display update will not happens before splat is ready.\r\n     */\r\n    public static ProgressiveUpdateAmount = 0;\r\n\r\n    /**\r\n     * Gets the covariancesA texture\r\n     */\r\n    public get covariancesATexture() {\r\n        return this._covariancesATexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the covariancesB texture\r\n     */\r\n    public get covariancesBTexture() {\r\n        return this._covariancesBTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the centers texture\r\n     */\r\n    public get centersTexture() {\r\n        return this._centersTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    public get colorsTexture() {\r\n        return this._colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets the SH textures\r\n     */\r\n    public get shTextures() {\r\n        return this._shTextures;\r\n    }\r\n\r\n    /**\r\n     * Gets the kernel size\r\n     * Documentation and mathematical explanations here:\r\n     * https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\r\n     * https://github.com/autonomousvision/mip-splatting/issues/18#issuecomment-1929388931\r\n     */\r\n    public get kernelSize() {\r\n        return this._material instanceof GaussianSplattingMaterial ? this._material.kernelSize : 0;\r\n    }\r\n\r\n    /**\r\n     * Get the compensation state\r\n     */\r\n    public get compensation() {\r\n        return this._material instanceof GaussianSplattingMaterial ? this._material.compensation : false;\r\n    }\r\n\r\n    /**\r\n     * set rendering material\r\n     */\r\n    public override set material(value: Material) {\r\n        this._material = value;\r\n        this._material.backFaceCulling = true;\r\n        this._material.cullBackFaces = false;\r\n        value.resetDrawCache();\r\n    }\r\n\r\n    /**\r\n     * get rendering material\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new gaussian splatting mesh\r\n     * @param name defines the name of the mesh\r\n     * @param url defines the url to load from (optional)\r\n     * @param scene defines the hosting scene (optional)\r\n     * @param keepInRam keep datas in ram for editing purpose\r\n     */\r\n    constructor(name: string, url: Nullable<string> = null, scene: Nullable<Scene> = null, keepInRam: boolean = false) {\r\n        super(name, scene);\r\n\r\n        const vertexData = new VertexData();\r\n\r\n        vertexData.positions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\r\n        vertexData.indices = [0, 1, 2, 0, 2, 3];\r\n        vertexData.applyToMesh(this);\r\n\r\n        this.subMeshes = [];\r\n        new SubMesh(0, 0, 4, 0, 6, this);\r\n\r\n        this.setEnabled(false);\r\n        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1\r\n        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;\r\n\r\n        this._keepInRam = keepInRam;\r\n        if (url) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            this.loadFileAsync(url);\r\n        }\r\n        this._material = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\r\n    }\r\n\r\n    /**\r\n     * Returns the class name\r\n     * @returns \"GaussianSplattingMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingMesh\";\r\n    }\r\n\r\n    /**\r\n     * Returns the total number of vertices (splats) within the mesh\r\n     * @returns the total number of vertices\r\n     */\r\n    public override getTotalVertices(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Is this node ready to be used/rendered\r\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\r\n     * @returns true when ready\r\n     */\r\n    public override isReady(completeCheck = false): boolean {\r\n        if (!super.isReady(completeCheck, true)) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._readyToDisplay) {\r\n            // mesh is ready when worker has done at least 1 sorting\r\n            this._postToWorker(true);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _postToWorker(forced = false): void {\r\n        const frameId = this.getScene().getFrameId();\r\n        if ((forced || frameId !== this._frameIdLastUpdate) && this._worker && this._scene.activeCamera && this._canPostToWorker) {\r\n            const cameraMatrix = this._scene.activeCamera.getViewMatrix();\r\n            this.getWorldMatrix().multiplyToRef(cameraMatrix, this._modelViewMatrix);\r\n            cameraMatrix.invertToRef(TmpVectors.Matrix[0]);\r\n            this.getWorldMatrix().multiplyToRef(TmpVectors.Matrix[0], TmpVectors.Matrix[1]);\r\n            Vector3.TransformNormalToRef(Vector3.Forward(this._scene.useRightHandedSystem), TmpVectors.Matrix[1], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[2].normalize();\r\n\r\n            const dot = Vector3.Dot(TmpVectors.Vector3[2], this._oldDirection);\r\n            if (forced || Math.abs(dot - 1) >= 0.01) {\r\n                this._oldDirection.copyFrom(TmpVectors.Vector3[2]);\r\n                this._frameIdLastUpdate = frameId;\r\n                this._canPostToWorker = false;\r\n                this._worker.postMessage({ view: this._modelViewMatrix.m, depthMix: this._depthMix, useRightHandedSystem: this._scene.useRightHandedSystem }, [\r\n                    this._depthMix.buffer,\r\n                ]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\r\n     * @param subMesh defines the subMesh to render\r\n     * @param enableAlphaMode defines if alpha mode can be changed\r\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\r\n     * @returns the current mesh\r\n     */\r\n    public override render(subMesh: SubMesh, enableAlphaMode: boolean, effectiveMeshReplacement?: AbstractMesh): Mesh {\r\n        this._postToWorker();\r\n        return super.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\r\n    }\r\n\r\n    private static _TypeNameToEnum(name: string): PLYType {\r\n        switch (name) {\r\n            case \"float\":\r\n                return PLYType.FLOAT;\r\n            case \"int\":\r\n                return PLYType.INT;\r\n                break;\r\n            case \"uint\":\r\n                return PLYType.UINT;\r\n            case \"double\":\r\n                return PLYType.DOUBLE;\r\n            case \"uchar\":\r\n                return PLYType.UCHAR;\r\n        }\r\n        return PLYType.UNDEFINED;\r\n    }\r\n\r\n    private static _ValueNameToEnum(name: string): PLYValue {\r\n        switch (name) {\r\n            case \"min_x\":\r\n                return PLYValue.MIN_X;\r\n            case \"min_y\":\r\n                return PLYValue.MIN_Y;\r\n            case \"min_z\":\r\n                return PLYValue.MIN_Z;\r\n            case \"max_x\":\r\n                return PLYValue.MAX_X;\r\n            case \"max_y\":\r\n                return PLYValue.MAX_Y;\r\n            case \"max_z\":\r\n                return PLYValue.MAX_Z;\r\n            case \"min_scale_x\":\r\n                return PLYValue.MIN_SCALE_X;\r\n            case \"min_scale_y\":\r\n                return PLYValue.MIN_SCALE_Y;\r\n            case \"min_scale_z\":\r\n                return PLYValue.MIN_SCALE_Z;\r\n            case \"max_scale_x\":\r\n                return PLYValue.MAX_SCALE_X;\r\n            case \"max_scale_y\":\r\n                return PLYValue.MAX_SCALE_Y;\r\n            case \"max_scale_z\":\r\n                return PLYValue.MAX_SCALE_Z;\r\n            case \"packed_position\":\r\n                return PLYValue.PACKED_POSITION;\r\n            case \"packed_rotation\":\r\n                return PLYValue.PACKED_ROTATION;\r\n            case \"packed_scale\":\r\n                return PLYValue.PACKED_SCALE;\r\n            case \"packed_color\":\r\n                return PLYValue.PACKED_COLOR;\r\n            case \"x\":\r\n                return PLYValue.X;\r\n            case \"y\":\r\n                return PLYValue.Y;\r\n            case \"z\":\r\n                return PLYValue.Z;\r\n            case \"scale_0\":\r\n                return PLYValue.SCALE_0;\r\n            case \"scale_1\":\r\n                return PLYValue.SCALE_1;\r\n            case \"scale_2\":\r\n                return PLYValue.SCALE_2;\r\n            case \"diffuse_red\":\r\n            case \"red\":\r\n                return PLYValue.DIFFUSE_RED;\r\n            case \"diffuse_green\":\r\n            case \"green\":\r\n                return PLYValue.DIFFUSE_GREEN;\r\n            case \"diffuse_blue\":\r\n            case \"blue\":\r\n                return PLYValue.DIFFUSE_BLUE;\r\n            case \"f_dc_0\":\r\n                return PLYValue.F_DC_0;\r\n            case \"f_dc_1\":\r\n                return PLYValue.F_DC_1;\r\n            case \"f_dc_2\":\r\n                return PLYValue.F_DC_2;\r\n            case \"f_dc_3\":\r\n                return PLYValue.F_DC_3;\r\n            case \"opacity\":\r\n                return PLYValue.OPACITY;\r\n            case \"rot_0\":\r\n                return PLYValue.ROT_0;\r\n            case \"rot_1\":\r\n                return PLYValue.ROT_1;\r\n            case \"rot_2\":\r\n                return PLYValue.ROT_2;\r\n            case \"rot_3\":\r\n                return PLYValue.ROT_3;\r\n            case \"min_r\":\r\n                return PLYValue.MIN_COLOR_R;\r\n            case \"min_g\":\r\n                return PLYValue.MIN_COLOR_G;\r\n            case \"min_b\":\r\n                return PLYValue.MIN_COLOR_B;\r\n            case \"max_r\":\r\n                return PLYValue.MAX_COLOR_R;\r\n            case \"max_g\":\r\n                return PLYValue.MAX_COLOR_G;\r\n            case \"max_b\":\r\n                return PLYValue.MAX_COLOR_B;\r\n            case \"f_rest_0\":\r\n                return PLYValue.SH_0;\r\n            case \"f_rest_1\":\r\n                return PLYValue.SH_1;\r\n            case \"f_rest_2\":\r\n                return PLYValue.SH_2;\r\n            case \"f_rest_3\":\r\n                return PLYValue.SH_3;\r\n            case \"f_rest_4\":\r\n                return PLYValue.SH_4;\r\n            case \"f_rest_5\":\r\n                return PLYValue.SH_5;\r\n            case \"f_rest_6\":\r\n                return PLYValue.SH_6;\r\n            case \"f_rest_7\":\r\n                return PLYValue.SH_7;\r\n            case \"f_rest_8\":\r\n                return PLYValue.SH_8;\r\n            case \"f_rest_9\":\r\n                return PLYValue.SH_9;\r\n            case \"f_rest_10\":\r\n                return PLYValue.SH_10;\r\n            case \"f_rest_11\":\r\n                return PLYValue.SH_11;\r\n            case \"f_rest_12\":\r\n                return PLYValue.SH_12;\r\n            case \"f_rest_13\":\r\n                return PLYValue.SH_13;\r\n            case \"f_rest_14\":\r\n                return PLYValue.SH_14;\r\n            case \"f_rest_15\":\r\n                return PLYValue.SH_15;\r\n            case \"f_rest_16\":\r\n                return PLYValue.SH_16;\r\n            case \"f_rest_17\":\r\n                return PLYValue.SH_17;\r\n            case \"f_rest_18\":\r\n                return PLYValue.SH_18;\r\n            case \"f_rest_19\":\r\n                return PLYValue.SH_19;\r\n            case \"f_rest_20\":\r\n                return PLYValue.SH_20;\r\n            case \"f_rest_21\":\r\n                return PLYValue.SH_21;\r\n            case \"f_rest_22\":\r\n                return PLYValue.SH_22;\r\n            case \"f_rest_23\":\r\n                return PLYValue.SH_23;\r\n            case \"f_rest_24\":\r\n                return PLYValue.SH_24;\r\n            case \"f_rest_25\":\r\n                return PLYValue.SH_25;\r\n            case \"f_rest_26\":\r\n                return PLYValue.SH_26;\r\n            case \"f_rest_27\":\r\n                return PLYValue.SH_27;\r\n            case \"f_rest_28\":\r\n                return PLYValue.SH_28;\r\n            case \"f_rest_29\":\r\n                return PLYValue.SH_29;\r\n            case \"f_rest_30\":\r\n                return PLYValue.SH_30;\r\n            case \"f_rest_31\":\r\n                return PLYValue.SH_31;\r\n            case \"f_rest_32\":\r\n                return PLYValue.SH_32;\r\n            case \"f_rest_33\":\r\n                return PLYValue.SH_33;\r\n            case \"f_rest_34\":\r\n                return PLYValue.SH_34;\r\n            case \"f_rest_35\":\r\n                return PLYValue.SH_35;\r\n            case \"f_rest_36\":\r\n                return PLYValue.SH_36;\r\n            case \"f_rest_37\":\r\n                return PLYValue.SH_37;\r\n            case \"f_rest_38\":\r\n                return PLYValue.SH_38;\r\n            case \"f_rest_39\":\r\n                return PLYValue.SH_39;\r\n            case \"f_rest_40\":\r\n                return PLYValue.SH_40;\r\n            case \"f_rest_41\":\r\n                return PLYValue.SH_41;\r\n            case \"f_rest_42\":\r\n                return PLYValue.SH_42;\r\n            case \"f_rest_43\":\r\n                return PLYValue.SH_43;\r\n            case \"f_rest_44\":\r\n                return PLYValue.SH_44;\r\n        }\r\n\r\n        return PLYValue.UNDEFINED;\r\n    }\r\n    /**\r\n     * Parse a PLY file header and returns metas infos on splats and chunks\r\n     * @param data the loaded buffer\r\n     * @returns a PLYHeader\r\n     */\r\n    static ParseHeader(data: ArrayBuffer): PLYHeader | null {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return null;\r\n        }\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        const enum ElementMode {\r\n            Vertex = 0,\r\n            Chunk = 1,\r\n            SH = 2,\r\n        }\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        let shDegree = 0;\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, typeName, name] = prop.split(\" \");\r\n\r\n                const value = GaussianSplattingMesh._ValueNameToEnum(name);\r\n                if (value != PLYValue.UNDEFINED) {\r\n                    // SH degree 1,2 or 3 for 9, 24 or 45 values\r\n                    if (value >= PLYValue.SH_44) {\r\n                        shDegree = 3;\r\n                    } else if (value >= PLYValue.SH_24) {\r\n                        shDegree = 2;\r\n                    } else if (value >= PLYValue.SH_8) {\r\n                        shDegree = 1;\r\n                    }\r\n                }\r\n                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ value, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[typeName];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[typeName];\r\n                } else if (chunkMode == ElementMode.SH) {\r\n                    // SH doesn't count for vertex row size but its properties are used to retrieve SH\r\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\r\n                }\r\n\r\n                if (!offsets[typeName]) {\r\n                    Logger.Warn(`Unsupported property type: ${typeName}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                } else if (type == \"sh\") {\r\n                    chunkMode = ElementMode.SH;\r\n                }\r\n            }\r\n        }\r\n\r\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);\r\n\r\n        let shBuffer = null;\r\n        let shCoefficientCount = 0;\r\n        if (shDegree) {\r\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;\r\n            shCoefficientCount = shVectorCount * 3;\r\n            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);\r\n        }\r\n\r\n        return {\r\n            vertexCount: vertexCount,\r\n            chunkCount: chunkCount,\r\n            rowVertexLength: rowVertexOffset,\r\n            rowChunkLength: rowChunkOffset,\r\n            vertexProperties: vertexProperties,\r\n            chunkProperties: chunkProperties,\r\n            dataView: dataView,\r\n            buffer: buffer,\r\n            shDegree: shDegree,\r\n            shCoefficientCount: shCoefficientCount,\r\n            shBuffer: shBuffer,\r\n        };\r\n    }\r\n    private static _GetCompressedChunks(header: PLYHeader, offset: { value: number }): Array<ICompressedPLYChunk> | null {\r\n        if (!header.chunkCount) {\r\n            return null;\r\n        }\r\n        const dataView = header.dataView;\r\n        const compressedChunks = new Array<ICompressedPLYChunk>(header.chunkCount);\r\n        for (let i = 0; i < header.chunkCount; i++) {\r\n            const currentChunk = {\r\n                min: new Vector3(),\r\n                max: new Vector3(),\r\n                minScale: new Vector3(),\r\n                maxScale: new Vector3(),\r\n                minColor: new Vector3(0, 0, 0),\r\n                maxColor: new Vector3(1, 1, 1),\r\n            };\r\n            compressedChunks[i] = currentChunk;\r\n            for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {\r\n                const property = header.chunkProperties[propertyIndex];\r\n                let value;\r\n                switch (property.type) {\r\n                    case PLYType.FLOAT:\r\n                        value = dataView.getFloat32(property.offset + offset.value, true);\r\n                        break;\r\n                    default:\r\n                        continue;\r\n                }\r\n\r\n                switch (property.value) {\r\n                    case PLYValue.MIN_X:\r\n                        currentChunk.min.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_Y:\r\n                        currentChunk.min.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_Z:\r\n                        currentChunk.min.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_X:\r\n                        currentChunk.max.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_Y:\r\n                        currentChunk.max.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_Z:\r\n                        currentChunk.max.z = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_X:\r\n                        currentChunk.minScale.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_Y:\r\n                        currentChunk.minScale.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_SCALE_Z:\r\n                        currentChunk.minScale.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_X:\r\n                        currentChunk.maxScale.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_Y:\r\n                        currentChunk.maxScale.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_SCALE_Z:\r\n                        currentChunk.maxScale.z = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_R:\r\n                        currentChunk.minColor.x = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_G:\r\n                        currentChunk.minColor.y = value;\r\n                        break;\r\n                    case PLYValue.MIN_COLOR_B:\r\n                        currentChunk.minColor.z = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_R:\r\n                        currentChunk.maxColor.x = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_G:\r\n                        currentChunk.maxColor.y = value;\r\n                        break;\r\n                    case PLYValue.MAX_COLOR_B:\r\n                        currentChunk.maxColor.z = value;\r\n                        break;\r\n                }\r\n            }\r\n            offset.value += header.rowChunkLength;\r\n        }\r\n        return compressedChunks;\r\n    }\r\n\r\n    private static _GetSplat(header: PLYHeader, index: number, compressedChunks: Array<ICompressedPLYChunk> | null, offset: { value: number }): void {\r\n        const q = TmpVectors.Quaternion[0];\r\n        const temp3 = TmpVectors.Vector3[0];\r\n\r\n        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;\r\n        const buffer = header.buffer;\r\n        const dataView = header.dataView;\r\n        const position = new Float32Array(buffer, index * rowOutputLength, 3);\r\n        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);\r\n        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);\r\n        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);\r\n        let sh = null;\r\n        if (header.shBuffer) {\r\n            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);\r\n        }\r\n        const chunkIndex = index >> 8;\r\n        let r0: number = 255;\r\n        let r1: number = 0;\r\n        let r2: number = 0;\r\n        let r3: number = 0;\r\n\r\n        const plySH = [];\r\n\r\n        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {\r\n            const property = header.vertexProperties[propertyIndex];\r\n            let value;\r\n            switch (property.type) {\r\n                case PLYType.FLOAT:\r\n                    value = dataView.getFloat32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.INT:\r\n                    value = dataView.getInt32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.UINT:\r\n                    value = dataView.getUint32(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.DOUBLE:\r\n                    value = dataView.getFloat64(offset.value + property.offset, true);\r\n                    break;\r\n                case PLYType.UCHAR:\r\n                    value = dataView.getUint8(offset.value + property.offset);\r\n                    break;\r\n                default:\r\n                    continue;\r\n            }\r\n\r\n            switch (property.value) {\r\n                case PLYValue.PACKED_POSITION:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        Unpack111011(value, temp3);\r\n                        position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);\r\n                        position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);\r\n                        position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_ROTATION:\r\n                    {\r\n                        UnpackRot(value, q);\r\n\r\n                        r0 = q.x;\r\n                        r1 = q.y;\r\n                        r2 = q.z;\r\n                        r3 = q.w;\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_SCALE:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        Unpack111011(value, temp3);\r\n                        scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));\r\n                        scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));\r\n                        scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));\r\n                    }\r\n                    break;\r\n                case PLYValue.PACKED_COLOR:\r\n                    {\r\n                        const compressedChunk = compressedChunks![chunkIndex];\r\n                        Unpack8888(value, rgba);\r\n                        rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;\r\n                        rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;\r\n                        rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;\r\n                    }\r\n                    break;\r\n                case PLYValue.X:\r\n                    position[0] = value;\r\n                    break;\r\n                case PLYValue.Y:\r\n                    position[1] = value;\r\n                    break;\r\n                case PLYValue.Z:\r\n                    position[2] = value;\r\n                    break;\r\n                case PLYValue.SCALE_0:\r\n                    scale[0] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.SCALE_1:\r\n                    scale[1] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.SCALE_2:\r\n                    scale[2] = Math.exp(value);\r\n                    break;\r\n                case PLYValue.DIFFUSE_RED:\r\n                    rgba[0] = value;\r\n                    break;\r\n                case PLYValue.DIFFUSE_GREEN:\r\n                    rgba[1] = value;\r\n                    break;\r\n                case PLYValue.DIFFUSE_BLUE:\r\n                    rgba[2] = value;\r\n                    break;\r\n                case PLYValue.F_DC_0:\r\n                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_1:\r\n                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_2:\r\n                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.F_DC_3:\r\n                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\r\n                    break;\r\n                case PLYValue.OPACITY:\r\n                    rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\r\n                    break;\r\n                case PLYValue.ROT_0:\r\n                    r0 = value;\r\n                    break;\r\n                case PLYValue.ROT_1:\r\n                    r1 = value;\r\n                    break;\r\n                case PLYValue.ROT_2:\r\n                    r2 = value;\r\n                    break;\r\n                case PLYValue.ROT_3:\r\n                    r3 = value;\r\n                    break;\r\n            }\r\n            if (sh && property.value >= PLYValue.SH_0 && property.value <= PLYValue.SH_44) {\r\n                const shIndex = property.value - PLYValue.SH_0;\r\n                if (property.type == PLYType.UCHAR && header.chunkCount) {\r\n                    // compressed ply. dataView points to beginning of vertex\r\n                    // could be improved with a direct copy instead of a per SH index computation + copy\r\n                    const compressedValue = dataView.getUint8(\r\n                        header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex\r\n                    );\r\n                    // compressed .ply SH import : https://github.com/playcanvas/engine/blob/fda3f0368b45d7381f0b5a1722bd2056128eaebe/src/scene/gsplat/gsplat-compressed-data.js#L88C81-L88C98\r\n                    plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;\r\n                } else {\r\n                    const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);\r\n                    plySH[shIndex] = clampedValue;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (sh) {\r\n            const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;\r\n            for (let j = 0; j < shDim; j++) {\r\n                sh[j * 3 + 0] = plySH[j];\r\n                sh[j * 3 + 1] = plySH[j + shDim];\r\n                sh[j * 3 + 2] = plySH[j + shDim * 2];\r\n            }\r\n        }\r\n\r\n        q.set(r1, r2, r3, r0);\r\n        q.normalize();\r\n        rot[0] = q.w * 127.5 + 127.5;\r\n        rot[1] = q.x * 127.5 + 127.5;\r\n        rot[2] = q.y * 127.5 + 127.5;\r\n        rot[3] = q.z * 127.5 + 127.5;\r\n        offset.value += header.rowVertexLength;\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data with SH coefficients splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @param useCoroutine use coroutine and yield\r\n     * @returns the loaded splat buffer and optional array of sh coefficients\r\n     */\r\n    public static *ConvertPLYWithSHToSplat(data: ArrayBuffer, useCoroutine = false) {\r\n        const header = GaussianSplattingMesh.ParseHeader(data);\r\n        if (!header) {\r\n            return { buffer: data };\r\n        }\r\n\r\n        const offset = { value: 0 };\r\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\r\n\r\n        for (let i = 0; i < header.vertexCount; i++) {\r\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\r\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        let sh = null;\r\n        // make SH texture buffers\r\n        if (header.shDegree && header.shBuffer) {\r\n            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n            let shIndexRead = 0;\r\n            const ubuf = new Uint8Array(header.shBuffer);\r\n\r\n            // sh is an array of uint8array that will be used to create sh textures\r\n            sh = [];\r\n\r\n            const splatCount = header.vertexCount;\r\n            const engine = EngineStore.LastCreatedEngine;\r\n            if (engine) {\r\n                const width = engine.getCaps().maxTextureSize;\r\n                const height = Math.ceil(splatCount / width);\r\n                // create array for the number of textures needed.\r\n                for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n                    sh.push(texture);\r\n                }\r\n\r\n                for (let i = 0; i < splatCount; i++) {\r\n                    for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {\r\n                        const shValue = ubuf[shIndexRead++];\r\n\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { buffer: header.buffer, sh: sh };\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @param useCoroutine use coroutine and yield\r\n     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.\r\n     */\r\n    public static *ConvertPLYToSplat(data: ArrayBuffer, useCoroutine = false) {\r\n        const header = GaussianSplattingMesh.ParseHeader(data);\r\n        if (!header) {\r\n            return data;\r\n        }\r\n\r\n        const offset = { value: 0 };\r\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\r\n\r\n        for (let i = 0; i < header.vertexCount; i++) {\r\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\r\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\r\n                yield;\r\n            }\r\n        }\r\n\r\n        return header.buffer;\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    public static async ConvertPLYToSplatAsync(data: ArrayBuffer) {\r\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());\r\n    }\r\n\r\n    /**\r\n     * Converts a .ply with SH data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer with SH\r\n     */\r\n    public static async ConvertPLYWithSHToSplatAsync(data: ArrayBuffer) {\r\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());\r\n    }\r\n    /**\r\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\r\n     * @param data arraybuffer containing splat file\r\n     * @returns a promise that resolves when the operation is complete\r\n     */\r\n\r\n    public async loadDataAsync(data: ArrayBuffer): Promise<void> {\r\n        return await this.updateDataAsync(data);\r\n    }\r\n\r\n    /**\r\n     * Loads a .splat Gaussian or .ply Splatting file asynchronously\r\n     * @param url path to the splat file to load\r\n     * @returns a promise that resolves when the operation is complete\r\n     * @deprecated Please use SceneLoader.ImportMeshAsync instead\r\n     */\r\n    public async loadFileAsync(url: string): Promise<void> {\r\n        const plyBuffer = await Tools.LoadFileAsync(url, true);\r\n        const splatsData: IPLYConversionBuffers = await (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(plyBuffer) as any);\r\n        await this.updateDataAsync(splatsData.buffer, splatsData.sh);\r\n    }\r\n\r\n    /**\r\n     * Releases resources associated with this mesh.\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean): void {\r\n        this._covariancesATexture?.dispose();\r\n        this._covariancesBTexture?.dispose();\r\n        this._centersTexture?.dispose();\r\n        this._colorsTexture?.dispose();\r\n        if (this._shTextures) {\r\n            for (const shTexture of this._shTextures) {\r\n                shTexture.dispose();\r\n            }\r\n        }\r\n\r\n        this._covariancesATexture = null;\r\n        this._covariancesBTexture = null;\r\n        this._centersTexture = null;\r\n        this._colorsTexture = null;\r\n        this._shTextures = null;\r\n\r\n        this._worker?.terminate();\r\n        this._worker = null;\r\n\r\n        super.dispose(doNotRecurse, true);\r\n    }\r\n\r\n    private _copyTextures(source: GaussianSplattingMesh): void {\r\n        this._covariancesATexture = source.covariancesATexture?.clone()!;\r\n        this._covariancesBTexture = source.covariancesBTexture?.clone()!;\r\n        this._centersTexture = source.centersTexture?.clone()!;\r\n        this._colorsTexture = source.colorsTexture?.clone()!;\r\n        if (source._shTextures) {\r\n            this._shTextures = [];\r\n            for (const shTexture of this._shTextures) {\r\n                this._shTextures?.push(shTexture.clone()!);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a new Mesh object generated from the current mesh properties.\r\n     * @param name is a string, the name given to the new mesh\r\n     * @returns a new Gaussian Splatting Mesh\r\n     */\r\n    public override clone(name: string = \"\"): GaussianSplattingMesh {\r\n        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());\r\n        newGS._copySource(this);\r\n        newGS.makeGeometryUnique();\r\n        newGS._vertexCount = this._vertexCount;\r\n        newGS._copyTextures(this);\r\n        newGS._modelViewMatrix = Matrix.Identity();\r\n        newGS._splatPositions = this._splatPositions;\r\n        newGS._readyToDisplay = false;\r\n        newGS._instanciateWorker();\r\n\r\n        const binfo = this.getBoundingInfo();\r\n        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());\r\n\r\n        newGS.forcedInstanceCount = newGS._vertexCount;\r\n        newGS.setEnabled(true);\r\n        return newGS;\r\n    }\r\n\r\n    private static _CreateWorker = function (self: Worker) {\r\n        let vertexCount = 0;\r\n        let positions: Float32Array;\r\n        let depthMix: BigInt64Array;\r\n        let indices: Uint32Array;\r\n        let floatMix: Float32Array;\r\n\r\n        self.onmessage = (e: any) => {\r\n            // updated on init\r\n            if (e.data.positions) {\r\n                positions = e.data.positions;\r\n                vertexCount = e.data.vertexCount;\r\n            }\r\n            // udpate on view changed\r\n            else {\r\n                const viewProj = e.data.view;\r\n                if (!positions || !viewProj) {\r\n                    // Sanity check, it shouldn't happen!\r\n                    throw new Error(\"positions or view is not defined!\");\r\n                }\r\n\r\n                depthMix = e.data.depthMix;\r\n                indices = new Uint32Array(depthMix.buffer);\r\n                floatMix = new Float32Array(depthMix.buffer);\r\n\r\n                // Sort\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    indices[2 * j] = j;\r\n                }\r\n\r\n                let depthFactor = -1;\r\n                if (e.data.useRightHandedSystem) {\r\n                    depthFactor = 1;\r\n                }\r\n\r\n                for (let j = 0; j < vertexCount; j++) {\r\n                    floatMix[2 * j + 1] = 10000 + (viewProj[2] * positions[4 * j + 0] + viewProj[6] * positions[4 * j + 1] + viewProj[10] * positions[4 * j + 2]) * depthFactor;\r\n                }\r\n\r\n                depthMix.sort();\r\n\r\n                self.postMessage({ depthMix }, [depthMix.buffer]);\r\n            }\r\n        };\r\n    };\r\n\r\n    private _makeSplat(\r\n        index: number,\r\n        fBuffer: Float32Array,\r\n        uBuffer: Uint8Array,\r\n        covA: Uint16Array,\r\n        covB: Uint16Array,\r\n        colorArray: Uint8Array,\r\n        minimum: Vector3,\r\n        maximum: Vector3\r\n    ): void {\r\n        const matrixRotation = TmpVectors.Matrix[0];\r\n        const matrixScale = TmpVectors.Matrix[1];\r\n        const quaternion = TmpVectors.Quaternion[0];\r\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\r\n\r\n        const x = fBuffer[8 * index + 0];\r\n        const y = -fBuffer[8 * index + 1];\r\n        const z = fBuffer[8 * index + 2];\r\n\r\n        this._splatPositions![4 * index + 0] = x;\r\n        this._splatPositions![4 * index + 1] = y;\r\n        this._splatPositions![4 * index + 2] = z;\r\n\r\n        minimum.minimizeInPlaceFromFloats(x, y, z);\r\n        maximum.maximizeInPlaceFromFloats(x, y, z);\r\n\r\n        quaternion.set(\r\n            (uBuffer[32 * index + 28 + 1] - 127.5) / 127.5,\r\n            (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5,\r\n            (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5,\r\n            -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5\r\n        );\r\n        quaternion.normalize();\r\n        quaternion.toRotationMatrix(matrixRotation);\r\n\r\n        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);\r\n\r\n        const m = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\r\n\r\n        const covariances = this._tmpCovariances;\r\n        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\r\n        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];\r\n        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];\r\n        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\r\n        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];\r\n        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\r\n\r\n        // normalize covA, covB\r\n        let factor = -10000;\r\n        for (let covIndex = 0; covIndex < 6; covIndex++) {\r\n            factor = Math.max(factor, Math.abs(covariances[covIndex]));\r\n        }\r\n\r\n        this._splatPositions![4 * index + 3] = factor;\r\n        const transform = factor;\r\n\r\n        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);\r\n        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);\r\n        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);\r\n        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);\r\n        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);\r\n        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);\r\n\r\n        // colors\r\n        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];\r\n        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];\r\n        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];\r\n        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];\r\n    }\r\n\r\n    private _updateTextures(covA: Uint16Array, covB: Uint16Array, colorArray: Uint8Array, sh?: Uint8Array[]): void {\r\n        const textureSize = this._getTextureSize(this._vertexCount);\r\n        // Update the textures\r\n        const createTextureFromData = (data: Float32Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\r\n        };\r\n\r\n        const createTextureFromDataU8 = (data: Uint8Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\r\n        };\r\n\r\n        const createTextureFromDataU32 = (data: Uint32Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_INTEGER);\r\n        };\r\n\r\n        const createTextureFromDataF16 = (data: Uint16Array, width: number, height: number, format: number) => {\r\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_HALF_FLOAT);\r\n        };\r\n\r\n        if (this._covariancesATexture) {\r\n            this._delayedTextureUpdate = { covA: covA, covB: covB, colors: colorArray, centers: this._splatPositions!, sh: sh };\r\n            const positions = Float32Array.from(this._splatPositions!);\r\n            const vertexCount = this._vertexCount;\r\n            this._worker!.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n\r\n            this._postToWorker(true);\r\n        } else {\r\n            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            this._covariancesBTexture = createTextureFromDataF16(\r\n                covB,\r\n                textureSize.x,\r\n                textureSize.y,\r\n                this._useRGBACovariants ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_RG\r\n            );\r\n            this._centersTexture = createTextureFromData(this._splatPositions!, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\r\n            if (sh) {\r\n                this._shTextures = [];\r\n                for (const shData of sh) {\r\n                    const buffer = new Uint32Array(shData.buffer);\r\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\r\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n                    this._shTextures!.push(shTexture);\r\n                }\r\n            }\r\n            this._instanciateWorker();\r\n        }\r\n    }\r\n\r\n    private *_updateData(data: ArrayBuffer, isAsync: boolean, sh?: Uint8Array[]): Coroutine<void> {\r\n        // if a covariance texture is present, then it's not a creation but an update\r\n        if (!this._covariancesATexture) {\r\n            this._readyToDisplay = false;\r\n        }\r\n\r\n        // Parse the data\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(uBuffer.buffer);\r\n\r\n        if (this._keepInRam) {\r\n            this._splatsData = data;\r\n            if (sh) {\r\n                this._sh = sh;\r\n            }\r\n        }\r\n\r\n        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;\r\n        if (vertexCount != this._vertexCount) {\r\n            this._updateSplatIndexBuffer(vertexCount);\r\n        }\r\n        this._vertexCount = vertexCount;\r\n        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)\r\n        this._shDegree = sh ? sh.length : 0;\r\n\r\n        const textureSize = this._getTextureSize(vertexCount);\r\n        const textureLength = textureSize.x * textureSize.y;\r\n        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;\r\n        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;\r\n\r\n        this._splatPositions = new Float32Array(4 * textureLength);\r\n        const covA = new Uint16Array(textureLength * 4);\r\n        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);\r\n        const colorArray = new Uint8Array(textureLength * 4);\r\n\r\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {\r\n            // create textures with not filled-yet array, then update directly portions of it\r\n            this._updateTextures(covA, covB, colorArray, sh);\r\n            this.setEnabled(true);\r\n\r\n            const partCount = Math.ceil(textureSize.y / lineCountUpdate);\r\n            for (let partIndex = 0; partIndex < partCount; partIndex++) {\r\n                const updateLine = partIndex * lineCountUpdate;\r\n                const splatIndexBase = updateLine * textureSize.x;\r\n                for (let i = 0; i < textureLengthPerUpdate; i++) {\r\n                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\r\n                }\r\n                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));\r\n                // Update the binfo\r\n                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\r\n                if (isAsync) {\r\n                    yield;\r\n                }\r\n            }\r\n\r\n            // sort will be dirty here as just finished filled positions will not be sorted\r\n            const positions = Float32Array.from(this._splatPositions);\r\n            const vertexCount = this._vertexCount;\r\n            this._worker!.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n            this._sortIsDirty = true;\r\n        } else {\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum);\r\n                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {\r\n                    yield;\r\n                }\r\n            }\r\n            // textures\r\n            this._updateTextures(covA, covB, colorArray, sh);\r\n            // Update the binfo\r\n            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\r\n            this.setEnabled(true);\r\n        }\r\n        this._postToWorker(true);\r\n    }\r\n\r\n    /**\r\n     * Update asynchronously the buffer\r\n     * @param data array buffer containing center, color, orientation and scale of splats\r\n     * @param sh optional array of uint8 array for SH data\r\n     * @returns a promise\r\n     */\r\n    public async updateDataAsync(data: ArrayBuffer, sh?: Uint8Array[]): Promise<void> {\r\n        return await runCoroutineAsync(this._updateData(data, true, sh), createYieldingScheduler());\r\n    }\r\n\r\n    /**\r\n     * @experimental\r\n     * Update data from GS (position, orientation, color, scaling)\r\n     * @param data array that contain all the datas\r\n     * @param sh optional array of uint8 array for SH data\r\n     */\r\n    public updateData(data: ArrayBuffer, sh?: Uint8Array[]): void {\r\n        runCoroutineSync(this._updateData(data, false, sh));\r\n    }\r\n\r\n    /**\r\n     * Refreshes the bounding info, taking into account all the thin instances defined\r\n     * @returns the current Gaussian Splatting\r\n     */\r\n    public override refreshBoundingInfo(): Mesh {\r\n        this.thinInstanceRefreshBoundingInfo(false);\r\n        return this;\r\n    }\r\n\r\n    // in case size is different\r\n    private _updateSplatIndexBuffer(vertexCount: number): void {\r\n        if (!this._splatIndex || vertexCount > this._splatIndex.length) {\r\n            this._splatIndex = new Float32Array(vertexCount);\r\n\r\n            this.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 1, false);\r\n        }\r\n        this.forcedInstanceCount = vertexCount;\r\n    }\r\n\r\n    private _updateSubTextures(centers: Float32Array, covA: Uint16Array, covB: Uint16Array, colors: Uint8Array, lineStart: number, lineCount: number, sh?: Uint8Array[]): void {\r\n        const updateTextureFromData = (texture: BaseTexture, data: ArrayBufferView, width: number, lineStart: number, lineCount: number) => {\r\n            (this.getEngine() as ThinEngine).updateTextureData(texture.getInternalTexture()!, data, 0, lineStart, width, lineCount, 0, 0, false);\r\n        };\r\n\r\n        const textureSize = this._getTextureSize(this._vertexCount);\r\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\r\n        const texelStart = lineStart * textureSize.x;\r\n        const texelCount = lineCount * textureSize.x;\r\n        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);\r\n        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);\r\n        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);\r\n        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);\r\n        updateTextureFromData(this._covariancesATexture!, covAView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._covariancesBTexture!, covBView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._centersTexture!, centersView, textureSize.x, lineStart, lineCount);\r\n        updateTextureFromData(this._colorsTexture!, colorsView, textureSize.x, lineStart, lineCount);\r\n        if (sh) {\r\n            for (let i = 0; i < sh.length; i++) {\r\n                const componentCount = 4;\r\n                const shView = new Uint8Array(this._sh![i].buffer, texelStart * componentCount, texelCount * componentCount);\r\n                updateTextureFromData(this._shTextures![i], shView, textureSize.x, lineStart, lineCount);\r\n            }\r\n        }\r\n    }\r\n    private _instanciateWorker(): void {\r\n        if (!this._vertexCount) {\r\n            return;\r\n        }\r\n        this._updateSplatIndexBuffer(this._vertexCount);\r\n\r\n        // Start the worker thread\r\n        this._worker?.terminate();\r\n        this._worker = new Worker(\r\n            URL.createObjectURL(\r\n                new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\r\n                    type: \"application/javascript\",\r\n                })\r\n            )\r\n        );\r\n\r\n        this._depthMix = new BigInt64Array(this._vertexCount);\r\n        const positions = Float32Array.from(this._splatPositions!);\r\n        const vertexCount = this._vertexCount;\r\n\r\n        this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\r\n\r\n        this._worker.onmessage = (e) => {\r\n            this._depthMix = e.data.depthMix;\r\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\r\n            if (this._splatIndex) {\r\n                for (let j = 0; j < this._vertexCount; j++) {\r\n                    this._splatIndex[j] = indexMix[2 * j];\r\n                }\r\n            }\r\n            if (this._delayedTextureUpdate) {\r\n                const textureSize = this._getTextureSize(vertexCount);\r\n                this._updateSubTextures(\r\n                    this._delayedTextureUpdate.centers,\r\n                    this._delayedTextureUpdate.covA,\r\n                    this._delayedTextureUpdate.covB,\r\n                    this._delayedTextureUpdate.colors,\r\n                    0,\r\n                    textureSize.y,\r\n                    this._delayedTextureUpdate.sh\r\n                );\r\n                this._delayedTextureUpdate = null;\r\n            }\r\n            this.thinInstanceBufferUpdated(\"splatIndex\");\r\n            this._canPostToWorker = true;\r\n            this._readyToDisplay = true;\r\n            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled\r\n            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.\r\n            if (this._sortIsDirty) {\r\n                this._postToWorker(true);\r\n                this._sortIsDirty = false;\r\n            }\r\n        };\r\n    }\r\n\r\n    private _getTextureSize(length: number): Vector2 {\r\n        const engine = this._scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n\r\n        let height = 1;\r\n\r\n        if (engine.version === 1 && !engine.isWebGPU) {\r\n            while (width * height < length) {\r\n                height *= 2;\r\n            }\r\n        } else {\r\n            height = Math.ceil(length / width);\r\n        }\r\n\r\n        if (height > width) {\r\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\r\n            height = width;\r\n        }\r\n\r\n        return new Vector2(width, height);\r\n    }\r\n}\r\n", "/**\r\n * Wrapper class for promise with external resolve and reject.\r\n */\r\nexport class Deferred<T> {\r\n    /**\r\n     * The promise associated with this deferred object.\r\n     */\r\n    public readonly promise: Promise<T>;\r\n\r\n    private _resolve: (value: T | PromiseLike<T>) => void;\r\n    private _reject: (reason?: any) => void;\r\n\r\n    /**\r\n     * The resolve method of the promise associated with this deferred object.\r\n     */\r\n    public get resolve() {\r\n        return this._resolve;\r\n    }\r\n\r\n    /**\r\n     * The reject method of the promise associated with this deferred object.\r\n     */\r\n    public get reject() {\r\n        return this._reject;\r\n    }\r\n\r\n    /**\r\n     * Constructor for this deferred object.\r\n     */\r\n    constructor() {\r\n        this.promise = new Promise((resolve: (value: T | PromiseLike<T>) => void, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n}\r\n", "import { Decode } from \"./stringTools\";\r\n\r\n/**\r\n * Interface for a data buffer\r\n */\r\nexport interface IDataBuffer {\r\n    /**\r\n     * Reads bytes from the data buffer.\r\n     * @param byteOffset The byte offset to read\r\n     * @param byteLength The byte length to read\r\n     * @returns A promise that resolves when the bytes are read\r\n     */\r\n    readAsync(byteOffset: number, byteLength: number): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * The byte length of the buffer.\r\n     */\r\n    readonly byteLength: number;\r\n}\r\n\r\n/**\r\n * Utility class for reading from a data buffer\r\n */\r\nexport class DataReader {\r\n    /**\r\n     * The data buffer associated with this data reader.\r\n     */\r\n    public readonly buffer: IDataBuffer;\r\n\r\n    /**\r\n     * The current byte offset from the beginning of the data buffer.\r\n     */\r\n    public byteOffset = 0;\r\n\r\n    private _dataView: DataView;\r\n    private _dataByteOffset: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param buffer The buffer to read\r\n     */\r\n    constructor(buffer: IDataBuffer) {\r\n        this.buffer = buffer;\r\n    }\r\n\r\n    /**\r\n     * Loads the given byte length.\r\n     * @param byteLength The byte length to load\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public async loadAsync(byteLength: number): Promise<void> {\r\n        const data = await this.buffer.readAsync(this.byteOffset, byteLength);\r\n        this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        this._dataByteOffset = 0;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._dataByteOffset, true);\r\n        this._dataByteOffset += 4;\r\n        this.byteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a byte array from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The byte array read\r\n     */\r\n    public readUint8Array(byteLength: number): Uint8Array {\r\n        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a string from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The string read\r\n     */\r\n    public readString(byteLength: number): string {\r\n        return Decode(this.readUint8Array(byteLength));\r\n    }\r\n\r\n    /**\r\n     * Skips the given byte length the currently loaded data range.\r\n     * @param byteLength The byte length to skip\r\n     */\r\n    public skipBytes(byteLength: number): void {\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n    }\r\n}\r\n", "/**\r\n * A class that lazily initializes a value given a factory function.\r\n */\r\nexport class Lazy<T> {\r\n    private _factory: (() => T) | undefined;\r\n    private _value: T | undefined;\r\n\r\n    /**\r\n     * Creates a new instance of the Lazy class.\r\n     * @param factory A function that creates the value.\r\n     */\r\n    constructor(factory: () => T) {\r\n        this._factory = factory;\r\n    }\r\n\r\n    /**\r\n     * Gets the lazily initialized value.\r\n     */\r\n    public get value(): T {\r\n        // If the factory function is still defined, it means we haven't called it yet.\r\n        if (this._factory) {\r\n            this._value = this._factory();\r\n            // Set the factory function to undefined to allow it to be garbage collected.\r\n            this._factory = undefined;\r\n        }\r\n        return this._value as T;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math\";\r\nimport { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { BoundingInfo } from \"../Culling/boundingInfo\";\r\nimport type { PointsCloudSystem } from \"./pointsCloudSystem\";\r\n/**\r\n * Represents one particle of a points cloud system.\r\n */\r\nexport class CloudPoint {\r\n    /**\r\n     * particle global index\r\n     */\r\n    public idx: number = 0;\r\n    /**\r\n     * The color of the particle\r\n     */\r\n    public color: Nullable<Color4> = new Color4(1.0, 1.0, 1.0, 1.0);\r\n    /**\r\n     * The world space position of the particle.\r\n     */\r\n    public position: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation of the particle. (Not use if rotationQuaternion is set)\r\n     */\r\n    public rotation: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The world space rotation quaternion of the particle.\r\n     */\r\n    public rotationQuaternion: Nullable<Quaternion>;\r\n    /**\r\n     * The uv of the particle.\r\n     */\r\n    public uv: Nullable<Vector2> = new Vector2(0.0, 0.0);\r\n    /**\r\n     * The current speed of the particle.\r\n     */\r\n    public velocity: Vector3 = Vector3.Zero();\r\n    /**\r\n     * The pivot point in the particle local space.\r\n     */\r\n    public pivot: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Must the particle be translated from its pivot point in its local space ?\r\n     * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\r\n     * Default : false\r\n     */\r\n    public translateFromPivot: boolean = false;\r\n    /**\r\n     * Index of this particle in the global \"positions\" array (Internal use)\r\n     * @internal\r\n     */\r\n    public _pos: number = 0;\r\n    /**\r\n     * @internal Index of this particle in the global \"indices\" array (Internal use)\r\n     */\r\n    public _ind: number = 0;\r\n    /**\r\n     * Group this particle belongs to\r\n     */\r\n    public _group: PointsGroup;\r\n    /**\r\n     * Group id of this particle\r\n     */\r\n    public groupId: number = 0;\r\n    /**\r\n     * Index of the particle in its group id (Internal use)\r\n     */\r\n    public idxInGroup: number = 0;\r\n    /**\r\n     * @internal Particle BoundingInfo object (Internal use)\r\n     */\r\n    public _boundingInfo: BoundingInfo;\r\n    /**\r\n     * @internal Reference to the PCS that the particle belongs to (Internal use)\r\n     */\r\n    public _pcs: PointsCloudSystem;\r\n    /**\r\n     * @internal Still set as invisible in order to skip useless computations (Internal use)\r\n     */\r\n    public _stillInvisible: boolean = false;\r\n    /**\r\n     * @internal Last computed particle rotation matrix\r\n     */\r\n    public _rotationMatrix: number[] = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\r\n    /**\r\n     * Parent particle Id, if any.\r\n     * Default null.\r\n     */\r\n    public parentId: Nullable<number> = null;\r\n    /**\r\n     * @internal Internal global position in the PCS.\r\n     */\r\n    public _globalPosition: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * Creates a Point Cloud object.\r\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\r\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\r\n     * @param group (PointsGroup) is the group the particle belongs to\r\n     * @param groupId (integer) is the group identifier in the PCS.\r\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\r\n     * @param pcs defines the PCS it is associated to\r\n     */\r\n    constructor(particleIndex: number, group: PointsGroup, groupId: number, idxInGroup: number, pcs: PointsCloudSystem) {\r\n        this.idx = particleIndex;\r\n        this._group = group;\r\n        this.groupId = groupId;\r\n        this.idxInGroup = idxInGroup;\r\n        this._pcs = pcs;\r\n    }\r\n\r\n    /**\r\n     * get point size\r\n     */\r\n    public get size(): Vector3 {\r\n        return this.size;\r\n    }\r\n\r\n    /**\r\n     * Set point size\r\n     */\r\n    public set size(scale: Vector3) {\r\n        this.size = scale;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public get quaternion(): Nullable<Quaternion> {\r\n        return this.rotationQuaternion;\r\n    }\r\n\r\n    /**\r\n     * Legacy support, changed quaternion to rotationQuaternion\r\n     */\r\n    public set quaternion(q: Nullable<Quaternion>) {\r\n        this.rotationQuaternion = q;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean. True if the particle intersects a mesh, else false\r\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\r\n     * @param target is the object (point or mesh) what the intersection is computed against\r\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\r\n     * @returns true if it intersects\r\n     */\r\n    public intersectsMesh(target: Mesh, isSphere: boolean): boolean {\r\n        if (!target.hasBoundingInfo) {\r\n            return false;\r\n        }\r\n\r\n        if (!this._pcs.mesh) {\r\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\r\n        }\r\n\r\n        if (isSphere) {\r\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\r\n        }\r\n\r\n        const bbox = target.getBoundingInfo().boundingBox;\r\n\r\n        const maxX = bbox.maximumWorld.x;\r\n        const minX = bbox.minimumWorld.x;\r\n        const maxY = bbox.maximumWorld.y;\r\n        const minY = bbox.minimumWorld.y;\r\n        const maxZ = bbox.maximumWorld.z;\r\n        const minZ = bbox.minimumWorld.z;\r\n\r\n        const x = this.position.x + this._pcs.mesh.position.x;\r\n        const y = this.position.y + this._pcs.mesh.position.y;\r\n        const z = this.position.z + this._pcs.mesh.position.z;\r\n\r\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\r\n    }\r\n\r\n    /**\r\n     * get the rotation matrix of the particle\r\n     * @internal\r\n     */\r\n    public getRotationMatrix(m: Matrix) {\r\n        let quaternion: Quaternion;\r\n        if (this.rotationQuaternion) {\r\n            quaternion = this.rotationQuaternion;\r\n        } else {\r\n            quaternion = TmpVectors.Quaternion[0];\r\n            const rotation = this.rotation;\r\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\r\n        }\r\n\r\n        quaternion.toRotationMatrix(m);\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a group of points in a points cloud system\r\n *  * PCS internal tool, don't use it manually.\r\n */\r\nexport class PointsGroup {\r\n    /**\r\n     * Get or set the groupId\r\n     * @deprecated Please use groupId instead\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public get groupID(): number {\r\n        return this.groupId;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public set groupID(groupID: number) {\r\n        this.groupId = groupID;\r\n    }\r\n    /**\r\n     * The group id\r\n     * @internal\r\n     */\r\n    public groupId: number;\r\n    /**\r\n     * image data for group (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImageData: Nullable<ArrayBufferView>;\r\n    /**\r\n     * Image Width (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgWidth: number;\r\n    /**\r\n     * Image Height (internal use)\r\n     * @internal\r\n     */\r\n    public _groupImgHeight: number;\r\n    /**\r\n     * Custom position function (internal use)\r\n     * @internal\r\n     */\r\n    public _positionFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>;\r\n    /**\r\n     * density per facet for surface points\r\n     * @internal\r\n     */\r\n    public _groupDensity: number[];\r\n    /**\r\n     * Only when points are colored by texture carries pointer to texture list array\r\n     * @internal\r\n     */\r\n    public _textureNb: number;\r\n\r\n    /**\r\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\r\n     * PCS internal tool, don't use it manually.\r\n     * @internal\r\n     */\r\n    constructor(id: number, posFunction: Nullable<(particle: CloudPoint, i?: number, s?: number) => void>) {\r\n        this.groupId = id;\r\n        this._positionFunction = posFunction;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Matrix } from \"../Maths/math.vector\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\n\r\nimport { Scene } from \"../scene\";\r\nimport { Camera } from \"../Cameras/camera\";\r\n\r\nimport type { MeshPredicate, TrianglePickingPredicate, Ray } from \"./ray.core\";\r\nimport {\r\n    AddRayExtensions,\r\n    CreatePickingRayInCameraSpace,\r\n    CreatePickingRayInCameraSpaceToRef,\r\n    CreatePickingRayToRef,\r\n    MultiPick,\r\n    MultiPickWithRay,\r\n    Pick,\r\n    PickWithBoundingInfo,\r\n    PickWithRay,\r\n} from \"./ray.core\";\r\n\r\nexport * from \"./ray.core\";\r\n\r\n// Picking\r\nAddRayExtensions(Scene, Camera);\r\n\r\nScene.prototype.createPickingRayToRef = function (\r\n    x: number,\r\n    y: number,\r\n    world: Nullable<Matrix>,\r\n    result: Ray,\r\n    camera: Nullable<Camera>,\r\n    cameraViewSpace = false,\r\n    enableDistantPicking = false\r\n): Scene {\r\n    return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpace = function (x: number, y: number, camera?: Camera): Ray {\r\n    return CreatePickingRayInCameraSpace(this, x, y, camera);\r\n};\r\n\r\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x: number, y: number, result: Ray, camera?: Camera): Scene {\r\n    return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);\r\n};\r\n\r\nScene.prototype.pickWithBoundingInfo = function (x: number, y: number, predicate?: MeshPredicate, fastCheck?: boolean, camera?: Nullable<Camera>): Nullable<PickingInfo> {\r\n    return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);\r\n};\r\n\r\nScene.prototype.pick = function (\r\n    x: number,\r\n    y: number,\r\n    predicate?: MeshPredicate,\r\n    fastCheck?: boolean,\r\n    camera?: Nullable<Camera>,\r\n    trianglePredicate?: TrianglePickingPredicate,\r\n    _enableDistantPicking = false\r\n): PickingInfo {\r\n    return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);\r\n};\r\n\r\nScene.prototype.pickWithRay = function (ray: Ray, predicate?: MeshPredicate, fastCheck?: boolean, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo> {\r\n    return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPick = function (x: number, y: number, predicate?: MeshPredicate, camera?: Camera, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPick(this, x, y, predicate, camera, trianglePredicate);\r\n};\r\n\r\nScene.prototype.multiPickWithRay = function (ray: Ray, predicate?: MeshPredicate, trianglePredicate?: TrianglePickingPredicate): Nullable<PickingInfo[]> {\r\n    return MultiPickWithRay(this, ray, predicate, trianglePredicate);\r\n};\r\n", "import type { IndicesArray, FloatArray } from \"../types\";\r\nimport { Color4, Color3 } from \"../Maths/math\";\r\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\r\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\r\nimport { RandomRange } from \"../Maths/math.scalar.functions\";\r\nimport type { Material } from \"../Materials/material\";\r\n\r\n/** Defines the 4 color options */\r\nexport const enum PointColor {\r\n    /** color value */\r\n    Color = 2,\r\n    /** uv value */\r\n    UV = 1,\r\n    /** random value */\r\n    Random = 0,\r\n    /** stated value */\r\n    Stated = 3,\r\n}\r\n\r\n/**\r\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\r\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\r\n\r\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\r\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\r\n *\r\n * Full documentation here : TO BE ENTERED\r\n */\r\nexport class PointsCloudSystem implements IDisposable {\r\n    /**\r\n     *  The PCS array of cloud point objects. Just access each particle as with any classic array.\r\n     *  Example : var p = SPS.particles[i];\r\n     */\r\n    public particles: CloudPoint[] = new Array<CloudPoint>();\r\n    /**\r\n     * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\r\n     */\r\n    public nbParticles: number = 0;\r\n    /**\r\n     * This a counter for your own usage. It's not set by any SPS functions.\r\n     */\r\n    public counter: number = 0;\r\n    /**\r\n     * The PCS name. This name is also given to the underlying mesh.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The PCS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are available.\r\n     */\r\n    public mesh?: Mesh;\r\n    /**\r\n     * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\r\n     * Please read :\r\n     */\r\n    public vars: any = {};\r\n    /**\r\n     * @internal\r\n     */\r\n    public _size: number; //size of each point particle\r\n\r\n    private _scene: Scene;\r\n    private _promises: Array<Promise<any>> = [];\r\n    private _positions: number[] = new Array<number>();\r\n    private _indices: number[] = new Array<number>();\r\n    private _normals: number[] = new Array<number>();\r\n    private _colors: number[] = new Array<number>();\r\n    private _uvs: number[] = new Array<number>();\r\n    private _indices32: IndicesArray; // used as depth sorted array if depth sort enabled, else used as typed indices\r\n    private _positions32: Float32Array; // updated positions for the VBO\r\n    private _colors32: Float32Array;\r\n    private _uvs32: Float32Array;\r\n    private _updatable: boolean = true;\r\n    private _isVisibilityBoxLocked = false;\r\n    private _alwaysVisible: boolean = false;\r\n    private _groups: number[] = new Array<number>(); //start indices for each group of particles\r\n    private _groupCounter: number = 0;\r\n    private _computeParticleColor: boolean = true;\r\n    private _computeParticleTexture: boolean = true;\r\n    private _computeParticleRotation: boolean = true;\r\n    private _computeBoundingBox: boolean = false;\r\n    private _isReady: boolean = false;\r\n\r\n    /**\r\n     * Gets the particle positions computed by the Point Cloud System\r\n     */\r\n    public get positions(): Float32Array {\r\n        return this._positions32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle colors computed by the Point Cloud System\r\n     */\r\n    public get colors(): Float32Array {\r\n        return this._colors32;\r\n    }\r\n\r\n    /**\r\n     * Gets the particle uvs computed by the Point Cloud System\r\n     */\r\n    public get uvs(): Float32Array {\r\n        return this._uvs32;\r\n    }\r\n\r\n    /**\r\n     * Creates a PCS (Points Cloud System) object\r\n     * @param name (String) is the PCS name, this will be the underlying mesh name\r\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\r\n     * @param scene (Scene) is the scene in which the PCS is added\r\n     * @param options defines the options of the PCS e.g.\r\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\r\n     */\r\n    constructor(name: string, pointSize: number, scene: Scene, options?: { updatable?: boolean }) {\r\n        this.name = name;\r\n        this._size = pointSize;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        if (options && options.updatable !== undefined) {\r\n            this._updatable = options.updatable;\r\n        } else {\r\n            this._updatable = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\r\n     * If no points were added to the PCS, the returned mesh is just a single point.\r\n     * @param material The material to use to render the mesh. If not provided, will create a default one\r\n     * @returns a promise for the created mesh\r\n     */\r\n    public async buildMeshAsync(material?: Material): Promise<Mesh> {\r\n        await Promise.all(this._promises);\r\n        this._isReady = true;\r\n        return await this._buildMeshAsync(material);\r\n    }\r\n\r\n    private async _buildMeshAsync(material?: Material): Promise<Mesh> {\r\n        if (this.nbParticles === 0) {\r\n            this.addPoints(1);\r\n        }\r\n\r\n        this._positions32 = new Float32Array(this._positions);\r\n        this._uvs32 = new Float32Array(this._uvs);\r\n        this._colors32 = new Float32Array(this._colors);\r\n\r\n        const vertexData = new VertexData();\r\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\r\n\r\n        if (this._uvs32.length > 0) {\r\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\r\n        }\r\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\r\n        if (this._colors32.length > 0) {\r\n            ec = 1;\r\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\r\n        }\r\n        const mesh = new Mesh(this.name, this._scene);\r\n        vertexData.applyToMesh(mesh, this._updatable);\r\n        this.mesh = mesh;\r\n\r\n        // free memory\r\n        (<any>this._positions) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n\r\n        if (!this._updatable) {\r\n            this.particles.length = 0;\r\n        }\r\n\r\n        let mat = material;\r\n\r\n        if (!mat) {\r\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\r\n            (<StandardMaterial>mat).emissiveColor = new Color3(ec, ec, ec);\r\n            (<StandardMaterial>mat).disableLighting = true;\r\n            (<StandardMaterial>mat).pointsCloud = true;\r\n            (<StandardMaterial>mat).pointSize = this._size;\r\n        }\r\n        mesh.material = mat;\r\n\r\n        return mesh;\r\n    }\r\n\r\n    // adds a new particle object in the particles array\r\n    private _addParticle(idx: number, group: PointsGroup, groupId: number, idxInGroup: number): CloudPoint {\r\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\r\n        this.particles.push(cp);\r\n        return cp;\r\n    }\r\n\r\n    private _randomUnitVector(particle: CloudPoint): void {\r\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\r\n        particle.color = new Color4(1, 1, 1, 1);\r\n    }\r\n\r\n    private _getColorIndicesForCoord(pointsGroup: PointsGroup, x: number, y: number, width: number): Color4 {\r\n        const imageData = <Uint8Array>pointsGroup._groupImageData;\r\n        const color = y * (width * 4) + x * 4;\r\n        const colorIndices = [color, color + 1, color + 2, color + 3];\r\n        const redIndex = colorIndices[0];\r\n        const greenIndex = colorIndices[1];\r\n        const blueIndex = colorIndices[2];\r\n        const alphaIndex = colorIndices[3];\r\n        const redForCoord = imageData[redIndex];\r\n        const greenForCoord = imageData[greenIndex];\r\n        const blueForCoord = imageData[blueIndex];\r\n        const alphaForCoord = imageData[alphaIndex];\r\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\r\n    }\r\n\r\n    private _setPointsColorOrUV(\r\n        mesh: Mesh,\r\n        pointsGroup: PointsGroup,\r\n        isVolume: boolean,\r\n        colorFromTexture?: boolean,\r\n        hasTexture?: boolean,\r\n        color?: Color4,\r\n        range?: number,\r\n        uvSetIndex?: number\r\n    ): void {\r\n        uvSetIndex = uvSetIndex ?? 0;\r\n\r\n        if (isVolume) {\r\n            mesh.updateFacetData();\r\n        }\r\n\r\n        const boundInfo = mesh.getBoundingInfo();\r\n        const diameter = 2 * boundInfo.boundingSphere.radius;\r\n\r\n        let meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n        const meshUV = <FloatArray>mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\r\n        const meshCol = <FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind);\r\n\r\n        const place = Vector3.Zero();\r\n        mesh.computeWorldMatrix();\r\n        const meshMatrix: Matrix = mesh.getWorldMatrix();\r\n        if (!meshMatrix.isIdentity()) {\r\n            meshPos = meshPos.slice(0);\r\n            for (let p = 0; p < meshPos.length / 3; p++) {\r\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\r\n                meshPos[3 * p] = place.x;\r\n                meshPos[3 * p + 1] = place.y;\r\n                meshPos[3 * p + 2] = place.z;\r\n            }\r\n        }\r\n\r\n        let idxPoints: number = 0;\r\n\r\n        let id0: number = 0;\r\n        let id1: number = 0;\r\n        let id2: number = 0;\r\n        let v0X: number = 0;\r\n        let v0Y: number = 0;\r\n        let v0Z: number = 0;\r\n        let v1X: number = 0;\r\n        let v1Y: number = 0;\r\n        let v1Z: number = 0;\r\n        let v2X: number = 0;\r\n        let v2Y: number = 0;\r\n        let v2Z: number = 0;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n\r\n        let uv0X: number = 0;\r\n        let uv0Y: number = 0;\r\n        let uv1X: number = 0;\r\n        let uv1Y: number = 0;\r\n        let uv2X: number = 0;\r\n        let uv2Y: number = 0;\r\n        const uv0 = Vector2.Zero();\r\n        const uv1 = Vector2.Zero();\r\n        const uv2 = Vector2.Zero();\r\n        const uvec0 = Vector2.Zero();\r\n        const uvec1 = Vector2.Zero();\r\n\r\n        let col0X: number = 0;\r\n        let col0Y: number = 0;\r\n        let col0Z: number = 0;\r\n        let col0A: number = 0;\r\n        let col1X: number = 0;\r\n        let col1Y: number = 0;\r\n        let col1Z: number = 0;\r\n        let col1A: number = 0;\r\n        let col2X: number = 0;\r\n        let col2Y: number = 0;\r\n        let col2Z: number = 0;\r\n        let col2A: number = 0;\r\n        const col0 = Vector4.Zero();\r\n        const col1 = Vector4.Zero();\r\n        const col2 = Vector4.Zero();\r\n        const colvec0 = Vector4.Zero();\r\n        const colvec1 = Vector4.Zero();\r\n\r\n        let lamda: number = 0;\r\n        let mu: number = 0;\r\n        range = range ? range : 0;\r\n\r\n        let facetPoint: Vector3;\r\n        let uvPoint: Vector2;\r\n        let colPoint: Vector4 = new Vector4(0, 0, 0, 0);\r\n\r\n        let norm = Vector3.Zero();\r\n        let tang = Vector3.Zero();\r\n        let biNorm = Vector3.Zero();\r\n        let angle = 0;\r\n        let facetPlaneVec = Vector3.Zero();\r\n\r\n        let gap = 0;\r\n        let distance = 0;\r\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\r\n        let pickInfo: PickingInfo;\r\n        let direction = Vector3.Zero();\r\n\r\n        for (let index = 0; index < meshInd.length / 3; index++) {\r\n            id0 = meshInd[3 * index];\r\n            id1 = meshInd[3 * index + 1];\r\n            id2 = meshInd[3 * index + 2];\r\n            v0X = meshPos[3 * id0];\r\n            v0Y = meshPos[3 * id0 + 1];\r\n            v0Z = meshPos[3 * id0 + 2];\r\n            v1X = meshPos[3 * id1];\r\n            v1Y = meshPos[3 * id1 + 1];\r\n            v1Z = meshPos[3 * id1 + 2];\r\n            v2X = meshPos[3 * id2];\r\n            v2Y = meshPos[3 * id2 + 1];\r\n            v2Z = meshPos[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n\r\n            if (meshUV) {\r\n                uv0X = meshUV[2 * id0];\r\n                uv0Y = meshUV[2 * id0 + 1];\r\n                uv1X = meshUV[2 * id1];\r\n                uv1Y = meshUV[2 * id1 + 1];\r\n                uv2X = meshUV[2 * id2];\r\n                uv2Y = meshUV[2 * id2 + 1];\r\n                uv0.set(uv0X, uv0Y);\r\n                uv1.set(uv1X, uv1Y);\r\n                uv2.set(uv2X, uv2Y);\r\n                uv1.subtractToRef(uv0, uvec0);\r\n                uv2.subtractToRef(uv1, uvec1);\r\n            }\r\n\r\n            if (meshCol && colorFromTexture) {\r\n                col0X = meshCol[4 * id0];\r\n                col0Y = meshCol[4 * id0 + 1];\r\n                col0Z = meshCol[4 * id0 + 2];\r\n                col0A = meshCol[4 * id0 + 3];\r\n                col1X = meshCol[4 * id1];\r\n                col1Y = meshCol[4 * id1 + 1];\r\n                col1Z = meshCol[4 * id1 + 2];\r\n                col1A = meshCol[4 * id1 + 3];\r\n                col2X = meshCol[4 * id2];\r\n                col2Y = meshCol[4 * id2 + 1];\r\n                col2Z = meshCol[4 * id2 + 2];\r\n                col2A = meshCol[4 * id2 + 3];\r\n                col0.set(col0X, col0Y, col0Z, col0A);\r\n                col1.set(col1X, col1Y, col1Z, col1A);\r\n                col2.set(col2X, col2Y, col2Z, col2A);\r\n                col1.subtractToRef(col0, colvec0);\r\n                col2.subtractToRef(col1, colvec1);\r\n            }\r\n\r\n            let width: number;\r\n            let height: number;\r\n            let deltaS: number;\r\n            let deltaV: number;\r\n            let h: number;\r\n            let s: number;\r\n            let v: number;\r\n            let hsvCol: Color3;\r\n            const statedColor: Color3 = new Color3(0, 0, 0);\r\n            const colPoint3: Color3 = new Color3(0, 0, 0);\r\n            let pointColors: Color4;\r\n            let particle: CloudPoint;\r\n\r\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\r\n                idxPoints = this.particles.length;\r\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\r\n                particle = this.particles[idxPoints];\r\n                //form a point inside the facet v0, v1, v2;\r\n                lamda = Math.sqrt(RandomRange(0, 1));\r\n                mu = RandomRange(0, 1);\r\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\r\n                if (isVolume) {\r\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\r\n                    tang = vec0.clone().normalize();\r\n                    biNorm = Vector3.Cross(norm, tang);\r\n                    angle = RandomRange(0, 2 * Math.PI);\r\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\r\n                    angle = RandomRange(0.1, Math.PI / 2);\r\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\r\n\r\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\r\n                    ray.direction = direction;\r\n                    ray.length = diameter;\r\n                    pickInfo = ray.intersectsMesh(mesh);\r\n                    if (pickInfo.hit) {\r\n                        distance = pickInfo.pickedPoint!.subtract(facetPoint).length();\r\n                        gap = RandomRange(0, 1) * distance;\r\n                        facetPoint.addInPlace(direction.scale(gap));\r\n                    }\r\n                }\r\n                particle.position = facetPoint.clone();\r\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\r\n                if (colorFromTexture !== undefined) {\r\n                    if (meshUV) {\r\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\r\n                        if (colorFromTexture) {\r\n                            //Set particle color to texture color\r\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\r\n                                width = pointsGroup._groupImgWidth;\r\n                                height = pointsGroup._groupImgHeight;\r\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\r\n                                particle.color = pointColors;\r\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\r\n                            } else {\r\n                                if (meshCol) {\r\n                                    //failure in texture and colors available\r\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                } else {\r\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            //Set particle uv based on a mesh uv\r\n                            particle.uv = uvPoint.clone();\r\n                            this._uvs.push(particle.uv.x, particle.uv.y);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (color) {\r\n                        statedColor.set(color.r, color.g, color.b);\r\n                        deltaS = RandomRange(-range, range);\r\n                        deltaV = RandomRange(-range, range);\r\n                        hsvCol = statedColor.toHSV();\r\n                        h = hsvCol.r;\r\n                        s = hsvCol.g + deltaS;\r\n                        v = hsvCol.b + deltaV;\r\n                        if (s < 0) {\r\n                            s = 0;\r\n                        }\r\n                        if (s > 1) {\r\n                            s = 1;\r\n                        }\r\n                        if (v < 0) {\r\n                            v = 0;\r\n                        }\r\n                        if (v > 1) {\r\n                            v = 1;\r\n                        }\r\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\r\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\r\n                    } else {\r\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\r\n                    }\r\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // stores mesh texture in dynamic texture for color pixel retrieval\r\n    // when pointColor type is color for surface points\r\n    private _colorFromTexture(mesh: Mesh, pointsGroup: PointsGroup, isVolume: boolean): void {\r\n        if (mesh.material === null) {\r\n            Logger.Warn(mesh.name + \"has no material.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const mat = mesh.material;\r\n        const textureList: BaseTexture[] = mat.getActiveTextures();\r\n        if (textureList.length === 0) {\r\n            Logger.Warn(mesh.name + \"has no usable texture.\");\r\n            pointsGroup._groupImageData = null;\r\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\r\n            return;\r\n        }\r\n\r\n        const clone = mesh.clone();\r\n        clone.setEnabled(false);\r\n        this._promises.push(\r\n            new Promise((resolve: (_: void) => void) => {\r\n                BaseTexture.WhenAllReady(textureList, () => {\r\n                    let n = pointsGroup._textureNb;\r\n                    if (n < 0) {\r\n                        n = 0;\r\n                    }\r\n                    if (n > textureList.length - 1) {\r\n                        n = textureList.length - 1;\r\n                    }\r\n                    const finalize = () => {\r\n                        pointsGroup._groupImgWidth = textureList[n].getSize().width;\r\n                        pointsGroup._groupImgHeight = textureList[n].getSize().height;\r\n                        this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\r\n                        clone.dispose();\r\n                        resolve();\r\n                    };\r\n                    pointsGroup._groupImageData = null;\r\n                    const dataPromise = textureList[n].readPixels();\r\n                    if (!dataPromise) {\r\n                        finalize();\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        dataPromise.then((data) => {\r\n                            pointsGroup._groupImageData = data;\r\n                            finalize();\r\n                        });\r\n                    }\r\n                });\r\n            })\r\n        );\r\n    }\r\n\r\n    // calculates the point density per facet of a mesh for surface points\r\n    private _calculateDensity(nbPoints: number, positions: FloatArray, indices: IndicesArray): number[] {\r\n        let id0: number;\r\n        let id1: number;\r\n        let id2: number;\r\n        let v0X: number;\r\n        let v0Y: number;\r\n        let v0Z: number;\r\n        let v1X: number;\r\n        let v1Y: number;\r\n        let v1Z: number;\r\n        let v2X: number;\r\n        let v2Y: number;\r\n        let v2Z: number;\r\n        const vertex0 = Vector3.Zero();\r\n        const vertex1 = Vector3.Zero();\r\n        const vertex2 = Vector3.Zero();\r\n        const vec0 = Vector3.Zero();\r\n        const vec1 = Vector3.Zero();\r\n        const normal = Vector3.Zero();\r\n\r\n        let area: number;\r\n        const cumulativeAreas: number[] = [];\r\n        let surfaceArea: number = 0;\r\n\r\n        const nbFacets = indices.length / 3;\r\n\r\n        //surface area\r\n        for (let index = 0; index < nbFacets; index++) {\r\n            id0 = indices[3 * index];\r\n            id1 = indices[3 * index + 1];\r\n            id2 = indices[3 * index + 2];\r\n            v0X = positions[3 * id0];\r\n            v0Y = positions[3 * id0 + 1];\r\n            v0Z = positions[3 * id0 + 2];\r\n            v1X = positions[3 * id1];\r\n            v1Y = positions[3 * id1 + 1];\r\n            v1Z = positions[3 * id1 + 2];\r\n            v2X = positions[3 * id2];\r\n            v2Y = positions[3 * id2 + 1];\r\n            v2Z = positions[3 * id2 + 2];\r\n            vertex0.set(v0X, v0Y, v0Z);\r\n            vertex1.set(v1X, v1Y, v1Z);\r\n            vertex2.set(v2X, v2Y, v2Z);\r\n            vertex1.subtractToRef(vertex0, vec0);\r\n            vertex2.subtractToRef(vertex1, vec1);\r\n            Vector3.CrossToRef(vec0, vec1, normal);\r\n            area = 0.5 * normal.length();\r\n            surfaceArea += area;\r\n            cumulativeAreas[index] = surfaceArea;\r\n        }\r\n\r\n        const density: number[] = new Array<number>(nbFacets);\r\n        let remainingPoints = nbPoints;\r\n        for (let index = nbFacets - 1; index > 0; index--) {\r\n            const cumulativeArea = cumulativeAreas[index];\r\n            if (cumulativeArea === 0) {\r\n                // avoiding division by 0 upon degenerate triangles\r\n                density[index] = 0;\r\n            } else {\r\n                const area = cumulativeArea - cumulativeAreas[index - 1];\r\n                const facetPointsWithFraction = (area / cumulativeArea) * remainingPoints;\r\n                const floored = Math.floor(facetPointsWithFraction);\r\n                const fraction = facetPointsWithFraction - floored;\r\n                const extraPoint = Number(Math.random() < fraction);\r\n                const facetPoints = floored + extraPoint;\r\n                density[index] = facetPoints;\r\n                remainingPoints -= facetPoints;\r\n            }\r\n        }\r\n        density[0] = remainingPoints;\r\n\r\n        return density;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS in random positions within a unit sphere\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addPoints(nb: number, pointFunction: any = this._randomUnitVector): number {\r\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\r\n        let cp: CloudPoint;\r\n\r\n        // particles\r\n        let idx = this.nbParticles;\r\n        for (let i = 0; i < nb; i++) {\r\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\r\n            if (pointsGroup && pointsGroup._positionFunction) {\r\n                pointsGroup._positionFunction(cp, idx, i);\r\n            }\r\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\r\n            if (cp.color) {\r\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\r\n            }\r\n            if (cp.uv) {\r\n                this._uvs.push(cp.uv.x, cp.uv.y);\r\n            }\r\n            idx++;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS from the surface of the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addSurfacePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     * Adds points to the PCS inside the model shape\r\n     * @param mesh is any Mesh object that will be used as a surface model for the points\r\n     * @param nb (positive integer) the number of particles to be created from this model\r\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\r\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\r\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\r\n     * @returns the number of groups in the system\r\n     */\r\n    public addVolumePoints(mesh: Mesh, nb: number, colorWith?: number, color?: Color4 | number, range?: number): number {\r\n        let colored = colorWith ? colorWith : PointColor.Random;\r\n        if (isNaN(colored) || colored < 0 || colored > 3) {\r\n            colored = PointColor.Random;\r\n        }\r\n\r\n        const meshPos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const meshInd = <IndicesArray>mesh.getIndices();\r\n\r\n        this._groups.push(this._groupCounter);\r\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\r\n\r\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\r\n        if (colored === PointColor.Color) {\r\n            pointsGroup._textureNb = <number>color ? <number>color : 0;\r\n        } else {\r\n            color = <Color4>color ? <Color4>color : new Color4(1, 1, 1, 1);\r\n        }\r\n        switch (colored) {\r\n            case PointColor.Color:\r\n                this._colorFromTexture(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.UV:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\r\n                break;\r\n            case PointColor.Random:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\r\n                break;\r\n            case PointColor.Stated:\r\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, <Color4>color, range);\r\n                break;\r\n        }\r\n        this.nbParticles += nb;\r\n        this._groupCounter++;\r\n        return this._groupCounter - 1;\r\n    }\r\n\r\n    /**\r\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\r\n     *  This method calls `updateParticle()` for each particle of the SPS.\r\n     *  For an animated SPS, it is usually called within the render loop.\r\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\r\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\r\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\r\n     * @returns the PCS.\r\n     */\r\n    public setParticles(start: number = 0, end: number = this.nbParticles - 1, update: boolean = true): PointsCloudSystem {\r\n        if (!this._updatable || !this._isReady) {\r\n            return this;\r\n        }\r\n\r\n        // custom beforeUpdate\r\n        this.beforeUpdateParticles(start, end, update);\r\n\r\n        const rotMatrix = TmpVectors.Matrix[0];\r\n        const mesh = this.mesh;\r\n        const colors32 = this._colors32;\r\n        const positions32 = this._positions32;\r\n        const uvs32 = this._uvs32;\r\n\r\n        const tempVectors = TmpVectors.Vector3;\r\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\r\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\r\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\r\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\r\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\r\n\r\n        Matrix.IdentityToRef(rotMatrix);\r\n        let idx = 0; // current index of the particle\r\n\r\n        if (this.mesh?.isFacetDataEnabled) {\r\n            this._computeBoundingBox = true;\r\n        }\r\n\r\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\r\n        if (this._computeBoundingBox) {\r\n            if (start != 0 || end != this.nbParticles - 1) {\r\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\r\n                const boundingInfo = this.mesh?.getBoundingInfo();\r\n                if (boundingInfo) {\r\n                    minimum.copyFrom(boundingInfo.minimum);\r\n                    maximum.copyFrom(boundingInfo.maximum);\r\n                }\r\n            }\r\n        }\r\n\r\n        idx = 0; // particle index\r\n        let pindex = 0; //index in positions array\r\n        let cindex = 0; //index in color array\r\n        let uindex = 0; //index in uv array\r\n\r\n        // particle loop\r\n        for (let p = start; p <= end; p++) {\r\n            const particle = this.particles[p];\r\n            idx = particle.idx;\r\n            pindex = 3 * idx;\r\n            cindex = 4 * idx;\r\n            uindex = 2 * idx;\r\n\r\n            // call to custom user function to update the particle properties\r\n            this.updateParticle(particle);\r\n\r\n            const particleRotationMatrix = particle._rotationMatrix;\r\n            const particlePosition = particle.position;\r\n            const particleGlobalPosition = particle._globalPosition;\r\n\r\n            if (this._computeParticleRotation) {\r\n                particle.getRotationMatrix(rotMatrix);\r\n            }\r\n\r\n            const particleHasParent = particle.parentId !== null;\r\n            if (particleHasParent) {\r\n                const parent = this.particles[particle.parentId!];\r\n                const parentRotationMatrix = parent._rotationMatrix;\r\n                const parentGlobalPosition = parent._globalPosition;\r\n\r\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\r\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\r\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\r\n\r\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\r\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\r\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[1] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[2] =\r\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[3] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[4] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[5] =\r\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\r\n                    particleRotationMatrix[6] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\r\n                    particleRotationMatrix[7] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\r\n                    particleRotationMatrix[8] =\r\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\r\n                }\r\n            } else {\r\n                particleGlobalPosition.x = 0;\r\n                particleGlobalPosition.y = 0;\r\n                particleGlobalPosition.z = 0;\r\n\r\n                if (this._computeParticleRotation) {\r\n                    const rotMatrixValues = rotMatrix.m;\r\n                    particleRotationMatrix[0] = rotMatrixValues[0];\r\n                    particleRotationMatrix[1] = rotMatrixValues[1];\r\n                    particleRotationMatrix[2] = rotMatrixValues[2];\r\n                    particleRotationMatrix[3] = rotMatrixValues[4];\r\n                    particleRotationMatrix[4] = rotMatrixValues[5];\r\n                    particleRotationMatrix[5] = rotMatrixValues[6];\r\n                    particleRotationMatrix[6] = rotMatrixValues[8];\r\n                    particleRotationMatrix[7] = rotMatrixValues[9];\r\n                    particleRotationMatrix[8] = rotMatrixValues[10];\r\n                }\r\n            }\r\n\r\n            const pivotBackTranslation = tempVectors[11];\r\n            if (particle.translateFromPivot) {\r\n                pivotBackTranslation.setAll(0.0);\r\n            } else {\r\n                pivotBackTranslation.copyFrom(particle.pivot);\r\n            }\r\n\r\n            // positions\r\n            const tmpVertex = tempVectors[0];\r\n            tmpVertex.copyFrom(particle.position);\r\n            const vertexX = tmpVertex.x - particle.pivot.x;\r\n            const vertexY = tmpVertex.y - particle.pivot.y;\r\n            const vertexZ = tmpVertex.z - particle.pivot.z;\r\n\r\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\r\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\r\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\r\n\r\n            rotatedX += pivotBackTranslation.x;\r\n            rotatedY += pivotBackTranslation.y;\r\n            rotatedZ += pivotBackTranslation.z;\r\n\r\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\r\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\r\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\r\n\r\n            if (this._computeBoundingBox) {\r\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\r\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\r\n            }\r\n\r\n            if (this._computeParticleColor && particle.color) {\r\n                const color = particle.color;\r\n                const colors32 = this._colors32;\r\n                colors32[cindex] = color.r;\r\n                colors32[cindex + 1] = color.g;\r\n                colors32[cindex + 2] = color.b;\r\n                colors32[cindex + 3] = color.a;\r\n            }\r\n            if (this._computeParticleTexture && particle.uv) {\r\n                const uv = particle.uv;\r\n                const uvs32 = this._uvs32;\r\n                uvs32[uindex] = uv.x;\r\n                uvs32[uindex + 1] = uv.y;\r\n            }\r\n        }\r\n\r\n        // if the VBO must be updated\r\n        if (mesh) {\r\n            if (update) {\r\n                if (this._computeParticleColor) {\r\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\r\n                }\r\n                if (this._computeParticleTexture) {\r\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\r\n                }\r\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\r\n            }\r\n\r\n            if (this._computeBoundingBox) {\r\n                if (mesh.hasBoundingInfo) {\r\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\r\n                } else {\r\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\r\n                }\r\n            }\r\n        }\r\n        this.afterUpdateParticles(start, end, update);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes the PCS.\r\n     */\r\n    public dispose(): void {\r\n        this.mesh?.dispose();\r\n        this.vars = null;\r\n        // drop references to internal big arrays for the GC\r\n        (<any>this._positions) = null;\r\n        (<any>this._indices) = null;\r\n        (<any>this._normals) = null;\r\n        (<any>this._uvs) = null;\r\n        (<any>this._colors) = null;\r\n        (<any>this._indices32) = null;\r\n        (<any>this._positions32) = null;\r\n        (<any>this._uvs32) = null;\r\n        (<any>this._colors32) = null;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\r\n     * doc :\r\n     * @returns the PCS.\r\n     */\r\n    public refreshVisibleSize(): PointsCloudSystem {\r\n        if (!this._isVisibilityBoxLocked) {\r\n            this.mesh?.refreshBoundingInfo();\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\r\n     * @param size the size (float) of the visibility box\r\n     * note : this doesn't lock the PCS mesh bounding box.\r\n     * doc :\r\n     */\r\n    public setVisibilityBox(size: number): void {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        const vis = size / 2;\r\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the PCS is always visible or not\r\n     * doc :\r\n     */\r\n    public get isAlwaysVisible(): boolean {\r\n        return this._alwaysVisible;\r\n    }\r\n\r\n    /**\r\n     * Sets the PCS as always visible or not\r\n     * doc :\r\n     */\r\n    public set isAlwaysVisible(val: boolean) {\r\n        if (!this.mesh) {\r\n            return;\r\n        }\r\n\r\n        this._alwaysVisible = val;\r\n        this.mesh.alwaysSelectAsActiveMesh = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle rotations or not\r\n     * Default value : false. The PCS is faster when it's set to false\r\n     * Note : particle rotations are only applied to parent particles\r\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\r\n     */\r\n    public set computeParticleRotation(val: boolean) {\r\n        this._computeParticleRotation = val;\r\n    }\r\n\r\n    /**\r\n     * Tells to `setParticles()` to compute the particle colors or not.\r\n     * Default value : true. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public set computeParticleColor(val: boolean) {\r\n        this._computeParticleColor = val;\r\n    }\r\n\r\n    public set computeParticleTexture(val: boolean) {\r\n        this._computeParticleTexture = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle colors or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleColor(): boolean {\r\n        return this._computeParticleColor;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes the particle textures or not.\r\n     * Default value : false. The PCS is faster when it's set to false.\r\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\r\n     */\r\n    public get computeParticleTexture(): boolean {\r\n        return this._computeParticleTexture;\r\n    }\r\n    /**\r\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public set computeBoundingBox(val: boolean) {\r\n        this._computeBoundingBox = val;\r\n    }\r\n    /**\r\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\r\n     */\r\n    public get computeBoundingBox(): boolean {\r\n        return this._computeBoundingBox;\r\n    }\r\n\r\n    // =======================================================================\r\n    // Particle behavior logic\r\n    // these following methods may be overwritten by users to fit their needs\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to set all the particle first values.\r\n     * The PCS doesn't call this function, you may have to call it by your own.\r\n     * doc :\r\n     */\r\n    public initParticles(): void {}\r\n\r\n    /**\r\n     * This function does nothing. It may be overwritten to recycle a particle\r\n     * The PCS doesn't call this function, you can to call it\r\n     * doc :\r\n     * @param particle The particle to recycle\r\n     * @returns the recycled particle\r\n     */\r\n    public recycleParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * Updates a particle : this function should  be overwritten by the user.\r\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\r\n     * doc :\r\n     * @example : just set a particle position or velocity and recycle conditions\r\n     * @param particle The particle to update\r\n     * @returns the updated particle\r\n     */\r\n    public updateParticle(particle: CloudPoint): CloudPoint {\r\n        return particle;\r\n    }\r\n\r\n    /**\r\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public beforeUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n    /**\r\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\r\n     * This will be passed three parameters.\r\n     * This does nothing and may be overwritten by the user.\r\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\r\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\r\n     * @param update the boolean update value actually passed to setParticles()\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public afterUpdateParticles(start?: number, stop?: number, update?: boolean): void {}\r\n}\r\n"],
  "mappings": "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AA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KAAA;AACI,aAAO,aAAa,MAAM,OAAO,mCAAoC,GAAA;IACzE,KA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",
  "names": ["name", "name", "name", "transformNode", "name", "name", "name", "result", "_CameraProperty", "name", "name", "name", "name", "name", "name", "mesh", "name", "shader", "name", "shader", "name", "shader", "name", "data", "name", "PLYType", "PLYValue", "name", "ElementMode", "vertexCount", "lineStart", "lineCount", "PointColor", "name", "area", "rotatedY", "rotatedX", "rotatedZ", "colors32", "uvs32"]
}
