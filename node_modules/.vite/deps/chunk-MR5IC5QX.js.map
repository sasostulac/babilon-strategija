{
  "version": 3,
  "sources": ["../../../dev/core/src/ShadersWGSL/iblVoxelGrid.vertex.ts"],
  "sourcesContent": ["// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration\";\n\nconst name = \"iblVoxelGridVertexShader\";\nconst shader = `#include <bakedVertexAnimationDeclaration>\n#include <bonesDeclaration>\n#include <helperFunctions>\n#include <instancesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef VERTEX_PULLING_USE_INDEX_BUFFER\nvar<storage,read> indices : array<u32>;\n#endif\nvar<storage,read> position : array<f32>;uniform world : mat4x4f;uniform invWorldScale: mat4x4f;varying vNormalizedPosition : vec3f;flat varying f_swizzle: i32;fn readVertexPosition(index : u32)->vec3f {var pos : vec3f;pos.x=position[index*3];pos.y=position[index*3+1];pos.z=position[index*3+2];return pos;}\nfn readVertexIndex(index : u32)->u32 {\n#ifndef VERTEX_PULLING_USE_INDEX_BUFFER\nreturn index;\n#else\n#ifdef VERTEX_PULLING_INDEX_BUFFER_32BITS\nreturn indices[index];\n#else\nlet u32_index=index/2u;let bit_offset=(index & 1u)*16u;return (indices[u32_index]>>bit_offset) & 0xFFFFu;\n#endif\n#endif\n}\nfn calculateTriangleNormal(v0\n: vec3<f32>,v1\n: vec3<f32>,v2\n: vec3<f32>)\n->vec3<f32> {let edge1=v1-v0;let edge2=v2-v0;let triangleNormal=cross(edge1,edge2);let normalizedTriangleNormal=normalize(triangleNormal);return normalizedTriangleNormal;}\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var vertIdx=readVertexIndex(input.vertexIndex);var positionUpdated=readVertexPosition(vertIdx);\n#include <morphTargetsVertexGlobal>\nlet inputPosition: vec3f=positionUpdated;\n#include <morphTargetsVertex>(vertexInputs.position\\\\),inputPosition))[0..maxSimultaneousMorphTargets]\n#include <instancesVertex>\n#include <bakedVertexAnimation>\n#include <bonesVertex>\nlet worldPos=finalWorld*vec4f(positionUpdated,1.0);vertexOutputs.position=uniforms.invWorldScale*worldPos;var provokingVertNum : u32=input.vertexIndex/3*3;var pos0=readVertexPosition(readVertexIndex(provokingVertNum));var pos1=readVertexPosition(readVertexIndex(provokingVertNum+1));var pos2=readVertexPosition(readVertexIndex(provokingVertNum+2));var N : vec3<f32>=calculateTriangleNormal(pos0,pos1,pos2);N=abs(N);if (N.x>N.y && N.x>N.z) {vertexOutputs.f_swizzle=0;vertexOutputs.position=vec4f(vertexOutputs.position.yzx,1.0);} else if (N.y>N.z) {vertexOutputs.f_swizzle=1;vertexOutputs.position=vec4f(vertexOutputs.position.zxy,1.0);} else {vertexOutputs.f_swizzle=2;vertexOutputs.position=vec4f(vertexOutputs.position.xyz,1.0);}\nvertexOutputs.vNormalizedPosition=vertexOutputs.position.xyz*0.5+0.5;vertexOutputs.position.z =\nvertexOutputs.vNormalizedPosition.z; }\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const iblVoxelGridVertexShaderWGSL = { name, shader };\n"],
  "mappings": ";;;;;AAKA,IAAM,OAAO;AACb,IAAM,SAAS;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCf,IAAI,CAAC,YAAY,iBAAiB,IAAI,GAAG;AACrC,cAAY,iBAAiB,IAAI,IAAI;AACzC;AAEO,IAAM,+BAA+B,EAAE,MAAM,OAAM;",
  "names": []
}
