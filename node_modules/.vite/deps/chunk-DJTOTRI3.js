import {
  Light,
  ShadowLight
} from "./chunk-RHCBFNJ7.js";
import {
  PointerEventTypes,
  PointerInfo,
  PointerInfoPre
} from "./chunk-DXY34PCZ.js";
import {
  Node
} from "./chunk-APKXS56O.js";
import {
  UniqueIdGenerator
} from "./chunk-WKXRXUEO.js";
import {
  UniformBuffer
} from "./chunk-FXYS7N6E.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareStringDefinesForClipPlanes,
  PushAttributesForInstances
} from "./chunk-2VHVG2NH.js";
import {
  Engine,
  Frustum,
  ObjectRenderer,
  PostProcess,
  PostProcessManager,
  RenderTargetTexture,
  RenderingManager,
  SmartArray,
  SmartArrayNoDuplicate
} from "./chunk-X4TNHLCS.js";
import {
  PerfCounter
} from "./chunk-LJSODA3L.js";
import {
  LightConstants
} from "./chunk-WAGTS43G.js";
import {
  Texture
} from "./chunk-IKA6V2KA.js";
import {
  SerializationHelper,
  Tags
} from "./chunk-S6GWJ2HV.js";
import {
  __decorate,
  serialize,
  serializeAsColor4,
  serializeAsColorCurves,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-URVCX2UN.js";
import {
  Color3,
  Color4
} from "./chunk-5HS37WJT.js";
import {
  InvertMatrixToRef,
  Matrix,
  MultiplyMatricesToRef,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-EURVBQY7.js";
import {
  BuildArray,
  Epsilon,
  _ObserveArray
} from "./chunk-JKI5MLKH.js";
import {
  DrawWrapper,
  EffectWrapper,
  Viewport
} from "./chunk-SMWNVZJL.js";
import {
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  Tools
} from "./chunk-LNRVDUKV.js";
import {
  LoadFile,
  ReadFile,
  RequestFile
} from "./chunk-3HK5Y47I.js";
import {
  GetClass,
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Mix
} from "./chunk-I4NFOKIT.js";
import {
  Effect,
  _RetryWithInterval
} from "./chunk-OF4ZSZ6U.js";
import {
  _WarnImport
} from "./chunk-OWCZTH5B.js";
import {
  IsNavigatorAvailable,
  IsWindowObjectExist,
  PrecisionDate
} from "./chunk-AZNEH5GV.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager = class _AbstractActionManager {
  constructor() {
    this.hoverCursor = "";
    this.actions = [];
    this.isRecursive = false;
    this.disposeWhenUnowned = true;
  }
  /**
   * Does exist one action manager with at least one trigger
   **/
  static get HasTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Does exist one action manager with at least one pick trigger
   **/
  static get HasPickTriggers() {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt >= 1 && tAsInt <= 7) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Does exist one action manager that handles actions of a given trigger
   * @param trigger defines the trigger to be tested
   * @returns a boolean indicating whether the trigger is handled by at least one action manager
   **/
  static HasSpecificTrigger(trigger) {
    for (const t in _AbstractActionManager.Triggers) {
      if (Object.prototype.hasOwnProperty.call(_AbstractActionManager.Triggers, t)) {
        const tAsInt = parseInt(t);
        if (tAsInt === trigger) {
          return true;
        }
      }
    }
    return false;
  }
};
AbstractActionManager.Triggers = {};

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent = class _ActionEvent {
  /**
   * Creates a new ActionEvent
   * @param source The mesh or sprite that triggered the action
   * @param pointerX The X mouse cursor position at the time of the event
   * @param pointerY The Y mouse cursor position at the time of the event
   * @param meshUnderPointer The mesh that is currently pointed at (can be null)
   * @param sourceEvent the original (browser) event that triggered the ActionEvent
   * @param additionalData additional data for the event
   */
  constructor(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  /**
   * Helper function to auto-create an ActionEvent from a source mesh.
   * @param source The source mesh that triggered the event
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNew(source, evt, additionalData) {
    const scene = source.getScene();
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a source sprite
   * @param source The source sprite that triggered the event
   * @param scene Scene associated with the sprite
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromSprite(source, scene, evt, additionalData) {
    return new _ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  }
  /**
   * Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew
   * @param scene the scene where the event occurred
   * @param evt The original (browser) event
   * @returns the new ActionEvent
   */
  static CreateNewFromScene(scene, evt) {
    return new _ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  }
  /**
   * Helper function to auto-create an ActionEvent from a primitive
   * @param prim defines the target primitive
   * @param pointerPos defines the pointer position
   * @param evt The original (browser) event
   * @param additionalData additional data for the event
   * @returns the new ActionEvent
   */
  static CreateNewFromPrimitive(prim, pointerPos, evt, additionalData) {
    return new _ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  }
};

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary = class {
  constructor() {
    this._count = 0;
    this._data = {};
  }
  /**
   * This will clear this dictionary and copy the content from the 'source' one.
   * If the T value is a custom object, it won't be copied/cloned, the same object will be used
   * @param source the dictionary to take the content from and copy to this dictionary
   */
  copyFrom(source) {
    this.clear();
    source.forEach((t, v) => this.add(t, v));
  }
  /**
   * Get a value based from its key
   * @param key the given key to get the matching value from
   * @returns the value if found, otherwise undefined is returned
   */
  get(key) {
    const val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  }
  /**
   * Get a value from its key or add it if it doesn't exist.
   * This method will ensure you that a given key/data will be present in the dictionary.
   * @param key the given key to get the matching value from
   * @param factory the factory that will create the value if the key is not present in the dictionary.
   * The factory will only be invoked if there's no data for the given key.
   * @returns the value corresponding to the key.
   */
  getOrAddWithFactory(key, factory) {
    let val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  }
  /**
   * Get a value from its key if present in the dictionary otherwise add it
   * @param key the key to get the value from
   * @param val if there's no such key/value pair in the dictionary add it with this value
   * @returns the value corresponding to the key
   */
  getOrAdd(key, val) {
    const curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  }
  /**
   * Check if there's a given key in the dictionary
   * @param key the key to check for
   * @returns true if the key is present, false otherwise
   */
  contains(key) {
    return this._data[key] !== void 0;
  }
  /**
   * Add a new key and its corresponding value
   * @param key the key to add
   * @param value the value corresponding to the key
   * @returns true if the operation completed successfully, false if we couldn't insert the key/value because there was already this key in the dictionary
   */
  add(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  }
  /**
   * Update a specific value associated to a key
   * @param key defines the key to use
   * @param value defines the value to store
   * @returns true if the value was updated (or false if the key was not found)
   */
  set(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  }
  /**
   * Get the element of the given key and remove it from the dictionary
   * @param key defines the key to search
   * @returns the value associated with the key or null if not found
   */
  getAndRemove(key) {
    const val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  }
  /**
   * Remove a key/value from the dictionary.
   * @param key the key to remove
   * @returns true if the item was successfully deleted, false if no item with such key exist in the dictionary
   */
  remove(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  }
  /**
   * Clear the whole content of the dictionary
   */
  clear() {
    this._data = {};
    this._count = 0;
  }
  /**
   * Gets the current count
   */
  get count() {
    return this._count;
  }
  /**
   * Execute a callback on each key/val of the dictionary.
   * Note that you can remove any element in this dictionary in the callback implementation
   * @param callback the callback to execute on a given key/value pair
   */
  forEach(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      callback(cur, val);
    }
  }
  /**
   * Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
   * If the callback returns null or undefined the method will iterate to the next key/value pair
   * Note that you can remove any element in this dictionary in the callback implementation
   * @param callback the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned
   * @returns the first item
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  first(callback) {
    for (const cur in this._data) {
      const val = this._data[cur];
      const res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  }
};

// node_modules/@babylonjs/core/Materials/colorCurves.functions.js
function PrepareUniformsForColorCurves(uniformsList) {
  uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
}

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves = class _ColorCurves {
  constructor() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  /**
   * Gets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get globalHue() {
    return this._globalHue;
  }
  /**
   * Sets the global Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set globalHue(value) {
    this._globalHue = value;
    this._dirty = true;
  }
  /**
   * Gets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get globalDensity() {
    return this._globalDensity;
  }
  /**
   * Sets the global Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set globalDensity(value) {
    this._globalDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get globalSaturation() {
    return this._globalSaturation;
  }
  /**
   * Sets the global Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set globalSaturation(value) {
    this._globalSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get globalExposure() {
    return this._globalExposure;
  }
  /**
   * Sets the global Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set globalExposure(value) {
    this._globalExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get highlightsHue() {
    return this._highlightsHue;
  }
  /**
   * Sets the highlights Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set highlightsHue(value) {
    this._highlightsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  /**
   * Sets the highlights Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set highlightsDensity(value) {
    this._highlightsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  /**
   * Sets the highlights Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set highlightsSaturation(value) {
    this._highlightsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  /**
   * Sets the highlights Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set highlightsExposure(value) {
    this._highlightsExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get midtonesHue() {
    return this._midtonesHue;
  }
  /**
   * Sets the midtones Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set midtonesHue(value) {
    this._midtonesHue = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  /**
   * Sets the midtones Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set midtonesDensity(value) {
    this._midtonesDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  /**
   * Sets the midtones Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set midtonesSaturation(value) {
    this._midtonesSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  /**
   * Sets the midtones Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set midtonesExposure(value) {
    this._midtonesExposure = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  get shadowsHue() {
    return this._shadowsHue;
  }
  /**
   * Sets the shadows Hue value.
   * The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
   */
  set shadowsHue(value) {
    this._shadowsHue = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  /**
   * Sets the shadows Density value.
   * The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
   * Values less than zero provide a filter of opposite hue.
   */
  set shadowsDensity(value) {
    this._shadowsDensity = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  /**
   * Sets the shadows Saturation value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
   */
  set shadowsSaturation(value) {
    this._shadowsSaturation = value;
    this._dirty = true;
  }
  /**
   * Gets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  /**
   * Sets the shadows Exposure value.
   * This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
   */
  set shadowsExposure(value) {
    this._shadowsExposure = value;
    this._dirty = true;
  }
  /**
   * Returns the class name
   * @returns The class name
   */
  getClassName() {
    return "ColorCurves";
  }
  /**
   * Binds the color curves to the shader.
   * @param colorCurves The color curve to bind
   * @param effect The effect to bind to
   * @param positiveUniform The positive uniform shader parameter
   * @param neutralUniform The neutral uniform shader parameter
   * @param negativeUniform The negative uniform shader parameter
   */
  static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  }
  /**
   * Returns color grading data based on a hue, density, saturation and exposure value.
   * @param hue
   * @param density
   * @param saturation The saturation.
   * @param exposure The exposure.
   * @param result The result data container.
   */
  _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = _ColorCurves._Clamp(hue, 0, 360);
    density = _ColorCurves._Clamp(density, -100, 100);
    saturation = _ColorCurves._Clamp(saturation, -100, 100);
    exposure = _ColorCurves._Clamp(exposure, -100, 100);
    density = _ColorCurves._ApplyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = _ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    _ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  }
  /**
   * Takes an input slider value and returns an adjusted value that provides extra control near the centre.
   * @param value The input slider value in range [-100,100].
   * @returns Adjusted value.
   */
  static _ApplyColorGradingSliderNonlinear(value) {
    value /= 100;
    let x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  }
  /**
   * Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).
   * @param hue The hue (H) input.
   * @param saturation The saturation (S) input.
   * @param brightness The brightness (B) input.
   * @param result An RGBA color represented as Vector4.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static _FromHSBToRef(hue, saturation, brightness, result) {
    let h = _ColorCurves._Clamp(hue, 0, 360);
    const s = _ColorCurves._Clamp(saturation / 100, 0, 1);
    const v = _ColorCurves._Clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      const i = Math.floor(h);
      const f = h - i;
      const p = v * (1 - s);
      const q = v * (1 - s * f);
      const t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  }
  /**
   * Returns a value clamped between min and max
   * @param value The value to clamp
   * @param min The minimum of value
   * @param max The maximum of value
   * @returns The clamped value.
   */
  static _Clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  /**
   * Clones the current color curve instance.
   * @returns The cloned curves
   */
  clone() {
    return SerializationHelper.Clone(() => new _ColorCurves(), this);
  }
  /**
   * Serializes the current color curve instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the color curve from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed curves
   */
  static Parse(source) {
    return SerializationHelper.Parse(() => new _ColorCurves(), source, null, null);
  }
};
ColorCurves.PrepareUniforms = PrepareUniformsForColorCurves;
__decorate([
  serialize()
], ColorCurves.prototype, "_globalHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_globalExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_highlightsExposure", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesHue", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesDensity", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesSaturation", void 0);
__decorate([
  serialize()
], ColorCurves.prototype, "_midtonesExposure", void 0);
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.functions.js
function PrepareUniformsForImageProcessing(uniforms, defines) {
  if (defines.EXPOSURE) {
    uniforms.push("exposureLinear");
  }
  if (defines.CONTRAST) {
    uniforms.push("contrast");
  }
  if (defines.COLORGRADING) {
    uniforms.push("colorTransformSettings");
  }
  if (defines.VIGNETTE || defines.DITHER) {
    uniforms.push("vInverseScreenSize");
  }
  if (defines.VIGNETTE) {
    uniforms.push("vignetteSettings1");
    uniforms.push("vignetteSettings2");
  }
  if (defines.COLORCURVES) {
    PrepareUniformsForColorCurves(uniforms);
  }
  if (defines.DITHER) {
    uniforms.push("ditherIntensity");
  }
}
function PrepareSamplersForImageProcessing(samplersList, defines) {
  if (defines.COLORGRADING) {
    samplersList.push("txColorTransform");
  }
}

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfiguration = class _ImageProcessingConfiguration {
  constructor() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = _ImageProcessingConfiguration.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCenterX = 0;
    this.vignetteCenterY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = _ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._ditheringEnabled = false;
    this._ditheringIntensity = 1 / 255;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.outputTextureWidth = 0;
    this.outputTextureHeight = 0;
    this.onUpdateParameters = new Observable();
  }
  /**
   * Gets whether the color curves effect is enabled.
   */
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  /**
   * Sets whether the color curves effect is enabled.
   */
  set colorCurvesEnabled(value) {
    if (this._colorCurvesEnabled === value) {
      return;
    }
    this._colorCurvesEnabled = value;
    this._updateParameters();
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  /**
   * Color grading LUT texture used in the effect if colorGradingEnabled is set to true
   */
  set colorGradingTexture(value) {
    if (this._colorGradingTexture === value) {
      return;
    }
    this._colorGradingTexture = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is enabled.
   */
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  /**
   * Sets whether the color grading effect is enabled.
   */
  set colorGradingEnabled(value) {
    if (this._colorGradingEnabled === value) {
      return;
    }
    this._colorGradingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading effect is using a green depth for the 3d Texture.
   */
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  /**
   * Sets whether the color grading effect is using a green depth for the 3d Texture.
   */
  set colorGradingWithGreenDepth(value) {
    if (this._colorGradingWithGreenDepth === value) {
      return;
    }
    this._colorGradingWithGreenDepth = value;
    this._updateParameters();
  }
  /**
   * Gets whether the color grading texture contains BGR values.
   */
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  /**
   * Sets whether the color grading texture contains BGR values.
   */
  set colorGradingBGR(value) {
    if (this._colorGradingBGR === value) {
      return;
    }
    this._colorGradingBGR = value;
    this._updateParameters();
  }
  /**
   * Gets the Exposure used in the effect.
   */
  get exposure() {
    return this._exposure;
  }
  /**
   * Sets the Exposure used in the effect.
   */
  set exposure(value) {
    if (this._exposure === value) {
      return;
    }
    this._exposure = value;
    this._updateParameters();
  }
  /**
   * Gets whether the tone mapping effect is enabled.
   */
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  /**
   * Sets whether the tone mapping effect is enabled.
   */
  set toneMappingEnabled(value) {
    if (this._toneMappingEnabled === value) {
      return;
    }
    this._toneMappingEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the type of tone mapping effect.
   */
  get toneMappingType() {
    return this._toneMappingType;
  }
  /**
   * Sets the type of tone mapping effect used in BabylonJS.
   */
  set toneMappingType(value) {
    if (this._toneMappingType === value) {
      return;
    }
    this._toneMappingType = value;
    this._updateParameters();
  }
  /**
   * Gets the contrast used in the effect.
   */
  get contrast() {
    return this._contrast;
  }
  /**
   * Sets the contrast used in the effect.
   */
  set contrast(value) {
    if (this._contrast === value) {
      return;
    }
    this._contrast = value;
    this._updateParameters();
  }
  /**
   * Back Compat: Vignette center Y Offset.
   * @deprecated use vignetteCenterY instead
   */
  get vignetteCentreY() {
    return this.vignetteCenterY;
  }
  set vignetteCentreY(value) {
    this.vignetteCenterY = value;
  }
  /**
   * Back Compat: Vignette center X Offset.
   * @deprecated use vignetteCenterX instead
   */
  get vignetteCentreX() {
    return this.vignetteCenterX;
  }
  set vignetteCentreX(value) {
    this.vignetteCenterX = value;
  }
  /**
   * Gets the vignette blend mode allowing different kind of effect.
   */
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  /**
   * Sets the vignette blend mode allowing different kind of effect.
   */
  set vignetteBlendMode(value) {
    if (this._vignetteBlendMode === value) {
      return;
    }
    this._vignetteBlendMode = value;
    this._updateParameters();
  }
  /**
   * Gets whether the vignette effect is enabled.
   */
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  /**
   * Sets whether the vignette effect is enabled.
   */
  set vignetteEnabled(value) {
    if (this._vignetteEnabled === value) {
      return;
    }
    this._vignetteEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  /**
   * Sets whether the dithering effect is enabled.
   * The dithering effect can be used to reduce banding.
   */
  set ditheringEnabled(value) {
    if (this._ditheringEnabled === value) {
      return;
    }
    this._ditheringEnabled = value;
    this._updateParameters();
  }
  /**
   * Gets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  /**
   * Sets the dithering intensity. 0 is no dithering. Default is 1.0 / 255.0.
   */
  set ditheringIntensity(value) {
    if (this._ditheringIntensity === value) {
      return;
    }
    this._ditheringIntensity = value;
    this._updateParameters();
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  /**
   * If apply by post process is set to true, setting this to true will skip the final color clamp step in the fragment shader
   * Applies to PBR materials.
   */
  set skipFinalColorClamp(value) {
    if (this._skipFinalColorClamp === value) {
      return;
    }
    this._skipFinalColorClamp = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is applied through a post process or not.
   */
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  /**
   * Sets whether the image processing is applied through a post process or not.
   */
  set applyByPostProcess(value) {
    if (this._applyByPostProcess === value) {
      return;
    }
    this._applyByPostProcess = value;
    this._updateParameters();
  }
  /**
   * Gets whether the image processing is enabled or not.
   */
  get isEnabled() {
    return this._isEnabled;
  }
  /**
   * Sets whether the image processing is enabled or not.
   */
  set isEnabled(value) {
    if (this._isEnabled === value) {
      return;
    }
    this._isEnabled = value;
    this._updateParameters();
  }
  /**
   * Method called each time the image processing information changes requires to recompile the effect.
   */
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  /**
   * Gets the current class name.
   * @returns "ImageProcessingConfiguration"
   */
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  /**
   * Prepare the list of defines associated to the shader.
   * @param defines the list of defines to complete
   * @param forPostProcess Define if we are currently in post process mode or not
   */
  prepareDefines(defines, forPostProcess = false) {
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = 0;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.DITHER = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === _ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    if (!this._toneMappingEnabled) {
      defines.TONEMAPPING = 0;
    } else {
      switch (this._toneMappingType) {
        case _ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL:
          defines.TONEMAPPING = 3;
          break;
        case _ImageProcessingConfiguration.TONEMAPPING_ACES:
          defines.TONEMAPPING = 2;
          break;
        default:
          defines.TONEMAPPING = 1;
          break;
      }
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.DITHER = this._ditheringEnabled;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || !!defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
  }
  /**
   * Returns true if all the image processing information are ready.
   * @returns True if ready, otherwise, false
   */
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  /**
   * Binds the image processing to the shader.
   * @param effect The effect to bind to
   * @param overrideAspectRatio Override the aspect ratio of the effect
   */
  bind(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled || this._ditheringEnabled) {
      const inverseWidth = 1 / (this.outputTextureWidth || effect.getEngine().getRenderWidth());
      const inverseHeight = 1 / (this.outputTextureHeight || effect.getEngine().getRenderHeight());
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      if (this._ditheringEnabled) {
        effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
      }
      if (this._vignetteEnabled) {
        const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
        let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
        let vignetteScaleX = vignetteScaleY * aspectRatio;
        const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
        vignetteScaleX = Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
        vignetteScaleY = Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
        effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
        const vignettePower = -2 * this.vignetteWeight;
        effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
      }
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      const textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4(
        "colorTransformSettings",
        (textureSize - 1) / textureSize,
        // textureScale
        0.5 / textureSize,
        // textureOffset
        textureSize,
        // textureSize
        this.colorGradingTexture.level
        // weight
      );
    }
  }
  /**
   * Clones the current image processing instance.
   * @returns The cloned image processing
   */
  clone() {
    return SerializationHelper.Clone(() => new _ImageProcessingConfiguration(), this);
  }
  /**
   * Serializes the current image processing instance to a json representation.
   * @returns a JSON representation
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses the image processing from a json representation.
   * @param source the JSON source to parse
   * @returns The parsed image processing
   */
  static Parse(source) {
    const parsed = SerializationHelper.Parse(() => new _ImageProcessingConfiguration(), source, null, null);
    if (source.vignetteCentreX !== void 0) {
      parsed.vignetteCenterX = source.vignetteCentreX;
    }
    if (source.vignetteCentreY !== void 0) {
      parsed.vignetteCenterY = source.vignetteCentreY;
    }
    return parsed;
  }
  /**
   * Used to apply the vignette as a mix with the pixel color.
   */
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  /**
   * Used to apply the vignette as a replacement of the pixel color.
   */
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
};
ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
ImageProcessingConfiguration.TONEMAPPING_KHR_PBR_NEUTRAL = 2;
ImageProcessingConfiguration.PrepareUniforms = PrepareUniformsForImageProcessing;
ImageProcessingConfiguration.PrepareSamplers = PrepareSamplersForImageProcessing;
ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
__decorate([
  serializeAsColorCurves()
], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
__decorate([
  serializeAsTexture("colorGradingTexture")
], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_exposure", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_contrast", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
__decorate([
  serializeAsColor4()
], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureWidth", void 0);
__decorate([
  serialize()
], ImageProcessingConfiguration.prototype, "outputTextureHeight", void 0);
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
RegisterClass("BABYLON.ImageProcessingConfiguration", ImageProcessingConfiguration);

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo = class {
  constructor() {
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.ray = null;
    this.originMesh = null;
    this.aimTransform = null;
    this.gripTransform = null;
  }
  /**
   * Gets the normal corresponding to the face the pick collided with
   * @param useWorldCoordinates If the resulting normal should be relative to the world (default: false)
   * @param useVerticesNormals If the vertices normals should be used to calculate the normal instead of the normal map (default: true)
   * @returns The normal corresponding to the face the pick collided with
   * @remarks Note that the returned normal will always point towards the picking ray.
   */
  getNormal(useWorldCoordinates = false, useVerticesNormals = true) {
    if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    let indices = this.pickedMesh.getIndices();
    if (indices?.length === 0) {
      indices = null;
    }
    let result;
    const tmp0 = TmpVectors.Vector3[0];
    const tmp1 = TmpVectors.Vector3[1];
    const tmp2 = TmpVectors.Vector3[2];
    if (useVerticesNormals) {
      const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      let normal0 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);
      let normal1 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);
      let normal2 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      const vertex1 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);
      const vertex2 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);
      const vertex3 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);
      const p1p2 = vertex1.subtract(vertex2);
      const p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    const transformNormalToWorld = (pickedMesh, n) => {
      if (this.thinInstanceIndex !== -1) {
        const tm = pickedMesh.thinInstanceGetWorldMatrices()[this.thinInstanceIndex];
        if (tm) {
          Vector3.TransformNormalToRef(n, tm, n);
        }
      }
      let wm = pickedMesh.getWorldMatrix();
      if (pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      Vector3.TransformNormalToRef(n, wm, n);
    };
    if (useWorldCoordinates) {
      transformNormalToWorld(this.pickedMesh, result);
    }
    if (this.ray) {
      const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);
      if (!useWorldCoordinates) {
        transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);
      }
      if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {
        result.negateInPlace();
      }
    }
    result.normalize();
    return result;
  }
  /**
   * Gets the texture coordinates of where the pick occurred
   * @param uvSet The UV set to use to calculate the texture coordinates (default: VertexBuffer.UVKind)
   * @returns The vector containing the coordinates of the texture
   */
  getTextureCoordinates(uvSet = VertexBuffer.UVKind) {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {
      return null;
    }
    const indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    const uvs = this.pickedMesh.getVerticesData(uvSet);
    if (!uvs) {
      return null;
    }
    let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  }
};

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants = class {
};
SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
SceneComponentConstants.NAME_LAYER = "Layer";
SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
SceneComponentConstants.NAME_SPRITE = "Sprite";
SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
SceneComponentConstants.NAME_OCTREE = "Octree";
SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
SceneComponentConstants.NAME_AUDIO = "Audio";
SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
SceneComponentConstants.NAME_IBLCDFGENERATOR = "iblCDFGenerator";
SceneComponentConstants.NAME_CLUSTEREDLIGHTING = "ClusteredLighting";
SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_CLUSTEREDLIGHTING = 2;
SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
var Stage = class _Stage extends Array {
  /**
   * Hide ctor from the rest of the world.
   * @param items The items to add.
   */
  constructor(items) {
    super(...items);
  }
  /**
   * Creates a new Stage.
   * @returns A new instance of a Stage
   */
  static Create() {
    return Object.create(_Stage.prototype);
  }
  /**
   * Registers a step in an ordered way in the targeted stage.
   * @param index Defines the position to register the step in
   * @param component Defines the component attached to the step
   * @param action Defines the action to launch during the step
   */
  registerStep(index, component, action) {
    let i = 0;
    let maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      const step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  }
  /**
   * Clears all the steps from the stage.
   */
  clear() {
    this.length = 0;
  }
};

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes = class {
};
KeyboardEventTypes.KEYDOWN = 1;
KeyboardEventTypes.KEYUP = 2;
var KeyboardInfo = class {
  /**
   * Instantiates a new keyboard info.
   * This class is used to store keyboard related info for the onKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    this.type = type;
    this.event = event;
  }
};
var KeyboardInfoPre = class extends KeyboardInfo {
  /**
   * Defines whether the engine should skip the next onKeyboardObservable associated to this pre.
   * @deprecated use skipOnKeyboardObservable property instead
   */
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(value) {
    this.skipOnKeyboardObservable = value;
  }
  /**
   * Instantiates a new keyboard pre info.
   * This class is used to store keyboard related info for the onPreKeyboardObservable event.
   * @param type Defines the type of event (KeyboardEventTypes)
   * @param event Defines the related dom event
   */
  constructor(type, event) {
    super(type, event);
    this.type = type;
    this.event = event;
    this.skipOnKeyboardObservable = false;
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
  DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
  PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  PointerInput2[PointerInput2["Move"] = 12] = "Move";
})(PointerInput || (PointerInput = {}));
var NativePointerInput;
(function(NativePointerInput2) {
  NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
  NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
  NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
  NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
  NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
  NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
  NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
  NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
  NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
})(NativePointerInput || (NativePointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var DualSenseInput;
(function(DualSenseInput2) {
  DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
  DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
  DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
  DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
  DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
  DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
  DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
  DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
  DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
  DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
  DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
  DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
  DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
  DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
  DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
  DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
  DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
  DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
  DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualSenseInput || (DualSenseInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = class {
};
EventConstants.DOM_DELTA_PIXEL = 0;
EventConstants.DOM_DELTA_LINE = 1;
EventConstants.DOM_DELTA_PAGE = 2;

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js
var DeviceSource = class {
  /**
   * Default Constructor
   * @param deviceInputSystem - Reference to DeviceInputSystem
   * @param deviceType - Type of device
   * @param deviceSlot - "Slot" or index that device is referenced in
   */
  constructor(deviceInputSystem, deviceType, deviceSlot = 0) {
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  /**
   * Get input for specific input
   * @param inputIndex - index of specific input on device
   * @returns Input value from DeviceInputSystem
   */
  getInput(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  }
};

// node_modules/@babylonjs/core/DeviceInput/eventFactory.js
var DeviceEventFactory = class {
  /**
   * Create device input events based on provided type and slot
   *
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @param pointerId PointerId to use for pointer events
   * @returns IUIEvent object
   */
  static CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
    switch (deviceType) {
      case DeviceType.Keyboard:
        return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      case DeviceType.Mouse:
        if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
          return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        }
      // eslint-disable-next-line no-fallthrough
      case DeviceType.Touch:
        return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId);
      default:
        throw `Unable to generate event for device ${DeviceType[deviceType]}`;
    }
  }
  /**
   * Creates pointer event
   *
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @param pointerId PointerId to use for pointer events
   * @returns IUIEvent object (Pointer)
   */
  static _CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    if (deviceType === DeviceType.Mouse) {
      evt.deviceType = DeviceType.Mouse;
      evt.pointerId = 1;
      evt.pointerType = "mouse";
    } else {
      evt.deviceType = DeviceType.Touch;
      evt.pointerId = pointerId ?? deviceSlot;
      evt.pointerType = "touch";
    }
    let buttons = 0;
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.LeftClick);
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.RightClick) * 2;
    buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MiddleClick) * 4;
    evt.buttons = buttons;
    if (inputIndex === PointerInput.Move) {
      evt.type = "pointermove";
    } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
      evt.type = currentState === 1 ? "pointerdown" : "pointerup";
      evt.button = inputIndex - 2;
    }
    return evt;
  }
  /**
   * Create Mouse Wheel Event
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IUIEvent object (Wheel)
   */
  static _CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    evt.pointerId = 1;
    evt.type = "wheel";
    evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
    evt.deltaX = 0;
    evt.deltaY = 0;
    evt.deltaZ = 0;
    switch (inputIndex) {
      case PointerInput.MouseWheelX:
        evt.deltaX = currentState;
        break;
      case PointerInput.MouseWheelY:
        evt.deltaY = currentState;
        break;
      case PointerInput.MouseWheelZ:
        evt.deltaZ = currentState;
        break;
    }
    return evt;
  }
  /**
   * Create Mouse Event
   * @param deviceType Type of device
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IUIEvent object (Mouse)
   */
  static _CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    const pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
    const pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
    if (elementToAttachTo) {
      evt.movementX = 0;
      evt.movementY = 0;
      evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
      evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
    } else {
      evt.movementX = deviceInputSystem.pollInput(
        deviceType,
        deviceSlot,
        10
        /* NativePointerInput.DeltaHorizontal */
      );
      evt.movementY = deviceInputSystem.pollInput(
        deviceType,
        deviceSlot,
        11
        /* NativePointerInput.DeltaVertical */
      );
      evt.offsetX = 0;
      evt.offsetY = 0;
    }
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.clientX = pointerX;
    evt.clientY = pointerY;
    evt.x = pointerX;
    evt.y = pointerY;
    evt.deviceType = deviceType;
    evt.deviceSlot = deviceSlot;
    evt.inputIndex = inputIndex;
    return evt;
  }
  /**
   * Create Keyboard Event
   * @param inputIndex Id of input to be checked
   * @param currentState Current value for given input
   * @param deviceInputSystem Reference to DeviceInputSystem
   * @param elementToAttachTo HTMLElement to reference as target for inputs
   * @returns IEvent object (Keyboard)
   */
  static _CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    const evt = this._CreateEvent(elementToAttachTo);
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.deviceType = DeviceType.Keyboard;
    evt.deviceSlot = 0;
    evt.inputIndex = inputIndex;
    evt.type = currentState === 1 ? "keydown" : "keyup";
    evt.key = String.fromCharCode(inputIndex);
    evt.keyCode = inputIndex;
    return evt;
  }
  /**
   * Add parameters for non-character keys (Ctrl, Alt, Meta, Shift)
   * @param evt Event object to add parameters to
   * @param deviceInputSystem DeviceInputSystem to pull values from
   */
  static _CheckNonCharacterKeys(evt, deviceInputSystem) {
    const isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
    const altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
    const ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
    const metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
    const shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
    evt.altKey = altKey;
    evt.ctrlKey = ctrlKey;
    evt.metaKey = metaKey;
    evt.shiftKey = shiftKey;
  }
  /**
   * Create base event object
   * @param elementToAttachTo Value to use as event target
   * @returns
   */
  static _CreateEvent(elementToAttachTo) {
    const evt = {};
    evt.preventDefault = () => {
    };
    evt.target = elementToAttachTo;
    return evt;
  }
};

// node_modules/@babylonjs/core/DeviceInput/nativeDeviceInputSystem.js
var NativeDeviceInputSystem = class {
  constructor(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, (deviceType, deviceSlot, inputIndex, currentState) => {
      const evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, this);
      onInputChanged(deviceType, deviceSlot, evt);
    }) : this._createDummyNativeInput();
  }
  // Public functions
  /**
   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @returns Current value of input
   */
  pollInput(deviceType, deviceSlot, inputIndex) {
    return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
  }
  /**
   * Check for a specific device in the DeviceInputSystem
   * @param deviceType Type of device to check for
   * @returns bool with status of device's existence
   */
  isDeviceAvailable(deviceType) {
    return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
  }
  /**
   * Dispose of all the observables
   */
  dispose() {
    this._nativeInput.dispose();
  }
  /**
   * For versions of BabylonNative that don't have the NativeInput plugin initialized, create a dummy version
   * @returns Object with dummy functions
   */
  _createDummyNativeInput() {
    const nativeInput = {
      pollInput: () => {
        return 0;
      },
      isDeviceAvailable: () => {
        return false;
      },
      dispose: () => {
      }
    };
    return nativeInput;
  }
};

// node_modules/@babylonjs/core/DeviceInput/webDeviceInputSystem.js
var MAX_KEYCODES = 255;
var MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
var WebDeviceInputSystem = class {
  /**
   * Constructor for the WebDeviceInputSystem
   * @param engine Engine to reference
   * @param onDeviceConnected Callback to execute when device is connected
   * @param onDeviceDisconnected Callback to execute when device is disconnected
   * @param onInputChanged Callback to execute when input changes on device
   */
  constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._usingSafari = Tools.IsSafari();
    this._usingMacOs = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
    this._keyboardDownEvent = (evt) => {
    };
    this._keyboardUpEvent = (evt) => {
    };
    this._keyboardBlurEvent = (evt) => {
    };
    this._pointerMoveEvent = (evt) => {
    };
    this._pointerDownEvent = (evt) => {
    };
    this._pointerUpEvent = (evt) => {
    };
    this._pointerCancelEvent = (evt) => {
    };
    this._pointerCancelTouch = (pointerId) => {
    };
    this._pointerLeaveEvent = (evt) => {
    };
    this._pointerWheelEvent = (evt) => {
    };
    this._pointerBlurEvent = (evt) => {
    };
    this._pointerMacOsChromeOutEvent = (evt) => {
    };
    this._eventsAttached = false;
    this._mouseId = -1;
    this._isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
    this._isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Chrome") !== -1;
    this._maxTouchPoints = 0;
    this._pointerInputClearObserver = null;
    this._gamepadConnectedEvent = (evt) => {
    };
    this._gamepadDisconnectedEvent = (evt) => {
    };
    this._eventPrefix = Tools.GetPointerPrefix(engine);
    this._engine = engine;
    this._onDeviceConnected = onDeviceConnected;
    this._onDeviceDisconnected = onDeviceDisconnected;
    this._onInputChanged = onInputChanged;
    this._mouseId = this._isUsingFirefox ? 0 : 1;
    this._enableEvents();
    if (this._usingMacOs) {
      this._metaKeys = [];
    }
    if (!this._engine._onEngineViewChanged) {
      this._engine._onEngineViewChanged = () => {
        this._enableEvents();
      };
    }
  }
  // Public functions
  /**
   * Checks for current device input value, given an id and input index. Throws exception if requested device not initialized.
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   * @returns Current value of input
   */
  pollInput(deviceType, deviceSlot, inputIndex) {
    const device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw `Unable to find device ${DeviceType[deviceType]}`;
    }
    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {
      this._updateDevice(deviceType, deviceSlot, inputIndex);
    }
    const currentValue = device[inputIndex];
    if (currentValue === void 0) {
      throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;
    }
    if (inputIndex === PointerInput.Move) {
      Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);
    }
    return currentValue;
  }
  /**
   * Check for a specific device in the DeviceInputSystem
   * @param deviceType Type of device to check for
   * @returns bool with status of device's existence
   */
  isDeviceAvailable(deviceType) {
    return this._inputs[deviceType] !== void 0;
  }
  /**
   * Dispose of all the eventlisteners
   */
  dispose() {
    this._onDeviceConnected = () => {
    };
    this._onDeviceDisconnected = () => {
    };
    this._onInputChanged = () => {
    };
    delete this._engine._onEngineViewChanged;
    if (this._elementToAttachTo) {
      this._disableEvents();
    }
  }
  /**
   * Enable listening for user input events
   */
  _enableEvents() {
    const inputElement = this?._engine.getInputElement();
    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
      this._disableEvents();
      if (this._inputs) {
        for (const inputs of this._inputs) {
          if (inputs) {
            for (const deviceSlotKey in inputs) {
              const deviceSlot = +deviceSlotKey;
              const device = inputs[deviceSlot];
              if (device) {
                for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {
                  device[inputIndex] = 0;
                }
              }
            }
          }
        }
      }
      this._elementToAttachTo = inputElement;
      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._eventsAttached = true;
      this._checkForConnectedDevices();
    }
  }
  /**
   * Disable listening for user input events
   */
  _disableEvents() {
    if (this._elementToAttachTo) {
      this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
      this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
      this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
      this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "leave", this._pointerLeaveEvent);
      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
      if (this._usingMacOs && this._isUsingChromium) {
        this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOsChromeOutEvent);
      }
      window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
      window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    }
    if (this._pointerInputClearObserver) {
      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
    }
    this._eventsAttached = false;
  }
  /**
   * Checks for existing connections to devices and register them, if necessary
   * Currently handles gamepads and mouse
   */
  _checkForConnectedDevices() {
    if (navigator.getGamepads) {
      const gamepads = navigator.getGamepads();
      for (const gamepad of gamepads) {
        if (gamepad) {
          this._addGamePad(gamepad);
        }
      }
    }
    if (typeof matchMedia === "function" && matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  }
  // Private functions
  /**
   * Add a gamepad to the DeviceInputSystem
   * @param gamepad A single DOM Gamepad object
   */
  _addGamePad(gamepad) {
    const deviceType = this._getGamepadDeviceType(gamepad.id);
    const deviceSlot = gamepad.index;
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads[deviceSlot] = deviceType;
  }
  /**
   * Add pointer device to DeviceInputSystem
   * @param deviceType Type of Pointer to add
   * @param deviceSlot Pointer ID (0 for mouse, pointerId for Touch)
   * @param currentX Current X at point of adding
   * @param currentY Current Y at point of adding
   */
  _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {
    if (!this._pointerActive) {
      this._pointerActive = true;
    }
    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
    const pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  }
  /**
   * Add device and inputs to device array
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param numberOfInputs Number of input entries to create for given device
   */
  _registerDevice(deviceType, deviceSlot, numberOfInputs) {
    if (deviceSlot === void 0) {
      throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;
    }
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = {};
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      const device = new Array(numberOfInputs);
      device.fill(0);
      this._inputs[deviceType][deviceSlot] = device;
      this._onDeviceConnected(deviceType, deviceSlot);
    }
  }
  /**
   * Given a specific device name, remove that device from the device map
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   */
  _unregisterDevice(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this._onDeviceDisconnected(deviceType, deviceSlot);
    }
  }
  /**
   * Handle all actions that come from keyboard interaction
   */
  _handleKeyActions() {
    this._keyboardDownEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOs && evt.metaKey && evt.key !== "Meta") {
          if (!this._metaKeys.includes(evt.keyCode)) {
            this._metaKeys.push(evt.keyCode);
          }
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardUpEvent = (evt) => {
      if (!this._keyboardActive) {
        this._keyboardActive = true;
        this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      const kbKey = this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 0;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        if (this._usingMacOs && evt.key === "Meta" && this._metaKeys.length > 0) {
          for (const keyCode of this._metaKeys) {
            const deviceEvent2 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);
            kbKey[keyCode] = 0;
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent2);
          }
          this._metaKeys.splice(0, this._metaKeys.length);
        }
        this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardBlurEvent = () => {
      if (this._keyboardActive) {
        const kbKey = this._inputs[DeviceType.Keyboard][0];
        for (let i = 0; i < kbKey.length; i++) {
          if (kbKey[i] !== 0) {
            kbKey[i] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        }
        if (this._usingMacOs) {
          this._metaKeys.splice(0, this._metaKeys.length);
        }
      }
    };
    this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
    this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
    this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }
  /**
   * Handle all actions that come from pointer interaction
   */
  _handlePointerActions() {
    this._maxTouchPoints = IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
    if (!this._activeTouchIds) {
      this._activeTouchIds = new Array(this._maxTouchPoints);
    }
    for (let i = 0; i < this._maxTouchPoints; i++) {
      this._activeTouchIds[i] = -1;
    }
    this._pointerMoveEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch && deviceSlot === -1) {
        const idx = this._activeTouchIds.indexOf(-1);
        if (idx >= 0) {
          deviceSlot = idx;
          this._activeTouchIds[idx] = evt.pointerId;
          this._onDeviceConnected(deviceType, deviceSlot);
        } else {
          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const deviceEvent = evt;
        deviceEvent.inputIndex = PointerInput.Move;
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {
          pointer[PointerInput.LeftClick] = 1;
        }
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (!this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerDownEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
      if (deviceType === DeviceType.Touch) {
        let idx = this._activeTouchIds.indexOf(evt.pointerId);
        if (idx === -1) {
          idx = this._activeTouchIds.indexOf(-1);
        }
        if (idx >= 0) {
          deviceSlot = idx;
          this._activeTouchIds[idx] = evt.pointerId;
        } else {
          Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = {};
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      } else if (deviceType === DeviceType.Touch) {
        this._onDeviceConnected(deviceType, deviceSlot);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        if (deviceType === DeviceType.Mouse) {
          if (evt.pointerId === void 0) {
            evt.pointerId = this._mouseId;
          }
          if (!document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(this._mouseId);
            } catch (e) {
            }
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement) {
            try {
              this._elementToAttachTo.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
          }
        }
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 1;
        const deviceEvent = evt;
        deviceEvent.inputIndex = evt.button + 2;
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerUpEvent = (evt) => {
      const deviceType = this._getPointerType(evt);
      const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch) {
        if (deviceSlot === -1) {
          return;
        } else {
          this._activeTouchIds[deviceSlot] = -1;
        }
      }
      const pointer = this._inputs[deviceType]?.[deviceSlot];
      let button = evt.button;
      let shouldProcessPointerUp = pointer && pointer[button + 2] !== 0;
      if (!shouldProcessPointerUp && this._isUsingFirefox && this._usingMacOs && pointer) {
        button = button === 2 ? 0 : 2;
        shouldProcessPointerUp = pointer[button + 2] !== 0;
      }
      if (shouldProcessPointerUp) {
        const previousHorizontal = pointer[PointerInput.Horizontal];
        const previousVertical = pointer[PointerInput.Vertical];
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[button + 2] = 0;
        const deviceEvent = evt;
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        deviceEvent.inputIndex = button + 2;
        if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        } else if (evt.pointerId && this._elementToAttachTo.hasPointerCapture?.(evt.pointerId)) {
          this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (deviceType === DeviceType.Touch) {
          this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
    };
    this._pointerCancelTouch = (pointerId) => {
      const deviceSlot = this._activeTouchIds.indexOf(pointerId);
      if (deviceSlot === -1) {
        return;
      }
      if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {
        this._elementToAttachTo.releasePointerCapture(pointerId);
      }
      this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
      const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);
      this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
      this._activeTouchIds[deviceSlot] = -1;
      this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
    };
    this._pointerCancelEvent = (evt) => {
      if (evt.pointerType === "mouse") {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      } else {
        this._pointerCancelTouch(evt.pointerId);
      }
    };
    this._pointerLeaveEvent = (evt) => {
      if (evt.pointerType === "pen") {
        this._pointerCancelTouch(evt.pointerId);
      }
    };
    this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let passiveSupported = false;
    const noop = function() {
    };
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
        }
      });
      this._elementToAttachTo.addEventListener("test", noop, options);
      this._elementToAttachTo.removeEventListener("test", noop, options);
    } catch (e) {
    }
    this._pointerBlurEvent = () => {
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        if (this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId)) {
          this._elementToAttachTo.releasePointerCapture(this._mouseId);
        }
        for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
            this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      }
      if (this.isDeviceAvailable(DeviceType.Touch)) {
        const pointer = this._inputs[DeviceType.Touch];
        for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {
          const pointerId = this._activeTouchIds[deviceSlot];
          if (this._elementToAttachTo.hasPointerCapture?.(pointerId)) {
            this._elementToAttachTo.releasePointerCapture(pointerId);
          }
          if (pointerId !== -1 && pointer[deviceSlot]?.[PointerInput.LeftClick] === 1) {
            pointer[deviceSlot][PointerInput.LeftClick] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);
            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            this._activeTouchIds[deviceSlot] = -1;
            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        }
      }
    };
    this._pointerWheelEvent = (evt) => {
      const deviceType = DeviceType.Mouse;
      const deviceSlot = 0;
      if (!this._inputs[deviceType]) {
        this._inputs[deviceType] = [];
      }
      if (!this._inputs[deviceType][deviceSlot]) {
        this._pointerActive = true;
        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
      }
      const pointer = this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
        const deviceEvent = evt;
        if (evt.pointerId === void 0) {
          evt.pointerId = this._mouseId;
        }
        if (pointer[PointerInput.MouseWheelX] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelX;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelY] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelY;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelZ] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelZ;
          this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    if (this._usingMacOs && this._isUsingChromium) {
      this._pointerMacOsChromeOutEvent = (evt) => {
        if (evt.buttons > 1) {
          this._pointerCancelEvent(evt);
        }
      };
      this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOsChromeOutEvent);
    }
    this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "leave", this._pointerLeaveEvent);
    this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
      if (this.isDeviceAvailable(DeviceType.Mouse)) {
        const pointer = this._inputs[DeviceType.Mouse][0];
        pointer[PointerInput.MouseWheelX] = 0;
        pointer[PointerInput.MouseWheelY] = 0;
        pointer[PointerInput.MouseWheelZ] = 0;
      }
    });
  }
  /**
   * Handle all actions that come from gamepad interaction
   */
  _handleGamepadActions() {
    this._gamepadConnectedEvent = (evt) => {
      this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = (evt) => {
      if (this._gamepads) {
        const deviceType = this._getGamepadDeviceType(evt.gamepad.id);
        const deviceSlot = evt.gamepad.index;
        this._unregisterDevice(deviceType, deviceSlot);
        delete this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }
  /**
   * Update all non-event based devices with each frame
   * @param deviceType Enum specifying device type
   * @param deviceSlot "Slot" or index that device is referenced in
   * @param inputIndex Id of input to be checked
   */
  _updateDevice(deviceType, deviceSlot, inputIndex) {
    const gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType === this._gamepads[deviceSlot]) {
      const device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  }
  /**
   * Gets DeviceType from the device name
   * @param deviceName Name of Device from DeviceInputSystem
   * @returns DeviceType enum value
   */
  _getGamepadDeviceType(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  }
  /**
   * Get DeviceType from a given pointer/mouse/touch event.
   * @param evt PointerEvent to evaluate
   * @returns DeviceType interpreted from event
   */
  _getPointerType(evt) {
    let deviceType = DeviceType.Mouse;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = DeviceType.Touch;
    }
    return deviceType;
  }
};

// node_modules/@babylonjs/core/DeviceInput/internalDeviceSourceManager.js
var InternalDeviceSourceManager = class {
  constructor(engine) {
    this._registeredManagers = new Array();
    this._refCount = 0;
    this.registerManager = (manager) => {
      for (let deviceType = 0; deviceType < this._devices.length; deviceType++) {
        const device = this._devices[deviceType];
        for (const deviceSlotKey in device) {
          const deviceSlot = +deviceSlotKey;
          manager._addDevice(new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot));
        }
      }
      this._registeredManagers.push(manager);
    };
    this.unregisterManager = (manager) => {
      const idx = this._registeredManagers.indexOf(manager);
      if (idx > -1) {
        this._registeredManagers.splice(idx, 1);
      }
    };
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    const onDeviceConnected = (deviceType, deviceSlot) => {
      if (!this._devices[deviceType]) {
        this._devices[deviceType] = new Array();
      }
      if (!this._devices[deviceType][deviceSlot]) {
        this._devices[deviceType][deviceSlot] = deviceSlot;
      }
      for (const manager of this._registeredManagers) {
        const deviceSource = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
        manager._addDevice(deviceSource);
      }
    };
    const onDeviceDisconnected = (deviceType, deviceSlot) => {
      if (this._devices[deviceType]?.[deviceSlot]) {
        delete this._devices[deviceType][deviceSlot];
      }
      for (const manager of this._registeredManagers) {
        manager._removeDevice(deviceType, deviceSlot);
      }
    };
    const onInputChanged = (deviceType, deviceSlot, eventData) => {
      if (eventData) {
        for (const manager of this._registeredManagers) {
          manager._onInputChanged(deviceType, deviceSlot, eventData);
        }
      }
    };
    if (typeof _native !== "undefined") {
      this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
    } else {
      this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
    }
  }
  dispose() {
    this._deviceInputSystem.dispose();
  }
};

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSourceManager = class {
  // Public Functions
  /**
   * Gets a DeviceSource, given a type and slot
   * @param deviceType - Type of Device
   * @param deviceSlot - Slot or ID of device
   * @returns DeviceSource
   */
  getDeviceSource(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  }
  /**
   * Gets an array of DeviceSource objects for a given device type
   * @param deviceType - Type of Device
   * @returns All available DeviceSources of a given type
   */
  getDeviceSources(deviceType) {
    if (!this._devices[deviceType]) {
      return [];
    }
    return this._devices[deviceType].filter((source) => {
      return !!source;
    });
  }
  /**
   * Default constructor
   * @param engine - Used to get canvas (if applicable)
   */
  constructor(engine) {
    const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._engine = engine;
    if (!this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
    }
    this._engine._deviceSourceManager._refCount++;
    this.onDeviceConnectedObservable = new Observable((observer) => {
      for (const devices of this._devices) {
        if (devices) {
          for (const device of devices) {
            if (device) {
              this.onDeviceConnectedObservable.notifyObserver(observer, device);
            }
          }
        }
      }
    });
    this.onDeviceDisconnectedObservable = new Observable();
    this._engine._deviceSourceManager.registerManager(this);
    this._onDisposeObserver = engine.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  /**
   * Dispose of DeviceSourceManager
   */
  dispose() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    if (this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager.unregisterManager(this);
      if (--this._engine._deviceSourceManager._refCount < 1) {
        this._engine._deviceSourceManager.dispose();
        delete this._engine._deviceSourceManager;
      }
    }
    this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }
  // Hidden Functions
  /**
   * @param deviceSource - Source to add
   * @internal
   */
  _addDevice(deviceSource) {
    if (!this._devices[deviceSource.deviceType]) {
      this._devices[deviceSource.deviceType] = [];
    }
    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
      this._updateFirstDevices(deviceSource.deviceType);
    }
    this.onDeviceConnectedObservable.notifyObservers(deviceSource);
  }
  /**
   * @param deviceType - DeviceType
   * @param deviceSlot - DeviceSlot
   * @internal
   */
  _removeDevice(deviceType, deviceSlot) {
    const deviceSource = this._devices[deviceType]?.[deviceSlot];
    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
    if (this._devices[deviceType]?.[deviceSlot]) {
      delete this._devices[deviceType][deviceSlot];
    }
    this._updateFirstDevices(deviceType);
  }
  /**
   * @param deviceType - DeviceType
   * @param deviceSlot - DeviceSlot
   * @param eventData - Event
   * @internal
   */
  _onInputChanged(deviceType, deviceSlot, eventData) {
    this._devices[deviceType]?.[deviceSlot]?.onInputChangedObservable.notifyObservers(eventData);
  }
  // Private Functions
  _updateFirstDevices(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualSense:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic: {
        delete this._firstDevice[type];
        const devices = this._devices[type];
        if (devices) {
          for (let i = 0; i < devices.length; i++) {
            if (devices[i]) {
              this._firstDevice[type] = i;
              break;
            }
          }
        }
        break;
      }
    }
  }
};

// node_modules/@babylonjs/core/FrameGraph/frameGraphTypes.js
var backbufferColorTextureHandle = 0;
var backbufferDepthStencilTextureHandle = 1;

// node_modules/@babylonjs/core/FrameGraph/Passes/pass.js
var FrameGraphPass = class {
  constructor(name, _parentTask, _context) {
    this.name = name;
    this._parentTask = _parentTask;
    this._context = _context;
    this.disabled = false;
  }
  setExecuteFunc(func) {
    this._executeFunc = func;
  }
  _execute() {
    if (!this.disabled) {
      this._executeFunc(this._context);
    }
  }
  _isValid() {
    return this._executeFunc !== void 0 ? null : "Execute function is not set (call setExecuteFunc to set it)";
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/cullPass.js
var FrameGraphCullPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is a cull pass.
   * @param pass The pass to check.
   * @returns True if the pass is a cull pass, else false.
   */
  static IsCullPass(pass) {
    return pass.setObjectList !== void 0;
  }
  /**
   * Gets the object list used by the cull pass.
   */
  get objectList() {
    return this._objectList;
  }
  /**
   * Sets the object list to use for culling.
   * @param objectList The object list to use for culling.
   */
  setObjectList(objectList) {
    this._objectList = objectList;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._engine = engine;
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._objectList !== void 0 ? null : "Object list is not set (call setObjectList to set it)";
  }
};

// node_modules/@babylonjs/core/FrameGraph/Passes/renderPass.js
var FrameGraphRenderPass = class extends FrameGraphPass {
  /**
   * Checks if a pass is a render pass.
   * @param pass The pass to check.
   * @returns True if the pass is a render pass, else false.
   */
  static IsRenderPass(pass) {
    return pass.setRenderTarget !== void 0;
  }
  /**
   * Gets the render target(s) used by the render pass.
   */
  get renderTarget() {
    return this._renderTarget;
  }
  /**
   * Gets the render target depth used by the render pass.
   */
  get renderTargetDepth() {
    return this._renderTargetDepth;
  }
  /** @internal */
  constructor(name, parentTask, context, engine) {
    super(name, parentTask, context);
    this._dependencies = /* @__PURE__ */ new Set();
    this.depthReadOnly = false;
    this.stencilReadOnly = false;
    this._engine = engine;
  }
  /**
   * Sets the render target(s) to use for rendering.
   * @param renderTargetHandle The render target to use for rendering, or an array of render targets to use for multi render target rendering.
   */
  setRenderTarget(renderTargetHandle) {
    this._renderTarget = renderTargetHandle;
  }
  /**
   * Sets the render target depth to use for rendering.
   * @param renderTargetHandle The render target depth to use for rendering.
   */
  setRenderTargetDepth(renderTargetHandle) {
    this._renderTargetDepth = renderTargetHandle;
  }
  /**
   * Adds dependencies to the render pass.
   * @param dependencies The dependencies to add.
   */
  addDependencies(dependencies) {
    if (dependencies === void 0) {
      return;
    }
    if (Array.isArray(dependencies)) {
      for (const dependency of dependencies) {
        this._dependencies.add(dependency);
      }
    } else {
      this._dependencies.add(dependencies);
    }
  }
  /**
   * Collects the dependencies of the render pass.
   * @param dependencies The set of dependencies to update.
   */
  collectDependencies(dependencies) {
    const iterator = this._dependencies.keys();
    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
      dependencies.add(key.value);
    }
    if (this._renderTarget !== void 0) {
      if (Array.isArray(this._renderTarget)) {
        for (const handle of this._renderTarget) {
          if (handle !== void 0) {
            dependencies.add(handle);
          }
        }
      } else {
        dependencies.add(this._renderTarget);
      }
    }
    if (this._renderTargetDepth !== void 0) {
      dependencies.add(this._renderTargetDepth);
    }
  }
  /** @internal */
  _execute() {
    this._frameGraphRenderTarget = this._frameGraphRenderTarget || this._context.createRenderTarget(this.name, this._renderTarget, this._renderTargetDepth, this.depthReadOnly, this.stencilReadOnly);
    this._context.bindRenderTarget(this._frameGraphRenderTarget, `frame graph render pass - ${this.name}`);
    super._execute();
    this._context._flushDebugMessages();
  }
  /** @internal */
  _isValid() {
    const errMsg = super._isValid();
    return errMsg ? errMsg : this._renderTarget !== void 0 || this.renderTargetDepth !== void 0 ? null : "Render target and render target depth cannot both be undefined.";
  }
};

// node_modules/@babylonjs/core/FrameGraph/frameGraphTask.js
var FrameGraphTask = class {
  /**
   * The name of the task.
   */
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  /**
   * Whether the task is disabled.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  /**
   * Gets the render passes of the task.
   */
  get passes() {
    return this._passes;
  }
  /**
   * Gets the disabled render passes of the task.
   */
  get passesDisabled() {
    return this._passesDisabled;
  }
  /**
   * Checks if the task is ready to be executed.
   * @returns True if the task is ready to be executed, else false.
   */
  isReady() {
    return true;
  }
  /**
   * Disposes of the task.
   */
  dispose() {
    this._reset();
    this.onTexturesAllocatedObservable.clear();
  }
  /**
   * Constructs a new frame graph task.
   * @param name The name of the task.
   * @param frameGraph The frame graph this task is associated with.
   */
  constructor(name, frameGraph) {
    this._passes = [];
    this._passesDisabled = [];
    this._disabled = false;
    this.onTexturesAllocatedObservable = new Observable();
    this.name = name;
    this._frameGraph = frameGraph;
    this._reset();
  }
  /** @internal */
  _reset() {
    this._passes.length = 0;
    this._passesDisabled.length = 0;
  }
  /** @internal */
  _addPass(pass, disabled) {
    if (disabled) {
      this._passesDisabled.push(pass);
    } else {
      this._passes.push(pass);
    }
  }
  /** @internal */
  _checkTask() {
    let outputTexture = null;
    let outputDepthTexture = null;
    let outputObjectList;
    for (const pass of this._passes) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        outputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            outputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        outputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphCullPass.IsCullPass(pass)) {
        outputObjectList = pass.objectList;
      }
    }
    let disabledOutputTexture = null;
    let disabledOutputTextureHandle = [];
    let disabledOutputDepthTexture = null;
    let disabledOutputObjectList;
    for (const pass of this._passesDisabled) {
      const errMsg = pass._isValid();
      if (errMsg) {
        throw new Error(`Pass "${pass.name}" is not valid. ${errMsg}`);
      }
      if (FrameGraphRenderPass.IsRenderPass(pass)) {
        const handles = Array.isArray(pass.renderTarget) ? pass.renderTarget : [pass.renderTarget];
        disabledOutputTexture = [];
        for (const handle of handles) {
          if (handle !== void 0) {
            disabledOutputTexture.push(this._frameGraph.textureManager.getTextureFromHandle(handle));
          }
        }
        disabledOutputTextureHandle = handles;
        disabledOutputDepthTexture = pass.renderTargetDepth !== void 0 ? this._frameGraph.textureManager.getTextureFromHandle(pass.renderTargetDepth) : null;
      } else if (FrameGraphCullPass.IsCullPass(pass)) {
        disabledOutputObjectList = pass.objectList;
      }
    }
    if (this._passesDisabled.length > 0) {
      if (!this._checkSameRenderTarget(outputTexture, disabledOutputTexture)) {
        let ok = true;
        for (const handle of disabledOutputTextureHandle) {
          if (handle !== void 0 && !this._frameGraph.textureManager.isHistoryTexture(handle)) {
            ok = false;
            break;
          }
        }
        if (!ok) {
          throw new Error(`The output texture of the task "${this.name}" is different when it is enabled or disabled.`);
        }
      }
      if (outputDepthTexture !== disabledOutputDepthTexture) {
        throw new Error(`The output depth texture of the task "${this.name}" is different when it is enabled or disabled.`);
      }
      if (outputObjectList !== disabledOutputObjectList) {
        throw new Error(`The output object list of the task "${this.name}" is different when it is enabled or disabled.`);
      }
    }
  }
  /** @internal */
  _getPasses() {
    return this.disabled && this._passesDisabled.length > 0 ? this._passesDisabled : this._passes;
  }
  _checkSameRenderTarget(src, dst) {
    if (src === null || dst === null) {
      return src === dst;
    }
    if (src.length !== dst.length) {
      return false;
    }
    for (let i = 0; i < src.length; i++) {
      if (src[i] !== dst[i]) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/@babylonjs/core/PostProcesses/thinBlurPostProcess.js
var ThinBlurPostProcess = class _ThinBlurPostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(Promise.all([import("./kernelBlur.fragment-AO3EZR5M.js"), import("./kernelBlur.vertex-T6M3AJK3.js")]));
    } else {
      list.push(Promise.all([import("./kernelBlur.fragment-XD2HHPHM.js"), import("./kernelBlur.vertex-JXPTWPYG.js")]));
    }
  }
  /**
   * Constructs a new blur post process
   * @param name Name of the effect
   * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
   * @param direction Direction in which to apply the blur
   * @param kernel Kernel size of the blur
   * @param options Options to configure the effect
   */
  constructor(name, engine = null, direction, kernel, options) {
    const blockCompilationFinal = !!options?.blockCompilation;
    super({
      ...options,
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinBlurPostProcess.FragmentUrl,
      uniforms: _ThinBlurPostProcess.Uniforms,
      samplers: _ThinBlurPostProcess.Samplers,
      vertexUrl: _ThinBlurPostProcess.VertexUrl,
      blockCompilation: true
    });
    this._packedFloat = false;
    this._staticDefines = "";
    this.textureWidth = 0;
    this.textureHeight = 0;
    this._staticDefines = options ? Array.isArray(options.defines) ? options.defines.join("\n") : options.defines || "" : "";
    this.options.blockCompilation = blockCompilationFinal;
    if (direction !== void 0) {
      this.direction = direction;
    }
    if (kernel !== void 0) {
      this.kernel = kernel;
    }
  }
  /**
   * Sets the length in pixels of the blur sample region
   */
  set kernel(v) {
    if (this._idealKernel === v) {
      return;
    }
    v = Math.max(v, 1);
    this._idealKernel = v;
    this._kernel = this._nearestBestKernel(v);
    if (!this.options.blockCompilation) {
      this._updateParameters();
    }
  }
  /**
   * Gets the length in pixels of the blur sample region
   */
  get kernel() {
    return this._idealKernel;
  }
  /**
   * Sets whether or not the blur needs to unpack/repack floats
   */
  set packedFloat(v) {
    if (this._packedFloat === v) {
      return;
    }
    this._packedFloat = v;
    if (!this.options.blockCompilation) {
      this._updateParameters();
    }
  }
  /**
   * Gets whether or not the blur is unpacking/repacking floats
   */
  get packedFloat() {
    return this._packedFloat;
  }
  bind(noDefaultBindings = false) {
    super.bind(noDefaultBindings);
    this._drawWrapper.effect.setFloat2("delta", 1 / this.textureWidth * this.direction.x, 1 / this.textureHeight * this.direction.y);
  }
  /** @internal */
  _updateParameters(onCompiled, onError) {
    const n = this._kernel;
    const centerIndex = (n - 1) / 2;
    let offsets = [];
    let weights = [];
    let totalWeight = 0;
    for (let i = 0; i < n; i++) {
      const u = i / (n - 1);
      const w = this._gaussianWeight(u * 2 - 1);
      offsets[i] = i - centerIndex;
      weights[i] = w;
      totalWeight += w;
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] /= totalWeight;
    }
    const linearSamplingWeights = [];
    const linearSamplingOffsets = [];
    const linearSamplingMap = [];
    for (let i = 0; i <= centerIndex; i += 2) {
      const j = Math.min(i + 1, Math.floor(centerIndex));
      const singleCenterSample = i === j;
      if (singleCenterSample) {
        linearSamplingMap.push({ o: offsets[i], w: weights[i] });
      } else {
        const sharedCell = j === centerIndex;
        const weightLinear = weights[i] + weights[j] * (sharedCell ? 0.5 : 1);
        const offsetLinear = offsets[i] + 1 / (1 + weights[i] / weights[j]);
        if (offsetLinear === 0) {
          linearSamplingMap.push({ o: offsets[i], w: weights[i] });
          linearSamplingMap.push({ o: offsets[i + 1], w: weights[i + 1] });
        } else {
          linearSamplingMap.push({ o: offsetLinear, w: weightLinear });
          linearSamplingMap.push({ o: -offsetLinear, w: weightLinear });
        }
      }
    }
    for (let i = 0; i < linearSamplingMap.length; i++) {
      linearSamplingOffsets[i] = linearSamplingMap[i].o;
      linearSamplingWeights[i] = linearSamplingMap[i].w;
    }
    offsets = linearSamplingOffsets;
    weights = linearSamplingWeights;
    const maxVaryingRows = this.options.engine.getCaps().maxVaryingVectors - (this.options.shaderLanguage === 1 ? 1 : 0);
    const freeVaryingVec2 = Math.max(maxVaryingRows, 0) - 1;
    let varyingCount = Math.min(offsets.length, freeVaryingVec2);
    let defines = "";
    defines += this._staticDefines;
    if (this._staticDefines.indexOf("DOF") != -1) {
      defines += `#define CENTER_WEIGHT ${this._glslFloat(weights[varyingCount - 1])}
`;
      varyingCount--;
    }
    for (let i = 0; i < varyingCount; i++) {
      defines += `#define KERNEL_OFFSET${i} ${this._glslFloat(offsets[i])}
`;
      defines += `#define KERNEL_WEIGHT${i} ${this._glslFloat(weights[i])}
`;
    }
    let depCount = 0;
    for (let i = freeVaryingVec2; i < offsets.length; i++) {
      defines += `#define KERNEL_DEP_OFFSET${depCount} ${this._glslFloat(offsets[i])}
`;
      defines += `#define KERNEL_DEP_WEIGHT${depCount} ${this._glslFloat(weights[i])}
`;
      depCount++;
    }
    if (this.packedFloat) {
      defines += `#define PACKEDFLOAT 1`;
    }
    this.options.blockCompilation = false;
    this.updateEffect(defines, null, null, {
      varyingCount,
      depCount
    }, onCompiled, onError);
  }
  /**
   * Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
   * Other odd kernels optimize correctly but require proportionally more samples, even kernels are
   * possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
   * want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
   * The gaps between physical kernels are compensated for in the weighting of the samples
   * @param idealKernel Ideal blur kernel.
   * @returns Nearest best kernel.
   */
  _nearestBestKernel(idealKernel) {
    const v = Math.round(idealKernel);
    for (const k of [v, v - 1, v + 1, v - 2, v + 2]) {
      if (k % 2 !== 0 && Math.floor(k / 2) % 2 === 0 && k > 0) {
        return Math.max(k, 3);
      }
    }
    return Math.max(v, 3);
  }
  /**
   * Calculates the value of a Gaussian distribution with sigma 3 at a given point.
   * @param x The point on the Gaussian distribution to sample.
   * @returns the value of the Gaussian function at x.
   */
  _gaussianWeight(x) {
    const sigma = 1 / 3;
    const denominator = Math.sqrt(2 * Math.PI) * sigma;
    const exponent = -(x * x / (2 * sigma * sigma));
    const weight = 1 / denominator * Math.exp(exponent);
    return weight;
  }
  /**
   * Generates a string that can be used as a floating point number in GLSL.
   * @param x Value to print.
   * @param decimalFigures Number of decimal places to print the number to (excluding trailing 0s).
   * @returns GLSL float string.
   */
  _glslFloat(x, decimalFigures = 8) {
    return x.toFixed(decimalFigures).replace(/0+$/, "");
  }
};
ThinBlurPostProcess.VertexUrl = "kernelBlur";
ThinBlurPostProcess.FragmentUrl = "kernelBlur";
ThinBlurPostProcess.Uniforms = ["delta", "direction"];
ThinBlurPostProcess.Samplers = ["circleOfConfusionSampler"];

// node_modules/@babylonjs/core/PostProcesses/blurPostProcess.js
var BlurPostProcess = class _BlurPostProcess extends PostProcess {
  /** The direction in which to blur the image. */
  get direction() {
    return this._effectWrapper.direction;
  }
  set direction(value) {
    this._effectWrapper.direction = value;
  }
  /**
   * Sets the length in pixels of the blur sample region
   */
  set kernel(v) {
    this._effectWrapper.kernel = v;
  }
  /**
   * Gets the length in pixels of the blur sample region
   */
  get kernel() {
    return this._effectWrapper.kernel;
  }
  /**
   * Sets whether or not the blur needs to unpack/repack floats
   */
  set packedFloat(v) {
    this._effectWrapper.packedFloat = v;
  }
  /**
   * Gets whether or not the blur is unpacking/repacking floats
   */
  get packedFloat() {
    return this._effectWrapper.packedFloat;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "BlurPostProcess" string
   */
  getClassName() {
    return "BlurPostProcess";
  }
  /**
   * Creates a new instance BlurPostProcess
   * @param name The name of the effect.
   * @param direction The direction in which to blur the image.
   * @param kernel The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.
   * @param options The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType Type of textures used when performing the post process. (default: 0)
   * @param defines
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   * @param textureFormat Format of textures used when performing the post process. (default: TEXTUREFORMAT_RGBA)
   */
  constructor(name, direction, kernel, options, camera = null, samplingMode = Texture.BILINEAR_SAMPLINGMODE, engine, reusable, textureType = 0, defines = "", blockCompilation = false, textureFormat = 5) {
    const blockCompilationFinal = typeof options === "number" ? blockCompilation : !!options.blockCompilation;
    const localOptions = {
      uniforms: ThinBlurPostProcess.Uniforms,
      samplers: ThinBlurPostProcess.Samplers,
      size: typeof options === "number" ? options : void 0,
      camera,
      samplingMode,
      engine,
      reusable,
      textureType,
      vertexUrl: ThinBlurPostProcess.VertexUrl,
      indexParameters: { varyingCount: 0, depCount: 0 },
      textureFormat,
      defines,
      ...options,
      blockCompilation: true
    };
    super(name, ThinBlurPostProcess.FragmentUrl, {
      effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinBlurPostProcess(name, engine, void 0, void 0, localOptions) : void 0,
      ...localOptions
    });
    this._effectWrapper.options.blockCompilation = blockCompilationFinal;
    this.direction = direction;
    this.onApplyObservable.add(() => {
      this._effectWrapper.textureWidth = this._outputTexture ? this._outputTexture.width : this.width;
      this._effectWrapper.textureHeight = this._outputTexture ? this._outputTexture.height : this.height;
    });
    this.kernel = kernel;
  }
  updateEffect(_defines = null, _uniforms = null, _samplers = null, _indexParameters, onCompiled, onError) {
    this._effectWrapper._updateParameters(onCompiled, onError);
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _BlurPostProcess(parsedPostProcess.name, parsedPostProcess.direction, parsedPostProcess.kernel, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, scene.getEngine(), parsedPostProcess.reusable, parsedPostProcess.textureType, void 0, false);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serializeAsVector2()
], BlurPostProcess.prototype, "direction", null);
__decorate([
  serialize()
], BlurPostProcess.prototype, "kernel", null);
__decorate([
  serialize()
], BlurPostProcess.prototype, "packedFloat", null);
RegisterClass("BABYLON.BlurPostProcess", BlurPostProcess);

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks = class {
  constructor() {
    this._defines = {};
    this._currentRank = 32;
    this._maxRank = -1;
    this._mesh = null;
  }
  /**
   * Removes the fallback from the bound mesh.
   */
  unBindMesh() {
    this._mesh = null;
  }
  /**
   * Adds a fallback on the specified property.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param define The name of the define in the shader
   */
  addFallback(rank, define) {
    if (!this._defines[rank]) {
      if (rank < this._currentRank) {
        this._currentRank = rank;
      }
      if (rank > this._maxRank) {
        this._maxRank = rank;
      }
      this._defines[rank] = new Array();
    }
    this._defines[rank].push(define);
  }
  /**
   * Sets the mesh to use CPU skinning when needing to fallback.
   * @param rank The rank of the fallback (Lower ranks will be fallbacked to first)
   * @param mesh The mesh to use the fallbacks.
   */
  addCPUSkinningFallback(rank, mesh) {
    this._mesh = mesh;
    if (rank < this._currentRank) {
      this._currentRank = rank;
    }
    if (rank > this._maxRank) {
      this._maxRank = rank;
    }
  }
  /**
   * Checks to see if more fallbacks are still available.
   */
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  /**
   * Removes the defines that should be removed when falling back.
   * @param currentDefines defines the current define statements for the shader.
   * @param effect defines the current effect we try to compile
   * @returns The resulting defines with defines of the current rank removed.
   */
  reduce(currentDefines, effect) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = false;
      currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
      effect._bonesComputationForcedToCPU = true;
      const scene = this._mesh.getScene();
      for (let index = 0; index < scene.meshes.length; index++) {
        const otherMesh = scene.meshes[index];
        if (!otherMesh.material) {
          if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
            otherMesh.computeBonesUsingShaders = false;
          }
          continue;
        }
        if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
          continue;
        }
        if (otherMesh.material.getEffect() === effect) {
          otherMesh.computeBonesUsingShaders = false;
        } else if (otherMesh.subMeshes) {
          for (const subMesh of otherMesh.subMeshes) {
            const subMeshEffect = subMesh.effect;
            if (subMeshEffect === effect) {
              otherMesh.computeBonesUsingShaders = false;
              break;
            }
          }
        }
      }
    } else {
      const currentFallbacks = this._defines[this._currentRank];
      if (currentFallbacks) {
        for (let index = 0; index < currentFallbacks.length; index++) {
          currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
        }
      }
      this._currentRank++;
    }
    return currentDefines;
  }
};

// node_modules/@babylonjs/core/Materials/floatingOriginMatrixOverrides.js
var TempFinalMat = new Matrix();
var TempMat1 = new Matrix();
var TempMat2 = new Matrix();
var FloatingOriginCurrentScene = {
  getScene: () => void 0,
  eyeAtCamera: true
  // When true, we can assume viewMatrix translation is at origin. Otherwise, we must do full offset calculations
};
function OffsetWorldToRef(offset, world, ref) {
  const refArray = ref.asArray();
  const worldArray = world.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = worldArray[i];
  }
  refArray[12] -= offset.x;
  refArray[13] -= offset.y;
  refArray[14] -= offset.z;
  ref.markAsUpdated();
  return ref;
}
function GetFullOffsetView(offset, viewMatrix, ref) {
  InvertMatrixToRef(viewMatrix, TempMat1);
  OffsetWorldToRef(offset, TempMat1, TempMat2);
  InvertMatrixToRef(TempMat2, ref);
  return ref;
}
function OffsetViewToRef(offset, view, ref) {
  if (!FloatingOriginCurrentScene.eyeAtCamera) {
    return GetFullOffsetView(offset, view, ref);
  }
  const refArray = ref.asArray();
  const viewArray = view.asArray();
  for (let i = 0; i < 16; i++) {
    refArray[i] = viewArray[i];
  }
  refArray[12] = 0;
  refArray[13] = 0;
  refArray[14] = 0;
  ref.markAsUpdated();
  return ref;
}
function OffsetViewProjectionToRef(offset, view, projection, ref) {
  MultiplyMatricesToRef(OffsetViewToRef(offset, view, ref), projection, ref);
  return ref;
}
function GetOffsetTransformMatrices(offset, viewMatrices, projectionMatrices, length, resultArray) {
  for (let cascadeIndex = 0; cascadeIndex < length; ++cascadeIndex) {
    GetFullOffsetViewProjectionToRef(offset, viewMatrices[cascadeIndex], projectionMatrices[cascadeIndex], TempMat1);
    TempMat1.copyToArray(resultArray, cascadeIndex * 16);
  }
  return resultArray;
}
function OffsetWorldViewToRef(offset, worldView, view, ref) {
  InvertMatrixToRef(view, TempMat1);
  MultiplyMatricesToRef(worldView, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewToRef(offset, view, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetFullOffsetViewProjectionToRef(offset, viewMatrix, projectionMatrix, ref) {
  GetFullOffsetView(offset, viewMatrix, TempMat2);
  MultiplyMatricesToRef(TempMat2, projectionMatrix, ref);
  return ref;
}
function OffsetWorldViewProjectionToRef(offset, worldViewProjection, viewProjection, view, projection, ref) {
  InvertMatrixToRef(viewProjection, TempMat1);
  MultiplyMatricesToRef(worldViewProjection, TempMat1, TempMat2);
  OffsetWorldToRef(offset, TempMat2, TempMat1);
  OffsetViewProjectionToRef(offset, view, projection, TempMat2);
  MultiplyMatricesToRef(TempMat1, TempMat2, ref);
  return ref;
}
function GetOffsetMatrix(uniformName, mat) {
  TempFinalMat.updateFlag = mat.updateFlag;
  const scene = FloatingOriginCurrentScene.getScene();
  if (!scene) {
    return mat;
  }
  const offset = scene.floatingOriginOffset;
  switch (uniformName) {
    case "world":
      return OffsetWorldToRef(offset, mat, TempFinalMat);
    case "view":
      return OffsetViewToRef(offset, mat, TempFinalMat);
    case "worldView":
      return OffsetWorldViewToRef(offset, mat, scene.getViewMatrix(), TempFinalMat);
    case "viewProjection":
      return OffsetViewProjectionToRef(offset, scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    case "worldViewProjection":
      return OffsetWorldViewProjectionToRef(offset, mat, scene.getTransformMatrix(), scene.getViewMatrix(), scene.getProjectionMatrix(), TempFinalMat);
    default:
      return mat;
  }
}
var UniformBufferInternal = UniformBuffer;
var EffectInternal = Effect;
var OriginalUpdateMatrixForUniform = UniformBufferInternal.prototype._updateMatrixForUniform;
var OriginalSetMatrix = Effect.prototype.setMatrix;
function ResetMatrixFunctions() {
  Effect.prototype.setMatrix = OriginalSetMatrix;
  EffectInternal._setMatrixOverride = void 0;
  UniformBufferInternal.prototype._updateMatrixForUniform = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = void 0;
}
function OverrideMatrixFunctions() {
  EffectInternal.prototype._setMatrixOverride = OriginalSetMatrix;
  EffectInternal.prototype.setMatrix = function(uniformName, matrix) {
    this._setMatrixOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
    return this;
  };
  UniformBufferInternal.prototype._updateMatrixForUniformOverride = OriginalUpdateMatrixForUniform;
  UniformBufferInternal.prototype._updateMatrixForUniform = function(uniformName, matrix) {
    this._updateMatrixForUniformOverride(uniformName, GetOffsetMatrix(uniformName, matrix));
  };
}

// node_modules/@babylonjs/core/Lights/Shadows/shadowGenerator.js
var ShadowGenerator = class _ShadowGenerator {
  /**
   * Gets the bias: offset applied on the depth preventing acnea (in light direction).
   */
  get bias() {
    return this._bias;
  }
  /**
   * Sets the bias: offset applied on the depth preventing acnea (in light direction).
   */
  set bias(bias) {
    this._bias = bias;
  }
  /**
   * Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
   */
  get normalBias() {
    return this._normalBias;
  }
  /**
   * Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportional to the light/normal angle).
   */
  set normalBias(normalBias) {
    this._normalBias = normalBias;
  }
  /**
   * Gets the blur box offset: offset applied during the blur pass.
   * Only useful if useKernelBlur = false
   */
  get blurBoxOffset() {
    return this._blurBoxOffset;
  }
  /**
   * Sets the blur box offset: offset applied during the blur pass.
   * Only useful if useKernelBlur = false
   */
  set blurBoxOffset(value) {
    if (this._blurBoxOffset === value) {
      return;
    }
    this._blurBoxOffset = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the blur scale: scale of the blurred texture compared to the main shadow map.
   * 2 means half of the size.
   */
  get blurScale() {
    return this._blurScale;
  }
  /**
   * Sets the blur scale: scale of the blurred texture compared to the main shadow map.
   * 2 means half of the size.
   */
  set blurScale(value) {
    if (this._blurScale === value) {
      return;
    }
    this._blurScale = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the blur kernel: kernel size of the blur pass.
   * Only useful if useKernelBlur = true
   */
  get blurKernel() {
    return this._blurKernel;
  }
  /**
   * Sets the blur kernel: kernel size of the blur pass.
   * Only useful if useKernelBlur = true
   */
  set blurKernel(value) {
    if (this._blurKernel === value) {
      return;
    }
    this._blurKernel = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets whether the blur pass is a kernel blur (if true) or box blur.
   * Only useful in filtered mode (useBlurExponentialShadowMap...)
   */
  get useKernelBlur() {
    return this._useKernelBlur;
  }
  /**
   * Sets whether the blur pass is a kernel blur (if true) or box blur.
   * Only useful in filtered mode (useBlurExponentialShadowMap...)
   */
  set useKernelBlur(value) {
    if (this._useKernelBlur === value) {
      return;
    }
    this._useKernelBlur = value;
    this._disposeBlurPostProcesses();
  }
  /**
   * Gets the depth scale used in ESM mode.
   */
  get depthScale() {
    return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
  }
  /**
   * Sets the depth scale used in ESM mode.
   * This can override the scale stored on the light.
   */
  set depthScale(value) {
    this._depthScale = value;
  }
  _validateFilter(filter) {
    return filter;
  }
  /**
   * Gets the current mode of the shadow generator (normal, PCF, ESM...).
   * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
   */
  get filter() {
    return this._filter;
  }
  /**
   * Sets the current mode of the shadow generator (normal, PCF, ESM...).
   * The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
   */
  set filter(value) {
    value = this._validateFilter(value);
    if (this._light.needCube()) {
      if (value === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
        this.useExponentialShadowMap = true;
        return;
      } else if (value === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        this.useCloseExponentialShadowMap = true;
        return;
      } else if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (value === _ShadowGenerator.FILTER_PCF || value === _ShadowGenerator.FILTER_PCSS) {
      if (!this._scene.getEngine()._features.supportShadowSamplers) {
        this.usePoissonSampling = true;
        return;
      }
    }
    if (this._filter === value) {
      return;
    }
    this._filter = value;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets if the current filter is set to Poisson Sampling.
   */
  get usePoissonSampling() {
    return this.filter === _ShadowGenerator.FILTER_POISSONSAMPLING;
  }
  /**
   * Sets the current filter to Poisson Sampling.
   */
  set usePoissonSampling(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_POISSONSAMPLING);
    if (!value && this.filter !== _ShadowGenerator.FILTER_POISSONSAMPLING) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to ESM.
   */
  get useExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter is to ESM.
   */
  set useExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to filtered ESM.
   */
  get useBlurExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP;
  }
  /**
   * Gets if the current filter is set to filtered  ESM.
   */
  set useBlurExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  get useCloseExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter to "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  set useCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to filtered "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  get useBlurCloseExponentialShadowMap() {
    return this.filter === _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
  }
  /**
   * Sets the current filter to filtered "close ESM" (using the inverse of the
   * exponential to prevent steep falloff artifacts).
   */
  set useBlurCloseExponentialShadowMap(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
    if (!value && this.filter !== _ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets if the current filter is set to "PCF" (percentage closer filtering).
   */
  get usePercentageCloserFiltering() {
    return this.filter === _ShadowGenerator.FILTER_PCF;
  }
  /**
   * Sets the current filter to "PCF" (percentage closer filtering).
   */
  set usePercentageCloserFiltering(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_PCF);
    if (!value && this.filter !== _ShadowGenerator.FILTER_PCF) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets the PCF or PCSS Quality.
   * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
   */
  get filteringQuality() {
    return this._filteringQuality;
  }
  /**
   * Sets the PCF or PCSS Quality.
   * Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
   */
  set filteringQuality(filteringQuality) {
    if (this._filteringQuality === filteringQuality) {
      return;
    }
    this._filteringQuality = filteringQuality;
    this._disposeBlurPostProcesses();
    this._applyFilterValues();
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets if the current filter is set to "PCSS" (contact hardening).
   */
  get useContactHardeningShadow() {
    return this.filter === _ShadowGenerator.FILTER_PCSS;
  }
  /**
   * Sets the current filter to "PCSS" (contact hardening).
   */
  set useContactHardeningShadow(value) {
    const filter = this._validateFilter(_ShadowGenerator.FILTER_PCSS);
    if (!value && this.filter !== _ShadowGenerator.FILTER_PCSS) {
      return;
    }
    this.filter = value ? filter : _ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
   * Using a ratio helps keeping shape stability independently of the map size.
   *
   * It does not account for the light projection as it was having too much
   * instability during the light setup or during light position changes.
   *
   * Only valid if useContactHardeningShadow is true.
   */
  get contactHardeningLightSizeUVRatio() {
    return this._contactHardeningLightSizeUVRatio;
  }
  /**
   * Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
   * Using a ratio helps keeping shape stability independently of the map size.
   *
   * It does not account for the light projection as it was having too much
   * instability during the light setup or during light position changes.
   *
   * Only valid if useContactHardeningShadow is true.
   */
  set contactHardeningLightSizeUVRatio(contactHardeningLightSizeUVRatio) {
    this._contactHardeningLightSizeUVRatio = contactHardeningLightSizeUVRatio;
  }
  /** Gets or sets the actual darkness of a shadow */
  get darkness() {
    return this._darkness;
  }
  set darkness(value) {
    this.setDarkness(value);
  }
  /**
   * Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
   * 0 means strongest and 1 would means no shadow.
   * @returns the darkness.
   */
  getDarkness() {
    return this._darkness;
  }
  /**
   * Sets the darkness value (float). This can only decrease the actual darkness of a shadow.
   * @param darkness The darkness value 0 means strongest and 1 would means no shadow.
   * @returns the shadow generator allowing fluent coding.
   */
  setDarkness(darkness) {
    if (darkness >= 1) {
      this._darkness = 1;
    } else if (darkness <= 0) {
      this._darkness = 0;
    } else {
      this._darkness = darkness;
    }
    return this;
  }
  /** Gets or sets the ability to have transparent shadow */
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(value) {
    this.setTransparencyShadow(value);
  }
  /**
   * Sets the ability to have transparent shadow (boolean).
   * @param transparent True if transparent else False
   * @returns the shadow generator allowing fluent coding
   */
  setTransparencyShadow(transparent) {
    this._transparencyShadow = transparent;
    return this;
  }
  /**
   * Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
   * @returns The render target texture if present otherwise, null
   */
  getShadowMap() {
    return this._shadowMap;
  }
  /**
   * Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
   * @returns The render target texture if the shadow map is present otherwise, null
   */
  getShadowMapForRendering() {
    if (this._shadowMap2) {
      return this._shadowMap2;
    }
    return this._shadowMap;
  }
  /**
   * Gets the class name of that object
   * @returns "ShadowGenerator"
   */
  getClassName() {
    return _ShadowGenerator.CLASSNAME;
  }
  /**
   * Helper function to add a mesh and its descendants to the list of shadow casters.
   * @param mesh Mesh to add
   * @param includeDescendants boolean indicating if the descendants should be added. Default to true
   * @returns the Shadow Generator itself
   */
  addShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap) {
      return this;
    }
    if (!this._shadowMap.renderList) {
      this._shadowMap.renderList = [];
    }
    if (this._shadowMap.renderList.indexOf(mesh) === -1) {
      this._shadowMap.renderList.push(mesh);
    }
    if (includeDescendants) {
      for (const childMesh of mesh.getChildMeshes()) {
        if (this._shadowMap.renderList.indexOf(childMesh) === -1) {
          this._shadowMap.renderList.push(childMesh);
        }
      }
    }
    return this;
  }
  /**
   * Helper function to remove a mesh and its descendants from the list of shadow casters
   * @param mesh Mesh to remove
   * @param includeDescendants boolean indicating if the descendants should be removed. Default to true
   * @returns the Shadow Generator itself
   */
  removeShadowCaster(mesh, includeDescendants = true) {
    if (!this._shadowMap || !this._shadowMap.renderList) {
      return this;
    }
    const index = this._shadowMap.renderList.indexOf(mesh);
    if (index !== -1) {
      this._shadowMap.renderList.splice(index, 1);
    }
    if (includeDescendants) {
      for (const child of mesh.getChildren()) {
        this.removeShadowCaster(child);
      }
    }
    return this;
  }
  /**
   * Returns the associated light object.
   * @returns the light generating the shadow
   */
  getLight() {
    return this._light;
  }
  /**
   * Gets the shader language used in this generator.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  _getCamera() {
    return this._camera ?? this._scene.activeCamera;
  }
  /**
   * Gets or sets the size of the texture what stores the shadows
   */
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(size) {
    this._mapSize = size;
    this._light._markMeshesAsLightDirty();
    this.recreateShadowMap();
  }
  /**
   * Creates a ShadowGenerator object.
   * A ShadowGenerator is the required tool to use the shadows.
   * Each light casting shadows needs to use its own ShadowGenerator.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows
   * @param mapSize The size of the texture what stores the shadows. Example : 1024.
   * @param light The light object generating the shadows.
   * @param usefullFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
   * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
   * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: false)
   * @param forceGLSL defines a boolean indicating if the shader must be compiled in GLSL even if we are using WebGPU
   */
  constructor(mapSize, light, usefullFloatFirst, camera, useRedTextureType, forceGLSL = false) {
    this.onBeforeShadowMapRenderObservable = new Observable();
    this.onAfterShadowMapRenderObservable = new Observable();
    this.onBeforeShadowMapRenderMeshObservable = new Observable();
    this.onAfterShadowMapRenderMeshObservable = new Observable();
    this.doNotSerialize = false;
    this._bias = 5e-5;
    this._normalBias = 0;
    this._blurBoxOffset = 1;
    this._blurScale = 2;
    this._blurKernel = 1;
    this._useKernelBlur = false;
    this._filter = _ShadowGenerator.FILTER_NONE;
    this._filteringQuality = _ShadowGenerator.QUALITY_HIGH;
    this._contactHardeningLightSizeUVRatio = 0.1;
    this._darkness = 0;
    this._transparencyShadow = false;
    this.enableSoftTransparentShadow = false;
    this.useOpacityTextureForTransparentShadow = false;
    this.frustumEdgeFalloff = 0;
    this._shaderLanguage = 0;
    this.forceBackFacesOnly = false;
    this._lightDirection = Vector3.Zero();
    this._viewMatrix = Matrix.Zero();
    this._projectionMatrix = Matrix.Zero();
    this._transformMatrix = Matrix.Zero();
    this._cachedPosition = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cachedDirection = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._currentFaceIndex = 0;
    this._currentFaceIndexCache = 0;
    this._defaultTextureMatrix = Matrix.Identity();
    this._shadersLoaded = false;
    this._mapSize = mapSize;
    this._light = light;
    this._scene = light.getScene();
    this._camera = camera ?? null;
    this._useRedTextureType = !!useRedTextureType;
    this._initShaderSourceAsync(forceGLSL);
    let shadowGenerators = light._shadowGenerators;
    if (!shadowGenerators) {
      shadowGenerators = light._shadowGenerators = /* @__PURE__ */ new Map();
    }
    shadowGenerators.set(this._camera, this);
    this.id = light.id;
    this._useUBO = this._scene.getEngine().supportsUniformBuffers;
    if (this._useUBO) {
      this._sceneUBOs = [];
      this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`));
    }
    _ShadowGenerator._SceneComponentInitialization(this._scene);
    const caps = this._scene.getEngine().getCaps();
    if (!usefullFloatFirst) {
      if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else {
        this._textureType = 0;
      }
    } else {
      if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
        this._textureType = 1;
      } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
        this._textureType = 2;
      } else {
        this._textureType = 0;
      }
    }
    this._initializeGenerator();
    this._applyFilterValues();
  }
  _initializeGenerator() {
    this._light._markMeshesAsLightDirty();
    this._initializeShadowMap();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    this._shadowMap?.dispose();
    if (engine._features.supportDepthStencilTexture) {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube(), void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
      this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForShadowGenerator-${this._light.name}`);
    } else {
      this._shadowMap = new RenderTargetTexture(this._light.name + "_shadowMap", this._mapSize, this._scene, false, true, this._textureType, this._light.needCube());
    }
    this._shadowMap.noPrePassRenderer = true;
  }
  _initializeShadowMap() {
    this._createTargetRenderTexture();
    if (this._shadowMap === null) {
      return;
    }
    this._shadowMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._shadowMap.anisotropicFilteringLevel = 1;
    this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    this._shadowMap.renderParticles = false;
    this._shadowMap.ignoreCameraViewport = true;
    if (this._storedUniqueId) {
      this._shadowMap.uniqueId = this._storedUniqueId;
    }
    this._shadowMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => this._renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes);
    this._shadowMap.customIsReadyFunction = (mesh, _refreshRate, preWarm) => {
      if (!preWarm || !mesh.subMeshes) {
        return true;
      }
      let isReady = true;
      for (const subMesh of mesh.subMeshes) {
        const renderingMesh = subMesh.getRenderingMesh();
        const scene = this._scene;
        const engine2 = scene.getEngine();
        const material = subMesh.getMaterial();
        if (!material || subMesh.verticesCount === 0 || this.customAllowRendering && !this.customAllowRendering(subMesh)) {
          continue;
        }
        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
        if (batch.mustReturn) {
          continue;
        }
        const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
        const isTransparent = material.needAlphaBlendingForMesh(renderingMesh);
        isReady = this.isReady(subMesh, hardwareInstancedRendering, isTransparent) && isReady;
      }
      return isReady;
    };
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(() => {
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      engine._debugPushGroup?.(`shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
    });
    this._shadowMap.onBeforeRenderObservable.add((faceIndex) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[0]);
      }
      this._currentFaceIndex = faceIndex;
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      this.getTransformMatrix();
      FloatingOriginCurrentScene.eyeAtCamera = false;
      this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onAfterUnbindObservable.add(() => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._currentSceneUBO);
      }
      FloatingOriginCurrentScene.eyeAtCamera = true;
      this._scene.updateTransformMatrix();
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(true);
      }
      if (!this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
        engine._debugPopGroup?.(1);
        return;
      }
      const shadowMap = this.getShadowMapForRendering();
      if (shadowMap) {
        this._scene.postProcessManager.directRender(this._blurPostProcesses, shadowMap.renderTarget, true);
        engine.unBindFramebuffer(shadowMap.renderTarget, true);
      }
      engine._debugPopGroup?.(1);
    });
    const clearZero = new Color4(0, 0, 0, 0);
    const clearOne = new Color4(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add((engine2) => {
      if (this._filter === _ShadowGenerator.FILTER_PCF) {
        engine2.clear(clearOne, false, true, false);
      } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
        engine2.clear(clearZero, true, true, false);
      } else {
        engine2.clear(clearOne, true, true, false);
      }
    });
    this._shadowMap.onResizeObservable.add((rtt) => {
      this._storedUniqueId = this._shadowMap.uniqueId;
      this._mapSize = rtt.getRenderSize();
      this._light._markMeshesAsLightDirty();
      this.recreateShadowMap();
    });
    for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
      this._shadowMap.setRenderingAutoClearDepthStencil(i, false);
    }
  }
  async _initShaderSourceAsync(forceGLSL = false) {
    const engine = this._scene.getEngine();
    if (engine.isWebGPU && !forceGLSL && !_ShadowGenerator.ForceGLSL) {
      this._shaderLanguage = 1;
      await Promise.all([
        import("./shadowMap.fragment-RM7ZB5BM.js"),
        import("./shadowMap.vertex-ZKVJZIQF.js"),
        import("./depthBoxBlur.fragment-WYCRAQME.js"),
        import("./shadowMapFragmentSoftTransparentShadow-BRKVDIUB.js")
      ]);
    } else {
      await Promise.all([
        import("./shadowMap.fragment-HPENC2FJ.js"),
        import("./shadowMap.vertex-MFXHXEM4.js"),
        import("./depthBoxBlur.fragment-NJHNYQCD.js"),
        import("./shadowMapFragmentSoftTransparentShadow-NIZQJEPN.js")
      ]);
    }
    this._shadersLoaded = true;
  }
  _initializeBlurRTTAndPostProcesses() {
    const engine = this._scene.getEngine();
    const targetSize = this._mapSize / this.blurScale;
    if (!this.useKernelBlur || this.blurScale !== 1) {
      this._shadowMap2 = new RenderTargetTexture(this._light.name + "_shadowMap2", targetSize, this._scene, false, true, this._textureType, void 0, void 0, false);
      this._shadowMap2.wrapU = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.wrapV = Texture.CLAMP_ADDRESSMODE;
      this._shadowMap2.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
    if (this.useKernelBlur) {
      this._kernelBlurXPostprocess = new BlurPostProcess(this._light.name + "KernelBlurX", new Vector2(1, 0), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.width = targetSize;
      this._kernelBlurXPostprocess.height = targetSize;
      this._kernelBlurXPostprocess.externalTextureSamplerBinding = true;
      this._kernelBlurXPostprocess.onApplyObservable.add((effect) => {
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._kernelBlurYPostprocess = new BlurPostProcess(this._light.name + "KernelBlurY", new Vector2(0, 1), this.blurKernel, 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, this._textureType);
      this._kernelBlurXPostprocess.autoClear = false;
      this._kernelBlurYPostprocess.autoClear = false;
      if (this._textureType === 0) {
        this._kernelBlurXPostprocess.packedFloat = true;
        this._kernelBlurYPostprocess.packedFloat = true;
      }
      this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess];
    } else {
      this._boxBlurPostprocess = new PostProcess(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, Texture.BILINEAR_SAMPLINGMODE, engine, false, "#define OFFSET " + this._blurBoxOffset, this._textureType, void 0, void 0, void 0, void 0, this._shaderLanguage);
      this._boxBlurPostprocess.externalTextureSamplerBinding = true;
      this._boxBlurPostprocess.onApplyObservable.add((effect) => {
        effect.setFloat2("screenSize", targetSize, targetSize);
        effect.setTexture("textureSampler", this._shadowMap);
      });
      this._boxBlurPostprocess.autoClear = false;
      this._blurPostProcesses = [this._boxBlurPostprocess];
    }
  }
  _renderForShadowMap(opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) {
    let index;
    if (depthOnlySubMeshes.length) {
      for (index = 0; index < depthOnlySubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(depthOnlySubMeshes.data[index]);
      }
    }
    for (index = 0; index < opaqueSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(opaqueSubMeshes.data[index]);
    }
    for (index = 0; index < alphaTestSubMeshes.length; index++) {
      this._renderSubMeshForShadowMap(alphaTestSubMeshes.data[index]);
    }
    if (this._transparencyShadow) {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        this._renderSubMeshForShadowMap(transparentSubMeshes.data[index], true);
      }
    } else {
      for (index = 0; index < transparentSubMeshes.length; index++) {
        transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, mesh) {
    effect.setMatrix("viewProjection", this.getTransformMatrix());
  }
  _renderSubMeshForShadowMap(subMesh, isTransparent = false) {
    const renderingMesh = subMesh.getRenderingMesh();
    const effectiveMesh = subMesh.getEffectiveMesh();
    const scene = this._scene;
    const engine = scene.getEngine();
    const material = subMesh.getMaterial();
    effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    if (!material || subMesh.verticesCount === 0 || subMesh._renderId === scene.getRenderId()) {
      return;
    }
    const useRHS = scene.useRightHandedSystem;
    const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
    let sideOrientation = material._getEffectiveOrientation(renderingMesh);
    if (detNeg && !useRHS || !detNeg && useRHS) {
      sideOrientation = sideOrientation === 0 ? 1 : 0;
    }
    const reverseSideOrientation = sideOrientation === 0;
    engine.setState(material.backFaceCulling, void 0, void 0, reverseSideOrientation, material.cullBackFaces);
    const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
    if (batch.mustReturn) {
      return;
    }
    const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
    if (this.customAllowRendering && !this.customAllowRendering(subMesh)) {
      return;
    }
    if (this.isReady(subMesh, hardwareInstancedRendering, isTransparent)) {
      subMesh._renderId = scene.getRenderId();
      const shadowDepthWrapper = material.shadowDepthWrapper;
      const drawWrapper = shadowDepthWrapper?.getEffect(subMesh, this, engine.currentRenderPassId) ?? subMesh._getDrawWrapper();
      const effect = DrawWrapper.GetEffect(drawWrapper);
      engine.enableEffect(drawWrapper);
      if (!hardwareInstancedRendering) {
        renderingMesh._bind(subMesh, effect, material.fillMode);
      }
      this.getTransformMatrix();
      effect.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale);
      if (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
        effect.setVector3("lightDataSM", this._cachedDirection);
      } else {
        effect.setVector3("lightDataSM", this._cachedPosition.subtractToRef(this._scene.floatingOriginOffset, TmpVectors.Vector3[0]));
      }
      const camera = this._getCamera();
      effect.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera));
      if (isTransparent && this.enableSoftTransparentShadow) {
        effect.setFloat2("softTransparentShadowSM", effectiveMesh.visibility * material.alpha, this._opacityTexture?.getAlphaFromRGB ? 1 : 0);
      }
      if (shadowDepthWrapper) {
        subMesh._setMainDrawWrapperOverride(drawWrapper);
        if (shadowDepthWrapper.standalone) {
          shadowDepthWrapper.baseMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        } else {
          material.bindForSubMesh(effectiveMesh.getWorldMatrix(), renderingMesh, subMesh);
        }
        subMesh._setMainDrawWrapperOverride(null);
      } else {
        if (this._opacityTexture) {
          effect.setTexture("diffuseSampler", this._opacityTexture);
          effect.setMatrix("diffuseMatrix", this._opacityTexture.getTextureMatrix() || this._defaultTextureMatrix);
        }
        if (renderingMesh.useBones && renderingMesh.computeBonesUsingShaders && renderingMesh.skeleton) {
          const skeleton = renderingMesh.skeleton;
          if (skeleton.isUsingTextureForMatrices) {
            const boneTexture = skeleton.getTransformMatrixTexture(renderingMesh);
            if (!boneTexture) {
              return;
            }
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            effect.setMatrices("mBones", skeleton.getTransformMatrices(renderingMesh));
          }
        }
        BindMorphTargetParameters(renderingMesh, effect);
        if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
          renderingMesh.morphTargetManager._bind(effect);
        }
        const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
        if (bvaManager && bvaManager.isEnabled) {
          bvaManager.bind(effect, hardwareInstancedRendering);
        }
        BindClipPlane(effect, material, scene);
      }
      if (!this._useUBO && !shadowDepthWrapper) {
        this._bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect, effectiveMesh);
      }
      BindSceneUniformBuffer(effect, this._scene.getSceneUniformBuffer());
      this._scene.getSceneUniformBuffer().bindUniformBuffer();
      const world = effectiveMesh.getWorldMatrix();
      if (hardwareInstancedRendering) {
        effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        effectiveMesh.transferToEffect(world);
      }
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, true, material.cullBackFaces);
      }
      this.onBeforeShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
      this.onBeforeShadowMapRenderObservable.notifyObservers(effect);
      renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, worldOverride) => {
        if (effectiveMesh !== renderingMesh && !isInstance) {
          renderingMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          renderingMesh.transferToEffect(worldOverride);
        } else {
          effectiveMesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
          effectiveMesh.transferToEffect(isInstance ? worldOverride : world);
        }
      });
      if (this.forceBackFacesOnly) {
        engine.setState(true, 0, false, false, material.cullBackFaces);
      }
      this.onAfterShadowMapRenderObservable.notifyObservers(effect);
      this.onAfterShadowMapRenderMeshObservable.notifyObservers(renderingMesh);
    } else {
      if (this._shadowMap) {
        this._shadowMap.resetRefreshCounter();
      }
    }
  }
  _applyFilterValues() {
    if (!this._shadowMap) {
      return;
    }
    if (this.filter === _ShadowGenerator.FILTER_NONE || this.filter === _ShadowGenerator.FILTER_PCSS) {
      this._shadowMap.updateSamplingMode(Texture.NEAREST_SAMPLINGMODE);
    } else {
      this._shadowMap.updateSamplingMode(Texture.BILINEAR_SAMPLINGMODE);
    }
  }
  /**
   * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
   * @param onCompiled Callback triggered at the and of the effects compilation
   * @param options Sets of optional options forcing the compilation with different modes
   */
  forceCompilation(onCompiled, options) {
    const localOptions = {
      useInstances: false,
      ...options
    };
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const renderList = shadowMap.renderList;
    if (!renderList) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    const subMeshes = [];
    for (const mesh of renderList) {
      subMeshes.push(...mesh.subMeshes);
    }
    if (subMeshes.length === 0) {
      if (onCompiled) {
        onCompiled(this);
      }
      return;
    }
    let currentIndex = 0;
    const checkReady = () => {
      if (!this._scene || !this._scene.getEngine()) {
        return;
      }
      while (this.isReady(subMeshes[currentIndex], localOptions.useInstances, subMeshes[currentIndex].getMaterial()?.needAlphaBlendingForMesh(subMeshes[currentIndex].getMesh()) ?? false)) {
        currentIndex++;
        if (currentIndex >= subMeshes.length) {
          if (onCompiled) {
            onCompiled(this);
          }
          return;
        }
      }
      setTimeout(checkReady, 16);
    };
    checkReady();
  }
  /**
   * Forces all the attached effect to compile to enable rendering only once ready vs. lazily compiling effects.
   * @param options Sets of optional options forcing the compilation with different modes
   * @returns A promise that resolves when the compilation completes
   */
  async forceCompilationAsync(options) {
    return await new Promise((resolve) => {
      this.forceCompilation(() => {
        resolve();
      }, options);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _isReadyCustomDefines(defines, subMesh, useInstances) {
  }
  _prepareShadowDefines(subMesh, useInstances, defines, isTransparent) {
    defines.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase());
    defines.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0"));
    defines.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0"));
    defines.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    const mesh = subMesh.getMesh();
    defines.push("#define SM_NORMALBIAS " + (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind) ? "1" : "0"));
    defines.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0"));
    defines.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0"));
    defines.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && isTransparent ? "1" : "0"));
    this._isReadyCustomDefines(defines, subMesh, useInstances);
    return defines;
  }
  /**
   * Determine whether the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).
   * @param subMesh The submesh we want to render in the shadow map
   * @param useInstances Defines whether will draw in the map using instances
   * @param isTransparent Indicates that isReady is called for a transparent subMesh
   * @returns true if ready otherwise, false
   */
  isReady(subMesh, useInstances, isTransparent) {
    if (!this._shadersLoaded) {
      return false;
    }
    const material = subMesh.getMaterial(), shadowDepthWrapper = material?.shadowDepthWrapper;
    this._opacityTexture = null;
    if (!material) {
      return false;
    }
    const defines = [];
    this._prepareShadowDefines(subMesh, useInstances, defines, isTransparent);
    if (shadowDepthWrapper) {
      if (!shadowDepthWrapper.isReadyForSubMesh(subMesh, defines, this, useInstances, this._scene.getEngine().currentRenderPassId)) {
        return false;
      }
    } else {
      const subMeshEffect = subMesh._getDrawWrapper(void 0, true);
      let effect = subMeshEffect.effect;
      let cachedDefines = subMeshEffect.defines;
      const attribs = [VertexBuffer.PositionKind];
      const mesh = subMesh.getMesh();
      let useNormal = false;
      let uv1 = false;
      let uv2 = false;
      const color = false;
      if (this.normalBias && mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
        attribs.push(VertexBuffer.NormalKind);
        defines.push("#define NORMAL");
        useNormal = true;
        if (mesh.nonUniformScaling) {
          defines.push("#define NONUNIFORMSCALING");
        }
      }
      const needAlphaTesting = material.needAlphaTestingForMesh(mesh);
      if (needAlphaTesting || material.needAlphaBlendingForMesh(mesh)) {
        if (this.useOpacityTextureForTransparentShadow) {
          this._opacityTexture = material.opacityTexture;
        } else {
          this._opacityTexture = material.getAlphaTestTexture();
        }
        if (this._opacityTexture) {
          if (!this._opacityTexture.isReady()) {
            return false;
          }
          const alphaCutOff = material.alphaCutOff ?? _ShadowGenerator.DEFAULT_ALPHA_CUTOFF;
          defines.push("#define ALPHATEXTURE");
          if (needAlphaTesting) {
            defines.push(`#define ALPHATESTVALUE ${alphaCutOff}${alphaCutOff % 1 === 0 ? "." : ""}`);
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
            attribs.push(VertexBuffer.UVKind);
            defines.push("#define UV1");
            uv1 = true;
          }
          if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
            if (this._opacityTexture.coordinatesIndex === 1) {
              attribs.push(VertexBuffer.UV2Kind);
              defines.push("#define UV2");
              uv2 = true;
            }
          }
        }
      }
      const fallbacks = new EffectFallbacks();
      if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
        attribs.push(VertexBuffer.MatricesIndicesKind);
        attribs.push(VertexBuffer.MatricesWeightsKind);
        if (mesh.numBoneInfluencers > 4) {
          attribs.push(VertexBuffer.MatricesIndicesExtraKind);
          attribs.push(VertexBuffer.MatricesWeightsExtraKind);
        }
        const skeleton = mesh.skeleton;
        defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
        if (mesh.numBoneInfluencers > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
        }
        if (skeleton.isUsingTextureForMatrices) {
          defines.push("#define BONETEXTURE");
        } else {
          defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
        }
      } else {
        defines.push("#define NUM_BONE_INFLUENCERS 0");
      }
      const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
        mesh.morphTargetManager,
        defines,
        attribs,
        mesh,
        true,
        // usePositionMorph
        useNormal,
        // useNormalMorph
        false,
        // useTangentMorph
        uv1,
        // useUVMorph
        uv2,
        // useUV2Morph
        color
        // useColorMorph
      ) : 0;
      PrepareStringDefinesForClipPlanes(material, this._scene, defines);
      if (useInstances) {
        defines.push("#define INSTANCES");
        PushAttributesForInstances(attribs);
        if (subMesh.getRenderingMesh().hasThinInstances) {
          defines.push("#define THIN_INSTANCES");
        }
      }
      if (this.customShaderOptions) {
        if (this.customShaderOptions.defines) {
          for (const define of this.customShaderOptions.defines) {
            if (defines.indexOf(define) === -1) {
              defines.push(define);
            }
          }
        }
      }
      const bvaManager = mesh.bakedVertexAnimationManager;
      if (bvaManager && bvaManager.isEnabled) {
        defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
        if (useInstances) {
          attribs.push("bakedVertexAnimationSettingsInstanced");
        }
      }
      const join = defines.join("\n");
      if (cachedDefines !== join) {
        cachedDefines = join;
        let shaderName = "shadowMap";
        const uniforms = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "morphTargetCount",
          "boneTextureWidth",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices",
          "bakedVertexAnimationSettings",
          "bakedVertexAnimationTextureSizeInverted",
          "bakedVertexAnimationTime",
          "bakedVertexAnimationTexture"
        ];
        const samplers = ["diffuseSampler", "boneSampler", "morphTargets", "bakedVertexAnimationTexture"];
        const uniformBuffers = ["Scene", "Mesh"];
        AddClipPlaneUniforms(uniforms);
        if (this.customShaderOptions) {
          shaderName = this.customShaderOptions.shaderName;
          if (this.customShaderOptions.attributes) {
            for (const attrib of this.customShaderOptions.attributes) {
              if (attribs.indexOf(attrib) === -1) {
                attribs.push(attrib);
              }
            }
          }
          if (this.customShaderOptions.uniforms) {
            for (const uniform of this.customShaderOptions.uniforms) {
              if (uniforms.indexOf(uniform) === -1) {
                uniforms.push(uniform);
              }
            }
          }
          if (this.customShaderOptions.samplers) {
            for (const sampler of this.customShaderOptions.samplers) {
              if (samplers.indexOf(sampler) === -1) {
                samplers.push(sampler);
              }
            }
          }
        }
        const engine = this._scene.getEngine();
        effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
          shaderLanguage: this._shaderLanguage
        }, engine);
        subMeshEffect.setEffect(effect, cachedDefines);
      }
      if (!effect.isReady()) {
        return false;
      }
    }
    if (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      if (!this._blurPostProcesses || !this._blurPostProcesses.length) {
        this._initializeBlurRTTAndPostProcesses();
      }
    }
    if (this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady()) {
      return false;
    }
    if (this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady()) {
      return false;
    }
    if (this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady()) {
      return false;
    }
    return true;
  }
  /**
   * Prepare all the defines in a material relying on a shadow map at the specified light index.
   * @param defines Defines of the material we want to update
   * @param lightIndex Index of the light in the enabled light list of the material
   */
  prepareDefines(defines, lightIndex) {
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOW" + lightIndex] = true;
    if (this.useContactHardeningShadow) {
      defines["SHADOWPCSS" + lightIndex] = true;
      if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePercentageCloserFiltering) {
      defines["SHADOWPCF" + lightIndex] = true;
      if (this._filteringQuality === _ShadowGenerator.QUALITY_LOW) {
        defines["SHADOWLOWQUALITY" + lightIndex] = true;
      } else if (this._filteringQuality === _ShadowGenerator.QUALITY_MEDIUM) {
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = true;
      }
    } else if (this.usePoissonSampling) {
      defines["SHADOWPOISSON" + lightIndex] = true;
    } else if (this.useExponentialShadowMap || this.useBlurExponentialShadowMap) {
      defines["SHADOWESM" + lightIndex] = true;
    } else if (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) {
      defines["SHADOWCLOSEESM" + lightIndex] = true;
    }
    if (light.needCube()) {
      defines["SHADOWCUBE" + lightIndex] = true;
    }
  }
  /**
   * Binds the shadow related information inside of an effect (information like near, far, darkness...
   * defined in the generator but impacting the effect).
   * @param lightIndex Index of the light in the enabled light list of the material owning the effect
   * @param effect The effect we are binding the information for
   */
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    if (!light.needCube()) {
      const offset = scene.floatingOriginOffset;
      const transform = this.getTransformMatrix();
      const lightMatrix = scene.floatingOriginMode ? GetFullOffsetViewProjectionToRef(offset, this._viewMatrix, this._projectionMatrix, TmpVectors.Matrix[0]) : transform;
      effect.setMatrix("lightMatrix" + lightIndex, lightMatrix);
    }
    const shadowMapForRendering = this.getShadowMapForRendering();
    if (this._filter === _ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), shadowMap.getSize().width, 1 / shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === _ShadowGenerator.FILTER_PCSS) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      effect.setTexture("depthTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / shadowMap.getSize().width, this._contactHardeningLightSizeUVRatio * shadowMap.getSize().width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowTexture" + lightIndex, shadowMapForRendering);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / shadowMap.getSize().width, this.depthScale, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  /**
   * Gets the view matrix used to render the shadow map.
   */
  get viewMatrix() {
    return this._viewMatrix;
  }
  /**
   * Gets the projection matrix used to render the shadow map.
   */
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix used to project the meshes into the map from the light point of view.
   * (eq to shadow projection matrix * light transform matrix)
   * @returns The transform matrix used to create the shadow map
   */
  getTransformMatrix() {
    const scene = this._scene;
    if (this._currentRenderId === scene.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex) {
      return this._transformMatrix;
    }
    this._currentRenderId = scene.getRenderId();
    this._currentFaceIndexCache = this._currentFaceIndex;
    let lightPosition = this._light.position;
    if (this._light.computeTransformedInformation()) {
      lightPosition = this._light.transformedPosition;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    if (this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !lightPosition.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(lightPosition);
      this._cachedDirection.copyFrom(this._lightDirection);
      Matrix.LookAtLHToRef(lightPosition, lightPosition.add(this._lightDirection), Vector3.Up(), this._viewMatrix);
      const shadowMap = this.getShadowMap();
      if (shadowMap) {
        const renderList = shadowMap.renderList;
        if (renderList) {
          this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, renderList);
        }
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }
  /**
   * Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
   * Cube and 2D textures for instance.
   */
  recreateShadowMap() {
    const shadowMap = this._shadowMap;
    if (!shadowMap) {
      return;
    }
    const renderList = shadowMap.renderList;
    this._disposeRTTandPostProcesses();
    this._initializeGenerator();
    this.filter = this._filter;
    this._applyFilterValues();
    if (renderList) {
      if (!this._shadowMap.renderList) {
        this._shadowMap.renderList = [];
      }
      for (const mesh of renderList) {
        this._shadowMap.renderList.push(mesh);
      }
    } else {
      this._shadowMap.renderList = null;
    }
  }
  _disposeBlurPostProcesses() {
    if (this._shadowMap2) {
      this._shadowMap2.dispose();
      this._shadowMap2 = null;
    }
    if (this._boxBlurPostprocess) {
      this._boxBlurPostprocess.dispose();
      this._boxBlurPostprocess = null;
    }
    if (this._kernelBlurXPostprocess) {
      this._kernelBlurXPostprocess.dispose();
      this._kernelBlurXPostprocess = null;
    }
    if (this._kernelBlurYPostprocess) {
      this._kernelBlurYPostprocess.dispose();
      this._kernelBlurYPostprocess = null;
    }
    this._blurPostProcesses = [];
  }
  _disposeRTTandPostProcesses() {
    if (this._shadowMap) {
      this._shadowMap.dispose();
      this._shadowMap = null;
    }
    this._disposeBlurPostProcesses();
  }
  _disposeSceneUBOs() {
    if (this._sceneUBOs) {
      for (const ubo of this._sceneUBOs) {
        ubo.dispose();
      }
      this._sceneUBOs = [];
    }
  }
  /**
   * Disposes the ShadowGenerator.
   * Returns nothing.
   */
  dispose() {
    this._disposeRTTandPostProcesses();
    this._disposeSceneUBOs();
    if (this._light) {
      if (this._light._shadowGenerators) {
        const iterator = this._light._shadowGenerators.entries();
        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {
          const [camera, shadowGenerator] = entry.value;
          if (shadowGenerator === this) {
            this._light._shadowGenerators.delete(camera);
          }
        }
        if (this._light._shadowGenerators.size === 0) {
          this._light._shadowGenerators = null;
        }
      }
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear();
    this.onBeforeShadowMapRenderObservable.clear();
    this.onAfterShadowMapRenderMeshObservable.clear();
    this.onAfterShadowMapRenderObservable.clear();
  }
  /**
   * Serializes the shadow generator setup to a json object.
   * @returns The serialized JSON object
   */
  serialize() {
    const serializationObject = {};
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.className = this.getClassName();
    serializationObject.lightId = this._light.id;
    serializationObject.cameraId = this._camera?.id;
    serializationObject.id = this.id;
    serializationObject.mapSize = shadowMap.getRenderSize();
    serializationObject.forceBackFacesOnly = this.forceBackFacesOnly;
    serializationObject.darkness = this.getDarkness();
    serializationObject.transparencyShadow = this._transparencyShadow;
    serializationObject.frustumEdgeFalloff = this.frustumEdgeFalloff;
    serializationObject.bias = this.bias;
    serializationObject.normalBias = this.normalBias;
    serializationObject.usePercentageCloserFiltering = this.usePercentageCloserFiltering;
    serializationObject.useContactHardeningShadow = this.useContactHardeningShadow;
    serializationObject.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio;
    serializationObject.filteringQuality = this.filteringQuality;
    serializationObject.useExponentialShadowMap = this.useExponentialShadowMap;
    serializationObject.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap;
    serializationObject.usePoissonSampling = this.usePoissonSampling;
    serializationObject.depthScale = this.depthScale;
    serializationObject.blurBoxOffset = this.blurBoxOffset;
    serializationObject.blurKernel = this.blurKernel;
    serializationObject.blurScale = this.blurScale;
    serializationObject.useKernelBlur = this.useKernelBlur;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  /**
   * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
   * @param parsedShadowGenerator The JSON object to parse
   * @param scene The scene to create the shadow map for
   * @param constr A function that builds a shadow generator or undefined to create an instance of the default shadow generator
   * @returns The parsed shadow generator
   */
  static Parse(parsedShadowGenerator, scene, constr) {
    const light = scene.getLightById(parsedShadowGenerator.lightId);
    const camera = parsedShadowGenerator.cameraId !== void 0 ? scene.getCameraById(parsedShadowGenerator.cameraId) : null;
    const shadowGenerator = constr ? constr(parsedShadowGenerator.mapSize, light, camera) : new _ShadowGenerator(parsedShadowGenerator.mapSize, light, void 0, camera);
    const shadowMap = shadowGenerator.getShadowMap();
    if (parsedShadowGenerator.renderList.length && shadowMap) {
      const renderSet = new Set(parsedShadowGenerator.renderList);
      let renderList = shadowMap.renderList;
      if (!renderList) {
        renderList = shadowMap.renderList = [];
      }
      const meshes = scene.meshes;
      for (const mesh of meshes) {
        if (renderSet.has(mesh.id)) {
          renderList.push(mesh);
        }
      }
    }
    if (parsedShadowGenerator.id !== void 0) {
      shadowGenerator.id = parsedShadowGenerator.id;
    }
    shadowGenerator.forceBackFacesOnly = !!parsedShadowGenerator.forceBackFacesOnly;
    if (parsedShadowGenerator.darkness !== void 0) {
      shadowGenerator.setDarkness(parsedShadowGenerator.darkness);
    }
    if (parsedShadowGenerator.transparencyShadow) {
      shadowGenerator.setTransparencyShadow(true);
    }
    if (parsedShadowGenerator.frustumEdgeFalloff !== void 0) {
      shadowGenerator.frustumEdgeFalloff = parsedShadowGenerator.frustumEdgeFalloff;
    }
    if (parsedShadowGenerator.bias !== void 0) {
      shadowGenerator.bias = parsedShadowGenerator.bias;
    }
    if (parsedShadowGenerator.normalBias !== void 0) {
      shadowGenerator.normalBias = parsedShadowGenerator.normalBias;
    }
    if (parsedShadowGenerator.usePercentageCloserFiltering) {
      shadowGenerator.usePercentageCloserFiltering = true;
    } else if (parsedShadowGenerator.useContactHardeningShadow) {
      shadowGenerator.useContactHardeningShadow = true;
    } else if (parsedShadowGenerator.usePoissonSampling) {
      shadowGenerator.usePoissonSampling = true;
    } else if (parsedShadowGenerator.useExponentialShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurExponentialShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useCloseExponentialShadowMap) {
      shadowGenerator.useCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurCloseExponentialShadowMap) {
      shadowGenerator.useBlurCloseExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useVarianceShadowMap) {
      shadowGenerator.useExponentialShadowMap = true;
    } else if (parsedShadowGenerator.useBlurVarianceShadowMap) {
      shadowGenerator.useBlurExponentialShadowMap = true;
    }
    if (parsedShadowGenerator.contactHardeningLightSizeUVRatio !== void 0) {
      shadowGenerator.contactHardeningLightSizeUVRatio = parsedShadowGenerator.contactHardeningLightSizeUVRatio;
    }
    if (parsedShadowGenerator.filteringQuality !== void 0) {
      shadowGenerator.filteringQuality = parsedShadowGenerator.filteringQuality;
    }
    if (parsedShadowGenerator.depthScale) {
      shadowGenerator.depthScale = parsedShadowGenerator.depthScale;
    }
    if (parsedShadowGenerator.blurScale) {
      shadowGenerator.blurScale = parsedShadowGenerator.blurScale;
    }
    if (parsedShadowGenerator.blurBoxOffset) {
      shadowGenerator.blurBoxOffset = parsedShadowGenerator.blurBoxOffset;
    }
    if (parsedShadowGenerator.useKernelBlur) {
      shadowGenerator.useKernelBlur = parsedShadowGenerator.useKernelBlur;
    }
    if (parsedShadowGenerator.blurKernel) {
      shadowGenerator.blurKernel = parsedShadowGenerator.blurKernel;
    }
    return shadowGenerator;
  }
};
ShadowGenerator.CLASSNAME = "ShadowGenerator";
ShadowGenerator.ForceGLSL = false;
ShadowGenerator.FILTER_NONE = 0;
ShadowGenerator.FILTER_EXPONENTIALSHADOWMAP = 1;
ShadowGenerator.FILTER_POISSONSAMPLING = 2;
ShadowGenerator.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
ShadowGenerator.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
ShadowGenerator.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
ShadowGenerator.FILTER_PCF = 6;
ShadowGenerator.FILTER_PCSS = 7;
ShadowGenerator.QUALITY_HIGH = 0;
ShadowGenerator.QUALITY_MEDIUM = 1;
ShadowGenerator.QUALITY_LOW = 2;
ShadowGenerator.DEFAULT_ALPHA_CUTOFF = 0.5;
ShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox = class _BoundingBox {
  /**
   * Creates a new bounding box
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.vectors = BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = BuildArray(3, Vector3.Zero);
    this.vectorsWorld = BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  // Methods
  /**
   * Recreates the entire bounding box from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  }
  /**
   * Scale the current bounding box by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const tmpVectors = _BoundingBox._TmpVector3;
    const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    const len = diff.length();
    diff.normalizeFromLength(len);
    const distance = len * factor;
    const newRadius = diff.scaleInPlace(distance * 0.5);
    const min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    const max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  /**
   * @internal
   */
  _update(world) {
    const minWorld = this.minimumWorld;
    const maxWorld = this.maximumWorld;
    const directions = this.directions;
    const vectorsWorld = this.vectorsWorld;
    const vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (let index = 0; index < 8; ++index) {
        const v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (let index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  }
  /**
   * Tests if the bounding box is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    return _BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if the bounding box is entirely inside the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  isCompletelyInFrustum(frustumPlanes) {
    return _BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  }
  /**
   * Tests if a point is inside the bounding box
   * @param point defines the point to test
   * @returns true if the point is inside the bounding box
   */
  intersectsPoint(point) {
    const min = this.minimumWorld;
    const max = this.maximumWorld;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    const pointX = point.x, pointY = point.y, pointZ = point.z;
    const delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  }
  /**
   * Tests if the bounding box intersects with a bounding sphere
   * @param sphere defines the sphere to test
   * @returns true if there is an intersection
   */
  intersectsSphere(sphere) {
    return _BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  }
  /**
   * Tests if the bounding box intersects with a box defined by a min and max vectors
   * @param min defines the min vector to use
   * @param max defines the max vector to use
   * @returns true if there is an intersection
   */
  intersectsMinMax(min, max) {
    const myMin = this.minimumWorld;
    const myMax = this.maximumWorld;
    const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  }
  /**
   * Disposes the resources of the class
   */
  dispose() {
    this._drawWrapperFront?.dispose();
    this._drawWrapperBack?.dispose();
  }
  // Statics
  /**
   * Tests if two bounding boxes are intersections
   * @param box0 defines the first box to test
   * @param box1 defines the second box to test
   * @returns true if there is an intersection
   */
  static Intersects(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  }
  /**
   * Tests if a bounding box defines by a min/max vectors intersects a sphere
   * @param minPoint defines the minimum vector of the bounding box
   * @param maxPoint defines the maximum vector of the bounding box
   * @param sphereCenter defines the sphere center
   * @param sphereRadius defines the sphere radius
   * @returns true if there is an intersection
   */
  static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {
    const vector = _BoundingBox._TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    const num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  }
  /**
   * Tests if a bounding box defined with 8 vectors is entirely inside frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an inclusion
   */
  static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Tests if a bounding box defined with 8 vectors intersects frustum planes
   * @param boundingVectors defines an array of 8 vectors representing a bounding box
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  static IsInFrustum(boundingVectors, frustumPlanes) {
    for (let p = 0; p < 6; ++p) {
      let canReturnFalse = true;
      const frustumPlane = frustumPlanes[p];
      for (let i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  }
};
BoundingBox._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere = class _BoundingSphere {
  /**
   * Creates a new bounding sphere
   * @param min defines the minimum vector (in local space)
   * @param max defines the maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  constructor(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  /**
   * Recreates the entire bounding sphere from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    const distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  }
  /**
   * Scale the current bounding sphere by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding box
   */
  scale(factor) {
    const newRadius = this.radius * factor;
    const tmpVectors = _BoundingSphere._TmpVector3;
    const tempRadiusVector = tmpVectors[0].setAll(newRadius);
    const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  }
  /**
   * Gets the world matrix of the bounding box
   * @returns a matrix
   */
  getWorldMatrix() {
    return this._worldMatrix;
  }
  // Methods
  /**
   * @internal
   */
  _update(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      const tempVector = _BoundingSphere._TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  }
  /**
   * Tests if the bounding sphere is intersecting the frustum planes
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if there is an intersection
   */
  isInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    const radius = this.radiusWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if the bounding sphere center is in between the frustum planes.
   * Used for optimistic fast inclusion.
   * @param frustumPlanes defines the frustum planes to test
   * @returns true if the sphere center is in between the frustum planes
   */
  isCenterInFrustum(frustumPlanes) {
    const center = this.centerWorld;
    for (let i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Tests if a point is inside the bounding sphere
   * @param point defines the point to test
   * @returns true if the point is inside the bounding sphere
   */
  intersectsPoint(point) {
    const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  }
  // Statics
  /**
   * Checks if two sphere intersect
   * @param sphere0 sphere 0
   * @param sphere1 sphere 1
   * @returns true if the spheres intersect
   */
  static Intersects(sphere0, sphere1) {
    const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  }
  /**
   * Creates a sphere from a center and a radius
   * @param center The center
   * @param radius radius
   * @param matrix Optional worldMatrix
   * @returns The sphere
   */
  static CreateFromCenterAndRadius(center, radius, matrix) {
    this._TmpVector3[0].copyFrom(center);
    this._TmpVector3[1].copyFromFloats(0, 0, radius);
    this._TmpVector3[2].copyFrom(center);
    this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
    this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const sphere = new _BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  }
};
BoundingSphere._TmpVector3 = BuildArray(3, Vector3.Zero);

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _Result0 = { min: 0, max: 0 };
var _Result1 = { min: 0, max: 0 };
var ComputeBoxExtents = (axis, box, result) => {
  const p = Vector3.Dot(box.centerWorld, axis);
  const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  const r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var AxisOverlap = (axis, box0, box1) => {
  ComputeBoxExtents(axis, box0, _Result0);
  ComputeBoxExtents(axis, box1, _Result1);
  return !(_Result0.min > _Result1.max || _Result1.min > _Result0.max);
};
var BoundingInfo = class _BoundingInfo {
  /**
   * Constructs bounding info
   * @param minimum min vector of the bounding box/sphere
   * @param maximum max vector of the bounding box/sphere
   * @param worldMatrix defines the new world matrix
   */
  constructor(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  /**
   * Recreates the entire bounding info from scratch as if we call the constructor in place
   * @param min defines the new minimum vector (in local space)
   * @param max defines the new maximum vector (in local space)
   * @param worldMatrix defines the new world matrix
   */
  reConstruct(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  }
  /**
   * min vector of the bounding box/sphere
   */
  get minimum() {
    return this.boundingBox.minimum;
  }
  /**
   * max vector of the bounding box/sphere
   */
  get maximum() {
    return this.boundingBox.maximum;
  }
  /**
   * If the info is locked and won't be updated to avoid perf overhead
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(value) {
    this._isLocked = value;
  }
  // Methods
  /**
   * Updates the bounding sphere and box
   * @param world world matrix to be used to update
   */
  update(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  }
  /**
   * Recreate the bounding info to be centered around a specific point given a specific extend.
   * @param center New center of the bounding info
   * @param extend New extend of the bounding info
   * @returns the current bounding info
   */
  centerOn(center, extend) {
    const minimum = _BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    const maximum = _BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to include the given point.
   * @param point The point that will be included in the current bounding info (in local space)
   * @returns the current bounding info
   */
  encapsulate(point) {
    const minimum = Vector3.Minimize(this.minimum, point);
    const maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  }
  /**
   * Grows the bounding info to encapsulate the given bounding info.
   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info
   * @returns the current bounding info
   */
  encapsulateBoundingInfo(toEncapsulate) {
    const invw = TmpVectors.Matrix[0];
    this.boundingBox.getWorldMatrix().invertToRef(invw);
    const v = TmpVectors.Vector3[0];
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);
    this.encapsulate(v);
    Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);
    this.encapsulate(v);
    return this;
  }
  /**
   * Scale the current bounding info by applying a scale factor
   * @param factor defines the scale factor to apply
   * @returns the current bounding info
   */
  scale(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  }
  /**
   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.
   * @param frustumPlanes defines the frustum to test
   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)
   * The different strategies available are:
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION
   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY
   * @returns true if the bounding info is in the frustum planes
   */
  isInFrustum(frustumPlanes, strategy = 0) {
    const inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    const bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  }
  /**
   * Gets the world distance between the min and max points of the bounding box
   */
  get diagonalLength() {
    const boundingBox = this.boundingBox;
    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, _BoundingInfo._TmpVector3[0]);
    return diag.length();
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param frustumPlanes Camera near/planes
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  }
  /**
   * @internal
   */
  _checkCollision(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  /**
   * Checks if a point is inside the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param point the point to check intersection with
   * @returns if the point intersects
   */
  intersectsPoint(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  }
  /**
   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect
   * @param boundingInfo the bounding info to check intersection with
   * @param precise if the intersection should be done using OBB
   * @returns if the bounding info intersects
   */
  intersects(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    const box0 = this.boundingBox;
    const box1 = boundingInfo.boundingBox;
    if (!AxisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!AxisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  }
};
BoundingInfo._TmpVector3 = BuildArray(2, Vector3.Zero);

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera = class _Camera extends Node {
  /**
   * Define the current local position of the camera in the scene
   */
  get position() {
    return this._position;
  }
  set position(newPosition) {
    this._position = newPosition;
  }
  /**
   * The vector the camera should consider as up.
   * (default is Vector3(0, 1, 0) aka Vector3.Up())
   */
  set upVector(vec) {
    this._upVector = vec;
  }
  get upVector() {
    return this._upVector;
  }
  /**
   * The screen area in scene units squared
   */
  get screenArea() {
    let x = 0;
    let y = 0;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      if (this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED) {
        y = this.minZ * 2 * Math.tan(this.fov / 2);
        x = this.getEngine().getAspectRatio(this) * y;
      } else {
        x = this.minZ * 2 * Math.tan(this.fov / 2);
        y = x / this.getEngine().getAspectRatio(this);
      }
    } else {
      const halfWidth = this.getEngine().getRenderWidth() / 2;
      const halfHeight = this.getEngine().getRenderHeight() / 2;
      x = (this.orthoRight ?? halfWidth) - (this.orthoLeft ?? -halfWidth);
      y = (this.orthoTop ?? halfHeight) - (this.orthoBottom ?? -halfHeight);
    }
    return x * y;
  }
  /**
   * Define the current limit on the left side for an orthographic camera
   * In scene unit
   */
  set orthoLeft(value) {
    this._orthoLeft = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoLeft = value;
    }
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  /**
   * Define the current limit on the right side for an orthographic camera
   * In scene unit
   */
  set orthoRight(value) {
    this._orthoRight = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoRight = value;
    }
  }
  get orthoRight() {
    return this._orthoRight;
  }
  /**
   * Define the current limit on the bottom side for an orthographic camera
   * In scene unit
   */
  set orthoBottom(value) {
    this._orthoBottom = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoBottom = value;
    }
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  /**
   * Define the current limit on the top side for an orthographic camera
   * In scene unit
   */
  set orthoTop(value) {
    this._orthoTop = value;
    for (const rigCamera of this._rigCameras) {
      rigCamera.orthoTop = value;
    }
  }
  get orthoTop() {
    return this._orthoTop;
  }
  /**
   * Sets the camera's field of view in radians based on the focal length and sensor size.
   * @param value the focal length of the camera in mm.
   * @param sensorSize the sensor width size of the camera in mm. (default is 36mm, which is a full frame sensor)
   */
  setFocalLength(value, sensorSize = 36) {
    this.fov = 2 * Math.atan(sensorSize / (2 * value));
  }
  /**
   * Define the mode of the camera (Camera.PERSPECTIVE_CAMERA or Camera.ORTHOGRAPHIC_CAMERA)
   */
  set mode(mode) {
    this._mode = mode;
    for (const rigCamera of this._rigCameras) {
      rigCamera.mode = mode;
    }
  }
  get mode() {
    return this._mode;
  }
  /**
   * Gets a flag indicating that the camera has moved in some way since the last call to Camera.update()
   */
  get hasMoved() {
    return this._hasMoved;
  }
  /**
   * Instantiates a new camera object.
   * This should not be used directly but through the inherited cameras: ArcRotate, Free...
   * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras
   * @param name Defines the name of the camera in the scene
   * @param position Defines the position of the camera
   * @param scene Defines the scene the camera belongs too
   * @param setActiveOnSceneIfNoneActive Defines if the camera should be set as active after creation if no other camera have been defined in the scene
   */
  constructor(name, position, scene, setActiveOnSceneIfNoneActive = true) {
    super(name, scene, false);
    this._position = Vector3.Zero();
    this._upVector = Vector3.Up();
    this.oblique = null;
    this._orthoLeft = null;
    this._orthoRight = null;
    this._orthoBottom = null;
    this._orthoTop = null;
    this.fov = 0.8;
    this.projectionPlaneTilt = 0;
    this.minZ = 1;
    this.maxZ = 1e4;
    this.inertia = 0.9;
    this._mode = _Camera.PERSPECTIVE_CAMERA;
    this.isIntermediate = false;
    this.viewport = new Viewport(0, 0, 1, 1);
    this.layerMask = 268435455;
    this.fovMode = _Camera.FOVMODE_VERTICAL_FIXED;
    this.cameraRigMode = _Camera.RIG_MODE_NONE;
    this.customRenderTargets = [];
    this.outputRenderTarget = null;
    this.onViewMatrixChangedObservable = new Observable();
    this.onProjectionMatrixChangedObservable = new Observable();
    this.onAfterCheckInputsObservable = new Observable();
    this.onRestoreStateObservable = new Observable();
    this.isRigCamera = false;
    this._hasMoved = false;
    this._rigCameras = new Array();
    this._skipRendering = false;
    this._projectionMatrix = new Matrix();
    this._postProcesses = new Array();
    this._activeMeshes = new SmartArray(256);
    this._globalPosition = Vector3.Zero();
    this._computedViewMatrix = Matrix.Identity();
    this._doNotComputeProjectionMatrix = false;
    this._transformMatrix = Matrix.Zero();
    this._refreshFrustumPlanes = true;
    this._absoluteRotation = Quaternion.Identity();
    this._isCamera = true;
    this._isLeftCamera = false;
    this._isRightCamera = false;
    this.getScene().addCamera(this);
    if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
      this.getScene().activeCamera = this;
    }
    this.position = position;
    this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name}`);
  }
  /**
   * Store current camera state (fov, position, etc..)
   * @returns the camera
   */
  storeState() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  }
  /**
   * Returns true if a state has been stored by calling storeState method.
   * @returns true if state has been stored.
   */
  hasStateStored() {
    return !!this._stateStored;
  }
  /**
   * Restores the camera state values if it has been stored. You must call storeState() first
   * @returns true if restored and false otherwise
   */
  _restoreStateValues() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  }
  /**
   * Restored camera state. You must call storeState() first.
   * @returns true if restored and false otherwise
   */
  restoreState() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  }
  /**
   * Gets the class name of the camera.
   * @returns the class name
   */
  getClassName() {
    return "Camera";
  }
  /**
   * Gets a string representation of the camera useful for debug purpose.
   * @param fullDetails Defines that a more verbose level of logging is required
   * @returns the string representation
   */
  toString(fullDetails) {
    let ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (let i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  }
  /**
   * Automatically tilts the projection plane, using `projectionPlaneTilt`, to correct the perspective effect on vertical lines.
   */
  applyVerticalCorrection() {
    const rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  }
  /**
   * Gets the current world space position of the camera.
   */
  get globalPosition() {
    return this._globalPosition;
  }
  /**
   * Gets the list of active meshes this frame (meshes no culled or excluded by lod s in the frame)
   * @returns the active meshe list
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Check whether a mesh is part of the current active mesh list of the camera
   * @param mesh Defines the mesh to check
   * @returns true if active, false otherwise
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Is this camera ready to be used/rendered
   * @param completeCheck defines if a complete check (including post processes) has to be done (false by default)
   * @returns true if the camera is ready
   */
  isReady(completeCheck = false) {
    if (completeCheck) {
      for (const pp of this._postProcesses) {
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return super.isReady(completeCheck);
  }
  /** @internal */
  _initCache() {
    super._initCache();
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.obliqueAngle = void 0;
    this._cache.obliqueLength = void 0;
    this._cache.obliqueOffset = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  }
  /**
   * @internal
   */
  _updateCache(ignoreParentClass) {
    if (!ignoreParentClass) {
      super._updateCache();
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  }
  /** @internal */
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  /** @internal */
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronized()) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  }
  /** @internal */
  _isSynchronizedProjectionMatrix() {
    let isSynchronized = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!isSynchronized) {
      return false;
    }
    const engine = this.getEngine();
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      isSynchronized = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      isSynchronized = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
      if (this.oblique) {
        isSynchronized = isSynchronized && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset;
      }
    }
    return isSynchronized;
  }
  /**
   * Attach the input controls to a specific dom element to get the input from.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   * @param _noPreventDefault Defines whether event caught by the controls should call preventdefault() (https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault)
   */
  attachControl(_ignored, _noPreventDefault) {
  }
  /**
   * Detach the current controls from the specified dom element.
   * This function is here because typescript removes the typing of the last function.
   * @param _ignored defines an ignored parameter kept for backward compatibility.
   */
  detachControl(_ignored) {
  }
  /**
   * Update the camera state according to the different inputs gathered during the frame.
   */
  update() {
    this._hasMoved = false;
    this._checkInputs();
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
    this.getViewMatrix();
    this.getProjectionMatrix();
  }
  /** @internal */
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  /** @internal */
  get rigCameras() {
    return this._rigCameras;
  }
  /**
   * Gets the post process used by the rig cameras
   */
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  /**
   * Internal, gets the first post process.
   * @returns the first post process to be run on this camera.
   */
  _getFirstPostProcess() {
    for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (let i = 0, len = this._rigCameras.length; i < len; i++) {
      const cam = this._rigCameras[i];
      const rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        const isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  }
  /**
   * Attach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to attach to the camera
   * @param insertAt The position of the post process in case several of them are in use in the scene
   * @returns the position the post process has been inserted at
   */
  attachPostProcess(postProcess, insertAt = null) {
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  }
  /**
   * Detach a post process to the camera.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#attach-postprocess
   * @param postProcess The post process to detach from the camera
   */
  detachPostProcess(postProcess) {
    const idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  }
  /**
   * Gets the current world matrix of the camera
   * @returns the world matrix
   */
  getWorldMatrix() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  }
  /** @internal */
  _getViewMatrix() {
    return Matrix.Identity();
  }
  /**
   * Gets the current view matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the view matrix
   */
  getViewMatrix(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this._hasMoved = true;
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  }
  /**
   * Freeze the projection matrix.
   * It will prevent the cache check of the camera projection compute and can speed up perf
   * if no parameter of the camera are meant to change
   * @param projection Defines manually a projection if necessary
   */
  freezeProjectionMatrix(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  }
  /**
   * Unfreeze the projection matrix if it has previously been freezed by freezeProjectionMatrix.
   */
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = false;
  }
  /**
   * Gets the current projection matrix of the camera.
   * @param force forces the camera to recompute the matrix without looking at the cached state
   * @returns the projection matrix
   */
  getProjectionMatrix(force) {
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    const engine = this.getEngine();
    const scene = this.getScene();
    const reverseDepth = engine.useReverseDepthBuffer;
    if (this.mode === _Camera.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      let getProjectionMatrix;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === _Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
    } else {
      const halfWidth = engine.getRenderWidth() / 2;
      const halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        if (this.oblique) {
          Matrix.ObliqueOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterRHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      } else {
        if (this.oblique) {
          Matrix.ObliqueOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, engine.isNDCHalfZRange);
        } else {
          Matrix.OrthoOffCenterLHToRef(this.orthoLeft ?? -halfWidth, this.orthoRight ?? halfWidth, this.orthoBottom ?? -halfHeight, this.orthoTop ?? halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
        }
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.obliqueAngle = this.oblique?.angle;
      this._cache.obliqueLength = this.oblique?.length;
      this._cache.obliqueOffset = this.oblique?.offset;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  }
  /**
   * Gets the transformation matrix (ie. the multiplication of view by projection matrices)
   * @returns a Matrix
   */
  getTransformationMatrix() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  }
  _computeObliqueDistance(offset) {
    const arcRotateCamera = this;
    const targetCamera = this;
    return (arcRotateCamera.radius || (targetCamera.target ? Vector3.Distance(this.position, targetCamera.target) : this.position.length())) + offset;
  }
  /** @internal */
  _updateFrustumPlanes() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * This checks the bounding box center. See isCompletelyInFrustum for a full bounding check
   * @param target The object to check
   * @param checkRigCameras If the rig cameras should be checked (eg. with VR camera both eyes should be checked) (Default: false)
   * @returns true if the object is in frustum otherwise false
   */
  isInFrustum(target, checkRigCameras = false) {
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      let result = false;
      for (const cam of this.rigCameras) {
        cam._updateFrustumPlanes();
        result = result || target.isInFrustum(cam._frustumPlanes);
      }
      return result;
    } else {
      return target.isInFrustum(this._frustumPlanes);
    }
  }
  /**
   * Checks if a cullable object (mesh...) is in the camera frustum
   * Unlike isInFrustum this checks the full bounding box
   * @param target The object to check
   * @returns true if the object is in frustum otherwise false
   */
  isCompletelyInFrustum(target) {
    this._updateFrustumPlanes();
    return target.isCompletelyInFrustum(this._frustumPlanes);
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRay(length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Gets a ray in the forward direction from the camera.
   * @param refRay the ray to (re)use when setting the values
   * @param length Defines the length of the ray to create
   * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a world space ray
   * @param origin Defines the start point of the ray which defaults to the camera position
   * @returns the forward ray
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getForwardRayToRef(refRay, length = 100, transform, origin) {
    throw _WarnImport("Ray");
  }
  /**
   * Releases resources associated with this node.
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      const index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses.length = 0;
    } else {
      let i2 = this._postProcesses.length;
      while (--i2 >= 0) {
        const postProcess = this._postProcesses[i2];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    let i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets.length = 0;
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get isRightCamera() {
    return this._isRightCamera;
  }
  /**
   * Gets the left camera of a rig setup in case of Rigged Camera
   */
  get leftCamera() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0];
  }
  /**
   * Gets the right camera of a rig setup in case of Rigged Camera
   */
  get rightCamera() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1];
  }
  /**
   * Gets the left camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getLeftTarget() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  }
  /**
   * Gets the right camera target of a rig setup in case of Rigged Camera
   * @returns the target position
   */
  getRightTarget() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  }
  /**
   * @internal
   */
  setCameraRigMode(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      const camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== _Camera.RIG_MODE_NONE) {
      const leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      const rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _setRigMode(rigParams) {
  }
  /** @internal */
  _getVRProjectionMatrix() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  }
  /**
   * @internal
   */
  setCameraRigParameter(name, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name] = value;
    if (name === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  }
  /**
   * needs to be overridden by children so sub has required properties to be copied
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  createRigCamera(name, cameraIndex) {
    return null;
  }
  /**
   * May need to be overridden by children
   * @internal
   */
  _updateRigCameras() {
    for (let i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === _Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  }
  /** @internal */
  _setupInputs() {
  }
  /**
   * Serialiaze the camera setup to a json representation
   * @returns the JSON representation
   */
  serialize() {
    const serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      this.parent._serializeAsParent(serializationObject);
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  }
  /**
   * Clones the current camera.
   * @param name The cloned camera name
   * @param newParent The cloned camera's new parent (none by default)
   * @returns the cloned camera
   */
  clone(name, newParent = null) {
    const camera = SerializationHelper.Clone(_Camera.GetConstructorFromName(this.getClassName(), name, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  }
  /**
   * Gets the direction of the camera relative to a given local axis.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @returns the direction
   */
  getDirection(localAxis) {
    const result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  }
  /**
   * Returns the current camera absolute rotation
   */
  get absoluteRotation() {
    this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
    return this._absoluteRotation;
  }
  /**
   * Gets the direction of the camera relative to a given local axis into a passed vector.
   * @param localAxis Defines the reference axis to provide a relative direction.
   * @param result Defines the vector to store the result in
   */
  getDirectionToRef(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  }
  /**
   * Gets a camera constructor for a given camera type
   * @param type The type of the camera to construct (should be equal to one of the camera class name)
   * @param name The name of the camera the result will be able to instantiate
   * @param scene The scene the result will construct the camera in
   * @param interaxial_distance In case of stereoscopic setup, the distance between both eyes
   * @param isStereoscopicSideBySide In case of stereoscopic setup, should the sereo be side b side
   * @returns a factory method to construct the camera
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static GetConstructorFromName(type, name, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
    const constructorFunc = Node.Construct(type, name, scene, {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return () => _Camera._CreateDefaultParsedCamera(name, scene);
  }
  /**
   * Compute the world  matrix of the camera.
   * @returns the camera world matrix
   */
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  /**
   * Parse a JSON and creates the camera from the parsed information
   * @param parsedCamera The JSON to parse
   * @param scene The scene to instantiate the camera in
   * @returns the newly constructed camera
   */
  static Parse(parsedCamera, scene) {
    const type = parsedCamera.type;
    const construct = _Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (parsedCamera.parentInstanceIndex !== void 0) {
      camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        const parsedAnimation = parsedCamera.animations[animationIndex];
        const internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  }
  /** @internal */
  _calculateHandednessMultiplier() {
    let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
    if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
      handednessMultiplier *= -1;
    }
    return handednessMultiplier;
  }
};
Camera._CreateDefaultParsedCamera = (name, scene) => {
  throw _WarnImport("UniversalCamera");
};
Camera.PERSPECTIVE_CAMERA = 0;
Camera.ORTHOGRAPHIC_CAMERA = 1;
Camera.FOVMODE_VERTICAL_FIXED = 0;
Camera.FOVMODE_HORIZONTAL_FIXED = 1;
Camera.RIG_MODE_NONE = 0;
Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
Camera.RIG_MODE_VR = 20;
Camera.RIG_MODE_CUSTOM = 22;
Camera.ForceAttachControlToAlwaysPreventDefault = false;
__decorate([
  serializeAsVector3("position")
], Camera.prototype, "_position", void 0);
__decorate([
  serializeAsVector3("upVector")
], Camera.prototype, "_upVector", void 0);
__decorate([
  serialize()
], Camera.prototype, "orthoLeft", null);
__decorate([
  serialize()
], Camera.prototype, "orthoRight", null);
__decorate([
  serialize()
], Camera.prototype, "orthoBottom", null);
__decorate([
  serialize()
], Camera.prototype, "orthoTop", null);
__decorate([
  serialize()
], Camera.prototype, "fov", void 0);
__decorate([
  serialize()
], Camera.prototype, "projectionPlaneTilt", void 0);
__decorate([
  serialize()
], Camera.prototype, "minZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "maxZ", void 0);
__decorate([
  serialize()
], Camera.prototype, "inertia", void 0);
__decorate([
  serialize()
], Camera.prototype, "mode", null);
__decorate([
  serialize()
], Camera.prototype, "layerMask", void 0);
__decorate([
  serialize()
], Camera.prototype, "fovMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "cameraRigMode", void 0);
__decorate([
  serialize()
], Camera.prototype, "interaxialDistance", void 0);
__decorate([
  serialize()
], Camera.prototype, "isStereoscopicSideBySide", void 0);

// node_modules/@babylonjs/core/Rendering/depthRenderer.js
var DepthRenderer = class _DepthRenderer {
  /**
   * Gets the shader language used in this material.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Sets a specific material to be used to render a mesh/a list of meshes by the depth renderer
   * @param mesh mesh or array of meshes
   * @param material material to use by the depth render when rendering the mesh(es). If undefined is passed, the specific material created by the depth renderer will be used.
   */
  setMaterialForRendering(mesh, material) {
    this._depthMap.setMaterialForRendering(mesh, material);
  }
  /**
   * Instantiates a depth renderer
   * @param scene The scene the renderer belongs to
   * @param type The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)
   * @param camera The camera to be used to render the depth map (default: scene's active camera)
   * @param storeNonLinearDepth Defines whether the depth is stored linearly like in Babylon Shadows or directly like glFragCoord.z
   * @param samplingMode The sampling mode to be used with the render target (Linear, Nearest...) (default: TRILINEAR_SAMPLINGMODE)
   * @param storeCameraSpaceZ Defines whether the depth stored is the Z coordinate in camera space. If true, storeNonLinearDepth has no effect. (Default: false)
   * @param name Name of the render target (default: DepthRenderer)
   * @param existingRenderTargetTexture An existing render target texture to use (default: undefined). If not provided, a new render target texture will be created.
   */
  constructor(scene, type = 1, camera = null, storeNonLinearDepth = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, storeCameraSpaceZ = false, name, existingRenderTargetTexture) {
    this._shaderLanguage = 0;
    this.enabled = true;
    this.forceDepthWriteTransparentMeshes = false;
    this.useOnlyInActiveCamera = false;
    this.reverseCulling = false;
    this._shadersLoaded = false;
    this._scene = scene;
    this._storeNonLinearDepth = storeNonLinearDepth;
    this._storeCameraSpaceZ = storeCameraSpaceZ;
    this.isPacked = type === 0;
    if (this.isPacked) {
      this.clearColor = new Color4(1, 1, 1, 1);
    } else {
      this.clearColor = new Color4(storeCameraSpaceZ ? 0 : 1, 0, 0, 1);
    }
    this._initShaderSourceAsync();
    _DepthRenderer._SceneComponentInitialization(this._scene);
    const engine = scene.getEngine();
    this._camera = camera;
    if (samplingMode !== Texture.NEAREST_SAMPLINGMODE) {
      if (type === 1 && !engine._caps.textureFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
      if (type === 2 && !engine._caps.textureHalfFloatLinearFiltering) {
        samplingMode = Texture.NEAREST_SAMPLINGMODE;
      }
    }
    const format = this.isPacked || !engine._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = existingRenderTargetTexture ?? new RenderTargetTexture(name ?? "DepthRenderer", { width: engine.getRenderWidth(), height: engine.getRenderHeight() }, this._scene, false, true, type, false, samplingMode, void 0, void 0, void 0, format);
    this._depthMap.wrapU = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.wrapV = Texture.CLAMP_ADDRESSMODE;
    this._depthMap.refreshRate = 1;
    this._depthMap.renderParticles = false;
    this._depthMap.renderList = null;
    this._depthMap.noPrePassRenderer = true;
    this._depthMap.activeCamera = this._camera;
    this._depthMap.ignoreCameraViewport = true;
    this._depthMap.useCameraPostProcesses = false;
    this._depthMap.onClearObservable.add((engine2) => {
      engine2.clear(this.clearColor, true, true, true);
    });
    this._depthMap.onBeforeBindObservable.add(() => {
      engine._debugPushGroup?.("depth renderer", 1);
    });
    this._depthMap.onAfterUnbindObservable.add(() => {
      engine._debugPopGroup?.(1);
    });
    this._depthMap.customIsReadyFunction = (mesh, refreshRate, preWarm) => {
      if ((preWarm || refreshRate === 0) && mesh.subMeshes) {
        for (let i = 0; i < mesh.subMeshes.length; ++i) {
          const subMesh = mesh.subMeshes[i];
          const renderingMesh = subMesh.getRenderingMesh();
          const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
          const hardwareInstancedRendering = engine.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
          if (!this.isReady(subMesh, hardwareInstancedRendering)) {
            return false;
          }
        }
      }
      return true;
    };
    const renderSubMesh = (subMesh) => {
      const renderingMesh = subMesh.getRenderingMesh();
      const effectiveMesh = subMesh.getEffectiveMesh();
      const scene2 = this._scene;
      const engine2 = scene2.getEngine();
      const material = subMesh.getMaterial();
      effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;
      if (!material || effectiveMesh.infiniteDistance || material.disableDepthWrite || subMesh.verticesCount === 0 || subMesh._renderId === scene2.getRenderId()) {
        return;
      }
      const detNeg = effectiveMesh._getWorldMatrixDeterminant() < 0;
      let sideOrientation = material._getEffectiveOrientation(renderingMesh);
      if (detNeg) {
        sideOrientation = sideOrientation === 0 ? 1 : 0;
      }
      const reverseSideOrientation = sideOrientation === 0;
      engine2.setState(material.backFaceCulling, 0, false, reverseSideOrientation, this.reverseCulling ? !material.cullBackFaces : material.cullBackFaces);
      const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!subMesh.getReplacementMesh());
      if (batch.mustReturn) {
        return;
      }
      const hardwareInstancedRendering = engine2.getCaps().instancedArrays && (batch.visibleInstances[subMesh._id] !== null && batch.visibleInstances[subMesh._id] !== void 0 || renderingMesh.hasThinInstances);
      const camera2 = this._camera || scene2.activeCamera;
      if (this.isReady(subMesh, hardwareInstancedRendering) && camera2) {
        subMesh._renderId = scene2.getRenderId();
        const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine2.currentRenderPassId];
        let drawWrapper = subMesh._getDrawWrapper();
        if (!drawWrapper && renderingMaterial) {
          drawWrapper = renderingMaterial._getDrawWrapper();
        }
        const cameraIsOrtho = camera2.mode === Camera.ORTHOGRAPHIC_CAMERA;
        if (!drawWrapper) {
          return;
        }
        const effect = drawWrapper.effect;
        engine2.enableEffect(drawWrapper);
        if (!hardwareInstancedRendering) {
          renderingMesh._bind(subMesh, effect, material.fillMode);
        }
        if (!renderingMaterial) {
          effect.setMatrix("viewProjection", scene2.getTransformMatrix());
          effect.setMatrix("world", effectiveMesh.getWorldMatrix());
          if (this._storeCameraSpaceZ) {
            effect.setMatrix("view", scene2.getViewMatrix());
          }
        } else {
          renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh, subMesh);
        }
        let minZ, maxZ;
        if (cameraIsOrtho) {
          minZ = !engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : 1;
        } else {
          minZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? camera2.minZ : engine2.isNDCHalfZRange ? 0 : camera2.minZ;
          maxZ = engine2.useReverseDepthBuffer && engine2.isNDCHalfZRange ? 0 : camera2.maxZ;
        }
        effect.setFloat2("depthValues", minZ, minZ + maxZ);
        if (!renderingMaterial) {
          if (material.needAlphaTestingForMesh(effectiveMesh)) {
            const alphaTexture = material.getAlphaTestTexture();
            if (alphaTexture) {
              effect.setTexture("diffuseSampler", alphaTexture);
              effect.setMatrix("diffuseMatrix", alphaTexture.getTextureMatrix());
            }
          }
          BindBonesParameters(renderingMesh, effect);
          BindClipPlane(effect, material, scene2);
          BindMorphTargetParameters(renderingMesh, effect);
          if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {
            renderingMesh.morphTargetManager._bind(effect);
          }
          const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            bvaManager.bind(effect, hardwareInstancedRendering);
          }
          if (material.pointsCloud) {
            effect.setFloat("pointSize", material.pointSize);
          }
        }
        renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) => effect.setMatrix("world", world));
      }
    };
    this._depthMap.customRenderFunction = (opaqueSubMeshes, alphaTestSubMeshes, transparentSubMeshes, depthOnlySubMeshes) => {
      let index;
      if (depthOnlySubMeshes.length) {
        for (index = 0; index < depthOnlySubMeshes.length; index++) {
          renderSubMesh(depthOnlySubMeshes.data[index]);
        }
      }
      for (index = 0; index < opaqueSubMeshes.length; index++) {
        renderSubMesh(opaqueSubMeshes.data[index]);
      }
      for (index = 0; index < alphaTestSubMeshes.length; index++) {
        renderSubMesh(alphaTestSubMeshes.data[index]);
      }
      if (this.forceDepthWriteTransparentMeshes) {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          renderSubMesh(transparentSubMeshes.data[index]);
        }
      } else {
        for (index = 0; index < transparentSubMeshes.length; index++) {
          transparentSubMeshes.data[index].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        }
      }
    };
  }
  async _initShaderSourceAsync(forceGLSL = false) {
    const engine = this._scene.getEngine();
    if (engine.isWebGPU && !forceGLSL && !_DepthRenderer.ForceGLSL) {
      this._shaderLanguage = 1;
      await Promise.all([import("./depth.vertex-WCIATGF6.js"), import("./depth.fragment-CCK5JDXU.js")]);
    } else {
      await Promise.all([import("./depth.vertex-ABM7X6CW.js"), import("./depth.fragment-FB4LWFMM.js")]);
    }
    this._shadersLoaded = true;
  }
  /**
   * Creates the depth rendering effect and checks if the effect is ready.
   * @param subMesh The submesh to be used to render the depth map of
   * @param useInstances If multiple world instances should be used
   * @returns if the depth renderer is ready to render the depth map
   */
  isReady(subMesh, useInstances) {
    if (!this._shadersLoaded) {
      return false;
    }
    const engine = this._scene.getEngine();
    const mesh = subMesh.getMesh();
    const scene = mesh.getScene();
    const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];
    if (renderingMaterial) {
      return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);
    }
    const material = subMesh.getMaterial();
    if (!material || material.disableDepthWrite) {
      return false;
    }
    const defines = [];
    const attribs = [VertexBuffer.PositionKind];
    let uv1 = false;
    let uv2 = false;
    const color = false;
    if (material.needAlphaTestingForMesh(mesh) && material.getAlphaTestTexture()) {
      defines.push("#define ALPHATEST");
      if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
        attribs.push(VertexBuffer.UVKind);
        defines.push("#define UV1");
        uv1 = true;
      }
      if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
        attribs.push(VertexBuffer.UV2Kind);
        defines.push("#define UV2");
        uv2 = true;
      }
    }
    const fallbacks = new EffectFallbacks();
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (mesh.numBoneInfluencers > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
      defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
      if (mesh.numBoneInfluencers > 0) {
        fallbacks.addCPUSkinningFallback(0, mesh);
      }
      const skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices) {
        defines.push("#define BONETEXTURE");
      } else {
        defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
      }
    } else {
      defines.push("#define NUM_BONE_INFLUENCERS 0");
    }
    const numMorphInfluencers = mesh.morphTargetManager ? PrepareDefinesAndAttributesForMorphTargets(
      mesh.morphTargetManager,
      defines,
      attribs,
      mesh,
      true,
      // usePositionMorph
      false,
      // useNormalMorph
      false,
      // useTangentMorph
      uv1,
      // useUVMorph
      uv2,
      // useUV2Morph
      color
      // useColorMorph
    ) : 0;
    if (material.pointsCloud) {
      defines.push("#define POINTSIZE");
    }
    if (useInstances) {
      defines.push("#define INSTANCES");
      PushAttributesForInstances(attribs);
      if (subMesh.getRenderingMesh().hasThinInstances) {
        defines.push("#define THIN_INSTANCES");
      }
    }
    const bvaManager = mesh.bakedVertexAnimationManager;
    if (bvaManager && bvaManager.isEnabled) {
      defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
      if (useInstances) {
        attribs.push("bakedVertexAnimationSettingsInstanced");
      }
    }
    if (this._storeNonLinearDepth) {
      defines.push("#define NONLINEARDEPTH");
    }
    if (this._storeCameraSpaceZ) {
      defines.push("#define STORE_CAMERASPACE_Z");
    }
    if (this.isPacked) {
      defines.push("#define PACKED");
    }
    PrepareStringDefinesForClipPlanes(material, scene, defines);
    const drawWrapper = subMesh._getDrawWrapper(void 0, true);
    const cachedDefines = drawWrapper.defines;
    const join = defines.join("\n");
    if (cachedDefines !== join) {
      const uniforms = [
        "world",
        "mBones",
        "boneTextureWidth",
        "pointSize",
        "viewProjection",
        "view",
        "diffuseMatrix",
        "depthValues",
        "morphTargetInfluences",
        "morphTargetCount",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices",
        "bakedVertexAnimationSettings",
        "bakedVertexAnimationTextureSizeInverted",
        "bakedVertexAnimationTime",
        "bakedVertexAnimationTexture"
      ];
      const samplers = ["diffuseSampler", "morphTargets", "boneSampler", "bakedVertexAnimationTexture"];
      AddClipPlaneUniforms(uniforms);
      drawWrapper.setEffect(engine.createEffect("depth", {
        attributes: attribs,
        uniformsNames: uniforms,
        uniformBuffersNames: [],
        samplers,
        defines: join,
        fallbacks,
        onCompiled: null,
        onError: null,
        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },
        shaderLanguage: this._shaderLanguage
      }, engine), join);
    }
    return drawWrapper.effect.isReady();
  }
  /**
   * Gets the texture which the depth map will be written to.
   * @returns The depth map texture
   */
  getDepthMap() {
    return this._depthMap;
  }
  /**
   * Disposes of the depth renderer.
   */
  dispose() {
    const keysToDelete = [];
    for (const key in this._scene._depthRenderer) {
      const depthRenderer = this._scene._depthRenderer[key];
      if (depthRenderer === this) {
        keysToDelete.push(key);
      }
    }
    if (keysToDelete.length > 0) {
      this._depthMap.dispose();
      for (const key of keysToDelete) {
        delete this._scene._depthRenderer[key];
      }
    }
  }
};
DepthRenderer.ForceGLSL = false;
DepthRenderer._SceneComponentInitialization = (_) => {
  throw _WarnImport("DepthRendererSceneComponent");
};

// node_modules/@babylonjs/core/Misc/thinMinMaxReducer.js
var DepthTextureType;
(function(DepthTextureType2) {
  DepthTextureType2[DepthTextureType2["NormalizedViewDepth"] = 0] = "NormalizedViewDepth";
  DepthTextureType2[DepthTextureType2["ViewDepth"] = 1] = "ViewDepth";
  DepthTextureType2[DepthTextureType2["ScreenDepth"] = 2] = "ScreenDepth";
})(DepthTextureType || (DepthTextureType = {}));
var ThinMinMaxReducerPostProcess = class _ThinMinMaxReducerPostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(import("./minmaxRedux.fragment-VB2DD5DJ.js"));
    } else {
      list.push(import("./minmaxRedux.fragment-UGC7O67N.js"));
    }
  }
  constructor(name, engine = null, defines = "", options) {
    super({
      ...options,
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinMinMaxReducerPostProcess.FragmentUrl,
      uniforms: _ThinMinMaxReducerPostProcess.Uniforms,
      defines
    });
    this.textureWidth = 0;
    this.textureHeight = 0;
  }
  bind(noDefaultBindings = false) {
    super.bind(noDefaultBindings);
    const effect = this.drawWrapper.effect;
    if (this.textureWidth === 1 || this.textureHeight === 1) {
      effect.setInt2("texSize", this.textureWidth, this.textureHeight);
    } else {
      effect.setFloat2("texSize", this.textureWidth, this.textureHeight);
    }
  }
};
ThinMinMaxReducerPostProcess.FragmentUrl = "minmaxRedux";
ThinMinMaxReducerPostProcess.Uniforms = ["texSize"];
var BufferFloat = new Float32Array(4 * 1 * 1);
var BufferUint8 = new Uint8Array(4 * 1 * 1);
var MinMax = { min: 0, max: 0 };
var ThinMinMaxReducer = class {
  get depthRedux() {
    return this._depthRedux;
  }
  set depthRedux(value) {
    if (this._depthRedux === value) {
      return;
    }
    this._depthRedux = value;
    this._recreatePostProcesses();
  }
  get textureWidth() {
    return this._textureWidth;
  }
  get textureHeight() {
    return this._textureHeight;
  }
  constructor(scene, depthRedux = true) {
    this.onAfterReductionPerformed = new Observable();
    this._textureWidth = 0;
    this._textureHeight = 0;
    this._scene = scene;
    this._depthRedux = depthRedux;
    this.reductionSteps = [];
  }
  setTextureDimensions(width, height, depthTextureType = 0) {
    if (width === this._textureWidth && height === this._textureHeight && depthTextureType === this._depthTextureType) {
      return false;
    }
    this._textureWidth = width;
    this._textureHeight = height;
    this._depthTextureType = depthTextureType;
    this._recreatePostProcesses();
    return true;
  }
  readMinMax(texture) {
    const isFloat = texture.type === Engine.TEXTURETYPE_FLOAT || texture.type === Engine.TEXTURETYPE_HALF_FLOAT;
    const buffer = isFloat ? BufferFloat : BufferUint8;
    this._scene.getEngine()._readTexturePixels(texture, 1, 1, -1, 0, buffer, false);
    MinMax.min = buffer[0];
    MinMax.max = buffer[1];
    if (!isFloat) {
      MinMax.min = MinMax.min / 255;
      MinMax.max = MinMax.max / 255;
    }
    if (MinMax.min >= MinMax.max) {
      MinMax.min = 0;
      MinMax.max = 1;
    }
    this.onAfterReductionPerformed.notifyObservers(MinMax);
  }
  dispose(disposeAll = true) {
    if (disposeAll) {
      this.onAfterReductionPerformed.clear();
      this._textureWidth = 0;
      this._textureHeight = 0;
    }
    for (let i = 0; i < this.reductionSteps.length; ++i) {
      this.reductionSteps[i].dispose();
    }
    this.reductionSteps.length = 0;
  }
  _recreatePostProcesses() {
    this.dispose(false);
    const scene = this._scene;
    let w = this.textureWidth, h = this.textureHeight;
    const reductionInitial = new ThinMinMaxReducerPostProcess("Initial reduction phase", scene.getEngine(), "#define INITIAL" + (this._depthRedux ? "\n#define DEPTH_REDUX" : "") + (this._depthTextureType === 1 ? "\n#define VIEW_DEPTH" : ""));
    reductionInitial.textureWidth = w;
    reductionInitial.textureHeight = h;
    this.reductionSteps.push(reductionInitial);
    let index = 1;
    while (w > 1 || h > 1) {
      w = Math.max(Math.round(w / 2), 1);
      h = Math.max(Math.round(h / 2), 1);
      const reduction = new ThinMinMaxReducerPostProcess("Reduction phase " + index, scene.getEngine(), "#define " + (w == 1 && h == 1 ? "LAST" : w == 1 || h == 1 ? "ONEBEFORELAST" : "MAIN"));
      reduction.textureWidth = w;
      reduction.textureHeight = h;
      this.reductionSteps.push(reduction);
      index++;
    }
  }
};

// node_modules/@babylonjs/core/Misc/minMaxReducer.js
var MinMaxReducer = class {
  /**
   * Observable triggered when the computation has been performed
   */
  get onAfterReductionPerformed() {
    return this._thinMinMaxReducer.onAfterReductionPerformed;
  }
  /**
   * Creates a min/max reducer
   * @param camera The camera to use for the post processes
   */
  constructor(camera) {
    this._onAfterUnbindObserver = null;
    this._forceFullscreenViewport = true;
    this._activated = false;
    this._camera = camera;
    this._postProcessManager = new PostProcessManager(camera.getScene());
    this._thinMinMaxReducer = new ThinMinMaxReducer(camera.getScene());
    this._reductionSteps = [];
    this._onContextRestoredObserver = camera.getEngine().onContextRestoredObservable.add(() => {
      this._postProcessManager._rebuild();
    });
  }
  /**
   * Gets the texture used to read the values from.
   */
  get sourceTexture() {
    return this._sourceTexture;
  }
  /**
   * Sets the source texture to read the values from.
   * One must indicate if the texture is a depth texture or not through the depthRedux parameter
   * because in such textures '1' value must not be taken into account to compute the maximum
   * as this value is used to clear the texture.
   * Note that the computation is not activated by calling this function, you must call activate() for that!
   * @param sourceTexture The texture to read the values from. The values should be in the red channel.
   * @param depthRedux Indicates if the texture is a depth texture or not
   * @param type The type of the textures created for the reduction (defaults to TEXTURETYPE_HALF_FLOAT)
   * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
   */
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    if (sourceTexture === this._sourceTexture) {
      return;
    }
    this._thinMinMaxReducer.depthRedux = depthRedux;
    this.deactivate();
    this._sourceTexture = sourceTexture;
    this._forceFullscreenViewport = forceFullscreenViewport;
    if (this._thinMinMaxReducer.setTextureDimensions(sourceTexture.getRenderWidth(), sourceTexture.getRenderHeight())) {
      this._disposePostProcesses();
      const reductionSteps = this._thinMinMaxReducer.reductionSteps;
      for (let i = 0; i < reductionSteps.length; ++i) {
        const reductionStep = reductionSteps[i];
        const postProcess = new PostProcess(reductionStep.name, ThinMinMaxReducerPostProcess.FragmentUrl, {
          effectWrapper: reductionStep,
          samplingMode: 1,
          engine: this._camera.getScene().getEngine(),
          textureType: type,
          textureFormat: 7,
          size: { width: reductionStep.textureWidth, height: reductionStep.textureHeight }
        });
        this._reductionSteps.push(postProcess);
        postProcess.autoClear = false;
        postProcess.forceFullscreenViewport = forceFullscreenViewport;
        if (i === 0) {
          postProcess.externalTextureSamplerBinding = true;
          postProcess.onApplyObservable.add((effect) => {
            effect.setTexture("textureSampler", this._sourceTexture);
          });
        }
        if (i === reductionSteps.length - 1) {
          this._reductionSteps[i - 1].onAfterRenderObservable.add(() => {
            this._thinMinMaxReducer.readMinMax(postProcess.inputTexture.texture);
          });
        }
      }
    }
  }
  /**
   * Defines the refresh rate of the computation.
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   */
  get refreshRate() {
    return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
  }
  set refreshRate(value) {
    if (this._sourceTexture) {
      this._sourceTexture.refreshRate = value;
    }
  }
  /**
   * Gets the activation status of the reducer
   */
  get activated() {
    return this._activated;
  }
  /**
   * Activates the reduction computation.
   * When activated, the observers registered in onAfterReductionPerformed are
   * called after the computation is performed
   */
  activate() {
    if (this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
      const engine = this._camera.getScene().getEngine();
      engine._debugPushGroup?.(`min max reduction`, 1);
      this._reductionSteps[0].activate(this._camera);
      this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport, 0, 0, true, this._reductionSteps.length - 1);
      engine.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length - 1].inputTexture, false);
      engine._debugPopGroup?.(1);
    });
    this._activated = true;
  }
  /**
   * Deactivates the reduction computation.
   */
  deactivate() {
    if (!this._onAfterUnbindObserver || !this._sourceTexture) {
      return;
    }
    this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
    this._onAfterUnbindObserver = null;
    this._activated = false;
  }
  /**
   * Disposes the min/max reducer
   * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
   */
  dispose(disposeAll = true) {
    if (!disposeAll) {
      return;
    }
    this.onAfterReductionPerformed.clear();
    this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
    this._onContextRestoredObserver = void 0;
    this._disposePostProcesses();
    this._postProcessManager.dispose();
    this._postProcessManager = void 0;
    this._thinMinMaxReducer.dispose();
    this._thinMinMaxReducer = void 0;
    this._sourceTexture = null;
  }
  _disposePostProcesses() {
    for (let i = 0; i < this._reductionSteps.length; ++i) {
      this._reductionSteps[i].dispose();
    }
    this._reductionSteps.length = 0;
  }
};

// node_modules/@babylonjs/core/Misc/depthReducer.js
var DepthReducer = class extends MinMaxReducer {
  /**
   * Gets the depth renderer used for the computation.
   * Note that the result is null if you provide your own renderer when calling setDepthRenderer.
   */
  get depthRenderer() {
    return this._depthRenderer;
  }
  /**
   * Creates a depth reducer
   * @param camera The camera used to render the depth texture
   */
  constructor(camera) {
    super(camera);
  }
  /**
   * Sets the depth renderer to use to generate the depth map
   * @param depthRenderer The depth renderer to use. If not provided, a new one will be created automatically
   * @param type The texture type of the depth map (default: TEXTURETYPE_HALF_FLOAT)
   * @param forceFullscreenViewport Forces the post processes used for the reduction to be applied without taking into account viewport (defaults to true)
   */
  setDepthRenderer(depthRenderer = null, type = 2, forceFullscreenViewport = true) {
    const scene = this._camera.getScene();
    if (this._depthRenderer) {
      delete scene._depthRenderer[this._depthRendererId];
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
    if (depthRenderer === null) {
      if (!scene._depthRenderer) {
        scene._depthRenderer = {};
      }
      this._depthRendererId = "minmax_" + this._camera.id;
      depthRenderer = this._depthRenderer = new DepthRenderer(scene, type, this._camera, false, 1, false, `DepthRenderer ${this._depthRendererId}`);
      depthRenderer.enabled = false;
      scene._depthRenderer[this._depthRendererId] = depthRenderer;
    }
    super.setSourceTexture(depthRenderer.getDepthMap(), true, type, forceFullscreenViewport);
  }
  /**
   * @internal
   */
  setSourceTexture(sourceTexture, depthRedux, type = 2, forceFullscreenViewport = true) {
    super.setSourceTexture(sourceTexture, depthRedux, type, forceFullscreenViewport);
  }
  /**
   * Activates the reduction computation.
   * When activated, the observers registered in onAfterReductionPerformed are
   * called after the computation is performed
   */
  activate() {
    if (this._depthRenderer) {
      this._depthRenderer.enabled = true;
    }
    super.activate();
  }
  /**
   * Deactivates the reduction computation.
   */
  deactivate() {
    super.deactivate();
    if (this._depthRenderer) {
      this._depthRenderer.enabled = false;
    }
  }
  /**
   * Disposes the depth reducer
   * @param disposeAll true to dispose all the resources. You should always call this function with true as the parameter (or without any parameter as it is the default one). This flag is meant to be used internally.
   */
  dispose(disposeAll = true) {
    super.dispose(disposeAll);
    if (this._depthRenderer && disposeAll) {
      this._depthRenderer.dispose();
      this._depthRenderer = null;
    }
  }
};

// node_modules/@babylonjs/core/Lights/Shadows/cascadedShadowGenerator.js
var UpDir = Vector3.Up();
var ZeroVec = Vector3.Zero();
var Tmpv1 = new Vector3();
var Tmpv2 = new Vector3();
var TmpMatrix = new Matrix();
var CascadedShadowGenerator = class _CascadedShadowGenerator extends ShadowGenerator {
  _validateFilter(filter) {
    if (filter === ShadowGenerator.FILTER_NONE || filter === ShadowGenerator.FILTER_PCF || filter === ShadowGenerator.FILTER_PCSS) {
      return filter;
    }
    Logger.Error('Unsupported filter "' + filter + '"!');
    return ShadowGenerator.FILTER_NONE;
  }
  /**
   * Gets or set the number of cascades used by the CSM.
   */
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(value) {
    value = Math.min(Math.max(value, _CascadedShadowGenerator.MIN_CASCADES_COUNT), _CascadedShadowGenerator.MAX_CASCADES_COUNT);
    if (value === this._numCascades) {
      return;
    }
    this._numCascades = value;
    this.recreateShadowMap();
    this._recreateSceneUBOs();
  }
  /**
   * Enables or disables the shadow casters bounding info computation.
   * If your shadow casters don't move, you can disable this feature.
   * If it is enabled, the bounding box computation is done every frame.
   */
  get freezeShadowCastersBoundingInfo() {
    return this._freezeShadowCastersBoundingInfo;
  }
  set freezeShadowCastersBoundingInfo(freeze) {
    if (this._freezeShadowCastersBoundingInfoObservable && freeze) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (!this._freezeShadowCastersBoundingInfoObservable && !freeze) {
      this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(() => this._computeShadowCastersBoundingInfo());
    }
    this._freezeShadowCastersBoundingInfo = freeze;
    if (freeze) {
      this._computeShadowCastersBoundingInfo();
    }
  }
  _computeShadowCastersBoundingInfo() {
    this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._scbiMax.copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    if (this._shadowMap && this._shadowMap.renderList) {
      const renderList = this._shadowMap.renderList;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo(), boundingBox = boundingInfo.boundingBox;
        this._scbiMin.minimizeInPlace(boundingBox.minimumWorld);
        this._scbiMax.maximizeInPlace(boundingBox.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }
  /**
   * Gets or sets the shadow casters bounding info.
   * If you provide your own shadow casters bounding info, first enable freezeShadowCastersBoundingInfo
   * so that the system won't overwrite the bounds you provide
   */
  get shadowCastersBoundingInfo() {
    return this._shadowCastersBoundingInfo;
  }
  set shadowCastersBoundingInfo(boundingInfo) {
    this._shadowCastersBoundingInfo = boundingInfo;
  }
  /**
   * Sets the minimal and maximal distances to use when computing the cascade breaks.
   *
   * The values of min / max are typically the depth zmin and zmax values of your scene, for a given frame.
   * If you don't know these values, simply leave them to their defaults and don't call this function.
   * @param min minimal distance for the breaks (default to 0.)
   * @param max maximal distance for the breaks (default to 1.)
   */
  setMinMaxDistance(min, max) {
    if (this._minDistance === min && this._maxDistance === max) {
      return;
    }
    if (min > max) {
      min = 0;
      max = 1;
    }
    if (min < 0) {
      min = 0;
    }
    if (max > 1) {
      max = 1;
    }
    this._minDistance = min;
    this._maxDistance = max;
    this._breaksAreDirty = true;
  }
  /** Gets the minimal distance used in the cascade break computation */
  get minDistance() {
    return this._minDistance;
  }
  /** Gets the maximal distance used in the cascade break computation */
  get maxDistance() {
    return this._maxDistance;
  }
  /**
   * Gets the class name of that object
   * @returns "CascadedShadowGenerator"
   */
  getClassName() {
    return _CascadedShadowGenerator.CLASSNAME;
  }
  /**
   * Gets a cascade minimum extents
   * @param cascadeIndex index of the cascade
   * @returns the minimum cascade extents
   */
  getCascadeMinExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMinExtents[cascadeIndex] : null;
  }
  /**
   * Gets a cascade maximum extents
   * @param cascadeIndex index of the cascade
   * @returns the maximum cascade extents
   */
  getCascadeMaxExtents(cascadeIndex) {
    return cascadeIndex >= 0 && cascadeIndex < this._numCascades ? this._cascadeMaxExtents[cascadeIndex] : null;
  }
  /**
   * Gets the shadow max z distance. It's the limit beyond which shadows are not displayed.
   * It defaults to camera.maxZ
   */
  get shadowMaxZ() {
    if (!this._getCamera()) {
      return 0;
    }
    return this._shadowMaxZ;
  }
  /**
   * Sets the shadow max z distance.
   */
  set shadowMaxZ(value) {
    const camera = this._getCamera();
    if (!camera) {
      this._shadowMaxZ = value;
      return;
    }
    if (this._shadowMaxZ === value || value < camera.minZ || value > camera.maxZ && camera.maxZ !== 0) {
      return;
    }
    this._shadowMaxZ = value;
    this._light._markMeshesAsLightDirty();
    this._breaksAreDirty = true;
  }
  /**
   * Gets or sets the debug flag.
   * When enabled, the cascades are materialized by different colors on the screen.
   */
  get debug() {
    return this._debug;
  }
  set debug(dbg) {
    this._debug = dbg;
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets or sets the depth clamping value.
   *
   * When enabled, it improves the shadow quality because the near z plane of the light frustum don't need to be adjusted
   * to account for the shadow casters far away.
   *
   * Note that this property is incompatible with PCSS filtering, so it won't be used in that case.
   */
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(value) {
    this._depthClamp = value;
  }
  /**
   * Gets or sets the percentage of blending between two cascades (value between 0. and 1.).
   * It defaults to 0.1 (10% blending).
   */
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(value) {
    this._cascadeBlendPercentage = value;
    this._light._markMeshesAsLightDirty();
  }
  /**
   * Gets or set the lambda parameter.
   * This parameter is used to split the camera frustum and create the cascades.
   * It's a value between 0. and 1.: If 0, the split is a uniform split of the frustum, if 1 it is a logarithmic split.
   * For all values in-between, it's a linear combination of the uniform and logarithm split algorithm.
   */
  get lambda() {
    return this._lambda;
  }
  set lambda(value) {
    const lambda = Math.min(Math.max(value, 0), 1);
    if (this._lambda == lambda) {
      return;
    }
    this._lambda = lambda;
    this._breaksAreDirty = true;
  }
  /**
   * Gets the view matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the view matrix from
   * @returns the cascade view matrix
   */
  getCascadeViewMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._viewMatrices[cascadeNum] : null;
  }
  /**
   * Gets the projection matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the projection matrix from
   * @returns the cascade projection matrix
   */
  getCascadeProjectionMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._projectionMatrices[cascadeNum] : null;
  }
  /**
   * Gets the transformation matrix corresponding to a given cascade
   * @param cascadeNum cascade to retrieve the transformation matrix from
   * @returns the cascade transformation matrix
   */
  getCascadeTransformMatrix(cascadeNum) {
    return cascadeNum >= 0 && cascadeNum < this._numCascades ? this._transformMatrices[cascadeNum] : null;
  }
  /**
   * Sets the depth renderer to use when autoCalcDepthBounds is enabled.
   *
   * Note that if no depth renderer is set, a new one will be automatically created internally when necessary.
   *
   * You should call this function if you already have a depth renderer enabled in your scene, to avoid
   * doing multiple depth rendering each frame. If you provide your own depth renderer, make sure it stores linear depth!
   * @param depthRenderer The depth renderer to use when autoCalcDepthBounds is enabled. If you pass null or don't call this function at all, a depth renderer will be automatically created
   */
  setDepthRenderer(depthRenderer) {
    this._depthRenderer = depthRenderer;
    if (this._depthReducer) {
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
  }
  /**
   * Gets or sets the autoCalcDepthBounds property.
   *
   * When enabled, a depth rendering pass is first performed (with an internally created depth renderer or with the one
   * you provide by calling setDepthRenderer). Then, a min/max reducing is applied on the depth map to compute the
   * minimal and maximal depth of the map and those values are used as inputs for the setMinMaxDistance() function.
   * It can greatly enhance the shadow quality, at the expense of more GPU works.
   * When using this option, you should increase the value of the lambda parameter, and even set it to 1 for best results.
   */
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(value) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    this._autoCalcDepthBounds = value;
    if (!value) {
      if (this._depthReducer) {
        this._depthReducer.deactivate();
      }
      this.setMinMaxDistance(0, 1);
      return;
    }
    if (!this._depthReducer) {
      this._depthReducer = new DepthReducer(camera);
      this._depthReducer.onAfterReductionPerformed.add((minmax) => {
        let min = minmax.min, max = minmax.max;
        if (min >= max) {
          min = 0;
          max = 1;
        }
        if (min != this._minDistance || max != this._maxDistance) {
          this.setMinMaxDistance(min, max);
        }
      });
      this._depthReducer.setDepthRenderer(this._depthRenderer);
    }
    this._depthReducer.activate();
  }
  /**
   * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   * Note that if you provided your own depth renderer through a call to setDepthRenderer, you are responsible
   * for setting the refresh rate on the renderer yourself!
   */
  get autoCalcDepthBoundsRefreshRate() {
    return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate ?? -1;
  }
  set autoCalcDepthBoundsRefreshRate(value) {
    if (this._depthReducer?.depthRenderer) {
      this._depthReducer.depthRenderer.getDepthMap().refreshRate = value;
    }
  }
  /**
   * Create the cascade breaks according to the lambda, shadowMaxZ and min/max distance properties, as well as the camera near and far planes.
   * This function is automatically called when updating lambda, shadowMaxZ and min/max distances, however you should call it yourself if
   * you change the camera near/far planes!
   */
  splitFrustum() {
    this._breaksAreDirty = true;
  }
  _splitFrustum() {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const near = camera.minZ, far = camera.maxZ || this._shadowMaxZ, cameraRange = far - near, minDistance = this._minDistance, maxDistance = this._shadowMaxZ < far && this._shadowMaxZ >= near ? Math.min((this._shadowMaxZ - near) / (far - near), this._maxDistance) : this._maxDistance;
    const minZ = near + minDistance * cameraRange, maxZ = near + maxDistance * cameraRange;
    const range = maxZ - minZ, ratio = maxZ / minZ;
    for (let cascadeIndex = 0; cascadeIndex < this._cascades.length; ++cascadeIndex) {
      const p = (cascadeIndex + 1) / this._numCascades, log = minZ * ratio ** p, uniform = minZ + range * p;
      const d = this._lambda * (log - uniform) + uniform;
      this._cascades[cascadeIndex].prevBreakDistance = cascadeIndex === 0 ? minDistance : this._cascades[cascadeIndex - 1].breakDistance;
      this._cascades[cascadeIndex].breakDistance = (d - near) / cameraRange;
      this._viewSpaceFrustumsZ[cascadeIndex] = d;
      this._frustumLengths[cascadeIndex] = (this._cascades[cascadeIndex].breakDistance - this._cascades[cascadeIndex].prevBreakDistance) * cameraRange;
    }
    this._breaksAreDirty = false;
  }
  _computeMatrices() {
    const scene = this._scene;
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    Vector3.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection);
    if (Math.abs(Vector3.Dot(this._lightDirection, Vector3.Up())) === 1) {
      this._lightDirection.z = 1e-13;
    }
    this._cachedDirection.copyFrom(this._lightDirection);
    const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._computeFrustumInWorldSpace(cascadeIndex);
      this._computeCascadeFrustum(cascadeIndex);
      this._cascadeMaxExtents[cascadeIndex].subtractToRef(this._cascadeMinExtents[cascadeIndex], Tmpv1);
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection.scale(this._cascadeMinExtents[cascadeIndex].z), this._shadowCameraPos[cascadeIndex]);
      Matrix.LookAtLHToRef(this._shadowCameraPos[cascadeIndex], this._frustumCenter[cascadeIndex], UpDir, this._viewMatrices[cascadeIndex]);
      let viewMinZ = 0, viewMaxZ = Tmpv1.z;
      const boundingInfo = this._shadowCastersBoundingInfo;
      boundingInfo.update(this._viewMatrices[cascadeIndex]);
      const castersViewMinZ = boundingInfo.boundingBox.minimumWorld.z;
      const castersViewMaxZ = boundingInfo.boundingBox.maximumWorld.z;
      if (castersViewMinZ > viewMaxZ) {
      } else {
        if (!this._depthClamp || this.filter === ShadowGenerator.FILTER_PCSS) {
          viewMinZ = Math.min(viewMinZ, castersViewMinZ);
          if (this.filter !== ShadowGenerator.FILTER_PCSS) {
            viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
          }
        } else {
          viewMaxZ = Math.min(viewMaxZ, castersViewMaxZ);
          viewMinZ = Math.max(viewMinZ, castersViewMinZ);
          viewMaxZ = Math.max(viewMinZ + 1, viewMaxZ);
        }
      }
      Matrix.OrthoOffCenterLHToRef(this._cascadeMinExtents[cascadeIndex].x, this._cascadeMaxExtents[cascadeIndex].x, this._cascadeMinExtents[cascadeIndex].y, this._cascadeMaxExtents[cascadeIndex].y, useReverseDepthBuffer ? viewMaxZ : viewMinZ, useReverseDepthBuffer ? viewMinZ : viewMaxZ, this._projectionMatrices[cascadeIndex], scene.getEngine().isNDCHalfZRange);
      this._cascadeMinExtents[cascadeIndex].z = viewMinZ;
      this._cascadeMaxExtents[cascadeIndex].z = viewMaxZ;
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      Vector3.TransformCoordinatesToRef(ZeroVec, this._transformMatrices[cascadeIndex], Tmpv1);
      Tmpv1.scaleInPlace(this._mapSize / 2);
      Tmpv2.copyFromFloats(Math.round(Tmpv1.x), Math.round(Tmpv1.y), Math.round(Tmpv1.z));
      Tmpv2.subtractInPlace(Tmpv1).scaleInPlace(2 / this._mapSize);
      Matrix.TranslationToRef(Tmpv2.x, Tmpv2.y, 0, TmpMatrix);
      this._projectionMatrices[cascadeIndex].multiplyToRef(TmpMatrix, this._projectionMatrices[cascadeIndex]);
      this._viewMatrices[cascadeIndex].multiplyToRef(this._projectionMatrices[cascadeIndex], this._transformMatrices[cascadeIndex]);
      this._transformMatrices[cascadeIndex].copyToArray(this._transformMatricesAsArray, cascadeIndex * 16);
    }
  }
  // Get the 8 points of the view frustum in world space
  _computeFrustumInWorldSpace(cascadeIndex) {
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const prevSplitDist = this._cascades[cascadeIndex].prevBreakDistance, splitDist = this._cascades[cascadeIndex].breakDistance;
    const isNDCHalfZRange = this._scene.getEngine().isNDCHalfZRange;
    camera.getViewMatrix();
    const cameraInfiniteFarPlane = camera.maxZ === 0;
    const saveCameraMaxZ = camera.maxZ;
    if (cameraInfiniteFarPlane) {
      camera.maxZ = this._shadowMaxZ;
      camera.getProjectionMatrix(true);
    }
    const invViewProj = Matrix.Invert(camera.getTransformationMatrix());
    if (cameraInfiniteFarPlane) {
      camera.maxZ = saveCameraMaxZ;
      camera.getProjectionMatrix(true);
    }
    const cornerIndexOffset = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++cornerIndex) {
      Tmpv1.copyFrom(_CascadedShadowGenerator._FrustumCornersNdcSpace[(cornerIndex + cornerIndexOffset) % _CascadedShadowGenerator._FrustumCornersNdcSpace.length]);
      if (isNDCHalfZRange && Tmpv1.z === -1) {
        Tmpv1.z = 0;
      }
      Vector3.TransformCoordinatesToRef(Tmpv1, invViewProj, this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    for (let cornerIndex = 0; cornerIndex < _CascadedShadowGenerator._FrustumCornersNdcSpace.length / 2; ++cornerIndex) {
      Tmpv1.copyFrom(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4]).subtractInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      Tmpv2.copyFrom(Tmpv1).scaleInPlace(prevSplitDist);
      Tmpv1.scaleInPlace(splitDist);
      Tmpv1.addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex + 4].copyFrom(Tmpv1);
      this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].addInPlace(Tmpv2);
    }
  }
  _computeCascadeFrustum(cascadeIndex) {
    this._cascadeMinExtents[cascadeIndex].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cascadeMaxExtents[cascadeIndex].copyFromFloats(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    this._frustumCenter[cascadeIndex].copyFromFloats(0, 0, 0);
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
      this._frustumCenter[cascadeIndex].addInPlace(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex]);
    }
    this._frustumCenter[cascadeIndex].scaleInPlace(1 / this._frustumCornersWorldSpace[cascadeIndex].length);
    if (this.stabilizeCascades) {
      let sphereRadius = 0;
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        const dist = this._frustumCornersWorldSpace[cascadeIndex][cornerIndex].subtractToRef(this._frustumCenter[cascadeIndex], Tmpv1).length();
        sphereRadius = Math.max(sphereRadius, dist);
      }
      sphereRadius = Math.ceil(sphereRadius * 16) / 16;
      this._cascadeMaxExtents[cascadeIndex].copyFromFloats(sphereRadius, sphereRadius, sphereRadius);
      this._cascadeMinExtents[cascadeIndex].copyFromFloats(-sphereRadius, -sphereRadius, -sphereRadius);
    } else {
      const lightCameraPos = this._frustumCenter[cascadeIndex];
      this._frustumCenter[cascadeIndex].addToRef(this._lightDirection, Tmpv1);
      Matrix.LookAtLHToRef(lightCameraPos, Tmpv1, UpDir, TmpMatrix);
      for (let cornerIndex = 0; cornerIndex < this._frustumCornersWorldSpace[cascadeIndex].length; ++cornerIndex) {
        Vector3.TransformCoordinatesToRef(this._frustumCornersWorldSpace[cascadeIndex][cornerIndex], TmpMatrix, Tmpv1);
        this._cascadeMinExtents[cascadeIndex].minimizeInPlace(Tmpv1);
        this._cascadeMaxExtents[cascadeIndex].maximizeInPlace(Tmpv1);
      }
    }
  }
  _recreateSceneUBOs() {
    this._disposeSceneUBOs();
    if (this._sceneUBOs) {
      for (let i = 0; i < this._numCascades; ++i) {
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${i})`));
      }
    }
  }
  /**
   *  Support test.
   */
  static get IsSupported() {
    const engine = EngineStore.LastCreatedEngine;
    if (!engine) {
      return false;
    }
    return engine._features.supportCSM;
  }
  /**
   * Creates a Cascaded Shadow Generator object.
   * A ShadowGenerator is the required tool to use the shadows.
   * Each directional light casting shadows needs to use its own ShadowGenerator.
   * Documentation : https://doc.babylonjs.com/babylon101/cascadedShadows
   * @param mapSize The size of the texture what stores the shadows. Example : 1024.
   * @param light The directional light object generating the shadows.
   * @param usefulFloatFirst By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.
   * @param camera Camera associated with this shadow generator (default: null). If null, takes the scene active camera at the time we need to access it
   * @param useRedTextureType Forces the generator to use a Red instead of a RGBA type for the shadow map texture format (default: true)
   */
  constructor(mapSize, light, usefulFloatFirst, camera, useRedTextureType = true) {
    if (!_CascadedShadowGenerator.IsSupported) {
      Logger.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    super(mapSize, light, usefulFloatFirst, camera, useRedTextureType);
    this.usePercentageCloserFiltering = true;
  }
  _initializeGenerator() {
    this.penumbraDarkness = this.penumbraDarkness ?? 1;
    this._numCascades = this._numCascades ?? _CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
    this.stabilizeCascades = this.stabilizeCascades ?? false;
    this._freezeShadowCastersBoundingInfoObservable = this._freezeShadowCastersBoundingInfoObservable ?? null;
    this.freezeShadowCastersBoundingInfo = this.freezeShadowCastersBoundingInfo ?? false;
    this._scbiMin = this._scbiMin ?? new Vector3(0, 0, 0);
    this._scbiMax = this._scbiMax ?? new Vector3(0, 0, 0);
    this._shadowCastersBoundingInfo = this._shadowCastersBoundingInfo ?? new BoundingInfo(new Vector3(0, 0, 0), new Vector3(0, 0, 0));
    this._breaksAreDirty = this._breaksAreDirty ?? true;
    this._minDistance = this._minDistance ?? 0;
    this._maxDistance = this._maxDistance ?? 1;
    this._currentLayer = this._currentLayer ?? 0;
    this._shadowMaxZ = this._shadowMaxZ ?? this._getCamera()?.maxZ ?? 1e4;
    this._debug = this._debug ?? false;
    this._depthClamp = this._depthClamp ?? true;
    this._cascadeBlendPercentage = this._cascadeBlendPercentage ?? 0.1;
    this._lambda = this._lambda ?? 0.5;
    this._autoCalcDepthBounds = this._autoCalcDepthBounds ?? false;
    this._recreateSceneUBOs();
    super._initializeGenerator();
  }
  _createTargetRenderTexture() {
    const engine = this._scene.getEngine();
    this._shadowMap?.dispose();
    const size = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new RenderTargetTexture(this._light.name + "_CSMShadowMap", size, this._scene, false, true, this._textureType, false, void 0, false, false, void 0, this._useRedTextureType ? 6 : 5);
    this._shadowMap.createDepthStencilTexture(engine.useReverseDepthBuffer ? 516 : 513, true, void 0, void 0, void 0, `DepthStencilForCSMShadowGenerator-${this._light.name}`);
    this._shadowMap.noPrePassRenderer = true;
  }
  _initializeShadowMap() {
    super._initializeShadowMap();
    if (this._shadowMap === null) {
      return;
    }
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._tempTransformMatricesAsArray = new Float32Array(this._numCascades * 16);
    this._viewSpaceFrustumsZ = new Array(this._numCascades);
    this._frustumLengths = new Array(this._numCascades);
    this._lightSizeUVCorrection = new Array(this._numCascades * 2);
    this._depthCorrection = new Array(this._numCascades);
    this._cascades = [];
    this._viewMatrices = [];
    this._projectionMatrices = [];
    this._transformMatrices = [];
    this._cascadeMinExtents = [];
    this._cascadeMaxExtents = [];
    this._frustumCenter = [];
    this._shadowCameraPos = [];
    this._frustumCornersWorldSpace = [];
    for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
      this._cascades[cascadeIndex] = {
        prevBreakDistance: 0,
        breakDistance: 0
      };
      this._viewMatrices[cascadeIndex] = Matrix.Zero();
      this._projectionMatrices[cascadeIndex] = Matrix.Zero();
      this._transformMatrices[cascadeIndex] = Matrix.Zero();
      this._cascadeMinExtents[cascadeIndex] = new Vector3();
      this._cascadeMaxExtents[cascadeIndex] = new Vector3();
      this._frustumCenter[cascadeIndex] = new Vector3();
      this._shadowCameraPos[cascadeIndex] = new Vector3();
      this._frustumCornersWorldSpace[cascadeIndex] = new Array(_CascadedShadowGenerator._FrustumCornersNdcSpace.length);
      for (let i = 0; i < _CascadedShadowGenerator._FrustumCornersNdcSpace.length; ++i) {
        this._frustumCornersWorldSpace[cascadeIndex][i] = new Vector3();
      }
    }
    const engine = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear();
    this._shadowMap.onBeforeRenderObservable.clear();
    this._shadowMap.onBeforeRenderObservable.add((layer) => {
      if (this._sceneUBOs) {
        this._scene.setSceneUniformBuffer(this._sceneUBOs[layer]);
      }
      this._currentLayer = layer;
      if (this._filter === ShadowGenerator.FILTER_PCF) {
        engine.setColorWrite(false);
      }
      FloatingOriginCurrentScene.eyeAtCamera = false;
      this._scene.setTransformMatrix(this.getCascadeViewMatrix(layer), this.getCascadeProjectionMatrix(layer));
      if (this._useUBO) {
        this._scene.getSceneUniformBuffer().unbindEffect();
        this._scene.finalizeSceneUbo();
      }
    });
    this._shadowMap.onBeforeBindObservable.add(() => {
      this._currentSceneUBO = this._scene.getSceneUniformBuffer();
      engine._debugPushGroup?.(`cascaded shadow map generation for pass id ${engine.currentRenderPassId}`, 1);
      if (this._breaksAreDirty) {
        this._splitFrustum();
      }
      this._computeMatrices();
    });
    this._splitFrustum();
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(subMesh, effect) {
    effect.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }
  _isReadyCustomDefines(defines) {
    defines.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== ShadowGenerator.FILTER_PCSS ? "1" : "0"));
  }
  /**
   * Prepare all the defines in a material relying on a shadow map at the specified light index.
   * @param defines Defines of the material we want to update
   * @param lightIndex Index of the light in the enabled light list of the material
   */
  prepareDefines(defines, lightIndex) {
    super.prepareDefines(defines, lightIndex);
    const scene = this._scene;
    const light = this._light;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    defines["SHADOWCSM" + lightIndex] = true;
    defines["SHADOWCSMDEBUG" + lightIndex] = this.debug;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = this.numCascades;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = scene.useRightHandedSystem;
    const camera = this._getCamera();
    if (camera && this._shadowMaxZ <= (camera.maxZ || this._shadowMaxZ)) {
      defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = true;
    }
    if (this.cascadeBlendPercentage === 0) {
      defines["SHADOWCSMNOBLEND" + lightIndex] = true;
    }
  }
  /**
   * Binds the shadow related information inside of an effect (information like near, far, darkness...
   * defined in the generator but impacting the effect).
   * @param lightIndex Index of the light in the enabled light list of the material owning the effect
   * @param effect The effect we are binfing the information for
   */
  bindShadowLight(lightIndex, effect) {
    const light = this._light;
    const scene = this._scene;
    if (!scene.shadowsEnabled || !light.shadowEnabled) {
      return;
    }
    const camera = this._getCamera();
    if (!camera) {
      return;
    }
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return;
    }
    const width = shadowMap.getSize().width;
    const transform = this._transformMatricesAsArray;
    const lightMatrix = scene.floatingOriginMode ? GetOffsetTransformMatrices(this._scene.floatingOriginOffset, this._viewMatrices, this._projectionMatrices, this._numCascades, this._tempTransformMatricesAsArray) : transform;
    effect.setMatrices("lightMatrix" + lightIndex, lightMatrix);
    effect.setArray("viewFrustumZ" + lightIndex, this._viewSpaceFrustumsZ);
    effect.setFloat("cascadeBlendFactor" + lightIndex, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage);
    effect.setArray("frustumLengths" + lightIndex, this._frustumLengths);
    if (this._filter === ShadowGenerator.FILTER_PCF) {
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    } else if (this._filter === ShadowGenerator.FILTER_PCSS) {
      for (let cascadeIndex = 0; cascadeIndex < this._numCascades; ++cascadeIndex) {
        this._lightSizeUVCorrection[cascadeIndex * 2 + 0] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[cascadeIndex].x - this._cascadeMinExtents[cascadeIndex].x);
        this._lightSizeUVCorrection[cascadeIndex * 2 + 1] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[cascadeIndex].y - this._cascadeMinExtents[cascadeIndex].y);
        this._depthCorrection[cascadeIndex] = cascadeIndex === 0 ? 1 : (this._cascadeMaxExtents[cascadeIndex].z - this._cascadeMinExtents[cascadeIndex].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      }
      effect.setDepthStencilTexture("shadowTexture" + lightIndex, shadowMap);
      effect.setTexture("depthTexture" + lightIndex, shadowMap);
      effect.setArray2("lightSizeUVCorrection" + lightIndex, this._lightSizeUVCorrection);
      effect.setArray("depthCorrection" + lightIndex, this._depthCorrection);
      effect.setFloat("penumbraDarkness" + lightIndex, this.penumbraDarkness);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / width, this._contactHardeningLightSizeUVRatio * width, this.frustumEdgeFalloff, lightIndex);
    } else {
      effect.setTexture("shadowTexture" + lightIndex, shadowMap);
      light._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), width, 1 / width, this.frustumEdgeFalloff, lightIndex);
    }
    light._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(camera), this.getLight().getDepthMinZ(camera) + this.getLight().getDepthMaxZ(camera), lightIndex);
  }
  /**
   * Gets the transformation matrix of the first cascade used to project the meshes into the map from the light point of view.
   * (eq to view projection * shadow projection matrices)
   * @returns The transform matrix used to create the shadow map
   */
  getTransformMatrix() {
    return this.getCascadeTransformMatrix(0);
  }
  /**
   * Disposes the ShadowGenerator.
   * Returns nothing.
   */
  dispose() {
    super.dispose();
    if (this._freezeShadowCastersBoundingInfoObservable) {
      this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable);
      this._freezeShadowCastersBoundingInfoObservable = null;
    }
    if (this._depthReducer) {
      this._depthReducer.dispose();
      this._depthReducer = null;
    }
  }
  /**
   * Serializes the shadow generator setup to a json object.
   * @returns The serialized JSON object
   */
  serialize() {
    const serializationObject = super.serialize();
    const shadowMap = this.getShadowMap();
    if (!shadowMap) {
      return serializationObject;
    }
    serializationObject.numCascades = this._numCascades;
    serializationObject.debug = this._debug;
    serializationObject.stabilizeCascades = this.stabilizeCascades;
    serializationObject.lambda = this._lambda;
    serializationObject.cascadeBlendPercentage = this.cascadeBlendPercentage;
    serializationObject.depthClamp = this._depthClamp;
    serializationObject.autoCalcDepthBounds = this.autoCalcDepthBounds;
    serializationObject.shadowMaxZ = this._shadowMaxZ;
    serializationObject.penumbraDarkness = this.penumbraDarkness;
    serializationObject.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo;
    serializationObject.minDistance = this.minDistance;
    serializationObject.maxDistance = this.maxDistance;
    serializationObject.renderList = [];
    if (shadowMap.renderList) {
      for (let meshIndex = 0; meshIndex < shadowMap.renderList.length; meshIndex++) {
        const mesh = shadowMap.renderList[meshIndex];
        serializationObject.renderList.push(mesh.id);
      }
    }
    return serializationObject;
  }
  /**
   * Parses a serialized ShadowGenerator and returns a new ShadowGenerator.
   * @param parsedShadowGenerator The JSON object to parse
   * @param scene The scene to create the shadow map for
   * @returns The parsed shadow generator
   */
  static Parse(parsedShadowGenerator, scene) {
    const shadowGenerator = ShadowGenerator.Parse(parsedShadowGenerator, scene, (mapSize, light, camera) => new _CascadedShadowGenerator(mapSize, light, void 0, camera));
    if (parsedShadowGenerator.numCascades !== void 0) {
      shadowGenerator.numCascades = parsedShadowGenerator.numCascades;
    }
    if (parsedShadowGenerator.debug !== void 0) {
      shadowGenerator.debug = parsedShadowGenerator.debug;
    }
    if (parsedShadowGenerator.stabilizeCascades !== void 0) {
      shadowGenerator.stabilizeCascades = parsedShadowGenerator.stabilizeCascades;
    }
    if (parsedShadowGenerator.lambda !== void 0) {
      shadowGenerator.lambda = parsedShadowGenerator.lambda;
    }
    if (parsedShadowGenerator.cascadeBlendPercentage !== void 0) {
      shadowGenerator.cascadeBlendPercentage = parsedShadowGenerator.cascadeBlendPercentage;
    }
    if (parsedShadowGenerator.depthClamp !== void 0) {
      shadowGenerator.depthClamp = parsedShadowGenerator.depthClamp;
    }
    if (parsedShadowGenerator.autoCalcDepthBounds !== void 0) {
      shadowGenerator.autoCalcDepthBounds = parsedShadowGenerator.autoCalcDepthBounds;
    }
    if (parsedShadowGenerator.shadowMaxZ !== void 0) {
      shadowGenerator.shadowMaxZ = parsedShadowGenerator.shadowMaxZ;
    }
    if (parsedShadowGenerator.penumbraDarkness !== void 0) {
      shadowGenerator.penumbraDarkness = parsedShadowGenerator.penumbraDarkness;
    }
    if (parsedShadowGenerator.freezeShadowCastersBoundingInfo !== void 0) {
      shadowGenerator.freezeShadowCastersBoundingInfo = parsedShadowGenerator.freezeShadowCastersBoundingInfo;
    }
    if (parsedShadowGenerator.minDistance !== void 0 && parsedShadowGenerator.maxDistance !== void 0) {
      shadowGenerator.setMinMaxDistance(parsedShadowGenerator.minDistance, parsedShadowGenerator.maxDistance);
    }
    return shadowGenerator;
  }
};
CascadedShadowGenerator._FrustumCornersNdcSpace = [
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(1, -1, -1),
  new Vector3(-1, -1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1),
  new Vector3(1, -1, 1),
  new Vector3(-1, -1, 1)
];
CascadedShadowGenerator.CLASSNAME = "CascadedShadowGenerator";
CascadedShadowGenerator.DEFAULT_CASCADES_COUNT = 4;
CascadedShadowGenerator.MIN_CASCADES_COUNT = 2;
CascadedShadowGenerator.MAX_CASCADES_COUNT = 4;
CascadedShadowGenerator._SceneComponentInitialization = (_) => {
  throw _WarnImport("ShadowGeneratorSceneComponent");
};

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/shadowGeneratorTask.js
var FrameGraphShadowGeneratorTask = class extends FrameGraphTask {
  /**
   * The light to generate shadows from.
   */
  get light() {
    return this._light;
  }
  set light(value) {
    if (value === this._light) {
      return;
    }
    this._light = value;
    this._setupShadowGenerator();
  }
  /**
   * Gets or sets the camera used to generate the shadow generator.
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this._setupShadowGenerator();
  }
  /**
   * The size of the shadow map.
   */
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(value) {
    if (value === this._mapSize) {
      return;
    }
    this._mapSize = value;
    this._setupShadowGenerator();
  }
  /**
   * If true, the shadow map will use a 32 bits float texture type (else, 16 bits float is used if supported).
   */
  get useFloat32TextureType() {
    return this._useFloat32TextureType;
  }
  set useFloat32TextureType(value) {
    if (value === this._useFloat32TextureType) {
      return;
    }
    this._useFloat32TextureType = value;
    this._setupShadowGenerator();
  }
  /**
   * If true, the shadow map will use a red texture format (else, a RGBA format is used).
   */
  get useRedTextureFormat() {
    return this._useRedTextureFormat;
  }
  set useRedTextureFormat(value) {
    if (value === this._useRedTextureFormat) {
      return;
    }
    this._useRedTextureFormat = value;
    this._setupShadowGenerator();
  }
  /**
   * The bias to apply to the shadow map.
   */
  get bias() {
    return this._bias;
  }
  set bias(value) {
    if (value === this._bias) {
      return;
    }
    this._bias = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.bias = value;
    }
  }
  /**
   * The normal bias to apply to the shadow map.
   */
  get normalBias() {
    return this._normalBias;
  }
  set normalBias(value) {
    if (value === this._normalBias) {
      return;
    }
    this._normalBias = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.normalBias = value;
    }
  }
  /**
   * The darkness of the shadows.
   */
  get darkness() {
    return this._darkness;
  }
  set darkness(value) {
    if (value === this._darkness) {
      return;
    }
    this._darkness = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.darkness = value;
    }
  }
  /**
   * Gets or sets the ability to have transparent shadow
   */
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(value) {
    if (value === this._transparencyShadow) {
      return;
    }
    this._transparencyShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.transparencyShadow = value;
    }
  }
  /**
   * Enables or disables shadows with varying strength based on the transparency
   */
  get enableSoftTransparentShadow() {
    return this._enableSoftTransparentShadow;
  }
  set enableSoftTransparentShadow(value) {
    if (value === this._enableSoftTransparentShadow) {
      return;
    }
    this._enableSoftTransparentShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.enableSoftTransparentShadow = value;
    }
  }
  /**
   * If this is true, use the opacity texture's alpha channel for transparent shadows instead of the diffuse one
   */
  get useOpacityTextureForTransparentShadow() {
    return this._useOpacityTextureForTransparentShadow;
  }
  set useOpacityTextureForTransparentShadow(value) {
    if (value === this._useOpacityTextureForTransparentShadow) {
      return;
    }
    this._useOpacityTextureForTransparentShadow = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.useOpacityTextureForTransparentShadow = value;
    }
  }
  /**
   * The filter to apply to the shadow map.
   */
  get filter() {
    return this._filter;
  }
  set filter(value) {
    if (value === this._filter) {
      return;
    }
    this._filter = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.filter = value;
    }
  }
  /**
   * The filtering quality to apply to the filter.
   */
  get filteringQuality() {
    return this._filteringQuality;
  }
  set filteringQuality(value) {
    if (value === this._filteringQuality) {
      return;
    }
    this._filteringQuality = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.filteringQuality = value;
    }
  }
  _createShadowGenerator() {
    this._shadowGenerator = new ShadowGenerator(this._mapSize, this._light, this._useFloat32TextureType, void 0, this._useRedTextureFormat);
  }
  _setupShadowGenerator() {
    this._shadowGenerator?.dispose();
    this._shadowGenerator = void 0;
    if (this._light !== void 0) {
      this._createShadowGenerator();
      const shadowGenerator = this._shadowGenerator;
      if (shadowGenerator === void 0) {
        return;
      }
      shadowGenerator.bias = this._bias;
      shadowGenerator.normalBias = this._normalBias;
      shadowGenerator.darkness = this._darkness;
      shadowGenerator.transparencyShadow = this._transparencyShadow;
      shadowGenerator.enableSoftTransparentShadow = this._enableSoftTransparentShadow;
      shadowGenerator.useOpacityTextureForTransparentShadow = this._useOpacityTextureForTransparentShadow;
      shadowGenerator.filter = this._filter;
      shadowGenerator.filteringQuality = this._filteringQuality;
      const shadowMap = shadowGenerator.getShadowMap();
      shadowMap._disableEngineStages = true;
      shadowMap.cameraForLOD = this._camera;
      this.shadowGenerator = shadowGenerator;
    }
  }
  isReady() {
    return !!this._shadowGenerator && !!this._shadowGenerator.getShadowMap()?.isReadyForRendering();
  }
  /**
   * Creates a new shadow generator task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   * @param _scene The scene to create the shadow generator for.
   */
  constructor(name, frameGraph, _scene) {
    super(name, frameGraph);
    this._mapSize = 1024;
    this._useFloat32TextureType = false;
    this._useRedTextureFormat = true;
    this._bias = 0.01;
    this._normalBias = 0;
    this._darkness = 0;
    this._transparencyShadow = false;
    this._enableSoftTransparentShadow = false;
    this._useOpacityTextureForTransparentShadow = false;
    this._filter = ShadowGenerator.FILTER_PCF;
    this._filteringQuality = ShadowGenerator.QUALITY_HIGH;
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  record() {
    if (this.light === void 0 || this.objectList === void 0 || this.camera === void 0) {
      throw new Error(`FrameGraphShadowGeneratorTask ${this.name}: light, objectList and camera are required`);
    }
    const shadowMap = this._shadowGenerator.getShadowMap();
    shadowMap.renderList = this.objectList.meshes;
    shadowMap.particleSystemList = this.objectList.particleSystems;
    const shadowTextureHandle = this._frameGraph.textureManager.importTexture(`${this.name} shadowmap`, this._shadowGenerator.getShadowMap().getInternalTexture());
    this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, shadowTextureHandle);
    const pass = this._frameGraph.addPass(this.name);
    pass.setExecuteFunc((context) => {
      if (!this.light.isEnabled() || !this.light.shadowEnabled) {
        return;
      }
      const shadowMap2 = this._shadowGenerator.getShadowMap();
      shadowMap2.renderList = this.objectList.meshes;
      shadowMap2.particleSystemList = this.objectList.particleSystems;
      context.saveDepthStates();
      context.setDepthStates(true, true);
      context.renderUnmanaged(shadowMap2);
      context.restoreDepthStates();
    });
    const passDisabled = this._frameGraph.addPass(this.name + "_disabled", true);
    passDisabled.setExecuteFunc((_context) => {
    });
  }
  dispose() {
    this._shadowGenerator?.dispose();
    this._shadowGenerator = void 0;
  }
};

// node_modules/@babylonjs/core/Lights/directionalLight.js
Node.AddNodeConstructor("Light_Type_1", (name, scene) => {
  return () => new DirectionalLight(name, Vector3.Zero(), scene);
});
var DirectionalLight = class extends ShadowLight {
  /**
   * Fix frustum size for the shadow generation. This is disabled if the value is 0.
   */
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  /**
   * Specifies a fix frustum size for the shadow generation.
   */
  set shadowFrustumSize(value) {
    this._shadowFrustumSize = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  /**
   * Sets the shadow projection scale against the optimal computed one.
   * 0.1 by default which means that the projection window is increase by 10% from the optimal size.
   * This does not impact in fixed frustum size (shadowFrustumSize being set)
   */
  set shadowOrthoScale(value) {
    this._shadowOrthoScale = value;
    this.forceProjectionMatrixCompute();
  }
  /**
   * Gets or sets the orthoLeft property used to build the light frustum
   */
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(left) {
    this._orthoLeft = left;
  }
  /**
   * Gets or sets the orthoRight property used to build the light frustum
   */
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(right) {
    this._orthoRight = right;
  }
  /**
   * Gets or sets the orthoTop property used to build the light frustum
   */
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(top) {
    this._orthoTop = top;
  }
  /**
   * Gets or sets the orthoBottom property used to build the light frustum
   */
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(bottom) {
    this._orthoBottom = bottom;
  }
  /**
   * Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
   * The directional light is emitted from everywhere in the given direction.
   * It can cast shadows.
   * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction
   * @param name The friendly name of the light
   * @param direction The direction of the light
   * @param scene The scene the light belongs to
   */
  constructor(name, direction, scene) {
    super(name, scene);
    this._shadowFrustumSize = 0;
    this._shadowOrthoScale = 0.1;
    this.autoUpdateExtends = true;
    this.autoCalcShadowZBounds = false;
    this._orthoLeft = Number.MAX_VALUE;
    this._orthoRight = Number.MIN_VALUE;
    this._orthoTop = Number.MIN_VALUE;
    this._orthoBottom = Number.MAX_VALUE;
    this.position = direction.scale(-1);
    this.direction = direction;
  }
  /**
   * Returns the string "DirectionalLight".
   * @returns The class name
   */
  getClassName() {
    return "DirectionalLight";
  }
  /**
   * Returns the integer 1.
   * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTypeID() {
    return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  /**
   * Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    if (this.shadowFrustumSize > 0) {
      this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
    } else {
      this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
    }
  }
  /**
   * Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   */
  _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
    const activeCamera = this.getScene().activeCamera;
    if (!activeCamera) {
      return;
    }
    Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  /**
   * Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
   * Returns the DirectionalLight Shadow projection matrix.
   * @param matrix
   * @param viewMatrix
   * @param renderList
   */
  _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
    const activeCamera = this.getScene().activeCamera;
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const tempVector3 = Vector3.Zero();
      this._orthoLeft = Number.MAX_VALUE;
      this._orthoRight = -Number.MAX_VALUE;
      this._orthoTop = -Number.MAX_VALUE;
      this._orthoBottom = Number.MAX_VALUE;
      let shadowMinZ = Number.MAX_VALUE;
      let shadowMaxZ = -Number.MAX_VALUE;
      for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
        const mesh = renderList[meshIndex];
        if (!mesh) {
          continue;
        }
        const boundingInfo = mesh.getBoundingInfo();
        const boundingBox = boundingInfo.boundingBox;
        for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
          Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
          if (tempVector3.x < this._orthoLeft) {
            this._orthoLeft = tempVector3.x;
          }
          if (tempVector3.y < this._orthoBottom) {
            this._orthoBottom = tempVector3.y;
          }
          if (tempVector3.x > this._orthoRight) {
            this._orthoRight = tempVector3.x;
          }
          if (tempVector3.y > this._orthoTop) {
            this._orthoTop = tempVector3.y;
          }
          if (this.autoCalcShadowZBounds) {
            if (tempVector3.z < shadowMinZ) {
              shadowMinZ = tempVector3.z;
            }
            if (tempVector3.z > shadowMaxZ) {
              shadowMaxZ = tempVector3.z;
            }
          }
        }
      }
      if (this.autoCalcShadowZBounds) {
        this._shadowMinZ = shadowMinZ;
        this._shadowMaxZ = shadowMaxZ;
      }
    }
    const xOffset = this._orthoRight - this._orthoLeft;
    const yOffset = this._orthoTop - this._orthoBottom;
    const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera?.minZ || 0;
    const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera?.maxZ || 1e4;
    const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
    Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4);
    this._uniformBuffer.addUniform("vLightDiffuse", 4);
    this._uniformBuffer.addUniform("vLightSpecular", 4);
    this._uniformBuffer.addUniform("shadowsInfo", 3);
    this._uniformBuffer.addUniform("depthValues", 2);
    this._uniformBuffer.create();
  }
  /**
   * Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.
   * @param effect The effect to update
   * @param lightIndex The index of the light in the effect to update
   * @returns The directional light
   */
  transferToEffect(effect, lightIndex) {
    if (this.computeTransformedInformation()) {
      this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
      return this;
    }
    this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
    return this;
  }
  transferToNodeMaterialEffect(effect, lightDataUniformName) {
    if (this.computeTransformedInformation()) {
      effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
      return this;
    }
    effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
    return this;
  }
  /**
   * Gets the minZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param _activeCamera The camera we are returning the min for (not used)
   * @returns the depth min z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMinZ(_activeCamera) {
    const engine = this._scene.getEngine();
    return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Gets the maxZ used for shadow according to both the scene and the light.
   *
   * Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
   * -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.
   * (when not using reverse depth buffer / NDC half Z range)
   * @param _activeCamera The camera we are returning the max for
   * @returns the depth max z
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getDepthMaxZ(_activeCamera) {
    const engine = this._scene.getEngine();
    return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
  }
  /**
   * Prepares the list of defines specific to the light type.
   * @param defines the list of defines
   * @param lightIndex defines the index of the light for the effect
   */
  prepareLightSpecificDefines(defines, lightIndex) {
    defines["DIRLIGHT" + lightIndex] = true;
  }
};
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowFrustumSize", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "shadowOrthoScale", null);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoUpdateExtends", void 0);
__decorate([
  serialize()
], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
__decorate([
  serialize("orthoLeft")
], DirectionalLight.prototype, "_orthoLeft", void 0);
__decorate([
  serialize("orthoRight")
], DirectionalLight.prototype, "_orthoRight", void 0);
__decorate([
  serialize("orthoTop")
], DirectionalLight.prototype, "_orthoTop", void 0);
__decorate([
  serialize("orthoBottom")
], DirectionalLight.prototype, "_orthoBottom", void 0);
RegisterClass("BABYLON.DirectionalLight", DirectionalLight);

// node_modules/@babylonjs/core/FrameGraph/Tasks/PostProcesses/postProcessTask.js
var FrameGraphPostProcessTask = class extends FrameGraphTask {
  /**
   * The draw wrapper used by the post process
   */
  get drawWrapper() {
    return this._postProcessDrawWrapper;
  }
  /**
   * Constructs a new post process task.
   * @param name Name of the task.
   * @param frameGraph The frame graph this task is associated with.
   * @param postProcess The post process to apply.
   */
  constructor(name, frameGraph, postProcess) {
    super(name, frameGraph);
    this.sourceSamplingMode = 2;
    this.depthReadOnly = false;
    this.stencilReadOnly = false;
    this.disableColorWrite = false;
    this.drawBackFace = false;
    this.depthTest = true;
    this.postProcess = postProcess;
    this._postProcessDrawWrapper = this.postProcess.drawWrapper;
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
    this.outputDepthAttachmentTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  isReady() {
    return this.postProcess.isReady();
  }
  record(skipCreationOfDisabledPasses = false, additionalExecute, additionalBindings) {
    if (this.sourceTexture === void 0 && this.targetTexture === void 0) {
      throw new Error(`FrameGraphPostProcessTask "${this.name}": sourceTexture or targetTexture is required`);
    }
    const sourceTextureCreationOptions = this.sourceTexture !== void 0 ? this._frameGraph.textureManager.getTextureCreationOptions(this.sourceTexture) : void 0;
    if (sourceTextureCreationOptions) {
      sourceTextureCreationOptions.options.samples = 1;
    }
    this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, this.targetTexture, this.name, sourceTextureCreationOptions);
    if (this.depthAttachmentTexture !== void 0) {
      this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthAttachmentTexture, this.depthAttachmentTexture);
    }
    if (sourceTextureCreationOptions) {
      const sourceSize = this._frameGraph.textureManager.getTextureAbsoluteDimensions(sourceTextureCreationOptions);
      this._sourceWidth = sourceSize.width;
      this._sourceHeight = sourceSize.height;
    }
    const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.outputTexture);
    this._outputWidth = outputTextureDescription.size.width;
    this._outputHeight = outputTextureDescription.size.height;
    const pass = this._frameGraph.addRenderPass(this.name);
    pass.depthReadOnly = this.depthReadOnly;
    pass.stencilReadOnly = this.stencilReadOnly;
    pass.addDependencies(this.sourceTexture);
    pass.setRenderTarget(this.outputTexture);
    pass.setRenderTargetDepth(this.depthAttachmentTexture);
    pass.setExecuteFunc((context) => {
      if (this.sourceTexture !== void 0) {
        context.setTextureSamplingMode(this.sourceTexture, this.sourceSamplingMode);
      }
      additionalExecute?.(context);
      context.applyFullScreenEffect(this._postProcessDrawWrapper, () => {
        if (this.sourceTexture !== void 0) {
          context.bindTextureHandle(this._postProcessDrawWrapper.effect, "textureSampler", this.sourceTexture);
        }
        additionalBindings?.(context);
        this.postProcess.bind();
      }, this.stencilState, this.disableColorWrite, this.drawBackFace, this.depthTest);
    });
    if (!skipCreationOfDisabledPasses) {
      const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
      passDisabled.depthReadOnly = this.depthReadOnly;
      passDisabled.stencilReadOnly = this.stencilReadOnly;
      passDisabled.addDependencies(this.sourceTexture);
      passDisabled.setRenderTarget(this.outputTexture);
      passDisabled.setRenderTargetDepth(this.depthAttachmentTexture);
      passDisabled.setExecuteFunc((context) => {
        if (this.sourceTexture !== void 0) {
          context.copyTexture(this.sourceTexture);
        }
      });
    }
    return pass;
  }
  dispose() {
    this.postProcess.dispose();
    super.dispose();
  }
};

// node_modules/@babylonjs/core/Materials/Textures/textureCreationOptions.js
function textureSizeIsObject(size) {
  return size.width !== void 0;
}
function getDimensionsFromTextureSize(size) {
  if (textureSizeIsObject(size)) {
    return { width: size.width, height: size.height };
  }
  return { width: size, height: size };
}

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/csmShadowGeneratorTask.js
var FrameGraphCascadedShadowGeneratorTask = class extends FrameGraphShadowGeneratorTask {
  /**
   * Checks if a shadow generator task is a cascaded shadow generator task.
   * @param task The task to check.
   * @returns True if the task is a cascaded shadow generator task, else false.
   */
  static IsCascadedShadowGenerator(task) {
    return task.numCascades !== void 0;
  }
  /**
   * The number of cascades.
   */
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(value) {
    if (value === this._numCascades) {
      return;
    }
    this._numCascades = value;
    this._setupShadowGenerator();
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should display the cascades.
   */
  get debug() {
    return this._debug;
  }
  set debug(value) {
    if (value === this._debug) {
      return;
    }
    this._debug = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.debug = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should stabilize the cascades.
   */
  get stabilizeCascades() {
    return this._stabilizeCascades;
  }
  set stabilizeCascades(value) {
    if (value === this._stabilizeCascades) {
      return;
    }
    this._stabilizeCascades = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.stabilizeCascades = value;
    }
  }
  /**
   * Gets or sets the lambda parameter of the shadow generator.
   */
  get lambda() {
    return this._lambda;
  }
  set lambda(value) {
    if (value === this._lambda) {
      return;
    }
    this._lambda = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.lambda = value;
    }
  }
  /**
   * Gets or sets the cascade blend percentage.
   */
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(value) {
    if (value === this._cascadeBlendPercentage) {
      return;
    }
    this._cascadeBlendPercentage = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.cascadeBlendPercentage = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should use depth clamping.
   */
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(value) {
    if (value === this._depthClamp) {
      return;
    }
    this._depthClamp = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.depthClamp = value;
    }
  }
  /**
   * Gets or sets a value indicating whether the shadow generator should automatically calculate the depth bounds.
   */
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(value) {
    if (value === this._autoCalcDepthBounds) {
      return;
    }
    this._autoCalcDepthBounds = value;
    this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;
    if (!value) {
      this._shadowGenerator?.setMinMaxDistance(0, 1);
    }
    const passes = this.passes;
    for (let i = 0; i < passes.length - 1; ++i) {
      passes[i].disabled = !value;
    }
  }
  /**
   * Defines the refresh rate of the min/max computation used when autoCalcDepthBounds is set to true
   * Use 0 to compute just once, 1 to compute on every frame, 2 to compute every two frames and so on...
   */
  get autoCalcDepthBoundsRefreshRate() {
    return this._autoCalcDepthBoundsRefreshRate;
  }
  set autoCalcDepthBoundsRefreshRate(value) {
    this._autoCalcDepthBoundsRefreshRate = value;
    this._currentAutoCalcDepthBoundsCounter = this._autoCalcDepthBoundsRefreshRate;
  }
  /**
   * Gets or sets the maximum shadow Z value.
   */
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  set shadowMaxZ(value) {
    if (value === this._shadowMaxZ) {
      return;
    }
    this._shadowMaxZ = value;
    if (this._shadowGenerator) {
      this._shadowGenerator.shadowMaxZ = value;
    }
  }
  /**
   * Creates a new shadow generator task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   * @param scene The scene to create the shadow generator for.
   */
  constructor(name, frameGraph, scene) {
    super(name, frameGraph, scene);
    this.depthTextureType = 0;
    this._numCascades = CascadedShadowGenerator.DEFAULT_CASCADES_COUNT;
    this._debug = false;
    this._stabilizeCascades = false;
    this._lambda = 0.5;
    this._cascadeBlendPercentage = 0.1;
    this._depthClamp = true;
    this._autoCalcDepthBounds = false;
    this._currentAutoCalcDepthBoundsCounter = 0;
    this._autoCalcDepthBoundsRefreshRate = 1;
    this._shadowMaxZ = 1e4;
    this._thinMinMaxReducer = new ThinMinMaxReducer(scene);
    this._thinMinMaxReducer.onAfterReductionPerformed.add((minmax) => {
      if (!this._shadowGenerator) {
        return;
      }
      const camera = this.camera;
      let min = minmax.min, max = minmax.max;
      if (min >= max) {
        min = 0;
        max = 1;
      } else if (camera && this.depthTextureType !== 0) {
        if (this.depthTextureType === 2) {
          const engine = this._frameGraph.engine;
          const projectionMatrix = camera.getProjectionMatrix();
          const p2z = projectionMatrix.m[10];
          const p3z = projectionMatrix.m[14];
          if (!engine.isNDCHalfZRange) {
            min = min * 2 - 1;
            max = max * 2 - 1;
          }
          min = p3z / (min - p2z);
          max = p3z / (max - p2z);
        }
        const zNear = camera.minZ;
        const zFar = camera.maxZ;
        min = (min - zNear) / (zFar - zNear);
        max = (max - zNear) / (zFar - zNear);
      }
      if (min !== this._shadowGenerator.minDistance || max !== this._shadowGenerator.maxDistance) {
        this._shadowGenerator.setMinMaxDistance(min, max);
      }
    });
  }
  _createShadowGenerator() {
    if (!(this.light instanceof DirectionalLight)) {
      throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: the CSM shadow generator only supports directional lights.`);
    }
    this._shadowGenerator = new CascadedShadowGenerator(this.mapSize, this.light, this.useFloat32TextureType, this.camera, this.useRedTextureFormat);
    this._shadowGenerator.numCascades = this._numCascades;
  }
  _setupShadowGenerator() {
    super._setupShadowGenerator();
    const shadowGenerator = this._shadowGenerator;
    if (shadowGenerator === void 0) {
      return;
    }
    shadowGenerator.debug = this._debug;
    shadowGenerator.stabilizeCascades = this._stabilizeCascades;
    shadowGenerator.lambda = this._lambda;
    shadowGenerator.cascadeBlendPercentage = this._cascadeBlendPercentage;
    shadowGenerator.depthClamp = this._depthClamp;
    shadowGenerator.shadowMaxZ = this._shadowMaxZ;
  }
  record() {
    if (this.light === void 0 || this.objectList === void 0 || this.camera === void 0) {
      throw new Error(`FrameGraphCascadedShadowGeneratorTask ${this.name}: light, objectList and camera are required`);
    }
    if (this.depthTexture !== void 0) {
      const depthTextureCreationOptions = this._frameGraph.textureManager.getTextureCreationOptions(this.depthTexture);
      const size = !depthTextureCreationOptions.sizeIsPercentage ? textureSizeIsObject(depthTextureCreationOptions.size) ? depthTextureCreationOptions.size : { width: depthTextureCreationOptions.size, height: depthTextureCreationOptions.size } : this._frameGraph.textureManager.getAbsoluteDimensions(depthTextureCreationOptions.size);
      const width = size.width;
      const height = size.height;
      depthTextureCreationOptions.sizeIsPercentage = false;
      depthTextureCreationOptions.options.formats = [7];
      depthTextureCreationOptions.options.samples = 1;
      this._thinMinMaxReducer.setTextureDimensions(width, height, this.depthTextureType);
      const reductionSteps = this._thinMinMaxReducer.reductionSteps;
      let targetTexture;
      this._frameGraph.addPass(`${this.name} Before Min Max Reduction`).setExecuteFunc((context) => {
        context.pushDebugGroup(`Min Max Reduction`);
      });
      for (let i = 0; i < reductionSteps.length - 1; ++i) {
        const reductionStep = reductionSteps[i];
        depthTextureCreationOptions.size = { width: reductionSteps[i + 1].textureWidth, height: reductionSteps[i + 1].textureHeight };
        const postProcess = new FrameGraphPostProcessTask(reductionStep.name, this._frameGraph, reductionStep);
        postProcess.sourceTexture = i == 0 ? this.depthTexture : targetTexture;
        postProcess.sourceSamplingMode = 1;
        postProcess.targetTexture = this._frameGraph.textureManager.createRenderTargetTexture(`${this.name} ${reductionStep.name}`, depthTextureCreationOptions);
        postProcess.record(true);
        targetTexture = postProcess.outputTexture;
      }
      this._frameGraph.addPass(`${this.name} After Min Max Reduction`).setExecuteFunc((context) => {
        context.popDebugGroup();
        if (this._autoCalcDepthBounds && this._currentAutoCalcDepthBoundsCounter >= 0) {
          if (++this._currentAutoCalcDepthBoundsCounter >= this._autoCalcDepthBoundsRefreshRate) {
            const minMaxTexture = context.getTextureFromHandle(targetTexture);
            if (minMaxTexture) {
              this._thinMinMaxReducer.readMinMax(minMaxTexture);
            }
          }
          this._currentAutoCalcDepthBoundsCounter %= this._autoCalcDepthBoundsRefreshRate;
          if (this._autoCalcDepthBoundsRefreshRate === 0) {
            this._currentAutoCalcDepthBoundsCounter = -1;
          }
        }
      });
    }
    super.record();
  }
  dispose() {
    super.dispose();
    this._thinMinMaxReducer.dispose();
  }
};

// node_modules/@babylonjs/core/FrameGraph/Tasks/Rendering/objectRendererTask.js
var FrameGraphObjectRendererTask = class extends FrameGraphTask {
  /**
   * Gets or sets the camera used to render the objects.
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this._renderer.activeCamera = this.camera;
  }
  /**
   * If image processing should be disabled (default is false).
   * false means that the default image processing configuration will be applied (the one from the scene)
   */
  get disableImageProcessing() {
    return this._disableImageProcessing;
  }
  set disableImageProcessing(value) {
    if (value === this._disableImageProcessing) {
      return;
    }
    this._disableImageProcessing = value;
    this._renderer.disableImageProcessing = value;
  }
  /**
   * Define if particles should be rendered (default is true).
   */
  get renderParticles() {
    return this._renderParticles;
  }
  set renderParticles(value) {
    if (value === this._renderParticles) {
      return;
    }
    this._renderParticles = value;
    this._renderer.renderParticles = value;
  }
  /**
   * Define if sprites should be rendered (default is true).
   */
  get renderSprites() {
    return this._renderSprites;
  }
  set renderSprites(value) {
    if (value === this._renderSprites) {
      return;
    }
    this._renderSprites = value;
    this._renderer.renderSprites = value;
  }
  /**
   * Force checking the layerMask property even if a custom list of meshes is provided (ie. if renderList is not undefined). Default is true.
   */
  get forceLayerMaskCheck() {
    return this._forceLayerMaskCheck;
  }
  set forceLayerMaskCheck(value) {
    if (value === this._forceLayerMaskCheck) {
      return;
    }
    this._forceLayerMaskCheck = value;
    this._renderer.forceLayerMaskCheck = value;
  }
  /**
   * Enables the rendering of bounding boxes for meshes (still subject to Mesh.showBoundingBox or scene.forceShowBoundingBoxes). Default is true.
   */
  get enableBoundingBoxRendering() {
    return this._enableBoundingBoxRendering;
  }
  set enableBoundingBoxRendering(value) {
    if (value === this._enableBoundingBoxRendering) {
      return;
    }
    this._enableBoundingBoxRendering = value;
    this._renderer.enableBoundingBoxRendering = value;
  }
  /**
   * Enables the rendering of outlines/overlays for meshes (still subject to Mesh.renderOutline/Mesh.renderOverlay). Default is true.
   */
  get enableOutlineRendering() {
    return this._enableOutlineRendering;
  }
  set enableOutlineRendering(value) {
    if (value === this._enableOutlineRendering) {
      return;
    }
    this._enableOutlineRendering = value;
    this._renderer.enableOutlineRendering = value;
  }
  /**
   * The object renderer used to render the objects.
   */
  get objectRenderer() {
    return this._renderer;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    if (this._renderer) {
      this._renderer.name = value;
    }
  }
  /**
   * Constructs a new object renderer task.
   * @param name The name of the task.
   * @param frameGraph The frame graph the task belongs to.
   * @param scene The scene the frame graph is associated with.
   * @param options The options of the object renderer.
   * @param existingObjectRenderer An existing object renderer to use (optional). If provided, the options parameter will be ignored.
   */
  constructor(name, frameGraph, scene, options, existingObjectRenderer) {
    super(name, frameGraph);
    this.shadowGenerators = [];
    this.depthTest = true;
    this.depthWrite = true;
    this.disableShadows = false;
    this._disableImageProcessing = false;
    this.isMainObjectRenderer = false;
    this._renderParticles = true;
    this._renderSprites = true;
    this._forceLayerMaskCheck = true;
    this._enableBoundingBoxRendering = true;
    this._enableOutlineRendering = true;
    this._onBeforeRenderObservable = null;
    this._onAfterRenderObservable = null;
    this._externalObjectRenderer = false;
    this._scene = scene;
    this._engine = scene.getEngine();
    this._externalObjectRenderer = !!existingObjectRenderer;
    this._renderer = existingObjectRenderer ?? new ObjectRenderer(name, scene, options);
    this.name = name;
    this._renderer.disableImageProcessing = this._disableImageProcessing;
    this._renderer.renderParticles = this._renderParticles;
    this._renderer.renderSprites = this._renderSprites;
    this._renderer.enableBoundingBoxRendering = this._enableBoundingBoxRendering;
    this._renderer.forceLayerMaskCheck = this._forceLayerMaskCheck;
    if (!this._externalObjectRenderer) {
      this._renderer.onBeforeRenderingManagerRenderObservable.add(() => {
        if (!this._renderer.options.doNotChangeAspectRatio) {
          scene.updateTransformMatrix(true);
        }
      });
    }
    this.outputTexture = this._frameGraph.textureManager.createDanglingHandle();
    this.outputDepthTexture = this._frameGraph.textureManager.createDanglingHandle();
  }
  isReady() {
    return this._renderer.isReadyForRendering(this._textureWidth, this._textureHeight);
  }
  record(skipCreationOfDisabledPasses = false, additionalExecute) {
    if (this.targetTexture === void 0 || this.objectList === void 0) {
      throw new Error(`FrameGraphObjectRendererTask ${this.name}: targetTexture and objectList are required`);
    }
    this._renderer.renderList = this.objectList.meshes;
    this._renderer.particleSystemList = this.objectList.particleSystems;
    const targetTextures = Array.isArray(this.targetTexture) ? this.targetTexture : [this.targetTexture];
    const outputTextureDescription = this._frameGraph.textureManager.getTextureDescription(targetTextures[0]);
    let depthEnabled = false;
    if (this.depthTexture !== void 0) {
      if (this.depthTexture === backbufferDepthStencilTextureHandle && (targetTextures[0] !== backbufferColorTextureHandle || targetTextures.length > 1)) {
        throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer color texture is the only color texture allowed when the depth is the back buffer depth/stencil`);
      }
      if (this.depthTexture !== backbufferDepthStencilTextureHandle && targetTextures[0] === backbufferColorTextureHandle) {
        throw new Error(`FrameGraphObjectRendererTask ${this.name}: the back buffer depth/stencil texture is the only depth texture allowed when the target is the back buffer color`);
      }
      const depthTextureDescription = this._frameGraph.textureManager.getTextureDescription(this.depthTexture);
      if (depthTextureDescription.options.samples !== outputTextureDescription.options.samples) {
        throw new Error(`FrameGraphObjectRendererTask ${this.name}: the depth texture and the output texture must have the same number of samples`);
      }
      depthEnabled = true;
    }
    this._frameGraph.textureManager.resolveDanglingHandle(this.outputTexture, targetTextures[0]);
    if (this.depthTexture !== void 0) {
      this._frameGraph.textureManager.resolveDanglingHandle(this.outputDepthTexture, this.depthTexture);
    }
    this._textureWidth = outputTextureDescription.size.width;
    this._textureHeight = outputTextureDescription.size.height;
    this._setLightsForShadow();
    const pass = this._frameGraph.addRenderPass(this.name);
    pass.setRenderTarget(targetTextures);
    pass.setRenderTargetDepth(this.depthTexture);
    pass.setExecuteFunc((context) => {
      this._renderer.renderList = this.objectList.meshes;
      this._renderer.particleSystemList = this.objectList.particleSystems;
      const boundingBoxRenderer = this.getBoundingBoxRenderer?.();
      const currentBoundingBoxMeshList = boundingBoxRenderer && boundingBoxRenderer.renderList.length > 0 ? boundingBoxRenderer.renderList.data.slice() : [];
      if (boundingBoxRenderer) {
        currentBoundingBoxMeshList.length = boundingBoxRenderer.renderList.length;
      }
      context.setDepthStates(this.depthTest && depthEnabled, this.depthWrite && depthEnabled);
      const camera = this._renderer.activeCamera;
      if (camera && camera.cameraRigMode !== 0 && !camera._renderingMultiview) {
        for (let index = 0; index < camera._rigCameras.length; index++) {
          const rigCamera = camera._rigCameras[index];
          rigCamera.rigParent = void 0;
          this._renderer.activeCamera = rigCamera;
          context.render(this._renderer, this._textureWidth, this._textureHeight);
          rigCamera.rigParent = camera;
        }
        this._renderer.activeCamera = camera;
      } else {
        context.render(this._renderer, this._textureWidth, this._textureHeight);
      }
      additionalExecute?.(context);
      if (boundingBoxRenderer) {
        boundingBoxRenderer.renderList.data = currentBoundingBoxMeshList;
        boundingBoxRenderer.renderList.length = currentBoundingBoxMeshList.length;
      }
    });
    if (!skipCreationOfDisabledPasses) {
      const passDisabled = this._frameGraph.addRenderPass(this.name + "_disabled", true);
      passDisabled.setRenderTarget(targetTextures);
      passDisabled.setRenderTargetDepth(this.depthTexture);
      passDisabled.setExecuteFunc((_context) => {
      });
    }
    return pass;
  }
  dispose() {
    this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
    this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
    if (!this._externalObjectRenderer) {
      this._renderer.dispose();
    }
    super.dispose();
  }
  _setLightsForShadow() {
    const lightsForShadow = /* @__PURE__ */ new Set();
    const shadowEnabled = /* @__PURE__ */ new Map();
    if (this.shadowGenerators) {
      for (const shadowGeneratorTask of this.shadowGenerators) {
        const shadowGenerator = shadowGeneratorTask.shadowGenerator;
        const light = shadowGenerator.getLight();
        if (light.isEnabled() && light.shadowEnabled) {
          lightsForShadow.add(light);
          if (FrameGraphCascadedShadowGeneratorTask.IsCascadedShadowGenerator(shadowGeneratorTask)) {
            light._shadowGenerators.set(shadowGeneratorTask.camera, shadowGenerator);
          } else {
            light._shadowGenerators.set(null, shadowGenerator);
          }
        }
      }
    }
    this._renderer.onBeforeRenderObservable.remove(this._onBeforeRenderObservable);
    this._onBeforeRenderObservable = this._renderer.onBeforeRenderObservable.add(() => {
      for (let i = 0; i < this._scene.lights.length; i++) {
        const light = this._scene.lights[i];
        if (!light.setShadowProjectionMatrix) {
          continue;
        }
        shadowEnabled.set(light, light.shadowEnabled);
        light.shadowEnabled = !this.disableShadows && lightsForShadow.has(light);
      }
    });
    this._renderer.onAfterRenderObservable.remove(this._onAfterRenderObservable);
    this._onAfterRenderObservable = this._renderer.onAfterRenderObservable.add(() => {
      for (let i = 0; i < this._scene.lights.length; i++) {
        const light = this._scene.lights[i];
        if (!light.setShadowProjectionMatrix) {
          continue;
        }
        light.shadowEnabled = shadowEnabled.get(light);
      }
    });
  }
};

// node_modules/@babylonjs/core/import.helper.js
var _ImportHelper = class {
};
_ImportHelper._IsPickingAvailable = false;

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo = class {
  constructor() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  get singleClick() {
    return this._singleClick;
  }
  get doubleClick() {
    return this._doubleClick;
  }
  get hasSwiped() {
    return this._hasSwiped;
  }
  get ignore() {
    return this._ignore;
  }
  set singleClick(b) {
    this._singleClick = b;
  }
  set doubleClick(b) {
    this._doubleClick = b;
  }
  set hasSwiped(b) {
    this._hasSwiped = b;
  }
  set ignore(b) {
    this._ignore = b;
  }
};
var InputManager = class _InputManager {
  /**
   * Creates a new InputManager
   * @param scene - defines the hosting scene
   */
  constructor(scene) {
    this._alreadyAttached = false;
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._activePointerIds = new Array();
    this._activePointerIdsCount = 0;
    this._doubleClickOccured = false;
    this._isSwiping = false;
    this._swipeButtonPressed = -1;
    this._skipPointerTap = false;
    this._isMultiTouchGesture = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = {};
    this._movePointerInfo = null;
    this._cameraObserverCount = 0;
    this._delayedClicks = [null, null, null, null, null];
    this._deviceSourceManager = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
  }
  /**
   * Gets the mesh that is currently under the pointer
   * @returns Mesh that the pointer is pointer is hovering over
   */
  get meshUnderPointer() {
    if (this._movePointerInfo) {
      this._movePointerInfo._generatePickInfo();
      this._movePointerInfo = null;
    }
    return this._pointerOverMesh;
  }
  /**
   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer
   * @param pointerId - the pointer id to use
   * @returns The mesh under this pointer id or null if not found
   */
  getMeshUnderPointerByPointerId(pointerId) {
    return this._meshUnderPointerId[pointerId] || null;
  }
  /**
   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)
   * @returns Vector with X/Y values directly from pointer event
   */
  get unTranslatedPointer() {
    return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
  }
  /**
   * Gets or sets the current on-screen X position of the pointer
   * @returns Translated X with respect to screen
   */
  get pointerX() {
    return this._pointerX;
  }
  set pointerX(value) {
    this._pointerX = value;
  }
  /**
   * Gets or sets the current on-screen Y position of the pointer
   * @returns Translated Y with respect to screen
   */
  get pointerY() {
    return this._pointerY;
  }
  set pointerY(value) {
    this._pointerY = value;
  }
  _updatePointerPosition(evt) {
    const canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  }
  _processPointerMove(pickResult, evt) {
    const scene = this._scene;
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (canvas) {
      canvas.tabIndex = engine.canvasTabIndex;
      if (!scene.doNotHandleCursors) {
        canvas.style.cursor = scene.defaultCursor;
      }
    }
    this._setCursorAndPointerOverMesh(pickResult, evt, scene);
    for (const step of scene._pointerMoveStage) {
      pickResult = pickResult || this._pickMove(evt);
      const isMeshPicked = pickResult?.pickedMesh ? true : false;
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
    if (scene.onPointerMove) {
      pickResult = pickResult || this._pickMove(evt);
      scene.onPointerMove(evt, pickResult, type);
    }
    let pointerInfo;
    if (pickResult) {
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
      this._movePointerInfo = pointerInfo;
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  // Pointers handling
  /** @internal */
  _setRayOnPointerInfo(pickInfo, event) {
    const scene = this._scene;
    if (pickInfo && _ImportHelper._IsPickingAvailable) {
      if (!pickInfo.ray) {
        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  }
  /** @internal */
  _addCameraPointerObserver(observer, mask) {
    this._cameraObserverCount++;
    return this._scene.onPointerObservable.add(observer, mask);
  }
  /** @internal */
  _removeCameraPointerObserver(observer) {
    this._cameraObserverCount--;
    return this._scene.onPointerObservable.remove(observer);
  }
  _checkForPicking() {
    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);
  }
  _checkPrePointerObservable(pickResult, evt, type) {
    const scene = this._scene;
    const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.originalPickingInfo = pickResult;
      pi.ray = pickResult.ray;
      if (evt.pointerType === "xr-near" && pickResult.originMesh) {
        pi.nearInteractionPickingInfo = pickResult;
      }
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  }
  /** @internal */
  _pickMove(evt) {
    const scene = this._scene;
    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
    this._setCursorAndPointerOverMesh(pickResult, evt, scene);
    return pickResult;
  }
  _setCursorAndPointerOverMesh(pickResult, evt, scene) {
    const engine = scene.getEngine();
    const canvas = engine.getInputElement();
    if (pickResult?.pickedMesh) {
      this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);
      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {
        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();
        if (actionManager && actionManager.hasPointerTriggers) {
          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;
        }
      }
    } else {
      this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);
    }
  }
  /**
   * Use this method to simulate a pointer move on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   */
  simulatePointerMove(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointermove", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  }
  /**
   * Use this method to simulate a pointer down on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   */
  simulatePointerDown(pickResult, pointerEventInit) {
    const evt = new PointerEvent("pointerdown", pointerEventInit);
    evt.inputIndex = evt.button + 2;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  }
  _processPointerDown(pickResult, evt) {
    const scene = this._scene;
    if (pickResult?.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager) {
        if (actionManager.hasPickTriggers) {
          actionManager.processTrigger(5, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
          switch (evt.button) {
            case 0:
              actionManager.processTrigger(2, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
            case 1:
              actionManager.processTrigger(4, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
            case 2:
              actionManager.processTrigger(3, new ActionEvent(pickResult.pickedMesh, scene.pointerX, scene.pointerY, pickResult.pickedMesh, evt, pickResult));
              break;
          }
        }
        if (actionManager.hasSpecificTrigger(8)) {
          window.setTimeout(() => {
            const pickResult2 = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);
            if (pickResult2?.pickedMesh && actionManager) {
              if (this._activePointerIdsCount !== 0 && Date.now() - this._startingPointerTime > _InputManager.LongPressDelay && !this._isPointerSwiping()) {
                this._startingPointerTime = 0;
                actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, _InputManager.LongPressDelay);
        }
      }
    } else {
      for (const step of scene._pointerDownStage) {
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);
      }
    }
    let pointerInfo;
    const type = PointerEventTypes.POINTERDOWN;
    if (pickResult) {
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      pointerInfo = new PointerInfo(type, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
    } else {
      pointerInfo = new PointerInfo(type, evt, null, this);
    }
    if (scene.onPointerObservable.hasObservers()) {
      scene.onPointerObservable.notifyObservers(pointerInfo, type);
    }
  }
  /**
   * @internal
   * @internals Boolean if delta for pointer exceeds drag movement threshold
   */
  _isPointerSwiping() {
    return this._isSwiping;
  }
  /**
   * Use this method to simulate a pointer up on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult - pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)
   */
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    const evt = new PointerEvent("pointerup", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    const clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  }
  _processPointerUp(pickResult, evt, clickInfo) {
    const scene = this._scene;
    if (pickResult?.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {
          const type = PointerEventTypes.POINTERPICK;
          const pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (const step of scene._pointerUpStage) {
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    if (!clickInfo.ignore) {
      const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);
      this._setRayOnPointerInfo(pickResult, evt);
      scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);
      if (scene.onPointerUp) {
        scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);
      }
      if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
        let type = 0;
        if (clickInfo.singleClick) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          const pi2 = new PointerInfo(type, evt, pickResult);
          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
            scene.onPointerObservable.notifyObservers(pi2, type);
          }
        }
      }
    }
  }
  /**
   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)
   * @returns true if the pointer was captured
   */
  isPointerCaptured(pointerId = 0) {
    return this._pointerCaptures[pointerId];
  }
  /**
   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
   * @param attachUp - defines if you want to attach events to pointerup
   * @param attachDown - defines if you want to attach events to pointerdown
   * @param attachMove - defines if you want to attach events to pointermove
   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)
   */
  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {
    const scene = this._scene;
    const engine = scene.getEngine();
    if (!elementToAttachTo) {
      elementToAttachTo = engine.getInputElement();
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    if (elementToAttachTo) {
      this._alreadyAttachedTo = elementToAttachTo;
    }
    this._deviceSourceManager = new DeviceSourceManager(engine);
    this._initActionManager = (act) => {
      if (!this._meshPickProceed) {
        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers, scene.pointerUpTrianglePredicate);
        this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = (btn, clickInfo, cb) => {
      if (Date.now() - this._previousStartingPointerTime > _InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {
        this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        if (this._delayedClicks[btn]) {
          const evt = this._delayedClicks[btn].evt;
          const type = PointerEventTypes.POINTERTAP;
          const pi = new PointerInfo(type, evt, this._currentPickResult);
          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
            scene.onPointerObservable.notifyObservers(pi, type);
          }
          this._delayedClicks[btn] = null;
        }
      }
    };
    this._initClickEvent = (obs1, obs2, evt, cb) => {
      const clickInfo = new _ClickInfo();
      this._currentPickResult = null;
      let act = null;
      let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      let needToIgnoreNext = false;
      checkPicking = checkPicking && !this._isMultiTouchGesture;
      if (checkPicking) {
        const btn = evt.button;
        clickInfo.hasSwiped = this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          let checkSingleClickImmediately = !_InputManager.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - this._previousStartingPointerTime > _InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            const delayedClick = {
              evt,
              clickInfo,
              timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), _InputManager.DoubleClickDelay)
            };
            this._delayedClicks[btn] = delayedClick;
          }
          let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < _InputManager.DoubleClickDelay && !this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {
                this._previousStartingPointerTime = 0;
                this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (_InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {
                  clearTimeout(this._delayedClicks[btn]?.timeoutId);
                  this._delayedClicks[btn] = null;
                }
                cb(clickInfo, this._currentPickResult);
              } else {
                this._doubleClickOccured = false;
                this._previousStartingPointerTime = this._startingPointerTime;
                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
                this._previousButtonPressed = btn;
                if (_InputManager.ExclusiveDoubleClickMode) {
                  if (this._delayedClicks[btn]) {
                    clearTimeout(this._delayedClicks[btn]?.timeoutId);
                    this._delayedClicks[btn] = null;
                  }
                  cb(clickInfo, this._previousPickResult);
                } else {
                  cb(clickInfo, this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              this._doubleClickOccured = false;
              this._previousStartingPointerTime = this._startingPointerTime;
              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
              this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, this._currentPickResult);
      }
    };
    this._onPointerMove = (evt) => {
      this._updatePointerPosition(evt);
      if (!this._isSwiping && this._swipeButtonPressed !== -1) {
        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > _InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > _InputManager.DragMovementThreshold;
      }
      if (engine.isPointerLock) {
        engine._verifyPointerLock();
      }
      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (scene.skipPointerMovePicking) {
        this._processPointerMove(new PickingInfo(), evt);
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
      }
      const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;
      this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = (evt) => {
      const freeIndex = this._activePointerIds.indexOf(-1);
      if (freeIndex === -1) {
        this._activePointerIds.push(evt.pointerId);
      } else {
        this._activePointerIds[freeIndex] = evt.pointerId;
      }
      this._activePointerIdsCount++;
      this._pickedDownMesh = null;
      this._meshPickProceed = false;
      if (_InputManager.ExclusiveDoubleClickMode) {
        for (let i = 0; i < this._delayedClicks.length; i++) {
          if (this._delayedClicks[i]) {
            if (evt.button === i) {
              clearTimeout(this._delayedClicks[i]?.timeoutId);
            } else {
              const clickInfo = this._delayedClicks[i].clickInfo;
              this._doubleClickOccured = false;
              clickInfo.singleClick = true;
              clickInfo.ignore = false;
              const prevEvt = this._delayedClicks[i].evt;
              const type = PointerEventTypes.POINTERTAP;
              const pi = new PointerInfo(type, prevEvt, this._currentPickResult);
              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
                scene.onPointerObservable.notifyObservers(pi, type);
              }
              this._delayedClicks[i] = null;
            }
          }
        }
      }
      this._updatePointerPosition(evt);
      if (this._swipeButtonPressed === -1) {
        this._swipeButtonPressed = evt.button;
      }
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._startingPointerPosition.x = this._pointerX;
      this._startingPointerPosition.y = this._pointerY;
      this._startingPointerTime = Date.now();
      if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = (mesh) => {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      this._pickedDownMesh = null;
      let pickResult;
      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {
        pickResult = new PickingInfo();
      } else {
        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers, scene.pointerDownTrianglePredicate);
      }
      this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = (evt) => {
      const pointerIdIndex = this._activePointerIds.indexOf(evt.pointerId);
      if (pointerIdIndex === -1) {
        return;
      }
      this._activePointerIds[pointerIdIndex] = -1;
      this._activePointerIdsCount--;
      this._pickedUpMesh = null;
      this._meshPickProceed = false;
      this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {
        if (scene.onPrePointerObservable.hasObservers()) {
          this._skipPointerTap = false;
          if (!clickInfo.ignore) {
            if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              if (this._swipeButtonPressed === evt.button) {
                this._isSwiping = false;
                this._swipeButtonPressed = -1;
              }
              if (evt.buttons === 0) {
                this._pointerCaptures[evt.pointerId] = false;
              }
              return;
            }
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  this._skipPointerTap = true;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  this._skipPointerTap = true;
                }
              }
            }
          }
        }
        if (!this._pointerCaptures[evt.pointerId]) {
          if (this._swipeButtonPressed === evt.button) {
            this._isSwiping = false;
            this._swipeButtonPressed = -1;
          }
          return;
        }
        if (evt.buttons === 0) {
          this._pointerCaptures[evt.pointerId] = false;
        }
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = (mesh) => {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {
          this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = this._currentPickResult;
        }
        this._processPointerUp(pickResult, evt, clickInfo);
        this._previousPickResult = this._currentPickResult;
        if (this._swipeButtonPressed === evt.button) {
          this._isSwiping = false;
          this._swipeButtonPressed = -1;
        }
      });
    };
    this._onKeyDown = (evt) => {
      const type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = (evt) => {
      const type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        const pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {
      if (deviceSource.deviceType === DeviceType.Mouse) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          this._originMouseEvent = eventData;
          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
            }
          } else if (attachMove) {
            if (eventData.inputIndex === PointerInput.Move) {
              this._onPointerMove(eventData);
            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
              this._onPointerMove(eventData);
            }
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Touch) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.inputIndex === PointerInput.LeftClick) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              this._onPointerDown(eventData);
              if (this._activePointerIdsCount > 1) {
                this._isMultiTouchGesture = true;
              }
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              this._onPointerUp(eventData);
              if (this._activePointerIdsCount === 0) {
                this._isMultiTouchGesture = false;
              }
            }
          }
          if (attachMove && eventData.inputIndex === PointerInput.Move) {
            this._onPointerMove(eventData);
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Keyboard) {
        deviceSource.onInputChangedObservable.add((eventData) => {
          if (eventData.type === "keydown") {
            this._onKeyDown(eventData);
          } else if (eventData.type === "keyup") {
            this._onKeyUp(eventData);
          }
        });
      }
    });
    this._alreadyAttached = true;
  }
  /**
   * Detaches all event handlers
   */
  detachControl() {
    if (this._alreadyAttached) {
      this._deviceSourceManager.dispose();
      this._deviceSourceManager = null;
      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
      }
      this._alreadyAttached = false;
      this._alreadyAttachedTo = null;
    }
  }
  /**
   * Set the value of meshUnderPointer for a given pointerId
   * @param mesh - defines the mesh to use
   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0
   * @param pickResult - optional pickingInfo data used to find mesh
   * @param evt - optional pointer event
   */
  setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {
    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {
      return;
    }
    const underPointerMesh = this._meshUnderPointerId[pointerId];
    let actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, new ActionEvent(underPointerMesh, this._pointerX, this._pointerY, mesh, evt, { pointerId }));
      }
    }
    if (mesh) {
      this._meshUnderPointerId[pointerId] = mesh;
      this._pointerOverMesh = mesh;
      actionManager = mesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, new ActionEvent(mesh, this._pointerX, this._pointerY, mesh, evt, { pointerId, pickResult }));
      }
    } else {
      delete this._meshUnderPointerId[pointerId];
      this._pointerOverMesh = null;
    }
    if (this._scene.onMeshUnderPointerUpdatedObservable.hasObservers()) {
      this._scene.onMeshUnderPointerUpdatedObservable.notifyObservers({
        mesh,
        pointerId
      });
    }
  }
  /**
   * Gets the mesh under the pointer
   * @returns a Mesh or null if no mesh is under the pointer
   */
  getPointerOverMesh() {
    return this.meshUnderPointer;
  }
  /**
   * @param mesh - Mesh to invalidate
   * @internal
   */
  _invalidateMesh(mesh) {
    if (this._pointerOverMesh === mesh) {
      this._pointerOverMesh = null;
    }
    if (this._pickedDownMesh === mesh) {
      this._pickedDownMesh = null;
    }
    if (this._pickedUpMesh === mesh) {
      this._pickedUpMesh = null;
    }
    for (const pointerId in this._meshUnderPointerId) {
      if (this._meshUnderPointerId[pointerId] === mesh) {
        delete this._meshUnderPointerId[pointerId];
      }
    }
  }
};
InputManager.DragMovementThreshold = 10;
InputManager.LongPressDelay = 500;
InputManager.DoubleClickDelay = 300;
InputManager.ExclusiveDoubleClickMode = false;

// node_modules/@babylonjs/core/Inputs/pointerPickingConfiguration.js
var PointerPickingConfiguration = class {
  constructor() {
    this.pointerDownFastCheck = false;
    this.pointerUpFastCheck = false;
    this.pointerMoveFastCheck = false;
    this.skipPointerMovePicking = false;
    this.skipPointerDownPicking = false;
    this.skipPointerUpPicking = false;
  }
};

// node_modules/@babylonjs/core/scene.js
var ScenePerformancePriority;
(function(ScenePerformancePriority2) {
  ScenePerformancePriority2[ScenePerformancePriority2["BackwardCompatible"] = 0] = "BackwardCompatible";
  ScenePerformancePriority2[ScenePerformancePriority2["Intermediate"] = 1] = "Intermediate";
  ScenePerformancePriority2[ScenePerformancePriority2["Aggressive"] = 2] = "Aggressive";
})(ScenePerformancePriority || (ScenePerformancePriority = {}));
var Scene = class _Scene {
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Factory used to create the default material.
   * @param scene The scene to create the material for
   * @returns The default material
   */
  static DefaultMaterialFactory(scene) {
    throw _WarnImport("StandardMaterial");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Factory used to create the a collision coordinator.
   * @returns The collision coordinator
   */
  static CollisionCoordinatorFactory() {
    throw _WarnImport("DefaultCollisionCoordinator");
  }
  /**
   * Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
   */
  get clearColor() {
    return this._clearColor;
  }
  set clearColor(value) {
    if (value !== this._clearColor) {
      this._clearColor = value;
      this.onClearColorChangedObservable.notifyObservers(this._clearColor);
    }
  }
  /**
   * Default image processing configuration used either in the rendering
   * Forward main pass or through the imageProcessingPostProcess if present.
   * As in the majority of the scene they are the same (exception for multi camera),
   * this is easier to reference from here than from all the materials and post process.
   *
   * No setter as we it is a shared configuration, you can set the values instead.
   */
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  /**
   * Gets or sets a value indicating how to treat performance relatively to ease of use and backward compatibility
   */
  get performancePriority() {
    return this._performancePriority;
  }
  set performancePriority(value) {
    if (value === this._performancePriority) {
      return;
    }
    this._performancePriority = value;
    switch (value) {
      case 0:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = false;
        this.autoClear = true;
        break;
      case 1:
        this.skipFrustumClipping = false;
        this._renderingManager.maintainStateBetweenFrames = false;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
      case 2:
        this.skipFrustumClipping = true;
        this._renderingManager.maintainStateBetweenFrames = true;
        this.skipPointerMovePicking = true;
        this.autoClear = false;
        break;
    }
    this.onScenePerformancePriorityChangedObservable.notifyObservers(value);
  }
  /**
   * Gets or sets a boolean indicating if all rendering must be done in wireframe
   */
  set forceWireframe(value) {
    if (this._forceWireframe === value) {
      return;
    }
    this._forceWireframe = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forceWireframe() {
    return this._forceWireframe;
  }
  /**
   * Gets or sets a boolean indicating if we should skip the frustum clipping part of the active meshes selection
   */
  set skipFrustumClipping(value) {
    if (this._skipFrustumClipping === value) {
      return;
    }
    this._skipFrustumClipping = value;
  }
  get skipFrustumClipping() {
    return this._skipFrustumClipping;
  }
  /**
   * Gets or sets a boolean indicating if all rendering must be done in point cloud
   */
  set forcePointsCloud(value) {
    if (this._forcePointsCloud === value) {
      return;
    }
    this._forcePointsCloud = value;
    this.markAllMaterialsAsDirty(16);
  }
  get forcePointsCloud() {
    return this._forcePointsCloud;
  }
  /**
   * Texture used in all pbr material as the reflection texture.
   * As in the majority of the scene they are the same (exception for multi room and so on),
   * this is easier to reference from here than from all the materials.
   */
  get environmentTexture() {
    return this._environmentTexture;
  }
  /**
   * Texture used in all pbr material as the reflection texture.
   * As in the majority of the scene they are the same (exception for multi room and so on),
   * this is easier to set here than in all the materials.
   */
  set environmentTexture(value) {
    if (this._environmentTexture === value) {
      return;
    }
    this._environmentTexture = value;
    this.onEnvironmentTextureChangedObservable.notifyObservers(value);
    this.markAllMaterialsAsDirty(1);
  }
  /**
   * @returns all meshes, lights, cameras, transformNodes and bones
   */
  getNodes() {
    let nodes = [];
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    for (const skeleton of this.skeletons) {
      nodes = nodes.concat(skeleton.bones);
    }
    return nodes;
  }
  /**
   * Gets or sets the animation properties override
   */
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(value) {
    this._animationPropertiesOverride = value;
  }
  /** Sets a function to be executed when this scene is disposed. */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /** Sets a function to be executed before rendering this scene */
  set beforeRender(callback) {
    if (this._onBeforeRenderObserver) {
      this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
    }
    if (callback) {
      this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
    }
  }
  /** Sets a function to be executed after rendering this scene */
  set afterRender(callback) {
    if (this._onAfterRenderObserver) {
      this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
    }
    if (callback) {
      this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
    }
  }
  /** Sets a function to be executed before rendering a camera*/
  set beforeCameraRender(callback) {
    if (this._onBeforeCameraRenderObserver) {
      this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
    }
    this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
  }
  /** Sets a function to be executed after rendering a camera*/
  set afterCameraRender(callback) {
    if (this._onAfterCameraRenderObserver) {
      this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
    }
    this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer down event
   */
  get pointerDownPredicate() {
    return this._pointerPickingConfiguration.pointerDownPredicate;
  }
  set pointerDownPredicate(value) {
    this._pointerPickingConfiguration.pointerDownPredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer up event
   */
  get pointerUpPredicate() {
    return this._pointerPickingConfiguration.pointerUpPredicate;
  }
  set pointerUpPredicate(value) {
    this._pointerPickingConfiguration.pointerUpPredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer move event
   */
  get pointerMovePredicate() {
    return this._pointerPickingConfiguration.pointerMovePredicate;
  }
  set pointerMovePredicate(value) {
    this._pointerPickingConfiguration.pointerMovePredicate = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer down event
   */
  get pointerDownFastCheck() {
    return this._pointerPickingConfiguration.pointerDownFastCheck;
  }
  set pointerDownFastCheck(value) {
    this._pointerPickingConfiguration.pointerDownFastCheck = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer up event
   */
  get pointerUpFastCheck() {
    return this._pointerPickingConfiguration.pointerUpFastCheck;
  }
  set pointerUpFastCheck(value) {
    this._pointerPickingConfiguration.pointerUpFastCheck = value;
  }
  /**
   * Gets or sets a predicate used to select candidate meshes for a pointer move event
   */
  get pointerMoveFastCheck() {
    return this._pointerPickingConfiguration.pointerMoveFastCheck;
  }
  set pointerMoveFastCheck(value) {
    this._pointerPickingConfiguration.pointerMoveFastCheck = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer move event occurs.
   */
  get skipPointerMovePicking() {
    return this._pointerPickingConfiguration.skipPointerMovePicking;
  }
  set skipPointerMovePicking(value) {
    this._pointerPickingConfiguration.skipPointerMovePicking = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer down event occurs.
   */
  get skipPointerDownPicking() {
    return this._pointerPickingConfiguration.skipPointerDownPicking;
  }
  set skipPointerDownPicking(value) {
    this._pointerPickingConfiguration.skipPointerDownPicking = value;
  }
  /**
   * Gets or sets a boolean indicating if the user want to entirely skip the picking phase when a pointer up event occurs.  Off by default.
   */
  get skipPointerUpPicking() {
    return this._pointerPickingConfiguration.skipPointerUpPicking;
  }
  set skipPointerUpPicking(value) {
    this._pointerPickingConfiguration.skipPointerUpPicking = value;
  }
  /**
   * Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
   */
  get unTranslatedPointer() {
    return this._inputManager.unTranslatedPointer;
  }
  /**
   * Gets or sets the distance in pixel that you have to move to prevent some events. Default is 10 pixels
   */
  static get DragMovementThreshold() {
    return InputManager.DragMovementThreshold;
  }
  static set DragMovementThreshold(value) {
    InputManager.DragMovementThreshold = value;
  }
  /**
   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 500 ms
   */
  static get LongPressDelay() {
    return InputManager.LongPressDelay;
  }
  static set LongPressDelay(value) {
    InputManager.LongPressDelay = value;
  }
  /**
   * Time in milliseconds to wait to raise long press events if button is still pressed. Default is 300 ms
   */
  static get DoubleClickDelay() {
    return InputManager.DoubleClickDelay;
  }
  static set DoubleClickDelay(value) {
    InputManager.DoubleClickDelay = value;
  }
  /** If you need to check double click without raising a single click at first click, enable this flag */
  static get ExclusiveDoubleClickMode() {
    return InputManager.ExclusiveDoubleClickMode;
  }
  static set ExclusiveDoubleClickMode(value) {
    InputManager.ExclusiveDoubleClickMode = value;
  }
  /**
   * Bind the current view position to an effect.
   * @param effect The effect to be bound
   * @param variableName name of the shader variable that will hold the eye position
   * @param isVector3 true to indicates that variableName is a Vector3 and not a Vector4
   * @returns the computed eye position
   */
  bindEyePosition(effect, variableName = "vEyePosition", isVector3 = false) {
    const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera?.globalPosition ?? Vector3.ZeroReadOnly;
    const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    const offset = this.floatingOriginOffset;
    const eyePos = this._tempVect4.set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
    const offsetEyePos = eyePos.subtractFromFloatsToRef(offset.x, offset.y, offset.z, 0, TmpVectors.Vector4[1]);
    if (effect) {
      if (isVector3) {
        effect.setFloat3(variableName, offsetEyePos.x, offsetEyePos.y, offsetEyePos.z);
      } else {
        effect.setVector4(variableName, offsetEyePos);
      }
    }
    return eyePos;
  }
  /**
   * Update the scene ubo before it can be used in rendering processing
   * @returns the scene UniformBuffer
   */
  finalizeSceneUbo() {
    const ubo = this.getSceneUniformBuffer();
    const eyePosition = this.bindEyePosition(null);
    const offset = this.floatingOriginOffset;
    ubo.updateFloat4("vEyePosition", eyePosition.x - offset.x, eyePosition.y - offset.y, eyePosition.z - offset.z, eyePosition.w);
    ubo.update();
    return ubo;
  }
  /**
   * Gets or sets a boolean indicating if the scene must use right-handed coordinates system
   */
  set useRightHandedSystem(value) {
    if (this._useRightHandedSystem === value) {
      return;
    }
    this._useRightHandedSystem = value;
    this.markAllMaterialsAsDirty(16);
  }
  get useRightHandedSystem() {
    return this._useRightHandedSystem;
  }
  /**
   * Sets the step Id used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @param newStepId defines the step Id
   */
  setStepId(newStepId) {
    this._currentStepId = newStepId;
  }
  /**
   * Gets the step Id used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns the step Id
   */
  getStepId() {
    return this._currentStepId;
  }
  /**
   * Gets the internal step used by deterministic lock step
   * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#deterministic-lockstep
   * @returns the internal step
   */
  getInternalStep() {
    return this._currentInternalStep;
  }
  /**
   * Gets or sets a boolean indicating if fog is enabled on this scene
   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog
   * (Default is true)
   */
  set fogEnabled(value) {
    if (this._fogEnabled === value) {
      return;
    }
    this._fogEnabled = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  /**
   * Gets or sets the fog mode to use
   * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/environment_introduction#fog
   * | mode | value |
   * | --- | --- |
   * | FOGMODE_NONE | 0 |
   * | FOGMODE_EXP | 1 |
   * | FOGMODE_EXP2 | 2 |
   * | FOGMODE_LINEAR | 3 |
   */
  set fogMode(value) {
    if (this._fogMode === value) {
      return;
    }
    this._fogMode = value;
    this.markAllMaterialsAsDirty(16);
  }
  get fogMode() {
    return this._fogMode;
  }
  /**
   * Flag indicating that the frame buffer binding is handled by another component
   */
  get prePass() {
    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
  }
  /**
   * Gets or sets a boolean indicating if shadows are enabled on this scene
   */
  set shadowsEnabled(value) {
    if (this._shadowsEnabled === value) {
      return;
    }
    this._shadowsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Gets or sets a boolean indicating if lights are enabled on this scene
   */
  set lightsEnabled(value) {
    if (this._lightsEnabled === value) {
      return;
    }
    this._lightsEnabled = value;
    this.markAllMaterialsAsDirty(2);
  }
  get lightsEnabled() {
    return this._lightsEnabled;
  }
  /** All of the active cameras added to this scene. */
  get activeCameras() {
    return this._activeCameras;
  }
  set activeCameras(cameras) {
    if (this._unObserveActiveCameras) {
      this._unObserveActiveCameras();
      this._unObserveActiveCameras = null;
    }
    if (cameras) {
      this._unObserveActiveCameras = _ObserveArray(cameras, () => {
        this.onActiveCamerasChanged.notifyObservers(this);
      });
    }
    this._activeCameras = cameras;
  }
  /** Gets or sets the current active camera */
  get activeCamera() {
    return this._activeCamera;
  }
  set activeCamera(value) {
    if (value === this._activeCamera) {
      return;
    }
    this._activeCamera = value;
    this.onActiveCameraChanged.notifyObservers(this);
  }
  /** @internal */
  get _hasDefaultMaterial() {
    return _Scene.DefaultMaterialFactory !== _Scene._OriginalDefaultMaterialFactory;
  }
  /** The default material used on meshes when no material is affected */
  get defaultMaterial() {
    if (!this._defaultMaterial) {
      this._defaultMaterial = _Scene.DefaultMaterialFactory(this);
    }
    return this._defaultMaterial;
  }
  /** The default material used on meshes when no material is affected */
  set defaultMaterial(value) {
    this._defaultMaterial = value;
  }
  /**
   * Gets or sets a boolean indicating if textures are enabled on this scene
   */
  set texturesEnabled(value) {
    if (this._texturesEnabled === value) {
      return;
    }
    this._texturesEnabled = value;
    this.markAllMaterialsAsDirty(1);
  }
  get texturesEnabled() {
    return this._texturesEnabled;
  }
  /**
   * Gets or sets the frame graph used to render the scene. If set, the scene will use the frame graph to render the scene instead of the default render loop.
   */
  get frameGraph() {
    return this._frameGraph;
  }
  set frameGraph(value) {
    if (this._frameGraph) {
      this._frameGraph = value;
      if (!value) {
        this.customRenderFunction = this._currentCustomRenderFunction;
      }
      return;
    }
    this._frameGraph = value;
    if (value) {
      this._currentCustomRenderFunction = this.customRenderFunction;
      this.customRenderFunction = this._renderWithFrameGraph;
      this.activeCamera = null;
    }
  }
  /**
   * Gets or sets a boolean indicating if skeletons are enabled on this scene
   */
  set skeletonsEnabled(value) {
    if (this._skeletonsEnabled === value) {
      return;
    }
    this._skeletonsEnabled = value;
    this.markAllMaterialsAsDirty(8);
  }
  get skeletonsEnabled() {
    return this._skeletonsEnabled;
  }
  /** @internal */
  get collisionCoordinator() {
    if (!this._collisionCoordinator) {
      this._collisionCoordinator = _Scene.CollisionCoordinatorFactory();
      this._collisionCoordinator.init(this);
    }
    return this._collisionCoordinator;
  }
  /**
   * Gets the scene's rendering manager
   */
  get renderingManager() {
    return this._renderingManager;
  }
  /**
   * Gets the list of frustum planes (built from the active camera)
   */
  get frustumPlanes() {
    return this._frustumPlanes;
  }
  /**
   * Registers the transient components if needed.
   */
  _registerTransientComponents() {
    if (this._transientComponents.length > 0) {
      for (const component of this._transientComponents) {
        component.register();
      }
      this._transientComponents.length = 0;
    }
  }
  /**
   * @internal
   * Add a component to the scene.
   * Note that the ccomponent could be registered on th next frame if this is called after
   * the register component stage.
   * @param component Defines the component to add to the scene
   */
  _addComponent(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    const serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  }
  /**
   * @internal
   * Gets a component from the scene.
   * @param name defines the name of the component to retrieve
   * @returns the component or null if not present
   */
  _getComponent(name) {
    for (const component of this._components) {
      if (component.name === name) {
        return component;
      }
    }
    return null;
  }
  /**
   * Gets the unique id of the scene
   */
  get uniqueId() {
    return this._uniqueId;
  }
  /**
   * Creates a new Scene
   * @param engine defines the engine to use to render this scene
   * @param options defines the scene options
   */
  constructor(engine, options) {
    this._inputManager = new InputManager(this);
    this.cameraToUseForPointers = null;
    this._isScene = true;
    this._blockEntityCollection = false;
    this.autoClear = true;
    this.autoClearDepthAndStencil = true;
    this._clearColor = new Color4(0.2, 0.2, 0.3, 1);
    this._tempVect4 = new Vector4();
    this.onClearColorChangedObservable = new Observable();
    this.ambientColor = new Color3(0, 0, 0);
    this.environmentIntensity = 1;
    this.iblIntensity = 1;
    this._performancePriority = 0;
    this.onScenePerformancePriorityChangedObservable = new Observable();
    this._forceWireframe = false;
    this._skipFrustumClipping = false;
    this._forcePointsCloud = false;
    this.rootNodes = [];
    this.cameras = [];
    this.lights = [];
    this.meshes = [];
    this.skeletons = [];
    this.particleSystems = [];
    this.animations = [];
    this.animationGroups = [];
    this.multiMaterials = [];
    this.materials = [];
    this.morphTargetManagers = [];
    this.geometries = [];
    this.transformNodes = [];
    this.actionManagers = [];
    this.objectRenderers = [];
    this.textures = [];
    this._environmentTexture = null;
    this.postProcesses = [];
    this.effectLayers = [];
    this.sounds = null;
    this.layers = [];
    this.lensFlareSystems = [];
    this.proceduralTextures = [];
    this.animationsEnabled = true;
    this._animationPropertiesOverride = null;
    this.useConstantAnimationDeltaTime = false;
    this.constantlyUpdateMeshUnderPointer = false;
    this.hoverCursor = "pointer";
    this.defaultCursor = "";
    this.doNotHandleCursors = false;
    this.preventDefaultOnPointerDown = true;
    this.preventDefaultOnPointerUp = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.disableOfflineSupportExceptionRules = [];
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this.onBeforeRenderObservable = new Observable();
    this._onBeforeRenderObserver = null;
    this.onAfterRenderObservable = new Observable();
    this.onAfterRenderCameraObservable = new Observable();
    this._onAfterRenderObserver = null;
    this.onBeforeAnimationsObservable = new Observable();
    this.onAfterAnimationsObservable = new Observable();
    this.onBeforeDrawPhaseObservable = new Observable();
    this.onAfterDrawPhaseObservable = new Observable();
    this.onReadyObservable = new Observable();
    this.onBeforeCameraRenderObservable = new Observable();
    this._onBeforeCameraRenderObserver = null;
    this.onAfterCameraRenderObservable = new Observable();
    this._onAfterCameraRenderObserver = null;
    this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    this.onAfterActiveMeshesEvaluationObservable = new Observable();
    this.onBeforeParticlesRenderingObservable = new Observable();
    this.onAfterParticlesRenderingObservable = new Observable();
    this.onDataLoadedObservable = new Observable();
    this.onNewCameraAddedObservable = new Observable();
    this.onCameraRemovedObservable = new Observable();
    this.onNewLightAddedObservable = new Observable();
    this.onLightRemovedObservable = new Observable();
    this.onNewGeometryAddedObservable = new Observable();
    this.onGeometryRemovedObservable = new Observable();
    this.onNewTransformNodeAddedObservable = new Observable();
    this.onTransformNodeRemovedObservable = new Observable();
    this.onNewMeshAddedObservable = new Observable();
    this.onMeshRemovedObservable = new Observable();
    this.onNewSkeletonAddedObservable = new Observable();
    this.onSkeletonRemovedObservable = new Observable();
    this.onNewParticleSystemAddedObservable = new Observable();
    this.onParticleSystemRemovedObservable = new Observable();
    this.onNewAnimationGroupAddedObservable = new Observable();
    this.onAnimationGroupRemovedObservable = new Observable();
    this.onNewMaterialAddedObservable = new Observable();
    this.onNewMultiMaterialAddedObservable = new Observable();
    this.onMaterialRemovedObservable = new Observable();
    this.onMultiMaterialRemovedObservable = new Observable();
    this.onNewTextureAddedObservable = new Observable();
    this.onTextureRemovedObservable = new Observable();
    this.onNewFrameGraphAddedObservable = new Observable();
    this.onFrameGraphRemovedObservable = new Observable();
    this.onNewObjectRendererAddedObservable = new Observable();
    this.onObjectRendererRemovedObservable = new Observable();
    this.onNewPostProcessAddedObservable = new Observable();
    this.onPostProcessRemovedObservable = new Observable();
    this.onNewEffectLayerAddedObservable = new Observable();
    this.onEffectLayerRemovedObservable = new Observable();
    this.onBeforeRenderTargetsRenderObservable = new Observable();
    this.onAfterRenderTargetsRenderObservable = new Observable();
    this.onBeforeStepObservable = new Observable();
    this.onAfterStepObservable = new Observable();
    this.onActiveCameraChanged = new Observable();
    this.onActiveCamerasChanged = new Observable();
    this.onBeforeRenderingGroupObservable = new Observable();
    this.onAfterRenderingGroupObservable = new Observable();
    this.onMeshImportedObservable = new Observable();
    this.onAnimationFileImportedObservable = new Observable();
    this.onEnvironmentTextureChangedObservable = new Observable();
    this.onMeshUnderPointerUpdatedObservable = new Observable();
    this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    this._pointerPickingConfiguration = new PointerPickingConfiguration();
    this.onPrePointerObservable = new Observable();
    this.onPointerObservable = new Observable();
    this.onPreKeyboardObservable = new Observable();
    this.onKeyboardObservable = new Observable();
    this._useRightHandedSystem = false;
    this._timeAccumulator = 0;
    this._currentStepId = 0;
    this._currentInternalStep = 0;
    this._fogEnabled = true;
    this._fogMode = _Scene.FOGMODE_NONE;
    this.fogColor = new Color3(0.2, 0.2, 0.3);
    this.fogDensity = 0.1;
    this.fogStart = 0;
    this.fogEnd = 1e3;
    this.needsPreviousWorldMatrices = false;
    this._shadowsEnabled = true;
    this._lightsEnabled = true;
    this._unObserveActiveCameras = null;
    this._texturesEnabled = true;
    this._frameGraph = null;
    this.frameGraphs = [];
    this.physicsEnabled = true;
    this.particlesEnabled = true;
    this.spritesEnabled = true;
    this._skeletonsEnabled = true;
    this.lensFlaresEnabled = true;
    this.collisionsEnabled = true;
    this.gravity = new Vector3(0, -9.807, 0);
    this.postProcessesEnabled = true;
    this.renderTargetsEnabled = true;
    this.dumpNextRenderTargets = false;
    this.customRenderTargets = [];
    this.importedMeshesFiles = [];
    this.probesEnabled = true;
    this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    this.proceduralTexturesEnabled = true;
    this._totalVertices = new PerfCounter();
    this._activeIndices = new PerfCounter();
    this._activeParticles = new PerfCounter();
    this._activeBones = new PerfCounter();
    this._animationTime = 0;
    this.animationTimeScale = 1;
    this._renderId = 0;
    this._frameId = 0;
    this._executeWhenReadyTimeoutId = null;
    this._intermediateRendering = false;
    this._defaultFrameBufferCleared = false;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
    this._toBeDisposed = new Array(256);
    this._activeRequests = new Array();
    this._pendingData = [];
    this._isDisposed = false;
    this.dispatchAllSubMeshesOfActiveMeshes = false;
    this._activeMeshes = new SmartArray(256);
    this._processedMaterials = new SmartArray(256);
    this._renderTargets = new SmartArrayNoDuplicate(256);
    this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
    this._activeParticleSystems = new SmartArray(256);
    this._activeSkeletons = new SmartArrayNoDuplicate(32);
    this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    this._activeAnimatables = new Array();
    this._transformMatrix = Matrix.Zero();
    this.requireLightSorting = false;
    this._components = [];
    this._serializableComponents = [];
    this._transientComponents = [];
    this._beforeCameraUpdateStage = Stage.Create();
    this._beforeClearStage = Stage.Create();
    this._beforeRenderTargetClearStage = Stage.Create();
    this._gatherRenderTargetsStage = Stage.Create();
    this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    this._isReadyForMeshStage = Stage.Create();
    this._beforeEvaluateActiveMeshStage = Stage.Create();
    this._evaluateSubMeshStage = Stage.Create();
    this._preActiveMeshStage = Stage.Create();
    this._cameraDrawRenderTargetStage = Stage.Create();
    this._beforeCameraDrawStage = Stage.Create();
    this._beforeRenderTargetDrawStage = Stage.Create();
    this._beforeRenderingGroupDrawStage = Stage.Create();
    this._beforeRenderingMeshStage = Stage.Create();
    this._afterRenderingMeshStage = Stage.Create();
    this._afterRenderingGroupDrawStage = Stage.Create();
    this._afterCameraDrawStage = Stage.Create();
    this._afterCameraPostProcessStage = Stage.Create();
    this._afterRenderTargetDrawStage = Stage.Create();
    this._afterRenderTargetPostProcessStage = Stage.Create();
    this._afterRenderStage = Stage.Create();
    this._pointerMoveStage = Stage.Create();
    this._pointerDownStage = Stage.Create();
    this._pointerUpStage = Stage.Create();
    this._geometriesByUniqueId = null;
    this._uniqueId = 0;
    this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    this._floatingOriginScene = void 0;
    this._floatingOriginOffsetDefault = Vector3.Zero();
    this._preventFreeActiveMeshesAndRenderingGroups = false;
    this._activeMeshesFrozen = false;
    this._activeMeshesFrozenButKeepClipping = false;
    this._skipEvaluateActiveMeshesCompletely = false;
    this._freezeActiveMeshesCancel = null;
    this._useCurrentFrameBuffer = false;
    this._allowPostProcessClearColor = true;
    this.getDeterministicFrameTime = () => {
      return this._engine.getTimeStep();
    };
    this._getFloatingOriginScene = () => {
      return this._floatingOriginScene;
    };
    this._registeredActions = 0;
    this._blockMaterialDirtyMechanism = false;
    this._perfCollector = null;
    this.activeCameras = [];
    this._uniqueId = this.getUniqueId();
    const fullOptions = {
      useGeometryUniqueIdsMap: true,
      useMaterialMeshMap: true,
      useClonedMeshMap: true,
      virtual: false,
      ...options
    };
    engine = this._engine = engine || EngineStore.LastCreatedEngine;
    if (fullOptions.virtual) {
      engine._virtualScenes.push(this);
    } else {
      EngineStore._LastCreatedScene = this;
      engine.scenes.push(this);
    }
    if (engine.getCreationOptions().useLargeWorldRendering || options?.useFloatingOrigin) {
      OverrideMatrixFunctions();
      this._floatingOriginScene = this;
    }
    this._uid = null;
    this._renderingManager = new RenderingManager(this);
    if (PostProcessManager) {
      this.postProcessManager = new PostProcessManager(this);
    }
    if (IsWindowObjectExist()) {
      this.attachControl();
    }
    this._createUbo();
    if (ImageProcessingConfiguration) {
      this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      this._geometriesByUniqueId = {};
    }
    this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      engine.onNewSceneAddedObservable.notifyObservers(this);
    }
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "Scene" string
   */
  getClassName() {
    return "Scene";
  }
  /**
   * @internal
   */
  _getDefaultMeshCandidates() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  }
  /**
   * @internal
   */
  _getDefaultSubMeshCandidates(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  }
  /**
   * Sets the default candidate providers for the scene.
   * This sets the getActiveMeshCandidates, getActiveSubMeshCandidates, getIntersectingSubMeshCandidates
   * and getCollidingSubMeshCandidates to their default function
   */
  setDefaultCandidateProviders() {
    this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates();
    this.getActiveSubMeshCandidates = (mesh) => this._getDefaultSubMeshCandidates(mesh);
    this.getIntersectingSubMeshCandidates = (mesh, localRay) => this._getDefaultSubMeshCandidates(mesh);
    this.getCollidingSubMeshCandidates = (mesh, collider) => this._getDefaultSubMeshCandidates(mesh);
  }
  /**
   * Gets the mesh that is currently under the pointer
   */
  get meshUnderPointer() {
    return this._inputManager.meshUnderPointer;
  }
  /**
   * Gets or sets the current on-screen X position of the pointer
   */
  get pointerX() {
    return this._inputManager.pointerX;
  }
  set pointerX(value) {
    this._inputManager.pointerX = value;
  }
  /**
   * Gets or sets the current on-screen Y position of the pointer
   */
  get pointerY() {
    return this._inputManager.pointerY;
  }
  set pointerY(value) {
    this._inputManager.pointerY = value;
  }
  /**
   * Gets the cached material (ie. the latest rendered one)
   * @returns the cached material
   */
  getCachedMaterial() {
    return this._cachedMaterial;
  }
  /**
   * Gets the cached effect (ie. the latest rendered one)
   * @returns the cached effect
   */
  getCachedEffect() {
    return this._cachedEffect;
  }
  /**
   * Gets the cached visibility state (ie. the latest rendered one)
   * @returns the cached visibility state
   */
  getCachedVisibility() {
    return this._cachedVisibility;
  }
  /**
   * Gets a boolean indicating if the current material / effect / visibility must be bind again
   * @param material defines the current material
   * @param effect defines the current effect
   * @param visibility defines the current visibility state
   * @returns true if one parameter is not cached
   */
  isCachedMaterialInvalid(material, effect, visibility = 1) {
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  }
  /**
   * Gets the engine associated with the scene
   * @returns an Engine
   */
  getEngine() {
    return this._engine;
  }
  /**
   * Gets the total number of vertices rendered per frame
   * @returns the total number of vertices rendered per frame
   */
  getTotalVertices() {
    return this._totalVertices.current;
  }
  /**
   * Gets the performance counter for total vertices
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get totalVerticesPerfCounter() {
    return this._totalVertices;
  }
  /**
   * Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
   * @returns the total number of active indices rendered per frame
   */
  getActiveIndices() {
    return this._activeIndices.current;
  }
  /**
   * Gets the performance counter for active indices
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get totalActiveIndicesPerfCounter() {
    return this._activeIndices;
  }
  /**
   * Gets the total number of active particles rendered per frame
   * @returns the total number of active particles rendered per frame
   */
  getActiveParticles() {
    return this._activeParticles.current;
  }
  /**
   * Gets the performance counter for active particles
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get activeParticlesPerfCounter() {
    return this._activeParticles;
  }
  /**
   * Gets the total number of active bones rendered per frame
   * @returns the total number of active bones rendered per frame
   */
  getActiveBones() {
    return this._activeBones.current;
  }
  /**
   * Gets the performance counter for active bones
   * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/optimize_your_scene#instrumentation
   */
  get activeBonesPerfCounter() {
    return this._activeBones;
  }
  /**
   * Gets the array of active meshes
   * @returns an array of AbstractMesh
   */
  getActiveMeshes() {
    return this._activeMeshes;
  }
  /**
   * Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
   * @returns a number
   */
  getAnimationRatio() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }
  /**
   * Gets an unique Id for the current render phase
   * @returns a number
   */
  getRenderId() {
    return this._renderId;
  }
  /**
   * Gets an unique Id for the current frame
   * @returns a number
   */
  getFrameId() {
    return this._frameId;
  }
  /** Call this function if you want to manually increment the render Id*/
  incrementRenderId() {
    this._renderId++;
  }
  _createUbo() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }
  /**
   * Use this method to simulate a pointer move on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @returns the current scene
   */
  simulatePointerMove(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  }
  /**
   * Use this method to simulate a pointer down on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @returns the current scene
   */
  simulatePointerDown(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  }
  /**
   * Use this method to simulate a pointer up on a mesh
   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay
   * @param pickResult pickingInfo of the object wished to simulate pointer event on
   * @param pointerEventInit pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)
   * @param doubleTap indicates that the pointer up event should be considered as part of a double click (false by default)
   * @returns the current scene
   */
  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  }
  /**
   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)
   * @param pointerId defines the pointer id to use in a multi-touch scenario (0 by default)
   * @returns true if the pointer was captured
   */
  isPointerCaptured(pointerId = 0) {
    return this._inputManager.isPointerCaptured(pointerId);
  }
  /**
   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp
   * @param attachUp defines if you want to attach events to pointerup
   * @param attachDown defines if you want to attach events to pointerdown
   * @param attachMove defines if you want to attach events to pointermove
   */
  attachControl(attachUp = true, attachDown = true, attachMove = true) {
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  }
  /** Detaches all event handlers*/
  detachControl() {
    this._inputManager.detachControl();
  }
  /**
   * This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
   * Delay loaded resources are not taking in account
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: true)
   * @returns true if all required resources are ready
   */
  isReady(checkRenderTargets = true) {
    if (this._isDisposed) {
      return false;
    }
    let index;
    const engine = this.getEngine();
    const currentRenderPassId = engine.currentRenderPassId;
    engine.currentRenderPassId = this.activeCamera?.renderPassId ?? currentRenderPassId;
    let isReady = true;
    if (this._pendingData.length > 0) {
      isReady = false;
    }
    this.prePassRenderer?.update();
    if (this.useOrderIndependentTransparency && this.depthPeelingRenderer) {
      isReady && (isReady = this.depthPeelingRenderer.isReady());
    }
    if (checkRenderTargets) {
      this._processedMaterials.reset();
      this._materialsRenderTargets.reset();
    }
    for (index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        isReady = false;
        continue;
      }
      const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (const step of this._isReadyForMeshStage) {
        if (!step.action(mesh, hardwareInstancedRendering)) {
          isReady = false;
        }
      }
      if (!checkRenderTargets) {
        continue;
      }
      const mat = mesh.material || this.defaultMaterial;
      if (mat) {
        if (mat._storeEffectOnSubMeshes) {
          for (const subMesh of mesh.subMeshes) {
            const material = subMesh.getMaterial();
            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
          }
        } else {
          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
            if (this._processedMaterials.indexOf(mat) === -1) {
              this._processedMaterials.push(mat);
              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
            }
          }
        }
      }
    }
    if (checkRenderTargets) {
      for (index = 0; index < this._materialsRenderTargets.length; ++index) {
        const rtt = this._materialsRenderTargets.data[index];
        if (!rtt.isReadyForRendering()) {
          isReady = false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      const geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        isReady = false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (const camera of this.activeCameras) {
        if (!camera.isReady(true)) {
          isReady = false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        isReady = false;
      }
    }
    for (const particleSystem of this.particleSystems) {
      if (!particleSystem.isReady()) {
        isReady = false;
      }
    }
    if (this.layers) {
      for (const layer of this.layers) {
        if (!layer.isReady()) {
          isReady = false;
        }
      }
    }
    if (this.effectLayers) {
      for (const effectLayer of this.effectLayers) {
        if (!effectLayer.isLayerReady()) {
          isReady = false;
        }
      }
    }
    if (!engine.areAllEffectsReady()) {
      isReady = false;
    }
    engine.currentRenderPassId = currentRenderPassId;
    return isReady;
  }
  /** Resets all cached information relative to material (including effect and visibility) */
  resetCachedMaterial() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  }
  /**
   * Registers a function to be called before every frame render
   * @param func defines the function to register
   */
  registerBeforeRender(func) {
    this.onBeforeRenderObservable.add(func);
  }
  /**
   * Unregisters a function called before every frame render
   * @param func defines the function to unregister
   */
  unregisterBeforeRender(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  }
  /**
   * Registers a function to be called after every frame render
   * @param func defines the function to register
   */
  registerAfterRender(func) {
    this.onAfterRenderObservable.add(func);
  }
  /**
   * Unregisters a function called after every frame render
   * @param func defines the function to unregister
   */
  unregisterAfterRender(func) {
    this.onAfterRenderObservable.removeCallback(func);
  }
  _executeOnceBeforeRender(func) {
    const execFunc = () => {
      func();
      setTimeout(() => {
        this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  }
  /**
   * The provided function will run before render once and will be disposed afterwards.
   * A timeout delay can be provided so that the function will be executed in N ms.
   * The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.
   * @param func The function to be executed.
   * @param timeout optional delay in ms
   */
  executeOnceBeforeRender(func, timeout) {
    if (timeout !== void 0) {
      setTimeout(() => {
        this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  }
  /**
   * This function can help adding any object to the list of data awaited to be ready in order to check for a complete scene loading.
   * @param data defines the object to wait for
   */
  addPendingData(data) {
    this._pendingData.push(data);
  }
  /**
   * Remove a pending data from the loading list which has previously been added with addPendingData.
   * @param data defines the object to remove from the pending list
   */
  removePendingData(data) {
    const wasLoading = this.isLoading;
    const index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  }
  /**
   * Returns the number of items waiting to be loaded
   * @returns the number of items waiting to be loaded
   */
  getWaitingItemsCount() {
    return this._pendingData.length;
  }
  /**
   * Returns a boolean indicating if the scene is still loading data
   */
  get isLoading() {
    return this._pendingData.length > 0;
  }
  /**
   * Registers a function to be executed when the scene is ready
   * @param func - the function to be executed
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)
   */
  executeWhenReady(func, checkRenderTargets = false) {
    this.onReadyObservable.addOnce(func);
    if (this._executeWhenReadyTimeoutId !== null) {
      return;
    }
    this._checkIsReady(checkRenderTargets);
  }
  /**
   * Returns a promise that resolves when the scene is ready
   * @param checkRenderTargets true to also check that the meshes rendered as part of a render target are ready (default: false)
   * @returns A promise that resolves when the scene is ready
   */
  async whenReadyAsync(checkRenderTargets = false) {
    return await new Promise((resolve) => {
      this.executeWhenReady(() => {
        resolve();
      }, checkRenderTargets);
    });
  }
  /**
   * @internal
   */
  _checkIsReady(checkRenderTargets = false) {
    this._registerTransientComponents();
    if (this.isReady(checkRenderTargets)) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(() => {
      this.incrementRenderId();
      this._checkIsReady(checkRenderTargets);
    }, 100);
  }
  /**
   * Gets all animatable attached to the scene
   */
  get animatables() {
    return this._activeAnimatables;
  }
  /**
   * Resets the last animation time frame.
   * Useful to override when animations start running when loading a scene for the first time.
   */
  resetLastAnimationTimeFrame() {
    this._animationTimeLast = PrecisionDate.Now;
  }
  // Matrix
  /**
   * Gets the current view matrix
   * @returns a Matrix
   */
  getViewMatrix() {
    return this._viewMatrix;
  }
  /**
   * Gets the current projection matrix
   * @returns a Matrix
   */
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  /**
   * Gets the current transform matrix
   * @returns a Matrix made of View * Projection
   */
  getTransformMatrix() {
    return this._transformMatrix;
  }
  /**
   * Sets the current transform matrix
   * @param viewL defines the View matrix to use
   * @param projectionL defines the Projection matrix to use
   * @param viewR defines the right View matrix to use (if provided)
   * @param projectionR defines the right Projection matrix to use (if provided)
   */
  setTransformMatrix(viewL, projectionL, viewR, projectionR) {
    if (!viewR && !projectionR && this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
      this._multiviewSceneUbo = null;
    }
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
    }
  }
  /**
   * Gets the uniform buffer used to store scene data
   * @returns a UniformBuffer
   */
  getSceneUniformBuffer() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }
  /**
   * Creates a scene UBO
   * @param name name of the uniform buffer (optional, for debugging purpose only)
   * @param trackUBOsInFrame define if the UBOs should be tracked in the frame (default: undefined - will use the value from Engine._features.trackUbosInFrame)
   * @returns a new ubo
   */
  createSceneUniformBuffer(name, trackUBOsInFrame) {
    const sceneUbo = new UniformBuffer(this._engine, void 0, false, name ?? "scene", void 0, trackUBOsInFrame);
    sceneUbo.addUniform("viewProjection", 16);
    sceneUbo.addUniform("view", 16);
    sceneUbo.addUniform("projection", 16);
    sceneUbo.addUniform("vEyePosition", 4);
    return sceneUbo;
  }
  /**
   * Sets the scene ubo
   * @param ubo the ubo to set for the scene
   */
  setSceneUniformBuffer(ubo) {
    this._sceneUbo = ubo;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
  }
  /**
   * @experimental
   * True if floatingOriginMode was passed to engine or this scene creation otions.
   * This mode avoids floating point imprecision in huge coordinate system by offsetting uniform values before passing to shader, centering camera at origin and displacing rest of scene by camera position
   */
  get floatingOriginMode() {
    return this._floatingOriginScene !== void 0;
  }
  /**
   * @experimental
   * When floatingOriginMode is enabled, offset is equal to the active camera position in world space. If no active camera or floatingOriginMode is disabled, offset is 0.
   */
  get floatingOriginOffset() {
    return this.floatingOriginMode && this.activeCamera ? this.activeCamera.getWorldMatrix().getTranslation() : this._floatingOriginOffsetDefault;
  }
  /**
   * Gets an unique (relatively to the current scene) Id
   * @returns an unique number for the scene
   */
  getUniqueId() {
    return UniqueIdGenerator.UniqueId;
  }
  /**
   * Add a mesh to the list of scene's meshes
   * @param newMesh defines the mesh to add
   * @param recursive if all child meshes should also be added to the scene
   */
  addMesh(newMesh, recursive = false) {
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    Tools.SetImmediate(() => {
      this.onNewMeshAddedObservable.notifyObservers(newMesh);
    });
    if (recursive) {
      const children = newMesh.getChildMeshes();
      for (const m of children) {
        this.addMesh(m);
      }
    }
  }
  /**
   * Remove a mesh for the list of scene's meshes
   * @param toRemove defines the mesh to remove
   * @param recursive if all child meshes should also be removed from the scene
   * @returns the index where the mesh was in the mesh list
   */
  removeMesh(toRemove, recursive = false) {
    const index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this._inputManager._invalidateMesh(toRemove);
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      const children = toRemove.getChildMeshes();
      for (const m of children) {
        this.removeMesh(m);
      }
    }
    return index;
  }
  /**
   * Add a transform node to the list of scene's transform nodes
   * @param newTransformNode defines the transform node to add
   */
  addTransformNode(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  }
  /**
   * Remove a transform node for the list of scene's transform nodes
   * @param toRemove defines the transform node to remove
   * @returns the index where the transform node was in the transform node list
   */
  removeTransformNode(toRemove) {
    const index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        const lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a skeleton for the list of scene's skeletons
   * @param toRemove defines the skeleton to remove
   * @returns the index where the skeleton was in the skeleton list
   */
  removeSkeleton(toRemove) {
    const index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
      this._executeActiveContainerCleanup(this._activeSkeletons);
    }
    return index;
  }
  /**
   * Remove a morph target for the list of scene's morph targets
   * @param toRemove defines the morph target to remove
   * @returns the index where the morph target was in the morph target list
   */
  removeMorphTargetManager(toRemove) {
    const index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  }
  /**
   * Remove a light for the list of scene's lights
   * @param toRemove defines the light to remove
   * @returns the index where the light was in the light list
   */
  removeLight(toRemove) {
    const index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (const mesh of this.meshes) {
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a camera for the list of scene's cameras
   * @param toRemove defines the camera to remove
   * @returns the index where the camera was in the camera list
   */
  removeCamera(toRemove) {
    const index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      const index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a particle system for the list of scene's particle systems
   * @param toRemove defines the particle system to remove
   * @returns the index where the particle system was in the particle system list
   */
  removeParticleSystem(toRemove) {
    const index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
      this._executeActiveContainerCleanup(this._activeParticleSystems);
    }
    this.onParticleSystemRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Remove a animation for the list of scene's animations
   * @param toRemove defines the animation to remove
   * @returns the index where the animation was in the animation list
   */
  removeAnimation(toRemove) {
    const index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  }
  /**
   * Will stop the animation of the given target
   * @param target - the target
   * @param animationName - the name of the animation to stop (all animations will be stopped if both this and targetMask are empty)
   * @param targetMask - a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)
   */
  stopAnimation(target, animationName, targetMask) {
  }
  /**
   * Removes the given animation group from this scene.
   * @param toRemove The animation group to remove
   * @returns The index of the removed animation group
   */
  removeAnimationGroup(toRemove) {
    const index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    this.onAnimationGroupRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given multi-material from this scene.
   * @param toRemove The multi-material to remove
   * @returns The index of the removed multi-material
   */
  removeMultiMaterial(toRemove) {
    const index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given material from this scene.
   * @param toRemove The material to remove
   * @returns The index of the removed material
   */
  removeMaterial(toRemove) {
    const index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        const lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given action manager from this scene.
   * @deprecated
   * @param toRemove The action manager to remove
   * @returns The index of the removed action manager
   */
  removeActionManager(toRemove) {
    const index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  }
  /**
   * Removes the given texture from this scene.
   * @param toRemove The texture to remove
   * @returns The index of the removed texture
   */
  removeTexture(toRemove) {
    const index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given frame graph from this scene.
   * @param toRemove The frame graph to remove
   * @returns The index of the removed frame graph
   */
  removeFrameGraph(toRemove) {
    const index = this.frameGraphs.indexOf(toRemove);
    if (index !== -1) {
      this.frameGraphs.splice(index, 1);
    }
    this.onFrameGraphRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given object renderer from this scene.
   * @param toRemove The object renderer to remove
   * @returns The index of the removed object renderer
   */
  removeObjectRenderer(toRemove) {
    const index = this.objectRenderers.indexOf(toRemove);
    if (index !== -1) {
      this.objectRenderers.splice(index, 1);
    }
    this.onObjectRendererRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given post-process from this scene.
   * @param toRemove The post-process to remove
   * @returns The index of the removed post-process
   */
  removePostProcess(toRemove) {
    const index = this.postProcesses.indexOf(toRemove);
    if (index !== -1) {
      this.postProcesses.splice(index, 1);
    }
    this.onPostProcessRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Removes the given layer from this scene.
   * @param toRemove The layer to remove
   * @returns The index of the removed layer
   */
  removeEffectLayer(toRemove) {
    const index = this.effectLayers.indexOf(toRemove);
    if (index !== -1) {
      this.effectLayers.splice(index, 1);
    }
    this.onEffectLayerRemovedObservable.notifyObservers(toRemove);
    return index;
  }
  /**
   * Adds the given light to this scene
   * @param newLight The light to add
   */
  addLight(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (const mesh of this.meshes) {
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    Tools.SetImmediate(() => {
      this.onNewLightAddedObservable.notifyObservers(newLight);
    });
  }
  /**
   * Sorts the list list based on light priorities
   */
  sortLightsByPriority() {
    if (this.requireLightSorting) {
      this.lights.sort(LightConstants.CompareLightsPriority);
    }
  }
  /**
   * Adds the given camera to this scene
   * @param newCamera The camera to add
   */
  addCamera(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    Tools.SetImmediate(() => {
      this.onNewCameraAddedObservable.notifyObservers(newCamera);
    });
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  }
  /**
   * Adds the given skeleton to this scene
   * @param newSkeleton The skeleton to add
   */
  addSkeleton(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    Tools.SetImmediate(() => {
      this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
    });
  }
  /**
   * Adds the given particle system to this scene
   * @param newParticleSystem The particle system to add
   */
  addParticleSystem(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
    Tools.SetImmediate(() => {
      this.onNewParticleSystemAddedObservable.notifyObservers(newParticleSystem);
    });
  }
  /**
   * Adds the given animation to this scene
   * @param newAnimation The animation to add
   */
  addAnimation(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  }
  /**
   * Adds the given animation group to this scene.
   * @param newAnimationGroup The animation group to add
   */
  addAnimationGroup(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
    Tools.SetImmediate(() => {
      this.onNewAnimationGroupAddedObservable.notifyObservers(newAnimationGroup);
    });
  }
  /**
   * Adds the given multi-material to this scene
   * @param newMultiMaterial The multi-material to add
   */
  addMultiMaterial(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    Tools.SetImmediate(() => {
      this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
    });
  }
  /**
   * Adds the given material to this scene
   * @param newMaterial The material to add
   */
  addMaterial(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    Tools.SetImmediate(() => {
      this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
    });
  }
  /**
   * Adds the given morph target to this scene
   * @param newMorphTargetManager The morph target to add
   */
  addMorphTargetManager(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  }
  /**
   * Adds the given geometry to this scene
   * @param newGeometry The geometry to add
   */
  addGeometry(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  }
  /**
   * Adds the given action manager to this scene
   * @deprecated
   * @param newActionManager The action manager to add
   */
  addActionManager(newActionManager) {
    this.actionManagers.push(newActionManager);
  }
  /**
   * Adds the given texture to this scene.
   * @param newTexture The texture to add
   */
  addTexture(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  }
  /**
   * Adds the given frame graph to this scene.
   * @param newFrameGraph The frame graph to add
   */
  addFrameGraph(newFrameGraph) {
    this.frameGraphs.push(newFrameGraph);
    Tools.SetImmediate(() => {
      this.onNewFrameGraphAddedObservable.notifyObservers(newFrameGraph);
    });
  }
  /**
   * Adds the given object renderer to this scene.
   * @param objectRenderer The object renderer to add
   */
  addObjectRenderer(objectRenderer) {
    this.objectRenderers.push(objectRenderer);
    Tools.SetImmediate(() => {
      this.onNewObjectRendererAddedObservable.notifyObservers(objectRenderer);
    });
  }
  /**
   * Adds the given post process to this scene.
   * @param newPostProcess The post process to add
   */
  addPostProcess(newPostProcess) {
    if (this._blockEntityCollection) {
      return;
    }
    this.postProcesses.push(newPostProcess);
    Tools.SetImmediate(() => {
      this.onNewPostProcessAddedObservable.notifyObservers(newPostProcess);
    });
  }
  /**
   * Adds the given effect layer to this scene.
   * @param newEffectLayer The effect layer to add
   */
  addEffectLayer(newEffectLayer) {
    if (this._blockEntityCollection) {
      return;
    }
    this.effectLayers.push(newEffectLayer);
    Tools.SetImmediate(() => {
      this.onNewEffectLayerAddedObservable.notifyObservers(newEffectLayer);
    });
  }
  /**
   * Switch active camera
   * @param newCamera defines the new active camera
   * @param attachControl defines if attachControl must be called for the new active camera (default: true)
   */
  switchActiveCamera(newCamera, attachControl = true) {
    const canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  }
  /**
   * sets the active camera of the scene using its Id
   * @param id defines the camera's Id
   * @returns the new active camera or null if none found.
   */
  setActiveCameraById(id) {
    const camera = this.getCameraById(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  /**
   * sets the active camera of the scene using its name
   * @param name defines the camera's name
   * @returns the new active camera or null if none found.
   */
  setActiveCameraByName(name) {
    const camera = this.getCameraByName(name);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  }
  /**
   * get an animation group using its name
   * @param name defines the material's name
   * @returns the animation group or null if none found.
   */
  getAnimationGroupByName(name) {
    for (let index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name) {
        return this.animationGroups[index];
      }
    }
    return null;
  }
  _getMaterial(allowMultiMaterials, predicate) {
    for (let index = 0; index < this.materials.length; index++) {
      const material = this.materials[index];
      if (predicate(material)) {
        return material;
      }
    }
    if (allowMultiMaterials) {
      for (let index = 0; index < this.multiMaterials.length; index++) {
        const material = this.multiMaterials[index];
        if (predicate(material)) {
          return material;
        }
      }
    }
    return null;
  }
  /**
   * Get a material using its unique id
   * @param uniqueId defines the material's unique id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   * @deprecated Please use getMaterialByUniqueId instead.
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {
    return this.getMaterialByUniqueId(uniqueId, allowMultiMaterials);
  }
  /**
   * Get a material using its unique id
   * @param uniqueId defines the material's unique id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialByUniqueId(uniqueId, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);
  }
  /**
   * get a material using its id
   * @param id defines the material's Id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialById(id, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.id === id);
  }
  /**
   * Gets a material using its name
   * @param name defines the material's name
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the material or null if none found.
   */
  getMaterialByName(name, allowMultiMaterials = false) {
    return this._getMaterial(allowMultiMaterials, (m) => m.name === name);
  }
  /**
   * Gets a last added material using a given id
   * @param id defines the material's id
   * @param allowMultiMaterials determines whether multimaterials should be considered
   * @returns the last material with the given id or null if none found.
   */
  getLastMaterialById(id, allowMultiMaterials = false) {
    for (let index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    if (allowMultiMaterials) {
      for (let index = this.multiMaterials.length - 1; index >= 0; index--) {
        if (this.multiMaterials[index].id === id) {
          return this.multiMaterials[index];
        }
      }
    }
    return null;
  }
  /**
   * Get a texture using its unique id
   * @param uniqueId defines the texture's unique id
   * @returns the texture or null if none found.
   */
  getTextureByUniqueId(uniqueId) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  }
  /**
   * Gets a texture using its name
   * @param name defines the texture's name
   * @returns the texture or null if none found.
   */
  getTextureByName(name) {
    for (let index = 0; index < this.textures.length; index++) {
      if (this.textures[index].name === name) {
        return this.textures[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its Id
   * @param id defines the Id to look for
   * @returns the camera or null if not found
   */
  getCameraById(id) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its unique Id
   * @param uniqueId defines the unique Id to look for
   * @returns the camera or null if not found
   */
  getCameraByUniqueId(uniqueId) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a camera using its name
   * @param name defines the camera's name
   * @returns the camera or null if none found.
   */
  getCameraByName(name) {
    for (let index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name) {
        return this.cameras[index];
      }
    }
    return null;
  }
  /**
   * Gets a bone using its Id
   * @param id defines the bone's Id
   * @returns the bone or null if not found
   */
  getBoneById(id) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  /**
   * Gets a bone using its id
   * @param name defines the bone's name
   * @returns the bone or null if not found
   */
  getBoneByName(name) {
    for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      const skeleton = this.skeletons[skeletonIndex];
      for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  }
  /**
   * Gets a light node using its name
   * @param name defines the light's name
   * @returns the light or null if none found.
   */
  getLightByName(name) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a light node using its Id
   * @param id defines the light's Id
   * @returns the light or null if none found.
   */
  getLightById(id) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a light node using its scene-generated unique Id
   * @param uniqueId defines the light's unique Id
   * @returns the light or null if none found.
   */
  getLightByUniqueId(uniqueId) {
    for (let index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a particle system by Id
   * @param id defines the particle system Id
   * @returns the corresponding system or null if none found
   */
  getParticleSystemById(id) {
    for (let index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  }
  /**
   * Gets a geometry using its Id
   * @param id defines the geometry's Id
   * @returns the geometry or null if none found.
   */
  getGeometryById(id) {
    for (let index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  }
  _getGeometryByUniqueId(uniqueId) {
    if (this._geometriesByUniqueId) {
      const index = this._geometriesByUniqueId[uniqueId];
      if (index !== void 0) {
        return this.geometries[index];
      }
    } else {
      for (let index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  }
  /**
   * Gets a frame graph using its name
   * @param name defines the frame graph's name
   * @returns the frame graph or null if none found.
   */
  getFrameGraphByName(name) {
    for (let index = 0; index < this.frameGraphs.length; index++) {
      if (this.frameGraphs[index].name === name) {
        return this.frameGraphs[index];
      }
    }
    return null;
  }
  /**
   * Add a new geometry to this scene
   * @param geometry defines the geometry to be added to the scene.
   * @param force defines if the geometry must be pushed even if a geometry with this id already exists
   * @returns a boolean defining if the geometry was added or not
   */
  pushGeometry(geometry, force) {
    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    Tools.SetImmediate(() => {
      this.onNewGeometryAddedObservable.notifyObservers(geometry);
    });
    return true;
  }
  /**
   * Removes an existing geometry
   * @param geometry defines the geometry to be removed from the scene
   * @returns a boolean defining if the geometry was removed or not
   */
  removeGeometry(geometry) {
    let index;
    if (this._geometriesByUniqueId) {
      index = this._geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      const lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
        }
      }
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[geometry.uniqueId] = void 0;
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  }
  /**
   * Gets the list of geometries attached to the scene
   * @returns an array of Geometry
   */
  getGeometries() {
    return this.geometries;
  }
  /**
   * Gets the first added mesh found of a given Id
   * @param id defines the Id to search for
   * @returns the mesh found or null if not found at all
   */
  getMeshById(id) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a list of meshes using their Id
   * @param id defines the Id to search for
   * @returns a list of meshes
   */
  getMeshesById(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  }
  /**
   * Gets the first added transform node found of a given Id
   * @param id defines the Id to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeById(id) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a transform node with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeByUniqueId(uniqueId) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a list of transform nodes using their Id
   * @param id defines the Id to search for
   * @returns a list of transform nodes
   */
  getTransformNodesById(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  }
  /**
   * Gets a mesh with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getMeshByUniqueId(uniqueId) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last added mesh using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getLastMeshById(id) {
    for (let index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last transform node using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   */
  getLastTransformNodeById(id) {
    for (let index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a the last added node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   */
  getLastEntryById(id) {
    let index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   */
  getNodeById(id) {
    const mesh = this.getMeshById(id);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeById(id);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightById(id);
    if (light) {
      return light;
    }
    const camera = this.getCameraById(id);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneById(id);
    if (bone) {
      return bone;
    }
    return null;
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given name
   * @param name defines the name to search for
   * @returns the found node or null if not found at all.
   */
  getNodeByName(name) {
    const mesh = this.getMeshByName(name);
    if (mesh) {
      return mesh;
    }
    const transformNode = this.getTransformNodeByName(name);
    if (transformNode) {
      return transformNode;
    }
    const light = this.getLightByName(name);
    if (light) {
      return light;
    }
    const camera = this.getCameraByName(name);
    if (camera) {
      return camera;
    }
    const bone = this.getBoneByName(name);
    if (bone) {
      return bone;
    }
    return null;
  }
  /**
   * Gets a mesh using a given name
   * @param name defines the name to search for
   * @returns the found mesh or null if not found at all.
   */
  getMeshByName(name) {
    for (let index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name) {
        return this.meshes[index];
      }
    }
    return null;
  }
  /**
   * Gets a transform node using a given name
   * @param name defines the name to search for
   * @returns the found transform node or null if not found at all.
   */
  getTransformNodeByName(name) {
    for (let index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name) {
        return this.transformNodes[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)
   * @param id defines the Id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getLastSkeletonById(id) {
    for (let index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given auto generated unique id
   * @param  uniqueId defines the unique id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonByUniqueId(uniqueId) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given id (if many are found, this function will pick the first one)
   * @param id defines the id to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonById(id) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a skeleton using a given name
   * @param name defines the name to search for
   * @returns the found skeleton or null if not found at all.
   */
  getSkeletonByName(name) {
    for (let index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name) {
        return this.skeletons[index];
      }
    }
    return null;
  }
  /**
   * Gets a morph target manager  using a given id (if many are found, this function will pick the last one)
   * @param id defines the id to search for
   * @returns the found morph target manager or null if not found at all.
   */
  getMorphTargetManagerById(id) {
    for (let index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  }
  /**
   * Gets a morph target using a given id (if many are found, this function will pick the first one)
   * @param id defines the id to search for
   * @returns the found morph target or null if not found at all.
   */
  getMorphTargetById(id) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.id === id) {
          return target;
        }
      }
    }
    return null;
  }
  /**
   * Gets a morph target using a given name (if many are found, this function will pick the first one)
   * @param name defines the name to search for
   * @returns the found morph target or null if not found at all.
   */
  getMorphTargetByName(name) {
    for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      const morphTargetManager = this.morphTargetManagers[managerIndex];
      for (let index = 0; index < morphTargetManager.numTargets; ++index) {
        const target = morphTargetManager.getTarget(index);
        if (target.name === name) {
          return target;
        }
      }
    }
    return null;
  }
  /**
   * Gets a post process using a given name (if many are found, this function will pick the first one)
   * @param name defines the name to search for
   * @returns the found post process or null if not found at all.
   */
  getPostProcessByName(name) {
    for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      const postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name) {
        return postProcess;
      }
    }
    return null;
  }
  /**
   * Gets a boolean indicating if the given mesh is active
   * @param mesh defines the mesh to look for
   * @returns true if the mesh is in the active list
   */
  isActiveMesh(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  }
  /**
   * Return a unique id as a string which can serve as an identifier for the scene
   */
  get uid() {
    if (!this._uid) {
      this._uid = Tools.RandomId();
    }
    return this._uid;
  }
  /**
   * Add an externally attached data from its key.
   * This method call will fail and return false, if such key already exists.
   * If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.
   * @param key the unique key that identifies the data
   * @param data the data object to associate to the key for this Engine instance
   * @returns true if no such key were already present and the data was added successfully, false otherwise
   */
  addExternalData(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  }
  /**
   * Get an externally attached data from its key
   * @param key the unique key that identifies the data
   * @returns the associated data, if present (can be null), or undefined if not present
   */
  getExternalData(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  }
  /**
   * Get an externally attached data from its key, create it using a factory if it's not already present
   * @param key the unique key that identifies the data
   * @param factory the factory that will be called to create the instance if and only if it doesn't exists
   * @returns the associated data, can be null if the factory returned null.
   */
  getOrAddExternalDataWithFactory(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  }
  /**
   * Remove an externally attached data from the Engine instance
   * @param key the unique key that identifies the data
   * @returns true if the data was successfully removed, false if it doesn't exist
   */
  removeExternalData(key) {
    return this._externalData.remove(key);
  }
  _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {
    if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {
      for (const step of this._evaluateSubMeshStage) {
        step.action(mesh, subMesh);
      }
      const material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  }
  /**
   * Clear the processed materials smart array preventing retention point in material dispose.
   */
  freeProcessedMaterials() {
    this._processedMaterials.dispose();
  }
  /** Gets or sets a boolean blocking all the calls to freeActiveMeshes and freeRenderingGroups
   * It can be used in order to prevent going through methods freeRenderingGroups and freeActiveMeshes several times to improve performance
   * when disposing several meshes in a row or a hierarchy of meshes.
   * When used, it is the responsibility of the user to blockfreeActiveMeshesAndRenderingGroups back to false.
   */
  get blockfreeActiveMeshesAndRenderingGroups() {
    return this._preventFreeActiveMeshesAndRenderingGroups;
  }
  set blockfreeActiveMeshesAndRenderingGroups(value) {
    if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
      return;
    }
    if (value) {
      this.freeActiveMeshes();
      this.freeRenderingGroups();
    }
    this._preventFreeActiveMeshesAndRenderingGroups = value;
  }
  /**
   * Clear the active meshes smart array preventing retention point in mesh dispose.
   */
  freeActiveMeshes() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (let i = 0; i < this.activeCameras.length; i++) {
        const activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  }
  /**
   * Clear the info related to rendering groups preventing retention points during dispose.
   */
  freeRenderingGroups() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (let i = 0; i < this.textures.length; i++) {
        const texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  }
  /** @internal */
  _isInIntermediateRendering() {
    return this._intermediateRendering;
  }
  /**
   * Use this function to stop evaluating active meshes. The current list will be keep alive between frames
   * @param skipEvaluateActiveMeshes defines an optional boolean indicating that the evaluate active meshes step must be completely skipped
   * @param onSuccess optional success callback
   * @param onError optional error callback
   * @param freezeMeshes defines if meshes should be frozen (true by default)
   * @param keepFrustumCulling defines if you want to keep running the frustum clipping (false by default)
   * @returns the current scene
   */
  freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {
    if (this.frameGraph) {
      this._renderWithFrameGraph(true, false, true);
      const objectRendererTasks = this.frameGraph.getTasksByType(FrameGraphObjectRendererTask);
      for (const task of objectRendererTasks) {
        task.objectRenderer._freezeActiveMeshes(freezeMeshes);
      }
      this._freezeActiveMeshesCancel = _RetryWithInterval(() => {
        let ok = true;
        let notCancelled = true;
        for (const task of objectRendererTasks) {
          ok && (ok = task.objectRenderer._isFrozen);
          notCancelled && (notCancelled = task.objectRenderer._freezeActiveMeshesCancel !== null);
        }
        if (ok) {
          return true;
        } else if (!notCancelled) {
          throw new Error("Freezing active meshes was cancelled");
        }
        return false;
      }, () => {
        this._freezeActiveMeshesCancel = null;
        this._activeMeshesFrozen = true;
        this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
        this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
        onSuccess?.();
      }, (err, isTimeout) => {
        this._freezeActiveMeshesCancel = null;
        this.unfreezeActiveMeshes();
        if (!isTimeout) {
          const errMsg = "Scene: An unexpected error occurred while trying to freeze active meshes.";
          if (onError) {
            onError(errMsg);
          } else {
            Logger.Error(errMsg);
            if (err) {
              Logger.Error(err);
              if (err.stack) {
                Logger.Error(err.stack);
              }
            }
          }
        } else {
          const errMsg = "Scene: Timeout while waiting for meshes to be frozen.";
          if (onError) {
            onError(errMsg);
          } else {
            Logger.Error(errMsg);
            if (err) {
              Logger.Error(err);
            }
          }
        }
      });
      return this;
    }
    this.executeWhenReady(() => {
      if (!this.activeCamera) {
        if (onError) {
          onError("No active camera found");
        }
        return;
      }
      if (!this._frustumPlanes) {
        this.updateTransformMatrix();
      }
      this._evaluateActiveMeshes();
      this._activeMeshesFrozen = true;
      this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
      this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      if (freezeMeshes) {
        for (let index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._freeze();
        }
      }
      if (onSuccess) {
        onSuccess();
      }
    });
    return this;
  }
  /**
   * Use this function to restart evaluating active meshes on every frame
   * @returns the current scene
   */
  unfreezeActiveMeshes() {
    for (let index = 0; index < this.meshes.length; index++) {
      const mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    this._freezeActiveMeshesCancel?.();
    this._freezeActiveMeshesCancel = null;
    if (this.frameGraph) {
      const objectRendererTasks = this.frameGraph.getTasksByType(FrameGraphObjectRendererTask);
      for (const task of objectRendererTasks) {
        task.objectRenderer._unfreezeActiveMeshes();
      }
    } else {
      for (let index = 0; index < this._activeMeshes.length; index++) {
        this._activeMeshes.data[index]._unFreeze();
      }
    }
    this._activeMeshesFrozen = false;
    return this;
  }
  _executeActiveContainerCleanup(container) {
    const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
      return;
    }
    this.onBeforeRenderObservable.addOnce(() => container.dispose());
  }
  _evaluateActiveMeshes() {
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      if (this._activeMeshes.length > 0) {
        this.activeCamera?._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
      }
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        const len2 = this._activeMeshes.length;
        for (let i = 0; i < len2; i++) {
          const mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        const psLength = this._activeParticleSystems.length;
        for (let i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      this._renderingManager.resetSprites();
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    this._materialsRenderTargets.reset();
    for (const step of this._beforeEvaluateActiveMeshStage) {
      step.action();
    }
    const meshes = this.getActiveMeshCandidates();
    const len = meshes.length;
    for (let i = 0; i < len; i++) {
      const mesh = meshes.data[i];
      let currentLOD = mesh._internalAbstractMeshDataInfo._currentLOD.get(this.activeCamera);
      if (currentLOD) {
        currentLOD[1] = -1;
      } else {
        currentLOD = [mesh, -1];
        mesh._internalAbstractMeshDataInfo._currentLOD.set(this.activeCamera, currentLOD);
      }
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      currentLOD[0] = meshToRender;
      currentLOD[1] = this._frameId;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (const step of this._preActiveMeshStage) {
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        const particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        const emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  }
  /** @internal */
  _prepareSkeleton(mesh) {
    if (!this._skeletonsEnabled || !mesh.skeleton) {
      return;
    }
    if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
      mesh.skeleton.prepare();
      this._activeBones.addCount(mesh.skeleton.bones.length, false);
    }
    if (!mesh.computeBonesUsingShaders) {
      if (this._softwareSkinnedMeshes.pushNoDuplicate(mesh) && this.frameGraph) {
        mesh.applySkeleton(mesh.skeleton);
      }
    }
  }
  _activeMesh(sourceMesh, mesh) {
    this._prepareSkeleton(mesh);
    let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;
    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
      const subMeshes = this.getActiveSubMeshCandidates(mesh);
      const len = subMeshes.length;
      forcePush = forcePush || len === 1;
      for (let i = 0; i < len; i++) {
        const subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);
      }
    }
  }
  /**
   * Update the transform matrix to update from the current active camera
   * @param force defines a boolean used to force the update even if cache is up to date
   */
  updateTransformMatrix(force) {
    const activeCamera = this.activeCamera;
    if (!activeCamera) {
      return;
    }
    if (activeCamera._renderingMultiview) {
      const leftCamera = activeCamera._rigCameras[0];
      const rightCamera = activeCamera._rigCameras[1];
      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
    } else {
      this.setTransformMatrix(activeCamera.getViewMatrix(), activeCamera.getProjectionMatrix(force));
    }
  }
  _bindFrameBuffer(camera, clear = true) {
    if (!this._useCurrentFrameBuffer) {
      if (camera && camera._multiviewTexture) {
        camera._multiviewTexture._bindFrameBuffer();
      } else if (camera && camera.outputRenderTarget) {
        camera.outputRenderTarget._bindFrameBuffer();
      } else {
        if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
          this._engine.restoreDefaultFramebuffer();
        }
      }
    }
    if (clear) {
      this._clearFrameBuffer(camera);
    }
  }
  _clearFrameBuffer(camera) {
    if (camera && camera._multiviewTexture) {
    } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {
      const rtt = camera.outputRenderTarget;
      if (rtt.onClearObservable.hasObservers()) {
        rtt.onClearObservable.notifyObservers(this._engine);
      } else if (!rtt.skipInitialClear && !camera.isRightCamera) {
        if (this.autoClear) {
          this._engine.clear(rtt.clearColor || this._clearColor, !rtt._cleared, true, true);
        }
        rtt._cleared = true;
      }
    } else {
      if (!this._defaultFrameBufferCleared) {
        this._defaultFrameBufferCleared = true;
        this._clear();
      } else {
        this._engine.clear(null, false, true, true);
      }
    }
  }
  /**
   * @internal
   */
  _renderForCamera(camera, rigParent, bindFrameBuffer = true) {
    if (camera && camera._skipRendering) {
      return;
    }
    const engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    if (!this.prePass && bindFrameBuffer) {
      let skipInitialClear = true;
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        skipInitialClear = camera.outputRenderTarget.skipInitialClear;
        if (this.autoClear) {
          this._defaultFrameBufferCleared = false;
          camera.outputRenderTarget.skipInitialClear = false;
        }
      }
      this._bindFrameBuffer(this._activeCamera);
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        camera.outputRenderTarget.skipInitialClear = skipInitialClear;
      }
    }
    this.updateTransformMatrix();
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
      this._renderTargets.pushNoDuplicate(this.environmentTexture);
    }
    for (const step of this._gatherActiveCameraRenderTargetsStage) {
      step.action(this._renderTargets);
    }
    let needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        const boundingBoxRenderer = this.getBoundingBoxRenderer?.();
        let currentBoundingBoxMeshList;
        for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          const renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            if (boundingBoxRenderer && !currentBoundingBoxMeshList) {
              currentBoundingBoxMeshList = boundingBoxRenderer.renderList.length > 0 ? boundingBoxRenderer.renderList.data.slice() : [];
              currentBoundingBoxMeshList.length = boundingBoxRenderer.renderList.length;
            }
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        if (boundingBoxRenderer && currentBoundingBoxMeshList) {
          boundingBoxRenderer.renderList.data = currentBoundingBoxMeshList;
          boundingBoxRenderer.renderList.length = currentBoundingBoxMeshList.length;
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (const step of this._cameraDrawRenderTargetStage) {
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
    }
    this._engine.currentRenderPassId = camera.outputRenderTarget?.renderPassId ?? camera.renderPassId ?? 0;
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
      this.updateTransformMatrix();
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (const step of this._beforeCameraDrawStage) {
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    const fastSnapshotMode = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
    if (fastSnapshotMode) {
      this.finalizeSceneUbo();
    }
    this._renderingManager.render(null, null, true, !fastSnapshotMode);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (const step of this._afterCameraDrawStage) {
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    for (const step of this._afterCameraPostProcessStage) {
      step.action(this.activeCamera);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  }
  _processSubCameras(camera, bindFrameBuffer = true) {
    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
      if (camera._renderingMultiview && !this._multiviewSceneUbo) {
        this._createMultiviewUbo();
      }
      this._renderForCamera(camera, void 0, bindFrameBuffer);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      this.onBeforeCameraRenderObservable.notifyObservers(camera);
      for (let index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.updateTransformMatrix();
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  }
  _checkIntersections() {
    for (let index = 0; index < this._meshesForIntersections.length; index++) {
      const sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        const action = sourceMesh.actionManager.actions[actionIndex];
        if (action.trigger === 12 || action.trigger === 13) {
          const parameters = action.getTriggerParameter();
          const otherMesh = parameters.mesh ? parameters.mesh : parameters;
          const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
              sourceMesh._intersectionsInProgress.push(otherMesh);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {
              const parameterMesh = parameter.mesh ? parameter.mesh : parameter;
              return otherMesh === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   */
  _advancePhysicsEngineStep(step) {
  }
  /** @internal */
  _animate(customDeltaTime) {
  }
  /** Execute all animations (for a frame) */
  animate() {
    if (this._engine.isDeterministicLockStep()) {
      let deltaTime = Math.max(_Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), _Scene.MaxDeltaTime)) + this._timeAccumulator;
      const defaultFrameTime = this._engine.getTimeStep();
      const defaultFPS = 1e3 / defaultFrameTime / 1e3;
      let stepsTaken = 0;
      const maxSubSteps = this._engine.getLockstepMaxSteps();
      let internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate(defaultFrameTime);
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(_Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), _Scene.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  }
  _clear() {
    if (this.autoClearDepthAndStencil || this.autoClear) {
      this._engine.clear(this._clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
  }
  _checkCameraRenderTarget(camera) {
    if (camera?.outputRenderTarget && !camera?.isRigCamera) {
      camera.outputRenderTarget._cleared = false;
    }
    if (camera?.rigCameras?.length) {
      for (let i = 0; i < camera.rigCameras.length; ++i) {
        const rtt = camera.rigCameras[i].outputRenderTarget;
        if (rtt) {
          rtt._cleared = false;
        }
      }
    }
  }
  /**
   * Resets the draw wrappers cache of all meshes
   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id
   */
  resetDrawCache(passId) {
    if (!this.meshes) {
      return;
    }
    for (const mesh of this.meshes) {
      mesh.resetDrawCache(passId);
    }
  }
  _renderWithFrameGraph(updateCameras = true, _ignoreAnimations = false, forceUpdateWorldMatrix = false) {
    this.activeCamera = null;
    this.activeCameras = null;
    if (updateCameras) {
      for (const camera of this.cameras) {
        camera.update();
        if (camera.cameraRigMode !== 0) {
          for (let index = 0; index < camera._rigCameras.length; index++) {
            camera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    for (const step of this._beforeClearStage) {
      step.action();
    }
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      this._activeParticleSystems.reset();
      this._activeSkeletons.reset();
      this._softwareSkinnedMeshes.reset();
    } else {
      const meshes = this.getActiveMeshCandidates();
      const len = meshes.length;
      if (!this._activeMeshesFrozen) {
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
        for (let i = 0; i < len; i++) {
          const mesh = meshes.data[i];
          mesh._internalAbstractMeshDataInfo._wasActiveLastFrame = false;
          if (mesh.isBlocked) {
            continue;
          }
          this._totalVertices.addCount(mesh.getTotalVertices(), false);
          if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
            continue;
          }
          mesh.computeWorldMatrix(forceUpdateWorldMatrix);
          if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
            this._meshesForIntersections.pushNoDuplicate(mesh);
          }
        }
        if (this.particlesEnabled) {
          for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
            const particleSystem = this.particleSystems[particleIndex];
            if (!particleSystem.isStarted() || !particleSystem.emitter) {
              continue;
            }
            const emitter = particleSystem.emitter;
            if (!emitter.position || emitter.isEnabled()) {
              this._activeParticleSystems.push(particleSystem);
              particleSystem.animate();
            }
          }
        }
      } else {
        if (!this._skipEvaluateActiveMeshesCompletely) {
          for (let i = 0; i < len; i++) {
            const mesh = meshes.data[i];
            if (mesh._internalAbstractMeshDataInfo._wasActiveLastFrame) {
              mesh.computeWorldMatrix();
            }
          }
        }
        if (this.particlesEnabled) {
          const psLength = this._activeParticleSystems.length;
          for (let i = 0; i < psLength; i++) {
            this._activeParticleSystems.data[i].animate();
          }
        }
      }
    }
    this.frameGraph?.execute();
  }
  /**
   * @internal
   */
  _renderRenderTarget(renderTarget, activeCamera, useCameraPostProcess = false, dumpForDebug = false) {
    this._intermediateRendering = true;
    if (renderTarget._shouldRender()) {
      this._renderId++;
      this.activeCamera = activeCamera;
      if (!this.activeCamera) {
        throw new Error("Active camera not set");
      }
      this._engine.setViewport(this.activeCamera.viewport);
      this.updateTransformMatrix();
      renderTarget.render(useCameraPostProcess, dumpForDebug);
    }
    this._intermediateRendering = false;
  }
  /**
   * Render the scene
   * @param updateCameras defines a boolean indicating if cameras must update according to their inputs (true by default)
   * @param ignoreAnimations defines a boolean indicating if animations should not be executed (false by default)
   */
  render(updateCameras = true, ignoreAnimations = false) {
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
      this._checkIsReady();
    }
    FloatingOriginCurrentScene.getScene = this._getFloatingOriginScene;
    this._frameId++;
    this._defaultFrameBufferCleared = false;
    this._checkCameraRenderTarget(this.activeCamera);
    if (this.activeCameras?.length) {
      for (const c of this.activeCameras) {
        this._checkCameraRenderTarget(c);
      }
    }
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (const step of this._beforeCameraUpdateStage) {
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          const camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== 0) {
            for (let index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== 0) {
          for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    if (this.customRenderFunction) {
      this._renderId++;
      this._engine.currentRenderPassId = 0;
      this.customRenderFunction(updateCameras, ignoreAnimations);
    } else {
      this.onBeforeRenderObservable.notifyObservers(this);
      this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
      const currentActiveCamera = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;
      if (this.renderTargetsEnabled) {
        Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
        for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
          const renderTarget = this.customRenderTargets[customIndex];
          const activeCamera = renderTarget.activeCamera || this.activeCamera;
          this._renderRenderTarget(renderTarget, activeCamera, currentActiveCamera !== activeCamera, this.dumpNextRenderTargets);
        }
        Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
        this._renderId++;
      }
      this._engine.currentRenderPassId = currentActiveCamera?.renderPassId ?? 0;
      this.activeCamera = currentActiveCamera;
      if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
        this._bindFrameBuffer(this._activeCamera, false);
      }
      this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
      for (const step of this._beforeClearStage) {
        step.action();
      }
      this._clearFrameBuffer(this.activeCamera);
      for (const step of this._gatherRenderTargetsStage) {
        step.action(this._renderTargets);
      }
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
        }
      } else {
        if (!this.activeCamera) {
          throw new Error("No camera defined");
        }
        this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
      }
    }
    this._checkIntersections();
    for (const step of this._afterRenderStage) {
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (let index = 0; index < this._toBeDisposed.length; index++) {
        const data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed.length = 0;
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
    this._engine.restoreDefaultFramebuffer();
  }
  /**
   * Freeze all materials
   * A frozen material will not be updatable but should be faster to render
   * Note: multimaterials will not be frozen, but their submaterials will
   */
  freezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  }
  /**
   * Unfreeze all materials
   * A frozen material will not be updatable but should be faster to render
   */
  unfreezeMaterials() {
    for (let i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  }
  /**
   * Releases all held resources
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.beforeRender = null;
    this.afterRender = null;
    this.metadata = null;
    this.skeletons.length = 0;
    this.morphTargetManagers.length = 0;
    this._transientComponents.length = 0;
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    this.importedMeshesFiles = [];
    if (this._activeAnimatables && this.stopAllAnimations) {
      for (const animatable of this._activeAnimatables) {
        animatable.onAnimationEndObservable.clear();
        animatable.onAnimationEnd = null;
      }
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this.activeCameras = null;
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._materialsRenderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed.length = 0;
    const activeRequests = this._activeRequests.slice();
    for (const request of activeRequests) {
      request.abort();
    }
    this._activeRequests.length = 0;
    try {
      this.onDisposeObservable.notifyObservers(this);
    } catch (e) {
      Logger.Error("An error occurred while calling onDisposeObservable!", e);
    }
    this.detachControl();
    const canvas = this._engine.getInputElement();
    if (canvas) {
      for (let index2 = 0; index2 < this.cameras.length; index2++) {
        this.cameras[index2].detachControl();
      }
    }
    this._disposeList(this.animationGroups);
    this._disposeList(this.lights);
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    this._disposeList(this.multiMaterials);
    this._disposeList(this.materials);
    this._disposeList(this.meshes, (item) => item.dispose(true));
    this._disposeList(this.transformNodes, (item) => item.dispose(true));
    const cameras = this.cameras;
    this._disposeList(cameras);
    this._disposeList(this.particleSystems);
    this._disposeList(this.postProcesses);
    this._disposeList(this.textures);
    this._disposeList(this.morphTargetManagers);
    this._disposeList(this.frameGraphs);
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    this._disposeList(this._components);
    let index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    this._floatingOriginScene = void 0;
    if (this._engine.scenes.length === 0) {
      ResetMatrixFunctions();
    }
    if (EngineStore._LastCreatedScene === this) {
      EngineStore._LastCreatedScene = null;
      let engineIndex = EngineStore.Instances.length - 1;
      while (engineIndex >= 0) {
        const engine = EngineStore.Instances[engineIndex];
        if (engine.scenes.length > 0) {
          EngineStore._LastCreatedScene = engine.scenes[this._engine.scenes.length - 1];
          break;
        }
        engineIndex--;
      }
    }
    index = this._engine._virtualScenes.indexOf(this);
    if (index > -1) {
      this._engine._virtualScenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onAfterRenderCameraObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onNewFrameGraphAddedObservable.clear();
    this.onFrameGraphRemovedObservable.clear();
    this.onNewObjectRendererAddedObservable.clear();
    this.onObjectRendererRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.onScenePerformancePriorityChangedObservable.clear();
    this.onClearColorChangedObservable.clear();
    this.onEnvironmentTextureChangedObservable.clear();
    this.onMeshUnderPointerUpdatedObservable.clear();
    this._isDisposed = true;
  }
  _disposeList(items, callback) {
    const itemsCopy = items.slice(0);
    callback = callback ?? ((item) => item.dispose());
    for (const item of itemsCopy) {
      callback(item);
    }
    items.length = 0;
  }
  /**
   * Gets if the scene is already disposed
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Call this function to reduce memory footprint of the scene.
   * Vertex buffers will not store CPU data anymore (this will prevent picking, collisions or physics to work correctly)
   */
  clearCachedVertexData() {
    for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      const mesh = this.meshes[meshIndex];
      const geometry = mesh.geometry;
      if (geometry) {
        geometry.clearCachedData();
      }
    }
  }
  /**
   * This function will remove the local cached buffer data from texture.
   * It will save memory but will prevent the texture from being rebuilt
   */
  cleanCachedTextureBuffer() {
    for (const baseTexture of this.textures) {
      const buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  }
  /**
   * Get the world extend vectors with an optional filter
   *
   * @param filterPredicate the predicate - which meshes should be included when calculating the world size
   * @returns {{ min: Vector3; max: Vector3 }} min and max vectors
   */
  getWorldExtends(filterPredicate) {
    const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || (() => true);
    const meshes = this.meshes.filter(filterPredicate);
    for (const mesh of meshes) {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        continue;
      }
      const boundingInfo = mesh.getBoundingInfo();
      const minBox = boundingInfo.boundingBox.minimumWorld;
      const maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    }
    return {
      min,
      max
    };
  }
  // Picking
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
   * @param camera defines the camera to use for the picking
   * @param cameraViewSpace defines if picking will be done in view space (false by default)
   * @returns a Ray
   */
  createPickingRay(x, y, world, camera, cameraViewSpace = false) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param world defines the world matrix to use if you want to pick in object space (instead of world space)
   * @param result defines the ray where to store the picking ray
   * @param camera defines the camera to use for the picking
   * @param cameraViewSpace defines if picking will be done in view space (false by default)
   * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)
   * @returns the current scene
   */
  createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param camera defines the camera to use for the picking
   * @returns a Ray
   */
  createPickingRayInCameraSpace(x, y, camera) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Creates a ray that can be used to pick in the scene
   * @param x defines the x coordinate of the origin (on-screen)
   * @param y defines the y coordinate of the origin (on-screen)
   * @param result defines the ray where to store the picking ray
   * @param camera defines the camera to use for the picking
   * @returns the current scene
   */
  createPickingRayInCameraSpaceToRef(x, y, result, camera) {
    throw _WarnImport("Ray");
  }
  /** Launch a ray to try to pick a mesh in the scene
   * @param x position on screen
   * @param y position on screen
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns a PickingInfo
   */
  pick(x, y, predicate, fastCheck, camera, trianglePredicate) {
    const warn = _WarnImport("Ray", true);
    if (warn) {
      Logger.Warn(warn);
    }
    return new PickingInfo();
  }
  /** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)
   * @param x position on screen
   * @param y position on screen
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)
   */
  pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {
    const warn = _WarnImport("Ray", true);
    if (warn) {
      Logger.Warn(warn);
    }
    return new PickingInfo();
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param ray The ray to use to pick meshes
   * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param fastCheck defines if the first intersection will be used (and not the closest)
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns a PickingInfo
   */
  pickWithRay(ray, predicate, fastCheck, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,
   * irrespective of orientation.
   * @param x X position on screen
   * @param y Y position on screen
   * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns an array of PickingInfo
   */
  multiPick(x, y, predicate, camera, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * Launch a ray to try to pick a mesh in the scene
   * @param ray Ray to use
   * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced
   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected
   * @returns an array of PickingInfo
   */
  multiPickWithRay(ray, predicate, trianglePredicate) {
    throw _WarnImport("Ray");
  }
  /**
   * Force the value of meshUnderPointer
   * @param mesh defines the mesh to use
   * @param pointerId optional pointer id when using more than one pointer
   * @param pickResult optional pickingInfo data used to find mesh
   */
  setPointerOverMesh(mesh, pointerId, pickResult) {
    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
  }
  /**
   * Gets the mesh under the pointer
   * @returns a Mesh or null if no mesh is under the pointer
   */
  getPointerOverMesh() {
    return this._inputManager.getPointerOverMesh();
  }
  // Misc.
  /** @internal */
  _rebuildGeometries() {
    for (const geometry of this.geometries) {
      geometry._rebuild();
    }
    for (const mesh of this.meshes) {
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (const component of this._components) {
      component.rebuild();
    }
    for (const system of this.particleSystems) {
      system.rebuild();
    }
    if (this.spriteManagers) {
      for (const spriteMgr of this.spriteManagers) {
        spriteMgr.rebuild();
      }
    }
  }
  /** @internal */
  _rebuildTextures() {
    for (const texture of this.textures) {
      texture._rebuild(true);
    }
    this.markAllMaterialsAsDirty(1);
  }
  /**
   * Get from a list of objects by tags
   * @param list the list of objects to use
   * @param tagsQuery the query to use
   * @param filter a predicate to filter for tags
   * @returns
   */
  _getByTags(list, tagsQuery, filter) {
    if (tagsQuery === void 0) {
      return list;
    }
    const listByTags = [];
    for (const i in list) {
      const item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {
        listByTags.push(item);
      }
    }
    return listByTags;
  }
  /**
   * Get a list of meshes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Mesh
   */
  getMeshesByTags(tagsQuery, filter) {
    return this._getByTags(this.meshes, tagsQuery, filter);
  }
  /**
   * Get a list of cameras by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Camera
   */
  getCamerasByTags(tagsQuery, filter) {
    return this._getByTags(this.cameras, tagsQuery, filter);
  }
  /**
   * Get a list of lights by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Light
   */
  getLightsByTags(tagsQuery, filter) {
    return this._getByTags(this.lights, tagsQuery, filter);
  }
  /**
   * Get a list of materials by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Material
   */
  getMaterialByTags(tagsQuery, filter) {
    return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));
  }
  /**
   * Get a list of transform nodes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of TransformNode
   */
  getTransformNodesByTags(tagsQuery, filter) {
    return this._getByTags(this.transformNodes, tagsQuery, filter);
  }
  /**
   * Overrides the default sort function applied in the rendering group to prepare the meshes.
   * This allowed control for front to back rendering or reversly depending of the special needs.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param opaqueSortCompareFn The opaque queue comparison function use to sort.
   * @param alphaTestSortCompareFn The alpha test queue comparison function use to sort.
   * @param transparentSortCompareFn The transparent queue comparison function use to sort.
   */
  setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  }
  /**
   * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.
   *
   * @param renderingGroupId The rendering group id corresponding to its index
   * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.
   * @param depth Automatically clears depth between groups if true and autoClear is true.
   * @param stencil Automatically clears stencil between groups if true and autoClear is true.
   */
  setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  }
  /**
   * Gets the current auto clear configuration for one rendering group of the rendering
   * manager.
   * @param index the rendering group index to get the information for
   * @returns The auto clear setup for the requested rendering group
   */
  getAutoClearDepthStencilSetup(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  }
  /** @internal */
  _forceBlockMaterialDirtyMechanism(value) {
    this._blockMaterialDirtyMechanism = value;
  }
  /** Gets or sets a boolean blocking all the calls to markAllMaterialsAsDirty (ie. the materials won't be updated if they are out of sync) */
  get blockMaterialDirtyMechanism() {
    return this._blockMaterialDirtyMechanism;
  }
  set blockMaterialDirtyMechanism(value) {
    if (this._blockMaterialDirtyMechanism === value) {
      return;
    }
    this._blockMaterialDirtyMechanism = value;
    if (!value) {
      this.markAllMaterialsAsDirty(127);
    }
  }
  /**
   * Will flag all materials as dirty to trigger new shader compilation
   * @param flag defines the flag used to specify which material part must be marked as dirty
   * @param predicate If not null, it will be used to specify if a material has to be marked as dirty
   */
  markAllMaterialsAsDirty(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (const material of this.materials) {
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  }
  /**
   * @internal
   */
  _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return await new Promise((resolve, reject) => {
      this._loadFile(fileOrUrl, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {
        reject(exception);
      }, onOpened);
    });
  }
  /**
   * @internal
   */
  _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    return await new Promise((resolve, reject) => {
      this._requestFile(url, (data) => {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {
        reject(error);
      }, onOpened);
    });
  }
  /**
   * @internal
   */
  _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
    const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add((request2) => {
      this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
    });
    return request;
  }
  /**
   * @internal
   */
  async _readFileAsync(file, onProgress, useArrayBuffer) {
    return await new Promise((resolve, reject) => {
      this._readFile(file, (data) => {
        resolve(data);
      }, onProgress, useArrayBuffer, (error) => {
        reject(error);
      });
    });
  }
  // eslint-disable-next-line jsdoc/require-returns-check
  /**
   * This method gets the performance collector belonging to the scene, which is generally shared with the inspector.
   * @returns the perf collector belonging to the scene.
   */
  getPerfCollector() {
    throw _WarnImport("performanceViewerSceneExtension");
  }
  // deprecated
  /**
   * Sets the active camera of the scene using its Id
   * @param id defines the camera's Id
   * @returns the new active camera or null if none found.
   * @deprecated Please use setActiveCameraById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  setActiveCameraByID(id) {
    return this.setActiveCameraById(id);
  }
  /**
   * Get a material using its id
   * @param id defines the material's Id
   * @returns the material or null if none found.
   * @deprecated Please use getMaterialById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMaterialByID(id) {
    return this.getMaterialById(id);
  }
  /**
   * Gets a the last added material using a given id
   * @param id defines the material's Id
   * @returns the last material with the given id or null if none found.
   * @deprecated Please use getLastMaterialById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastMaterialByID(id) {
    return this.getLastMaterialById(id);
  }
  /**
   * Get a texture using its unique id
   * @param uniqueId defines the texture's unique id
   * @returns the texture or null if none found.
   * @deprecated Please use getTextureByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTextureByUniqueID(uniqueId) {
    return this.getTextureByUniqueId(uniqueId);
  }
  /**
   * Gets a camera using its Id
   * @param id defines the Id to look for
   * @returns the camera or null if not found
   * @deprecated Please use getCameraById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getCameraByID(id) {
    return this.getCameraById(id);
  }
  /**
   * Gets a camera using its unique Id
   * @param uniqueId defines the unique Id to look for
   * @returns the camera or null if not found
   * @deprecated Please use getCameraByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getCameraByUniqueID(uniqueId) {
    return this.getCameraByUniqueId(uniqueId);
  }
  /**
   * Gets a bone using its Id
   * @param id defines the bone's Id
   * @returns the bone or null if not found
   * @deprecated Please use getBoneById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getBoneByID(id) {
    return this.getBoneById(id);
  }
  /**
   * Gets a light node using its Id
   * @param id defines the light's Id
   * @returns the light or null if none found.
   * @deprecated Please use getLightById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLightByID(id) {
    return this.getLightById(id);
  }
  /**
   * Gets a light node using its scene-generated unique Id
   * @param uniqueId defines the light's unique Id
   * @returns the light or null if none found.
   * @deprecated Please use getLightByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLightByUniqueID(uniqueId) {
    return this.getLightByUniqueId(uniqueId);
  }
  /**
   * Gets a particle system by Id
   * @param id defines the particle system Id
   * @returns the corresponding system or null if none found
   * @deprecated Please use getParticleSystemById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getParticleSystemByID(id) {
    return this.getParticleSystemById(id);
  }
  /**
   * Gets a geometry using its Id
   * @param id defines the geometry's Id
   * @returns the geometry or null if none found.
   * @deprecated Please use getGeometryById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getGeometryByID(id) {
    return this.getGeometryById(id);
  }
  /**
   * Gets the first added mesh found of a given Id
   * @param id defines the Id to search for
   * @returns the mesh found or null if not found at all
   * @deprecated Please use getMeshById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshByID(id) {
    return this.getMeshById(id);
  }
  /**
   * Gets a mesh with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found mesh or null if not found at all.
   * @deprecated Please use getMeshByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshByUniqueID(uniqueId) {
    return this.getMeshByUniqueId(uniqueId);
  }
  /**
   * Gets a the last added mesh using a given Id
   * @param id defines the Id to search for
   * @returns the found mesh or null if not found at all.
   * @deprecated Please use getLastMeshById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastMeshByID(id) {
    return this.getLastMeshById(id);
  }
  /**
   * Gets a list of meshes using their Id
   * @param id defines the Id to search for
   * @returns a list of meshes
   * @deprecated Please use getMeshesById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getMeshesByID(id) {
    return this.getMeshesById(id);
  }
  /**
   * Gets the first added transform node found of a given Id
   * @param id defines the Id to search for
   * @returns the found transform node or null if not found at all.
   * @deprecated Please use getTransformNodeById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodeByID(id) {
    return this.getTransformNodeById(id);
  }
  /**
   * Gets a transform node with its auto-generated unique Id
   * @param uniqueId defines the unique Id to search for
   * @returns the found transform node or null if not found at all.
   * @deprecated Please use getTransformNodeByUniqueId instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodeByUniqueID(uniqueId) {
    return this.getTransformNodeByUniqueId(uniqueId);
  }
  /**
   * Gets a list of transform nodes using their Id
   * @param id defines the Id to search for
   * @returns a list of transform nodes
   * @deprecated Please use getTransformNodesById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getTransformNodesByID(id) {
    return this.getTransformNodesById(id);
  }
  /**
   * Gets a node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   * @deprecated Please use getNodeById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getNodeByID(id) {
    return this.getNodeById(id);
  }
  /**
   * Gets a the last added node (Mesh, Camera, Light) using a given Id
   * @param id defines the Id to search for
   * @returns the found node or null if not found at all
   * @deprecated Please use getLastEntryById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastEntryByID(id) {
    return this.getLastEntryById(id);
  }
  /**
   * Gets a skeleton using a given Id (if many are found, this function will pick the last one)
   * @param id defines the Id to search for
   * @returns the found skeleton or null if not found at all.
   * @deprecated Please use getLastSkeletonById instead
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  getLastSkeletonByID(id) {
    return this.getLastSkeletonById(id);
  }
};
Scene.FOGMODE_NONE = 0;
Scene.FOGMODE_EXP = 1;
Scene.FOGMODE_EXP2 = 2;
Scene.FOGMODE_LINEAR = 3;
Scene.MinDeltaTime = 1;
Scene.MaxDeltaTime = 1e3;
Scene._OriginalDefaultMaterialFactory = Scene.DefaultMaterialFactory;
RegisterClass("BABYLON.Scene", Scene);

export {
  AbstractActionManager,
  ActionEvent,
  StringDictionary,
  ColorCurves,
  PrepareUniformsForImageProcessing,
  PrepareSamplersForImageProcessing,
  ImageProcessingConfiguration,
  PickingInfo,
  SceneComponentConstants,
  Stage,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  DeviceType,
  PointerInput,
  NativePointerInput,
  DualShockInput,
  DualSenseInput,
  XboxInput,
  SwitchInput,
  DeviceInputEventType,
  EventConstants,
  DeviceSource,
  DeviceSourceManager,
  _ImportHelper,
  backbufferColorTextureHandle,
  backbufferDepthStencilTextureHandle,
  FrameGraphPass,
  FrameGraphCullPass,
  FrameGraphRenderPass,
  FrameGraphTask,
  ThinBlurPostProcess,
  BlurPostProcess,
  EffectFallbacks,
  ShadowGenerator,
  BoundingBox,
  BoundingSphere,
  BoundingInfo,
  Camera,
  DepthRenderer,
  MinMaxReducer,
  DepthReducer,
  CascadedShadowGenerator,
  FrameGraphShadowGeneratorTask,
  DirectionalLight,
  FrameGraphPostProcessTask,
  textureSizeIsObject,
  getDimensionsFromTextureSize,
  FrameGraphCascadedShadowGeneratorTask,
  FrameGraphObjectRendererTask,
  ScenePerformancePriority,
  Scene
};
//# sourceMappingURL=chunk-DJTOTRI3.js.map
