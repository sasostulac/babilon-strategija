{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/HighDynamicRange/cubemapToSphericalPolynomial.ts"],
  "sourcesContent": ["import { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Clamp } from \"../../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial, SphericalHarmonics } from \"../../Maths/sphericalPolynomial\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { CubeMapInfo } from \"./panoramaToCubemap\";\r\nimport { ToLinearSpace } from \"../../Maths/math.constants\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\nclass FileFaceOrientation {\r\n    public name: string;\r\n    public worldAxisForNormal: Vector3; // the world axis corresponding to the normal to the face\r\n    public worldAxisForFileX: Vector3; // the world axis corresponding to texture right x-axis in file\r\n    public worldAxisForFileY: Vector3; // the world axis corresponding to texture down y-axis in file\r\n\r\n    public constructor(name: string, worldAxisForNormal: Vector3, worldAxisForFileX: Vector3, worldAxisForFileY: Vector3) {\r\n        this.name = name;\r\n        this.worldAxisForNormal = worldAxisForNormal;\r\n        this.worldAxisForFileX = worldAxisForFileX;\r\n        this.worldAxisForFileY = worldAxisForFileY;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper class dealing with the extraction of spherical polynomial dataArray\r\n * from a cube map.\r\n */\r\nexport class CubeMapToSphericalPolynomialTools {\r\n    private static _FileFaces: FileFaceOrientation[] = [\r\n        new FileFaceOrientation(\"right\", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)), // +X east\r\n        new FileFaceOrientation(\"left\", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)), // -X west\r\n        new FileFaceOrientation(\"up\", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)), // +Y north\r\n        new FileFaceOrientation(\"down\", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)), // -Y south\r\n        new FileFaceOrientation(\"front\", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)), // +Z top\r\n        new FileFaceOrientation(\"back\", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0)), // -Z bottom\r\n    ];\r\n\r\n    /** @internal */\r\n    public static MAX_HDRI_VALUE = 4096;\r\n    /** @internal */\r\n    public static PRESERVE_CLAMPED_COLORS = false;\r\n\r\n    /**\r\n     * Converts a texture to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param texture The texture to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapTextureToSphericalPolynomial(texture: BaseTexture): Nullable<Promise<SphericalPolynomial>> {\r\n        if (!texture.isCube) {\r\n            // Only supports cube Textures currently.\r\n            return null;\r\n        }\r\n\r\n        texture.getScene()?.getEngine().flushFramebuffer();\r\n\r\n        const size = texture.getSize().width;\r\n        const rightPromise = texture.readPixels(0, undefined, undefined, false);\r\n        const leftPromise = texture.readPixels(1, undefined, undefined, false);\r\n\r\n        let upPromise: Nullable<Promise<ArrayBufferView>>;\r\n        let downPromise: Nullable<Promise<ArrayBufferView>>;\r\n        if (texture.isRenderTarget) {\r\n            upPromise = texture.readPixels(3, undefined, undefined, false);\r\n            downPromise = texture.readPixels(2, undefined, undefined, false);\r\n        } else {\r\n            upPromise = texture.readPixels(2, undefined, undefined, false);\r\n            downPromise = texture.readPixels(3, undefined, undefined, false);\r\n        }\r\n\r\n        const frontPromise = texture.readPixels(4, undefined, undefined, false);\r\n        const backPromise = texture.readPixels(5, undefined, undefined, false);\r\n\r\n        const gammaSpace = texture.gammaSpace;\r\n        // Always read as RGBA.\r\n        const format = Constants.TEXTUREFORMAT_RGBA;\r\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (texture.textureType == Constants.TEXTURETYPE_FLOAT || texture.textureType == Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            type = Constants.TEXTURETYPE_FLOAT;\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {\r\n                const cubeInfo: CubeMapInfo = {\r\n                    size,\r\n                    right,\r\n                    left,\r\n                    up,\r\n                    down,\r\n                    front,\r\n                    back,\r\n                    format,\r\n                    type,\r\n                    gammaSpace,\r\n                };\r\n\r\n                resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the area on the unit sphere of the rectangle defined by (x,y) and the origin\r\n     * See https://www.rorydriscoll.com/2012/01/15/cubemap-texel-solid-angle/\r\n     * @param x\r\n     * @param y\r\n     * @returns the area\r\n     */\r\n    private static _AreaElement(x: number, y: number): number {\r\n        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));\r\n    }\r\n\r\n    /**\r\n     * Converts a cubemap to the according Spherical Polynomial data.\r\n     * This extracts the first 3 orders only as they are the only one used in the lighting.\r\n     *\r\n     * @param cubeInfo The Cube map to extract the information from.\r\n     * @returns The Spherical Polynomial data.\r\n     */\r\n    public static ConvertCubeMapToSphericalPolynomial(cubeInfo: CubeMapInfo): SphericalPolynomial {\r\n        const sphericalHarmonics = new SphericalHarmonics();\r\n        let totalSolidAngle = 0.0;\r\n\r\n        // The (u,v) range is [-1,+1], so the distance between each texel is 2/Size.\r\n        const du = 2.0 / cubeInfo.size;\r\n        const dv = du;\r\n\r\n        const halfTexel = 0.5 * du;\r\n\r\n        // The (u,v) of the first texel is half a texel from the corner (-1,-1).\r\n        const minUV = halfTexel - 1.0;\r\n\r\n        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {\r\n            const fileFace = this._FileFaces[faceIndex];\r\n            const dataArray = (<any>cubeInfo)[fileFace.name];\r\n            let v = minUV;\r\n\r\n            // TODO: we could perform the summation directly into a SphericalPolynomial (SP), which is more efficient than SphericalHarmonic (SH).\r\n            // This is possible because during the summation we do not need the SH-specific properties, e.g. orthogonality.\r\n            // Because SP is still linear, so summation is fine in that basis.\r\n            const stride = cubeInfo.format === Constants.TEXTUREFORMAT_RGBA ? 4 : 3;\r\n            for (let y = 0; y < cubeInfo.size; y++) {\r\n                let u = minUV;\r\n\r\n                for (let x = 0; x < cubeInfo.size; x++) {\r\n                    // World direction (not normalised)\r\n                    const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);\r\n                    worldDirection.normalize();\r\n\r\n                    const deltaSolidAngle =\r\n                        this._AreaElement(u - halfTexel, v - halfTexel) -\r\n                        this._AreaElement(u - halfTexel, v + halfTexel) -\r\n                        this._AreaElement(u + halfTexel, v - halfTexel) +\r\n                        this._AreaElement(u + halfTexel, v + halfTexel);\r\n\r\n                    let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];\r\n                    let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];\r\n                    let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];\r\n\r\n                    // Prevent NaN harmonics with extreme HDRI data.\r\n                    if (isNaN(r)) {\r\n                        r = 0;\r\n                    }\r\n                    if (isNaN(g)) {\r\n                        g = 0;\r\n                    }\r\n                    if (isNaN(b)) {\r\n                        b = 0;\r\n                    }\r\n\r\n                    // Handle Integer types.\r\n                    if (cubeInfo.type === Constants.TEXTURETYPE_UNSIGNED_BYTE) {\r\n                        r /= 255;\r\n                        g /= 255;\r\n                        b /= 255;\r\n                    }\r\n\r\n                    // Handle Gamma space textures.\r\n                    if (cubeInfo.gammaSpace) {\r\n                        r = Math.pow(Clamp(r), ToLinearSpace);\r\n                        g = Math.pow(Clamp(g), ToLinearSpace);\r\n                        b = Math.pow(Clamp(b), ToLinearSpace);\r\n                    }\r\n\r\n                    // Prevent to explode in case of really high dynamic ranges.\r\n                    // sh 3 would not be enough to accurately represent it.\r\n                    const max = this.MAX_HDRI_VALUE;\r\n                    if (this.PRESERVE_CLAMPED_COLORS) {\r\n                        const currentMax = Math.max(r, g, b);\r\n                        if (currentMax > max) {\r\n                            const factor = max / currentMax;\r\n                            r *= factor;\r\n                            g *= factor;\r\n                            b *= factor;\r\n                        }\r\n                    } else {\r\n                        r = Clamp(r, 0, max);\r\n                        g = Clamp(g, 0, max);\r\n                        b = Clamp(b, 0, max);\r\n                    }\r\n\r\n                    const color = new Color3(r, g, b);\r\n\r\n                    sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);\r\n\r\n                    totalSolidAngle += deltaSolidAngle;\r\n\r\n                    u += du;\r\n                }\r\n\r\n                v += dv;\r\n            }\r\n        }\r\n\r\n        // Solid angle for entire sphere is 4*pi\r\n        const sphereSolidAngle = 4.0 * Math.PI;\r\n\r\n        // Adjust the solid angle to allow for how many faces we processed.\r\n        const facesProcessed = 6.0;\r\n        const expectedSolidAngle = (sphereSolidAngle * facesProcessed) / 6.0;\r\n\r\n        // Adjust the harmonics so that the accumulated solid angle matches the expected solid angle.\r\n        // This is needed because the numerical integration over the cube uses a\r\n        // small angle approximation of solid angle for each texel (see deltaSolidAngle),\r\n        // and also to compensate for accumulative error due to float precision in the summation.\r\n        const correctionFactor = expectedSolidAngle / totalSolidAngle;\r\n        sphericalHarmonics.scaleInPlace(correctionFactor);\r\n\r\n        sphericalHarmonics.convertIncidentRadianceToIrradiance();\r\n        sphericalHarmonics.convertIrradianceToLambertianRadiance();\r\n\r\n        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
