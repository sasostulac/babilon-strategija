{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/materialPluginManager.ts", "../../../dev/core/src/Materials/materialPluginBase.ts", "../../../dev/core/src/Materials/material.detailMapConfiguration.ts"],
  "sourcesContent": ["import type { _IProcessingOptions, ShaderCustomProcessingFunction } from \"../Engines/Processors/shaderProcessingOptions\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport type {\r\n    MaterialPluginPrepareEffect,\r\n    MaterialPluginBindForSubMesh,\r\n    MaterialPluginDisposed,\r\n    MaterialPluginGetActiveTextures,\r\n    MaterialPluginGetAnimatables,\r\n    MaterialPluginGetDefineNames,\r\n    MaterialPluginHasTexture,\r\n    MaterialPluginIsReadyForSubMesh,\r\n    MaterialPluginPrepareDefines,\r\n    MaterialPluginPrepareUniformBuffer,\r\n    MaterialPluginHardBindForSubMesh,\r\n    MaterialPluginHasRenderTargetTextures,\r\n    MaterialPluginFillRenderTargetTextures,\r\n} from \"./materialPluginEvent\";\r\nimport { MaterialPluginEvent } from \"./materialPluginEvent\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { ProcessIncludes } from \"../Engines/Processors/shaderProcessor\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\nimport { ShaderStore } from \"../Engines/shaderStore\";\r\n\r\ndeclare module \"./material\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Material {\r\n        /**\r\n         * Plugin manager for this material\r\n         */\r\n        pluginManager?: MaterialPluginManager;\r\n    }\r\n}\r\n\r\nconst RxOption = new RegExp(\"^([gimus]+)!\");\r\n\r\n/**\r\n * Class that manages the plugins of a material\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginManager {\r\n    /** Map a plugin class name to a #define name (used in the vertex/fragment shaders as a marker of the plugin usage) */\r\n    private static _MaterialPluginClassToMainDefine: { [name: string]: string } = {};\r\n    private static _MaterialPluginCounter: number = 0;\r\n\r\n    protected _material: Material;\r\n    protected _scene: Scene;\r\n    protected _engine: AbstractEngine;\r\n    /** @internal */\r\n    public _plugins: MaterialPluginBase[] = [];\r\n    protected _activePlugins: MaterialPluginBase[] = [];\r\n    protected _activePluginsForExtraEvents: MaterialPluginBase[] = [];\r\n    protected _codeInjectionPoints: { [shaderType: string]: { [codeName: string]: boolean } };\r\n    protected _defineNamesFromPlugins?: { [name: string]: { type: string; default: any } };\r\n    protected _uboDeclaration: string;\r\n    protected _vertexDeclaration: string;\r\n    protected _fragmentDeclaration: string;\r\n    protected _uniformList: string[];\r\n    protected _samplerList: string[];\r\n    protected _uboList: string[];\r\n\r\n    static {\r\n        EngineStore.OnEnginesDisposedObservable.add(() => {\r\n            UnregisterAllMaterialPlugins();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the plugin manager\r\n     * @param material material that this manager will manage the plugins for\r\n     */\r\n    constructor(material: Material) {\r\n        this._material = material;\r\n        this._scene = material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _addPlugin(plugin: MaterialPluginBase): boolean {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === plugin.name) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        if (this._material._uniformBufferLayoutBuilt) {\r\n            this._material.resetDrawCache();\r\n            this._material._createUniformBuffer();\r\n        }\r\n\r\n        if (!plugin.isCompatible(this._material.shaderLanguage)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw `The plugin \"${plugin.name}\" can't be added to the material \"${this._material.name}\" because the plugin is not compatible with the shader language of the material.`;\r\n        }\r\n\r\n        const pluginClassName = plugin.getClassName();\r\n        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {\r\n            MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = \"MATERIALPLUGIN_\" + ++MaterialPluginManager._MaterialPluginCounter;\r\n        }\r\n\r\n        this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);\r\n\r\n        this._plugins.push(plugin);\r\n        this._plugins.sort((a, b) => a.priority - b.priority);\r\n\r\n        this._codeInjectionPoints = {};\r\n\r\n        const defineNamesFromPlugins: { [name: string]: { type: string; default: any } } = {};\r\n        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {\r\n            type: \"boolean\",\r\n            default: true,\r\n        };\r\n\r\n        for (const plugin of this._plugins) {\r\n            plugin.collectDefines(defineNamesFromPlugins);\r\n            this._collectPointNames(\"vertex\", plugin.getCustomCode(\"vertex\", this._material.shaderLanguage));\r\n            this._collectPointNames(\"fragment\", plugin.getCustomCode(\"fragment\", this._material.shaderLanguage));\r\n        }\r\n\r\n        this._defineNamesFromPlugins = defineNamesFromPlugins;\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activatePlugin(plugin: MaterialPluginBase): void {\r\n        if (this._activePlugins.indexOf(plugin) === -1) {\r\n            this._activePlugins.push(plugin);\r\n            this._activePlugins.sort((a, b) => a.priority - b.priority);\r\n\r\n            this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);\r\n            this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);\r\n            this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);\r\n            this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);\r\n\r\n            if (plugin.registerForExtraEvents) {\r\n                this._activePluginsForExtraEvents.push(plugin);\r\n                this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);\r\n                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);\r\n                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a plugin from the list of plugins managed by this manager\r\n     * @param name name of the plugin\r\n     * @returns the plugin if found, else null\r\n     */\r\n    public getPlugin<T = MaterialPluginBase>(name: string): Nullable<T> {\r\n        for (let i = 0; i < this._plugins.length; ++i) {\r\n            if (this._plugins[i].name === name) {\r\n                return this._plugins[i] as T;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    protected _handlePluginEventIsReadyForSubMesh(eventData: MaterialPluginIsReadyForSubMesh): void {\r\n        let isReady = true;\r\n        for (const plugin of this._activePlugins) {\r\n            isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n        eventData.isReadyForSubMesh = isReady;\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefinesBeforeAttributes(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventPrepareDefines(eventData: MaterialPluginPrepareDefines): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHardBindForSubMesh(eventData: MaterialPluginHardBindForSubMesh): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventBindForSubMesh(eventData: MaterialPluginBindForSubMesh): void {\r\n        for (const plugin of this._activePlugins) {\r\n            plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEventHasRenderTargetTextures(eventData: MaterialPluginHasRenderTargetTextures): void {\r\n        let hasRenderTargetTextures = false;\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            hasRenderTargetTextures = plugin.hasRenderTargetTextures();\r\n            if (hasRenderTargetTextures) {\r\n                break;\r\n            }\r\n        }\r\n        eventData.hasRenderTargetTextures = hasRenderTargetTextures;\r\n    }\r\n\r\n    protected _handlePluginEventFillRenderTargetTextures(eventData: MaterialPluginFillRenderTargetTextures): void {\r\n        for (const plugin of this._activePluginsForExtraEvents) {\r\n            plugin.fillRenderTargetTextures(eventData.renderTargets);\r\n        }\r\n    }\r\n\r\n    protected _handlePluginEvent(\r\n        id: number,\r\n        info:\r\n            | MaterialPluginGetActiveTextures\r\n            | MaterialPluginGetAnimatables\r\n            | MaterialPluginHasTexture\r\n            | MaterialPluginDisposed\r\n            | MaterialPluginGetDefineNames\r\n            | MaterialPluginPrepareEffect\r\n            | MaterialPluginPrepareUniformBuffer\r\n    ): void {\r\n        switch (id) {\r\n            case MaterialPluginEvent.GetActiveTextures: {\r\n                const eventData = info as MaterialPluginGetActiveTextures;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getActiveTextures(eventData.activeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetAnimatables: {\r\n                const eventData = info as MaterialPluginGetAnimatables;\r\n                for (const plugin of this._activePlugins) {\r\n                    plugin.getAnimatables(eventData.animatables);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.HasTexture: {\r\n                const eventData = info as MaterialPluginHasTexture;\r\n                let hasTexture = false;\r\n                for (const plugin of this._activePlugins) {\r\n                    hasTexture = plugin.hasTexture(eventData.texture);\r\n                    if (hasTexture) {\r\n                        break;\r\n                    }\r\n                }\r\n                eventData.hasTexture = hasTexture;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.Disposed: {\r\n                const eventData = info as MaterialPluginDisposed;\r\n                for (const plugin of this._plugins) {\r\n                    plugin.dispose(eventData.forceDisposeTextures);\r\n                }\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.GetDefineNames: {\r\n                const eventData = info as MaterialPluginGetDefineNames;\r\n                eventData.defineNames = this._defineNamesFromPlugins;\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareEffect: {\r\n                const eventData = info as MaterialPluginPrepareEffect;\r\n                for (const plugin of this._activePlugins) {\r\n                    eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);\r\n                    plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);\r\n                }\r\n                if (this._uniformList.length > 0) {\r\n                    eventData.uniforms.push(...this._uniformList);\r\n                }\r\n                if (this._samplerList.length > 0) {\r\n                    eventData.samplers.push(...this._samplerList);\r\n                }\r\n                if (this._uboList.length > 0) {\r\n                    eventData.uniformBuffersNames.push(...this._uboList);\r\n                }\r\n                eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);\r\n                break;\r\n            }\r\n\r\n            case MaterialPluginEvent.PrepareUniformBuffer: {\r\n                const eventData = info as MaterialPluginPrepareUniformBuffer;\r\n                this._uboDeclaration = \"\";\r\n                this._vertexDeclaration = \"\";\r\n                this._fragmentDeclaration = \"\";\r\n                this._uniformList = [];\r\n                this._samplerList = [];\r\n                this._uboList = [];\r\n                const isWebGPU = this._material.shaderLanguage === ShaderLanguage.WGSL;\r\n                for (const plugin of this._plugins) {\r\n                    const uniforms = plugin.getUniforms(this._material.shaderLanguage);\r\n                    if (uniforms) {\r\n                        if (uniforms.ubo) {\r\n                            for (const uniform of uniforms.ubo) {\r\n                                if (uniform.size && uniform.type) {\r\n                                    const arraySize = uniform.arraySize ?? 0;\r\n                                    eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);\r\n                                    if (isWebGPU) {\r\n                                        let type: string;\r\n                                        switch (uniform.type) {\r\n                                            case \"mat4\":\r\n                                                type = \"mat4x4f\";\r\n                                                break;\r\n                                            case \"float\":\r\n                                                type = \"f32\";\r\n                                                break;\r\n                                            default:\r\n                                                type = `${uniform.type}f`;\r\n                                                break;\r\n                                        }\r\n\r\n                                        if (arraySize > 0) {\r\n                                            this._uboDeclaration += `uniform ${uniform.name}: array<${type}, ${arraySize}>;\\n`;\r\n                                        } else {\r\n                                            this._uboDeclaration += `uniform ${uniform.name}: ${type};\\n`;\r\n                                        }\r\n                                    } else {\r\n                                        this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : \"\"};\\n`;\r\n                                    }\r\n                                }\r\n                                this._uniformList.push(uniform.name);\r\n                            }\r\n                        }\r\n                        if (uniforms.vertex) {\r\n                            this._vertexDeclaration += uniforms.vertex + \"\\n\";\r\n                        }\r\n                        if (uniforms.fragment) {\r\n                            this._fragmentDeclaration += uniforms.fragment + \"\\n\";\r\n                        }\r\n\r\n                        // These are uniforms which are used by the shader but not updated by the plugin directly.\r\n                        // They still need to be present in the _uniformList so the Effect can determine their locations.\r\n                        if (uniforms.externalUniforms) {\r\n                            this._uniformList.push(...uniforms.externalUniforms);\r\n                        }\r\n                    }\r\n                    plugin.getSamplers(this._samplerList);\r\n                    plugin.getUniformBuffersNames(this._uboList);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected _collectPointNames(shaderType: string, customCode: Nullable<{ [pointName: string]: string }> | undefined): void {\r\n        if (!customCode) {\r\n            return;\r\n        }\r\n        for (const pointName in customCode) {\r\n            if (!this._codeInjectionPoints[shaderType]) {\r\n                this._codeInjectionPoints[shaderType] = {};\r\n            }\r\n            this._codeInjectionPoints[shaderType][pointName] = true;\r\n        }\r\n    }\r\n\r\n    protected _injectCustomCode(eventData: MaterialPluginPrepareEffect, existingCallback?: (shaderType: string, code: string) => string): ShaderCustomProcessingFunction {\r\n        return (shaderType: string, code: string) => {\r\n            if (existingCallback) {\r\n                code = existingCallback(shaderType, code);\r\n            }\r\n            if (this._uboDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_UBO_DECLARATION\", this._uboDeclaration);\r\n            }\r\n            if (this._vertexDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_VERTEX_DECLARATION\", this._vertexDeclaration);\r\n            }\r\n            if (this._fragmentDeclaration) {\r\n                code = code.replace(\"#define ADDITIONAL_FRAGMENT_DECLARATION\", this._fragmentDeclaration);\r\n            }\r\n            const points = this._codeInjectionPoints?.[shaderType];\r\n            if (!points) {\r\n                return code;\r\n            }\r\n            let processorOptions: Nullable<_IProcessingOptions> = null;\r\n            for (let pointName in points) {\r\n                let injectedCode = \"\";\r\n                for (const plugin of this._activePlugins) {\r\n                    let customCode = plugin.getCustomCode(shaderType, this._material.shaderLanguage)?.[pointName];\r\n                    if (!customCode) {\r\n                        continue;\r\n                    }\r\n                    if (plugin.resolveIncludes) {\r\n                        if (processorOptions === null) {\r\n                            const shaderLanguage = ShaderLanguage.GLSL;\r\n                            processorOptions = {\r\n                                defines: [], // not used by _ProcessIncludes\r\n                                indexParameters: eventData.indexParameters,\r\n                                isFragment: false,\r\n                                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,\r\n                                processor: undefined as any, // not used by _ProcessIncludes\r\n                                supportsUniformBuffers: this._engine.supportsUniformBuffers,\r\n                                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),\r\n                                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),\r\n                                version: undefined as any, // not used by _ProcessIncludes\r\n                                platformName: this._engine.shaderPlatformName,\r\n                                processingContext: undefined as any, // not used by _ProcessIncludes\r\n                                isNDCHalfZRange: this._engine.isNDCHalfZRange,\r\n                                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,\r\n                                processCodeAfterIncludes: undefined as any, // not used by _ProcessIncludes\r\n                            };\r\n                        }\r\n                        processorOptions.isFragment = shaderType === \"fragment\";\r\n                        ProcessIncludes(customCode, processorOptions, (code) => (customCode = code));\r\n                    }\r\n                    injectedCode += customCode + \"\\n\";\r\n                }\r\n                if (injectedCode.length > 0) {\r\n                    if (pointName.charAt(0) === \"!\") {\r\n                        // pointName is a regular expression\r\n                        pointName = pointName.substring(1);\r\n\r\n                        let regexFlags = \"g\";\r\n                        if (pointName.charAt(0) === \"!\") {\r\n                            // no flags\r\n                            regexFlags = \"\";\r\n                            pointName = pointName.substring(1);\r\n                        } else {\r\n                            // get the flag(s)\r\n                            const matchOption = RxOption.exec(pointName);\r\n                            if (matchOption && matchOption.length >= 2) {\r\n                                regexFlags = matchOption[1];\r\n                                pointName = pointName.substring(regexFlags.length + 1);\r\n                            }\r\n                        }\r\n\r\n                        if (regexFlags.indexOf(\"g\") < 0) {\r\n                            // we force the \"g\" flag so that the regexp object is stateful!\r\n                            regexFlags += \"g\";\r\n                        }\r\n\r\n                        const sourceCode = code;\r\n                        const rx = new RegExp(pointName, regexFlags);\r\n                        let match = rx.exec(sourceCode);\r\n                        while (match !== null) {\r\n                            let newCode = injectedCode;\r\n                            for (let i = 0; i < match.length; ++i) {\r\n                                newCode = newCode.replace(\"$\" + i, match[i]);\r\n                            }\r\n                            code = code.replace(match[0], newCode);\r\n                            match = rx.exec(sourceCode);\r\n                        }\r\n                    } else {\r\n                        const fullPointName = \"#define \" + pointName;\r\n                        code = code.replace(fullPointName, \"\\n\" + injectedCode + \"\\n\" + fullPointName);\r\n                    }\r\n                }\r\n            }\r\n            return code;\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Type for plugin material factories.\r\n */\r\nexport type PluginMaterialFactory = (material: Material) => Nullable<MaterialPluginBase>;\r\n\r\nconst Plugins: Array<[string, PluginMaterialFactory]> = [];\r\nlet Inited = false;\r\nlet MaterialObserver: Nullable<Observer<Material>> = null;\r\n\r\n/**\r\n * Registers a new material plugin through a factory, or updates it. This makes the plugin available to all materials instantiated after its registration.\r\n * @param pluginName The plugin name\r\n * @param factory The factory function which allows to create the plugin\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function RegisterMaterialPlugin(pluginName: string, factory: PluginMaterialFactory): void {\r\n    if (!Inited) {\r\n        MaterialObserver = Material.OnEventObservable.add((material: Material) => {\r\n            for (const [, factory] of Plugins) {\r\n                factory(material);\r\n            }\r\n        }, MaterialPluginEvent.Created);\r\n        Inited = true;\r\n    }\r\n    const existing = Plugins.filter(([name, _factory]) => name === pluginName);\r\n    if (existing.length > 0) {\r\n        existing[0][1] = factory;\r\n    } else {\r\n        Plugins.push([pluginName, factory]);\r\n    }\r\n}\r\n\r\n/**\r\n * Removes a material plugin from the list of global plugins.\r\n * @param pluginName The plugin name\r\n * @returns true if the plugin has been removed, else false\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterMaterialPlugin(pluginName: string): boolean {\r\n    for (let i = 0; i < Plugins.length; ++i) {\r\n        if (Plugins[i][0] === pluginName) {\r\n            Plugins.splice(i, 1);\r\n            if (Plugins.length === 0) {\r\n                UnregisterAllMaterialPlugins();\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Clear the list of global material plugins\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function UnregisterAllMaterialPlugins(): void {\r\n    Plugins.length = 0;\r\n    Inited = false;\r\n    Material.OnEventObservable.remove(MaterialObserver);\r\n    MaterialObserver = null;\r\n}\r\n", "import { serialize } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { MaterialPluginManager } from \"./materialPluginManager\";\r\nimport type { SmartArray } from \"../Misc/smartArray\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { Material } from \"./material\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { RenderTargetTexture } from \"./Textures/renderTargetTexture\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"./shaderLanguage\";\r\n\r\n/**\r\n * Base class for material plugins.\r\n * @since 5.0\r\n */\r\nexport class MaterialPluginBase {\r\n    /**\r\n     * Defines the name of the plugin\r\n     */\r\n    @serialize()\r\n    public name: string;\r\n\r\n    /**\r\n     * Defines the priority of the plugin. Lower numbers run first.\r\n     */\r\n    @serialize()\r\n    public priority: number = 500;\r\n\r\n    /**\r\n     * Indicates that any #include directive in the plugin code must be replaced by the corresponding code.\r\n     */\r\n    @serialize()\r\n    public resolveIncludes: boolean = false;\r\n\r\n    /**\r\n     * Indicates that this plugin should be notified for the extra events (HasRenderTargetTextures / FillRenderTargetTextures / HardBindForSubMesh)\r\n     */\r\n    @serialize()\r\n    public registerForExtraEvents: boolean = false;\r\n\r\n    /**\r\n     * Specifies if the material plugin should be serialized, `true` to skip serialization\r\n     */\r\n    public doNotSerialize = false;\r\n\r\n    protected _material: Material;\r\n    protected _pluginManager: MaterialPluginManager;\r\n    protected _pluginDefineNames?: { [name: string]: any };\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @param shaderLanguage The shader language to use.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public isCompatible(shaderLanguage: ShaderLanguage): boolean {\r\n        switch (shaderLanguage) {\r\n            case ShaderLanguage.GLSL:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    protected _enable(enable: boolean) {\r\n        if (enable) {\r\n            this._pluginManager._activatePlugin(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper function to mark defines as being dirty.\r\n     */\r\n    public readonly markAllDefinesAsDirty: () => void;\r\n\r\n    /**\r\n     * Creates a new material plugin\r\n     * @param material parent material of the plugin\r\n     * @param name name of the plugin\r\n     * @param priority priority of the plugin\r\n     * @param defines list of defines used by the plugin. The value of the property is the default value for this property\r\n     * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)\r\n     * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)\r\n     * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)\r\n     */\r\n    constructor(material: Material, name: string, priority: number, defines?: { [key: string]: any }, addToPluginList = true, enable = false, resolveIncludes = false) {\r\n        this._material = material;\r\n        this.name = name;\r\n        this.priority = priority;\r\n        this.resolveIncludes = resolveIncludes;\r\n\r\n        if (!material.pluginManager) {\r\n            material.pluginManager = new MaterialPluginManager(material);\r\n            material.onDisposeObservable.add(() => {\r\n                material.pluginManager = undefined;\r\n            });\r\n        }\r\n\r\n        this._pluginDefineNames = defines;\r\n        this._pluginManager = material.pluginManager;\r\n\r\n        if (addToPluginList) {\r\n            this._pluginManager._addPlugin(this);\r\n        }\r\n\r\n        if (enable) {\r\n            this._enable(true);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty = material._dirtyCallbacks[Constants.MATERIAL_AllDirtyFlag];\r\n    }\r\n\r\n    /**\r\n     * Gets the current class name useful for serialization or dynamic coding.\r\n     * @returns The class name.\r\n     */\r\n    public getClassName(): string {\r\n        return \"MaterialPluginBase\";\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine the engine this scene belongs to.\r\n     * @param _subMesh the submesh to check for readiness\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public isReadyForSubMesh(_defines: MaterialDefines, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Binds the material data (this function is called even if mustRebind() returns false)\r\n     * @param _uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine defines the engine the material belongs to.\r\n     * @param _subMesh the submesh to bind data for\r\n     */\r\n    public hardBindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Binds the material data.\r\n     * @param _uniformBuffer defines the Uniform buffer to fill in.\r\n     * @param _scene defines the scene the material belongs to.\r\n     * @param _engine the engine this scene belongs to.\r\n     * @param _subMesh the submesh to bind data for\r\n     */\r\n    public bindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): void {}\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param _forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public dispose(_forceDisposeTextures?: boolean): void {}\r\n\r\n    /**\r\n     * Returns a list of custom shader code fragments to customize the shader.\r\n     * @param _shaderType \"vertex\" or \"fragment\"\r\n     * @param _shaderLanguage The shader language to use.\r\n     * @returns null if no code to be added, or a list of pointName =\\> code.\r\n     * Note that `pointName` can also be a regular expression if it starts with a `!`.\r\n     * In that case, the string found by the regular expression (if any) will be\r\n     * replaced by the code provided.\r\n     */\r\n    public getCustomCode(_shaderType: string, _shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Collects all defines.\r\n     * @param defines The object to append to.\r\n     */\r\n    public collectDefines(defines: { [name: string]: { type: string; default: any } }): void {\r\n        if (!this._pluginDefineNames) {\r\n            return;\r\n        }\r\n        for (const key of Object.keys(this._pluginDefineNames)) {\r\n            if (key[0] === \"_\") {\r\n                continue;\r\n            }\r\n\r\n            const type = typeof this._pluginDefineNames[key];\r\n            defines[key] = {\r\n                type: type === \"number\" ? \"number\" : type === \"string\" ? \"string\" : type === \"boolean\" ? \"boolean\" : \"object\",\r\n                default: this._pluginDefineNames[key],\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene to the material belongs to.\r\n     * @param _mesh the mesh being rendered\r\n     */\r\n    public prepareDefinesBeforeAttributes(_defines: MaterialDefines, _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Sets the defines for the next rendering\r\n     * @param _defines the list of \"defines\" to update.\r\n     * @param _scene defines the scene to the material belongs to.\r\n     * @param _mesh the mesh being rendered\r\n     */\r\n    public prepareDefines(_defines: MaterialDefines, _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param _texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public hasTexture(_texture: BaseTexture): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     * @returns true if this uses a render target otherwise false.\r\n     */\r\n    public hasRenderTargetTextures(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Fills the list of render target textures.\r\n     * @param _renderTargets the list of render targets to update\r\n     */\r\n    public fillRenderTargetTextures(_renderTargets: SmartArray<RenderTargetTexture>): void {}\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @param _activeTextures Array of BaseTextures\r\n     */\r\n    public getActiveTextures(_activeTextures: BaseTexture[]): void {}\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * @param _animatables Array of animatable textures.\r\n     */\r\n    public getAnimatables(_animatables: IAnimatable[]): void {}\r\n\r\n    /**\r\n     * Add fallbacks to the effect fallbacks list.\r\n     * @param defines defines the Base texture to use.\r\n     * @param fallbacks defines the current fallback list.\r\n     * @param currentRank defines the current fallback rank.\r\n     * @returns the new fallback rank.\r\n     */\r\n    public addFallbacks(defines: MaterialDefines, fallbacks: EffectFallbacks, currentRank: number): number {\r\n        return currentRank;\r\n    }\r\n\r\n    /**\r\n     * Gets the samplers used by the plugin.\r\n     * @param _samplers list that the sampler names should be added to.\r\n     */\r\n    public getSamplers(_samplers: string[]): void {}\r\n\r\n    /**\r\n     * Gets the attributes used by the plugin.\r\n     * @param _attributes list that the attribute names should be added to.\r\n     * @param _scene the scene that the material belongs to.\r\n     * @param _mesh the mesh being rendered.\r\n     */\r\n    public getAttributes(_attributes: string[], _scene: Scene, _mesh: AbstractMesh): void {}\r\n\r\n    /**\r\n     * Gets the uniform buffers names added by the plugin.\r\n     * @param _ubos list that the ubo names should be added to.\r\n     */\r\n    public getUniformBuffersNames(_ubos: string[]): void {}\r\n\r\n    /**\r\n     * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)\r\n     * @param _shaderLanguage The shader language to use.\r\n     * @returns the description of the uniforms\r\n     */\r\n    public getUniforms(_shaderLanguage = ShaderLanguage.GLSL): {\r\n        ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>;\r\n        vertex?: string;\r\n        fragment?: string;\r\n        externalUniforms?: string[];\r\n    } {\r\n        return {};\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public copyTo(plugin: MaterialPluginBase): void {\r\n        SerializationHelper.Clone(() => plugin, this);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin configuration.\r\n     * @returns - An object with the serialized config.\r\n     */\r\n    public serialize(): any {\r\n        return SerializationHelper.Serialize(this);\r\n    }\r\n\r\n    /**\r\n     * Parses a plugin configuration from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene Defines the scene we are parsing for\r\n     * @param rootUrl Defines the rootUrl to load from\r\n     */\r\n    public parse(source: any, scene: Scene, rootUrl: string): void {\r\n        SerializationHelper.Parse(() => this, source, scene, rootUrl);\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.MaterialPluginBase\", MaterialPluginBase);\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Material } from \"./material\";\r\nimport { serialize, expandToProperty, serializeAsTexture } from \"../Misc/decorators\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { MaterialDefines } from \"./materialDefines\";\r\nimport { MaterialPluginBase } from \"./materialPluginBase\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport type { StandardMaterial } from \"./standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"./PBR/pbrBaseMaterial\";\r\nimport { BindTextureMatrix, PrepareDefinesForMergedUV } from \"./materialHelper.functions\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialDetailMapDefines extends MaterialDefines {\r\n    DETAIL = false;\r\n    DETAILDIRECTUV = 0;\r\n    DETAIL_NORMALBLENDMETHOD = 0;\r\n}\r\n\r\n/**\r\n * Plugin that implements the detail map component of a material\r\n *\r\n * Inspired from:\r\n *   Unity: https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@9.0/manual/Mask-Map-and-Detail-Map.html and https://docs.unity3d.com/Manual/StandardShaderMaterialParameterDetail.html\r\n *   Unreal: https://docs.unrealengine.com/en-US/Engine/Rendering/Materials/HowTo/DetailTexturing/index.html\r\n *   Cryengine: https://docs.cryengine.com/display/SDKDOC2/Detail+Maps\r\n */\r\nexport class DetailMapConfiguration extends MaterialPluginBase {\r\n    private _texture: Nullable<BaseTexture> = null;\r\n    /**\r\n     * The detail texture of the material.\r\n     */\r\n    @serializeAsTexture(\"detailTexture\")\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public texture: Nullable<BaseTexture>;\r\n\r\n    /**\r\n     * Defines how strongly the detail diffuse/albedo channel is blended with the regular diffuse/albedo texture\r\n     * Bigger values mean stronger blending\r\n     */\r\n    @serialize()\r\n    public diffuseBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strongly the detail roughness channel is blended with the regular roughness value\r\n     * Bigger values mean stronger blending. Only used with PBR materials\r\n     */\r\n    @serialize()\r\n    public roughnessBlendLevel = 1;\r\n\r\n    /**\r\n     * Defines how strong the bump effect from the detail map is\r\n     * Bigger values mean stronger effect\r\n     */\r\n    @serialize()\r\n    public bumpLevel = 1;\r\n\r\n    private _normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;\r\n    /**\r\n     * The method used to blend the bump and detail normals together\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public normalBlendMethod: number;\r\n\r\n    private _isEnabled = false;\r\n    /**\r\n     * Enable or disable the detail map on this material\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public isEnabled = false;\r\n\r\n    /** @internal */\r\n    private _internalMarkAllSubMeshesAsTexturesDirty: () => void;\r\n\r\n    /** @internal */\r\n    public _markAllSubMeshesAsTexturesDirty(): void {\r\n        this._enable(this._isEnabled);\r\n        this._internalMarkAllSubMeshesAsTexturesDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language.\r\n     * @returns true if the plugin is compatible with the shader language\r\n     */\r\n    public override isCompatible(): boolean {\r\n        return true;\r\n    }\r\n\r\n    constructor(material: PBRBaseMaterial | StandardMaterial, addToPluginList = true) {\r\n        super(material, \"DetailMap\", 140, new MaterialDetailMapDefines(), addToPluginList);\r\n\r\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\r\n    }\r\n\r\n    public override isReadyForSubMesh(defines: MaterialDetailMapDefines, scene: Scene, engine: AbstractEngine): boolean {\r\n        if (!this._isEnabled) {\r\n            return true;\r\n        }\r\n\r\n        if (defines._areTexturesDirty && scene.texturesEnabled) {\r\n            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                // Detail texture cannot be not blocking.\r\n                if (!this._texture.isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    public override prepareDefines(defines: MaterialDetailMapDefines, scene: Scene): void {\r\n        if (this._isEnabled) {\r\n            defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n\r\n            const engine = scene.getEngine();\r\n\r\n            if (defines._areTexturesDirty) {\r\n                if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {\r\n                    PrepareDefinesForMergedUV(this._texture, defines, \"DETAIL\");\r\n                    defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;\r\n                } else {\r\n                    defines.DETAIL = false;\r\n                }\r\n            }\r\n        } else {\r\n            defines.DETAIL = false;\r\n        }\r\n    }\r\n\r\n    public override bindForSubMesh(uniformBuffer: UniformBuffer, scene: Scene): void {\r\n        if (!this._isEnabled) {\r\n            return;\r\n        }\r\n\r\n        const isFrozen = this._material.isFrozen;\r\n\r\n        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.updateFloat4(\"vDetailInfos\", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);\r\n                BindTextureMatrix(this._texture, uniformBuffer, \"detail\");\r\n            }\r\n        }\r\n\r\n        // Textures\r\n        if (scene.texturesEnabled) {\r\n            if (this._texture && MaterialFlags.DetailTextureEnabled) {\r\n                uniformBuffer.setTexture(\"detailSampler\", this._texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (this._texture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this._texture) {\r\n            activeTextures.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override getAnimatables(animatables: IAnimatable[]): void {\r\n        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {\r\n            animatables.push(this._texture);\r\n        }\r\n    }\r\n\r\n    public override dispose(forceDisposeTextures?: boolean): void {\r\n        if (forceDisposeTextures) {\r\n            this._texture?.dispose();\r\n        }\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"DetailMapConfiguration\";\r\n    }\r\n\r\n    public override getSamplers(samplers: string[]): void {\r\n        samplers.push(\"detailSampler\");\r\n    }\r\n\r\n    public override getUniforms(): { ubo?: Array<{ name: string; size: number; type: string }>; vertex?: string; fragment?: string } {\r\n        return {\r\n            ubo: [\r\n                { name: \"vDetailInfos\", size: 4, type: \"vec4\" },\r\n                { name: \"detailMatrix\", size: 16, type: \"mat4\" },\r\n            ],\r\n        };\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["plugin", "code", "factory"]
}
