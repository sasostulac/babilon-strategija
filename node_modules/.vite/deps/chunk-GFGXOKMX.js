import {
  Material,
  MaterialDefines
} from "./chunk-PRSXSHZ4.js";
import {
  BindTextureMatrix,
  MaterialFlags,
  PrepareDefinesForMergedUV
} from "./chunk-2VHVG2NH.js";
import {
  SerializationHelper
} from "./chunk-S6GWJ2HV.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsTexture
} from "./chunk-URVCX2UN.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  ProcessIncludes
} from "./chunk-OF4ZSZ6U.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  ShaderStore
} from "./chunk-FX6MN5HL.js";

// node_modules/@babylonjs/core/Materials/materialPluginManager.js
var RxOption = new RegExp("^([gimus]+)!");
var MaterialPluginManager = class _MaterialPluginManager {
  /**
   * Creates a new instance of the plugin manager
   * @param material material that this manager will manage the plugins for
   */
  constructor(material) {
    this._plugins = [];
    this._activePlugins = [];
    this._activePluginsForExtraEvents = [];
    this._material = material;
    this._scene = material.getScene();
    this._engine = this._scene.getEngine();
  }
  /**
   * @internal
   */
  _addPlugin(plugin) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === plugin.name) {
        return false;
      }
    }
    if (this._material._uniformBufferLayoutBuilt) {
      this._material.resetDrawCache();
      this._material._createUniformBuffer();
    }
    if (!plugin.isCompatible(this._material.shaderLanguage)) {
      throw `The plugin "${plugin.name}" can't be added to the material "${this._material.name}" because the plugin is not compatible with the shader language of the material.`;
    }
    const pluginClassName = plugin.getClassName();
    if (!_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {
      _MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = "MATERIALPLUGIN_" + ++_MaterialPluginManager._MaterialPluginCounter;
    }
    this._material._callbackPluginEventGeneric = (id, info) => this._handlePluginEvent(id, info);
    this._plugins.push(plugin);
    this._plugins.sort((a, b) => a.priority - b.priority);
    this._codeInjectionPoints = {};
    const defineNamesFromPlugins = {};
    defineNamesFromPlugins[_MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {
      type: "boolean",
      default: true
    };
    for (const plugin2 of this._plugins) {
      plugin2.collectDefines(defineNamesFromPlugins);
      this._collectPointNames("vertex", plugin2.getCustomCode("vertex", this._material.shaderLanguage));
      this._collectPointNames("fragment", plugin2.getCustomCode("fragment", this._material.shaderLanguage));
    }
    this._defineNamesFromPlugins = defineNamesFromPlugins;
    return true;
  }
  /**
   * @internal
   */
  _activatePlugin(plugin) {
    if (this._activePlugins.indexOf(plugin) === -1) {
      this._activePlugins.push(plugin);
      this._activePlugins.sort((a, b) => a.priority - b.priority);
      this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
      this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);
      this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
      this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
      if (plugin.registerForExtraEvents) {
        this._activePluginsForExtraEvents.push(plugin);
        this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);
        this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
        this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
        this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
      }
    }
  }
  /**
   * Gets a plugin from the list of plugins managed by this manager
   * @param name name of the plugin
   * @returns the plugin if found, else null
   */
  getPlugin(name) {
    for (let i = 0; i < this._plugins.length; ++i) {
      if (this._plugins[i].name === name) {
        return this._plugins[i];
      }
    }
    return null;
  }
  _handlePluginEventIsReadyForSubMesh(eventData) {
    let isReady = true;
    for (const plugin of this._activePlugins) {
      isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
    }
    eventData.isReadyForSubMesh = isReady;
  }
  _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventPrepareDefines(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
    }
  }
  _handlePluginEventHardBindForSubMesh(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventBindForSubMesh(eventData) {
    for (const plugin of this._activePlugins) {
      plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
    }
  }
  _handlePluginEventHasRenderTargetTextures(eventData) {
    let hasRenderTargetTextures = false;
    for (const plugin of this._activePluginsForExtraEvents) {
      hasRenderTargetTextures = plugin.hasRenderTargetTextures();
      if (hasRenderTargetTextures) {
        break;
      }
    }
    eventData.hasRenderTargetTextures = hasRenderTargetTextures;
  }
  _handlePluginEventFillRenderTargetTextures(eventData) {
    for (const plugin of this._activePluginsForExtraEvents) {
      plugin.fillRenderTargetTextures(eventData.renderTargets);
    }
  }
  _handlePluginEvent(id, info) {
    switch (id) {
      case 512: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getActiveTextures(eventData.activeTextures);
        }
        break;
      }
      case 256: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          plugin.getAnimatables(eventData.animatables);
        }
        break;
      }
      case 1024: {
        const eventData = info;
        let hasTexture = false;
        for (const plugin of this._activePlugins) {
          hasTexture = plugin.hasTexture(eventData.texture);
          if (hasTexture) {
            break;
          }
        }
        eventData.hasTexture = hasTexture;
        break;
      }
      case 2: {
        const eventData = info;
        for (const plugin of this._plugins) {
          plugin.dispose(eventData.forceDisposeTextures);
        }
        break;
      }
      case 4: {
        const eventData = info;
        eventData.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case 128: {
        const eventData = info;
        for (const plugin of this._activePlugins) {
          eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
          plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);
        }
        if (this._uniformList.length > 0) {
          eventData.uniforms.push(...this._uniformList);
        }
        if (this._samplerList.length > 0) {
          eventData.samplers.push(...this._samplerList);
        }
        if (this._uboList.length > 0) {
          eventData.uniformBuffersNames.push(...this._uboList);
        }
        eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);
        break;
      }
      case 8: {
        const eventData = info;
        this._uboDeclaration = "";
        this._vertexDeclaration = "";
        this._fragmentDeclaration = "";
        this._uniformList = [];
        this._samplerList = [];
        this._uboList = [];
        const isWebGPU = this._material.shaderLanguage === 1;
        for (const plugin of this._plugins) {
          const uniforms = plugin.getUniforms(this._material.shaderLanguage);
          if (uniforms) {
            if (uniforms.ubo) {
              for (const uniform of uniforms.ubo) {
                if (uniform.size && uniform.type) {
                  const arraySize = uniform.arraySize ?? 0;
                  eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);
                  if (isWebGPU) {
                    let type;
                    switch (uniform.type) {
                      case "mat4":
                        type = "mat4x4f";
                        break;
                      case "float":
                        type = "f32";
                        break;
                      default:
                        type = `${uniform.type}f`;
                        break;
                    }
                    if (arraySize > 0) {
                      this._uboDeclaration += `uniform ${uniform.name}: array<${type}, ${arraySize}>;
`;
                    } else {
                      this._uboDeclaration += `uniform ${uniform.name}: ${type};
`;
                    }
                  } else {
                    this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : ""};
`;
                  }
                }
                this._uniformList.push(uniform.name);
              }
            }
            if (uniforms.vertex) {
              this._vertexDeclaration += uniforms.vertex + "\n";
            }
            if (uniforms.fragment) {
              this._fragmentDeclaration += uniforms.fragment + "\n";
            }
            if (uniforms.externalUniforms) {
              this._uniformList.push(...uniforms.externalUniforms);
            }
          }
          plugin.getSamplers(this._samplerList);
          plugin.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }
  _collectPointNames(shaderType, customCode) {
    if (!customCode) {
      return;
    }
    for (const pointName in customCode) {
      if (!this._codeInjectionPoints[shaderType]) {
        this._codeInjectionPoints[shaderType] = {};
      }
      this._codeInjectionPoints[shaderType][pointName] = true;
    }
  }
  _injectCustomCode(eventData, existingCallback) {
    return (shaderType, code) => {
      if (existingCallback) {
        code = existingCallback(shaderType, code);
      }
      if (this._uboDeclaration) {
        code = code.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration);
      }
      if (this._vertexDeclaration) {
        code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration);
      }
      if (this._fragmentDeclaration) {
        code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration);
      }
      const points = this._codeInjectionPoints?.[shaderType];
      if (!points) {
        return code;
      }
      let processorOptions = null;
      for (let pointName in points) {
        let injectedCode = "";
        for (const plugin of this._activePlugins) {
          let customCode = plugin.getCustomCode(shaderType, this._material.shaderLanguage)?.[pointName];
          if (!customCode) {
            continue;
          }
          if (plugin.resolveIncludes) {
            if (processorOptions === null) {
              const shaderLanguage = 0;
              processorOptions = {
                defines: [],
                // not used by _ProcessIncludes
                indexParameters: eventData.indexParameters,
                isFragment: false,
                shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                processor: void 0,
                // not used by _ProcessIncludes
                supportsUniformBuffers: this._engine.supportsUniformBuffers,
                shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),
                includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),
                version: void 0,
                // not used by _ProcessIncludes
                platformName: this._engine.shaderPlatformName,
                processingContext: void 0,
                // not used by _ProcessIncludes
                isNDCHalfZRange: this._engine.isNDCHalfZRange,
                useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                processCodeAfterIncludes: void 0
                // not used by _ProcessIncludes
              };
            }
            processorOptions.isFragment = shaderType === "fragment";
            ProcessIncludes(customCode, processorOptions, (code2) => customCode = code2);
          }
          injectedCode += customCode + "\n";
        }
        if (injectedCode.length > 0) {
          if (pointName.charAt(0) === "!") {
            pointName = pointName.substring(1);
            let regexFlags = "g";
            if (pointName.charAt(0) === "!") {
              regexFlags = "";
              pointName = pointName.substring(1);
            } else {
              const matchOption = RxOption.exec(pointName);
              if (matchOption && matchOption.length >= 2) {
                regexFlags = matchOption[1];
                pointName = pointName.substring(regexFlags.length + 1);
              }
            }
            if (regexFlags.indexOf("g") < 0) {
              regexFlags += "g";
            }
            const sourceCode = code;
            const rx = new RegExp(pointName, regexFlags);
            let match = rx.exec(sourceCode);
            while (match !== null) {
              let newCode = injectedCode;
              for (let i = 0; i < match.length; ++i) {
                newCode = newCode.replace("$" + i, match[i]);
              }
              code = code.replace(match[0], newCode);
              match = rx.exec(sourceCode);
            }
          } else {
            const fullPointName = "#define " + pointName;
            code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
          }
        }
      }
      return code;
    };
  }
};
MaterialPluginManager._MaterialPluginClassToMainDefine = {};
MaterialPluginManager._MaterialPluginCounter = 0;
(() => {
  EngineStore.OnEnginesDisposedObservable.add(() => {
    UnregisterAllMaterialPlugins();
  });
})();
var Plugins = [];
var Inited = false;
var MaterialObserver = null;
function RegisterMaterialPlugin(pluginName, factory) {
  if (!Inited) {
    MaterialObserver = Material.OnEventObservable.add(
      (material) => {
        for (const [, factory2] of Plugins) {
          factory2(material);
        }
      },
      1
      /* MaterialPluginEvent.Created */
    );
    Inited = true;
  }
  const existing = Plugins.filter(([name, _factory]) => name === pluginName);
  if (existing.length > 0) {
    existing[0][1] = factory;
  } else {
    Plugins.push([pluginName, factory]);
  }
}
function UnregisterMaterialPlugin(pluginName) {
  for (let i = 0; i < Plugins.length; ++i) {
    if (Plugins[i][0] === pluginName) {
      Plugins.splice(i, 1);
      if (Plugins.length === 0) {
        UnregisterAllMaterialPlugins();
      }
      return true;
    }
  }
  return false;
}
function UnregisterAllMaterialPlugins() {
  Plugins.length = 0;
  Inited = false;
  Material.OnEventObservable.remove(MaterialObserver);
  MaterialObserver = null;
}

// node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase = class {
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @param shaderLanguage The shader language to use.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible(shaderLanguage) {
    switch (shaderLanguage) {
      case 0:
        return true;
      default:
        return false;
    }
  }
  _enable(enable) {
    if (enable) {
      this._pluginManager._activatePlugin(this);
    }
  }
  /**
   * Creates a new material plugin
   * @param material parent material of the plugin
   * @param name name of the plugin
   * @param priority priority of the plugin
   * @param defines list of defines used by the plugin. The value of the property is the default value for this property
   * @param addToPluginList true to add the plugin to the list of plugins managed by the material plugin manager of the material (default: true)
   * @param enable true to enable the plugin (it is handy if the plugin does not handle properties to switch its current activation)
   * @param resolveIncludes Indicates that any #include directive in the plugin code must be replaced by the corresponding code (default: false)
   */
  constructor(material, name, priority, defines, addToPluginList = true, enable = false, resolveIncludes = false) {
    this.priority = 500;
    this.resolveIncludes = false;
    this.registerForExtraEvents = false;
    this.doNotSerialize = false;
    this._material = material;
    this.name = name;
    this.priority = priority;
    this.resolveIncludes = resolveIncludes;
    if (!material.pluginManager) {
      material.pluginManager = new MaterialPluginManager(material);
      material.onDisposeObservable.add(() => {
        material.pluginManager = void 0;
      });
    }
    this._pluginDefineNames = defines;
    this._pluginManager = material.pluginManager;
    if (addToPluginList) {
      this._pluginManager._addPlugin(this);
    }
    if (enable) {
      this._enable(true);
    }
    this.markAllDefinesAsDirty = material._dirtyCallbacks[127];
  }
  /**
   * Gets the current class name useful for serialization or dynamic coding.
   * @returns The class name.
   */
  getClassName() {
    return "MaterialPluginBase";
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param _defines the list of "defines" to update.
   * @param _scene defines the scene the material belongs to.
   * @param _engine the engine this scene belongs to.
   * @param _subMesh the submesh to check for readiness
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(_defines, _scene, _engine, _subMesh) {
    return true;
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param _uniformBuffer defines the Uniform buffer to fill in.
   * @param _scene defines the scene the material belongs to.
   * @param _engine defines the engine the material belongs to.
   * @param _subMesh the submesh to bind data for
   */
  hardBindForSubMesh(_uniformBuffer, _scene, _engine, _subMesh) {
  }
  /**
   * Binds the material data.
   * @param _uniformBuffer defines the Uniform buffer to fill in.
   * @param _scene defines the scene the material belongs to.
   * @param _engine the engine this scene belongs to.
   * @param _subMesh the submesh to bind data for
   */
  bindForSubMesh(_uniformBuffer, _scene, _engine, _subMesh) {
  }
  /**
   * Disposes the resources of the material.
   * @param _forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(_forceDisposeTextures) {
  }
  /**
   * Returns a list of custom shader code fragments to customize the shader.
   * @param _shaderType "vertex" or "fragment"
   * @param _shaderLanguage The shader language to use.
   * @returns null if no code to be added, or a list of pointName =\> code.
   * Note that `pointName` can also be a regular expression if it starts with a `!`.
   * In that case, the string found by the regular expression (if any) will be
   * replaced by the code provided.
   */
  getCustomCode(_shaderType, _shaderLanguage = 0) {
    return null;
  }
  /**
   * Collects all defines.
   * @param defines The object to append to.
   */
  collectDefines(defines) {
    if (!this._pluginDefineNames) {
      return;
    }
    for (const key of Object.keys(this._pluginDefineNames)) {
      if (key[0] === "_") {
        continue;
      }
      const type = typeof this._pluginDefineNames[key];
      defines[key] = {
        type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
        default: this._pluginDefineNames[key]
      };
    }
  }
  /**
   * Sets the defines for the next rendering. Called before PrepareDefinesForAttributes is called.
   * @param _defines the list of "defines" to update.
   * @param _scene defines the scene to the material belongs to.
   * @param _mesh the mesh being rendered
   */
  prepareDefinesBeforeAttributes(_defines, _scene, _mesh) {
  }
  /**
   * Sets the defines for the next rendering
   * @param _defines the list of "defines" to update.
   * @param _scene defines the scene to the material belongs to.
   * @param _mesh the mesh being rendered
   */
  prepareDefines(_defines, _scene, _mesh) {
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param _texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(_texture) {
    return false;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   * @returns true if this uses a render target otherwise false.
   */
  hasRenderTargetTextures() {
    return false;
  }
  /**
   * Fills the list of render target textures.
   * @param _renderTargets the list of render targets to update
   */
  fillRenderTargetTextures(_renderTargets) {
  }
  /**
   * Returns an array of the actively used textures.
   * @param _activeTextures Array of BaseTextures
   */
  getActiveTextures(_activeTextures) {
  }
  /**
   * Returns the animatable textures.
   * @param _animatables Array of animatable textures.
   */
  getAnimatables(_animatables) {
  }
  /**
   * Add fallbacks to the effect fallbacks list.
   * @param defines defines the Base texture to use.
   * @param fallbacks defines the current fallback list.
   * @param currentRank defines the current fallback rank.
   * @returns the new fallback rank.
   */
  addFallbacks(defines, fallbacks, currentRank) {
    return currentRank;
  }
  /**
   * Gets the samplers used by the plugin.
   * @param _samplers list that the sampler names should be added to.
   */
  getSamplers(_samplers) {
  }
  /**
   * Gets the attributes used by the plugin.
   * @param _attributes list that the attribute names should be added to.
   * @param _scene the scene that the material belongs to.
   * @param _mesh the mesh being rendered.
   */
  getAttributes(_attributes, _scene, _mesh) {
  }
  /**
   * Gets the uniform buffers names added by the plugin.
   * @param _ubos list that the ubo names should be added to.
   */
  getUniformBuffersNames(_ubos) {
  }
  /**
   * Gets the description of the uniforms to add to the ubo (if engine supports ubos) or to inject directly in the vertex/fragment shaders (if engine does not support ubos)
   * @param _shaderLanguage The shader language to use.
   * @returns the description of the uniforms
   */
  getUniforms(_shaderLanguage = 0) {
    return {};
  }
  /**
   * Makes a duplicate of the current configuration into another one.
   * @param plugin define the config where to copy the info
   */
  copyTo(plugin) {
    SerializationHelper.Clone(() => plugin, this);
  }
  /**
   * Serializes this plugin configuration.
   * @returns - An object with the serialized config.
   */
  serialize() {
    return SerializationHelper.Serialize(this);
  }
  /**
   * Parses a plugin configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    SerializationHelper.Parse(() => this, source, scene, rootUrl);
  }
};
__decorate([
  serialize()
], MaterialPluginBase.prototype, "name", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "priority", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "resolveIncludes", void 0);
__decorate([
  serialize()
], MaterialPluginBase.prototype, "registerForExtraEvents", void 0);
RegisterClass("BABYLON.MaterialPluginBase", MaterialPluginBase);

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.DETAIL = false;
    this.DETAILDIRECTUV = 0;
    this.DETAIL_NORMALBLENDMETHOD = 0;
  }
};
var DetailMapConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList);
    this._texture = null;
    this.diffuseBlendLevel = 1;
    this.roughnessBlendLevel = 1;
    this.bumpLevel = 1;
    this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
    this._isEnabled = false;
    this.isEnabled = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty && scene.texturesEnabled) {
      if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
        if (!this._texture.isReady()) {
          return false;
        }
      }
    }
    return true;
  }
  prepareDefines(defines, scene) {
    if (this._isEnabled) {
      defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      const engine = scene.getEngine();
      if (defines._areTexturesDirty) {
        if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
          PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
        } else {
          defines.DETAIL = false;
        }
      }
    } else {
      defines.DETAIL = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
        BindTextureMatrix(this._texture, uniformBuffer, "detail");
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.DetailTextureEnabled) {
        uniformBuffer.setTexture("detailSampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
    }
  }
  getClassName() {
    return "DetailMapConfiguration";
  }
  getSamplers(samplers) {
    samplers.push("detailSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serializeAsTexture("detailTexture"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "texture", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "diffuseBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "roughnessBlendLevel", void 0);
__decorate([
  serialize()
], DetailMapConfiguration.prototype, "bumpLevel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "normalBlendMethod", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], DetailMapConfiguration.prototype, "isEnabled", void 0);

export {
  MaterialPluginManager,
  RegisterMaterialPlugin,
  UnregisterMaterialPlugin,
  UnregisterAllMaterialPlugins,
  MaterialPluginBase,
  MaterialDetailMapDefines,
  DetailMapConfiguration
};
//# sourceMappingURL=chunk-GFGXOKMX.js.map
