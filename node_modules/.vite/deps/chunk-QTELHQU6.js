import {
  GetEnvironmentBRDFTexture,
  GetEnvironmentFuzzBRDFTexture
} from "./chunk-54YZUFAJ.js";
import {
  ImageProcessingDefinesMixin,
  ImageProcessingMixin,
  Material,
  MaterialDefines,
  MaterialHelperGeometryRendering,
  PrePassConfiguration,
  PushMaterial,
  UVDefinesMixin
} from "./chunk-PRSXSHZ4.js";
import {
  EffectFallbacks,
  ImageProcessingConfiguration,
  Scene
} from "./chunk-DJTOTRI3.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindIBLParameters,
  BindIBLSamplers,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindTextureMatrix,
  HandleFallbacksForShadows,
  MaterialFlags,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForIBL,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformLayoutForIBL,
  PrepareUniformsAndSamplersForIBL,
  PrepareUniformsAndSamplersList
} from "./chunk-2VHVG2NH.js";
import {
  SmartArray
} from "./chunk-X4TNHLCS.js";
import {
  Texture
} from "./chunk-IKA6V2KA.js";
import {
  SerializationHelper
} from "./chunk-S6GWJ2HV.js";
import {
  __decorate,
  addAccessorsForMaterialProperty,
  expandToProperty,
  serialize
} from "./chunk-URVCX2UN.js";
import {
  Color3
} from "./chunk-5HS37WJT.js";
import {
  TmpVectors,
  Vector2,
  Vector4
} from "./chunk-EURVBQY7.js";
import {
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Materials/PBR/openpbrMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var Uniform = class _Uniform {
  populateVectorFromLinkedProperties(vector) {
    const destinationSize = vector.dimension[0];
    for (const propKey in this.linkedProperties) {
      const prop = this.linkedProperties[propKey];
      const sourceSize = prop.numComponents;
      if (destinationSize < sourceSize || prop.targetUniformComponentOffset > destinationSize - sourceSize) {
        if (sourceSize == 1) {
          Logger.Error(`Float property ${prop.name} has an offset that is too large.`);
        } else {
          Logger.Error(`Vector${sourceSize} property ${prop.name} won't fit in Vector${destinationSize} or has an offset that is too large.`);
        }
        return;
      }
      if (typeof prop.value === "number") {
        _Uniform._tmpArray[prop.targetUniformComponentOffset] = prop.value;
      } else {
        prop.value.toArray(_Uniform._tmpArray, prop.targetUniformComponentOffset);
      }
    }
    vector.fromArray(_Uniform._tmpArray);
  }
  constructor(name, componentNum) {
    this.linkedProperties = {};
    this.name = name;
    this.numComponents = componentNum;
  }
};
Uniform._tmpArray = [0, 0, 0, 0];
var Property = class {
  /**
   * Creates a new Property instance.
   * @param name The name of the property in the shader
   * @param defaultValue The default value of the property
   * @param targetUniformName The name of the property in the shader uniform block
   * @param targetUniformComponentNum The number of components in the target uniform. All properties that are
   * packed into the same uniform must agree on the size of the target uniform.
   * @param targetUniformComponentOffset The offset in the uniform where this property will be packed.
   */
  constructor(name, defaultValue, targetUniformName, targetUniformComponentNum, targetUniformComponentOffset = 0) {
    this.targetUniformComponentNum = 4;
    this.targetUniformComponentOffset = 0;
    this.name = name;
    this.targetUniformName = targetUniformName;
    this.defaultValue = defaultValue;
    this.value = defaultValue;
    this.targetUniformComponentNum = targetUniformComponentNum;
    this.targetUniformComponentOffset = targetUniformComponentOffset;
  }
  /**
   * Returns the number of components of the property based on its default value type.
   */
  get numComponents() {
    if (typeof this.defaultValue === "number") {
      return 1;
    }
    return this.defaultValue.dimension[0];
  }
};
var Sampler = class {
  /**
   * The name of the sampler used in the shader.
   * If this naming changes, we'll also need to change:
   * - samplerFragmentDeclaration.fx
   * - openpbr.fragment.fx
   */
  get samplerName() {
    return this.samplerPrefix + "Sampler";
  }
  /**
   * The name of the sampler info used in the shader.
   * If this naming changes, we'll also need to change:
   * - openpbr.vertex.fx
   * - openpbr.fragment.fx
   */
  get samplerInfoName() {
    return "v" + this.samplerPrefix.charAt(0).toUpperCase() + this.samplerPrefix.slice(1) + "Infos";
  }
  /**
   * The name of the matrix used for this sampler in the shader.
   * If this naming changes, we'll also need to change:
   * - materialHelper.functions.BindTextureMatrix
   * - samplerVertexImplementation.fx
   * - openpbr.fragment.fx
   */
  get samplerMatrixName() {
    return this.samplerPrefix + "Matrix";
  }
  /**
   * Creates a new Sampler instance.
   * @param name The name of the texture property
   * @param samplerPrefix The prefix used for the name of the sampler in the shader
   * @param textureDefine The define used in the shader for this sampler
   */
  constructor(name, samplerPrefix, textureDefine) {
    this.value = null;
    this.samplerPrefix = "";
    this.textureDefine = "";
    this.name = name;
    this.samplerPrefix = samplerPrefix;
    this.textureDefine = textureDefine;
  }
};
var OpenPBRMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
};
var OpenPBRMaterialDefines = class extends ImageProcessingDefinesMixin(OpenPBRMaterialDefinesBase) {
  /**
   * Initializes the PBR Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.NUM_SAMPLES = "0";
    this.REALTIME_FILTERING = false;
    this.IBL_CDF_FILTERING = false;
    this.VERTEXCOLOR = false;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.VERTEXALPHA = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHABLEND = false;
    this.ALPHA_FROM_BASE_COLOR_TEXTURE = false;
    this.ALPHATESTVALUE = "0.5";
    this.PREMULTIPLYALPHA = false;
    this.REFLECTIVITY_GAMMA = false;
    this.REFLECTIVITYDIRECTUV = 0;
    this.SPECULARTERM = false;
    this.LODBASEDMICROSFURACE = true;
    this.METALLICWORKFLOW = true;
    this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    this.METALLNESSSTOREINMETALMAPBLUE = false;
    this.AOSTOREINMETALMAPRED = false;
    this.SPECULAR_WEIGHT_IN_ALPHA = false;
    this.SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = false;
    this.SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;
    this.COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;
    this.USE_GLTF_STYLE_ANISOTROPY = false;
    this.THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = false;
    this.ENVIRONMENTBRDF = false;
    this.ENVIRONMENTBRDF_RGBD = false;
    this.FUZZENVIRONMENTBRDF = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.OBJECTSPACE_NORMALMAP = false;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.NORMALXYSCALE = true;
    this.ANISOTROPIC = false;
    this.ANISOTROPIC_OPENPBR = true;
    this.ANISOTROPIC_BASE = false;
    this.ANISOTROPIC_COAT = false;
    this.FUZZ_IBL_SAMPLES = 6;
    this.FUZZ = false;
    this.THIN_FILM = false;
    this.IRIDESCENCE = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.USESPHERICALFROMREFLECTIONMAP = false;
    this.USEIRRADIANCEMAP = false;
    this.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
    this.USESPHERICALINVERTEX = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.RADIANCEOCCLUSION = false;
    this.HORIZONOCCLUSION = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.PREPASS = false;
    this.PREPASS_COLOR = false;
    this.PREPASS_COLOR_INDEX = -1;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO = false;
    this.PREPASS_ALBEDO_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_SCREENSPACE_DEPTH = false;
    this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
    this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
    this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_WORLD_NORMAL = false;
    this.PREPASS_WORLD_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_LOCAL_POSITION = false;
    this.PREPASS_LOCAL_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_VELOCITY_LINEAR = false;
    this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.NONUNIFORMSCALING = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_POSITION = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.MORPHTARGETS_UV2 = false;
    this.MORPHTARGETS_COLOR = false;
    this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
    this.MORPHTARGETTEXTURE_HASNORMALS = false;
    this.MORPHTARGETTEXTURE_HASTANGENTS = false;
    this.MORPHTARGETTEXTURE_HASUVS = false;
    this.MORPHTARGETTEXTURE_HASUV2S = false;
    this.MORPHTARGETTEXTURE_HASCOLORS = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.USEPHYSICALLIGHTFALLOFF = false;
    this.USEGLTFLIGHTFALLOFF = false;
    this.TWOSIDEDLIGHTING = false;
    this.MIRRORED = false;
    this.SHADOWFLOAT = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LOGARITHMICDEPTH = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.AREALIGHTSUPPORTED = true;
    this.FORCENORMALFORWARD = false;
    this.SPECULARAA = false;
    this.UNLIT = false;
    this.DECAL_AFTER_DETAIL = false;
    this.DEBUGMODE = 0;
    this.CLUSTLIGHT_SLICES = 0;
    this.CLUSTLIGHT_BATCH = 0;
    this.BRDF_V_HEIGHT_CORRELATED = true;
    this.MS_BRDF_ENERGY_CONSERVATION = true;
    this.SPHERICAL_HARMONICS = true;
    this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = true;
    this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
    this.LEGACY_SPECULAR_ENERGY_CONSERVATION = false;
    this.BASE_DIFFUSE_MODEL = 0;
    this.DIELECTRIC_SPECULAR_MODEL = 1;
    this.CONDUCTOR_SPECULAR_MODEL = 1;
    this.rebuild();
  }
  /**
   * Resets the PBR Material defines.
   */
  reset() {
    super.reset();
    this.ALPHATESTVALUE = "0.5";
    this.NORMALXYSCALE = true;
  }
};
var OpenPBRMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
};
var OpenPBRMaterial = class _OpenPBRMaterial extends OpenPBRMaterialBase {
  /**
   * Defines the angle of the tangent of the material's geometry. Used only for anisotropic reflections.
   * See OpenPBR's specs for geometry_tangent
   */
  get geometryTangentAngle() {
    return Math.atan2(this.geometryTangent.y, this.geometryTangent.x);
  }
  set geometryTangentAngle(value) {
    this.geometryTangent = new Vector2(Math.cos(value), Math.sin(value));
  }
  /**
   * Defines the angle of the tangent of the material's coat layer.
   */
  get geometryCoatTangentAngle() {
    return Math.atan2(this.geometryCoatTangent.y, this.geometryCoatTangent.x);
  }
  /**
   * Defines the angle of the tangent of the material's coat layer.
   */
  set geometryCoatTangentAngle(value) {
    this.geometryCoatTangent = new Vector2(Math.cos(value), Math.sin(value));
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  get usePhysicalLightFalloff() {
    return this._lightFalloff === Material.LIGHTFALLOFF_PHYSICAL;
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  set usePhysicalLightFalloff(value) {
    if (value !== this.usePhysicalLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;
      } else {
        this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  get useGLTFLightFalloff() {
    return this._lightFalloff === Material.LIGHTFALLOFF_GLTF;
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  set useGLTFLightFalloff(value) {
    if (value !== this.useGLTFLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = Material.LIGHTFALLOFF_GLTF;
      } else {
        this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * Enables realtime filtering on the texture.
   */
  get realTimeFiltering() {
    return this._realTimeFiltering;
  }
  set realTimeFiltering(b) {
    this._realTimeFiltering = b;
    this.markAsDirty(1);
  }
  /**
   * Quality switch for realtime filtering
   */
  get realTimeFilteringQuality() {
    return this._realTimeFilteringQuality;
  }
  set realTimeFilteringQuality(n) {
    this._realTimeFilteringQuality = n;
    this.markAsDirty(1);
  }
  /**
   * The number of samples used to compute the fuzz IBL lighting.
   */
  get fuzzSampleNumber() {
    return this._fuzzSampleNumber;
  }
  set fuzzSampleNumber(n) {
    this._fuzzSampleNumber = n;
    this.markAsDirty(1);
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Instantiates a new OpenPBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name, scene, forceGLSL = false) {
    super(name, scene, void 0, forceGLSL || _OpenPBRMaterial.ForceGLSL);
    this._baseWeight = new Property("base_weight", 1, "vBaseWeight", 1);
    this._baseWeightTexture = new Sampler("base_weight", "baseWeight", "BASE_WEIGHT");
    this._baseColor = new Property("base_color", Color3.White(), "vBaseColor", 4);
    this._baseColorTexture = new Sampler("base_color", "baseColor", "BASE_COLOR");
    this._baseDiffuseRoughness = new Property("base_diffuse_roughness", 0, "vBaseDiffuseRoughness", 1);
    this._baseDiffuseRoughnessTexture = new Sampler("base_diffuse_roughness", "baseDiffuseRoughness", "BASE_DIFFUSE_ROUGHNESS");
    this._baseMetalness = new Property("base_metalness", 0, "vReflectanceInfo", 4, 0);
    this._baseMetalnessTexture = new Sampler("base_metalness", "baseMetalness", "BASE_METALNESS");
    this._specularWeight = new Property("specular_weight", 1, "vReflectanceInfo", 4, 3);
    this._specularWeightTexture = new Sampler("specular_weight", "specularWeight", "SPECULAR_WEIGHT");
    this._specularColor = new Property("specular_color", Color3.White(), "vSpecularColor", 4);
    this._specularColorTexture = new Sampler("specular_color", "specularColor", "SPECULAR_COLOR");
    this._specularRoughness = new Property("specular_roughness", 0.3, "vReflectanceInfo", 4, 1);
    this._specularRoughnessTexture = new Sampler("specular_roughness", "specularRoughness", "SPECULAR_ROUGHNESS");
    this._specularRoughnessAnisotropy = new Property("specular_roughness_anisotropy", 0, "vSpecularAnisotropy", 3, 2);
    this._specularRoughnessAnisotropyTexture = new Sampler("specular_roughness_anisotropy", "specularRoughnessAnisotropy", "SPECULAR_ROUGHNESS_ANISOTROPY");
    this._specularIor = new Property("specular_ior", 1.5, "vReflectanceInfo", 4, 2);
    this._coatWeight = new Property("coat_weight", 0, "vCoatWeight", 1, 0);
    this._coatWeightTexture = new Sampler("coat_weight", "coatWeight", "COAT_WEIGHT");
    this._coatColor = new Property("coat_color", Color3.White(), "vCoatColor", 3, 0);
    this._coatColorTexture = new Sampler("coat_color", "coatColor", "COAT_COLOR");
    this._coatRoughness = new Property("coat_roughness", 0, "vCoatRoughness", 1, 0);
    this._coatRoughnessTexture = new Sampler("coat_roughness", "coatRoughness", "COAT_ROUGHNESS");
    this._coatRoughnessAnisotropy = new Property("coat_roughness_anisotropy", 0, "vCoatRoughnessAnisotropy", 1);
    this._coatRoughnessAnisotropyTexture = new Sampler("coat_roughness_anisotropy", "coatRoughnessAnisotropy", "COAT_ROUGHNESS_ANISOTROPY");
    this._coatIor = new Property("coat_ior", 1.5, "vCoatIor", 1, 0);
    this._coatDarkening = new Property("coat_darkening", 1, "vCoatDarkening", 1, 0);
    this._coatDarkeningTexture = new Sampler("coat_darkening", "coatDarkening", "COAT_DARKENING");
    this.useCoatRoughnessFromWeightTexture = false;
    this._fuzzWeight = new Property("fuzz_weight", 0, "vFuzzWeight", 1, 0);
    this._fuzzWeightTexture = new Sampler("fuzz_weight", "fuzzWeight", "FUZZ_WEIGHT");
    this._fuzzColor = new Property("fuzz_color", Color3.White(), "vFuzzColor", 3, 0);
    this._fuzzColorTexture = new Sampler("fuzz_color", "fuzzColor", "FUZZ_COLOR");
    this._fuzzRoughness = new Property("fuzz_roughness", 0.5, "vFuzzRoughness", 1, 0);
    this._fuzzRoughnessTexture = new Sampler("fuzz_roughness", "fuzzRoughness", "FUZZ_ROUGHNESS");
    this._geometryNormalTexture = new Sampler("geometry_normal", "geometryNormal", "GEOMETRY_NORMAL");
    this._geometryTangent = new Property("geometry_tangent", new Vector2(1, 0), "vSpecularAnisotropy", 3, 0);
    this._geometryTangentTexture = new Sampler("geometry_tangent", "geometryTangent", "GEOMETRY_TANGENT");
    this._geometryCoatNormalTexture = new Sampler("geometry_coat_normal", "geometryCoatNormal", "GEOMETRY_COAT_NORMAL");
    this._geometryCoatTangent = new Property("geometry_coat_tangent", new Vector2(1, 0), "vGeometryCoatTangent", 2, 0);
    this._geometryCoatTangentTexture = new Sampler("geometry_coat_tangent", "geometryCoatTangent", "GEOMETRY_COAT_TANGENT");
    this._geometryOpacity = new Property("geometry_opacity", 1, "vBaseColor", 4, 3);
    this._geometryOpacityTexture = new Sampler("geometry_opacity", "geometryOpacity", "GEOMETRY_OPACITY");
    this._emissionLuminance = new Property("emission_luminance", 1, "vLightingIntensity", 4, 1);
    this._emissionColor = new Property("emission_color", Color3.Black(), "vEmissionColor", 3);
    this._emissionColorTexture = new Sampler("emission_color", "emissionColor", "EMISSION_COLOR");
    this._thinFilmWeight = new Property("thin_film_weight", 0, "vThinFilmWeight", 1, 0);
    this._thinFilmWeightTexture = new Sampler("thin_film_weight", "thinFilmWeight", "THIN_FILM_WEIGHT");
    this._thinFilmThickness = new Property("thin_film_thickness", 0.5, "vThinFilmThickness", 2, 0);
    this._thinFilmThicknessMin = new Property("thin_film_thickness_min", 0, "vThinFilmThickness", 2, 1);
    this._thinFilmThicknessTexture = new Sampler("thin_film_thickness", "thinFilmThickness", "THIN_FILM_THICKNESS");
    this._thinFilmIor = new Property("thin_film_ior", 1.4, "vThinFilmIor", 1, 0);
    this._ambientOcclusionTexture = new Sampler("ambient_occlusion", "ambientOcclusion", "AMBIENT_OCCLUSION");
    this._uniformsList = {};
    this._samplersList = {};
    this._samplerDefines = {};
    this.directIntensity = 1;
    this.environmentIntensity = 1;
    this.useSpecularWeightFromTextureAlpha = false;
    this.forceAlphaTest = false;
    this.alphaCutOff = 0.4;
    this.useAmbientOcclusionFromMetallicTextureRed = false;
    this.useAmbientInGrayScale = false;
    this.useObjectSpaceNormalMap = false;
    this.useParallax = false;
    this.useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this.disableLighting = false;
    this.forceIrradianceInFragment = false;
    this.maxSimultaneousLights = 4;
    this.invertNormalMapX = false;
    this.invertNormalMapY = false;
    this.twoSidedLighting = false;
    this.useAlphaFresnel = false;
    this.useLinearAlphaFresnel = false;
    this.environmentBRDFTexture = null;
    this.forceNormalForward = false;
    this.enableSpecularAntiAliasing = false;
    this.useHorizonOcclusion = true;
    this.useRadianceOcclusion = true;
    this.unlit = false;
    this.applyDecalMapAfterDetailMap = false;
    this._lightingInfos = new Vector4(this.directIntensity, 1, this.environmentIntensity, 1);
    this._radianceTexture = null;
    this._useSpecularWeightFromAlpha = false;
    this._useSpecularWeightFromSpecularColorTexture = false;
    this._useSpecularRoughnessAnisotropyFromTangentTexture = false;
    this._useCoatRoughnessAnisotropyFromTangentTexture = false;
    this._useGltfStyleAnisotropy = false;
    this._useHorizonOcclusion = true;
    this._useRadianceOcclusion = true;
    this._useAlphaFromBaseColorTexture = false;
    this._useAmbientOcclusionFromMetallicTextureRed = false;
    this._useRoughnessFromMetallicTextureGreen = false;
    this._useMetallicFromMetallicTextureBlue = false;
    this._useThinFilmThicknessFromTextureGreen = false;
    this._lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this._parallaxScaleBias = 0.05;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._alphaCutOff = 0.4;
    this._useAlphaFresnel = false;
    this._useLinearAlphaFresnel = false;
    this._environmentBRDFTexture = null;
    this._environmentFuzzBRDFTexture = null;
    this._forceIrradianceInFragment = false;
    this._realTimeFiltering = false;
    this._realTimeFilteringQuality = 8;
    this._fuzzSampleNumber = 4;
    this._forceNormalForward = false;
    this._enableSpecularAntiAliasing = false;
    this._renderTargets = new SmartArray(16);
    this._unlit = false;
    this._applyDecalMapAfterDetailMap = false;
    this._debugMode = 0;
    this._shadersLoaded = false;
    this._breakShaderLoadedCheck = false;
    this.debugMode = 0;
    this.debugLimit = -1;
    this.debugFactor = 1;
    this._cacheHasRenderTargetTextures = false;
    this._transparencyMode = Material.MATERIAL_OPAQUE;
    if (this.getScene() && !this.getScene()?.getEngine().isWebGPU && this.getScene().getEngine().webGLVersion < 2) {
      Logger.Error("OpenPBRMaterial: WebGL 2.0 or above is required for this material.");
    }
    if (!_OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]) {
      _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId] = new Texture("https://assets.babylonjs.com/textures/blue_noise/blue_noise_rgb.png", this.getScene(), false, true, 1);
      this.getScene().onDisposeObservable.addOnce(() => {
        _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]?.dispose();
        delete _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId];
      });
    }
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {
        this._renderTargets.push(this._radianceTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
    this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());
    this.prePassConfiguration = new PrePassConfiguration();
    this._propertyList = {};
    for (const key of Object.getOwnPropertyNames(this)) {
      const value = this[key];
      if (value instanceof Property) {
        this._propertyList[key] = value;
      }
    }
    const propertyKeys = Object.keys(this._propertyList);
    propertyKeys.forEach((key) => {
      const prop = this._propertyList[key];
      let uniform = this._uniformsList[prop.targetUniformName];
      if (!uniform) {
        uniform = new Uniform(prop.targetUniformName, prop.targetUniformComponentNum);
        this._uniformsList[prop.targetUniformName] = uniform;
      } else if (uniform.numComponents !== prop.targetUniformComponentNum) {
        Logger.Error(`Uniform ${prop.targetUniformName} already exists of size ${uniform.numComponents}, but trying to set it to ${prop.targetUniformComponentNum}.`);
      }
      uniform.linkedProperties[prop.name] = prop;
    });
    this._samplersList = {};
    for (const key of Object.getOwnPropertyNames(this)) {
      const value = this[key];
      if (value instanceof Sampler) {
        this._samplersList[key] = value;
      }
    }
    for (const samplerKey in this._samplersList) {
      const sampler = this._samplersList[samplerKey];
      const defineName = sampler.textureDefine;
      this._samplerDefines[defineName] = { type: "boolean", default: false };
      this._samplerDefines[defineName + "DIRECTUV"] = { type: "number", default: 0 };
      this._samplerDefines[defineName + "_GAMMA"] = { type: "boolean", default: false };
    }
    this._baseWeight;
    this._baseWeightTexture;
    this._baseColor;
    this._baseColorTexture;
    this._baseDiffuseRoughness;
    this._baseDiffuseRoughnessTexture;
    this._baseMetalness;
    this._baseMetalnessTexture;
    this._specularWeight;
    this._specularWeightTexture;
    this._specularColor;
    this._specularColorTexture;
    this._specularRoughness;
    this._specularIor;
    this._specularRoughnessTexture;
    this._specularRoughnessAnisotropy;
    this._specularRoughnessAnisotropyTexture;
    this._coatWeight;
    this._coatWeightTexture;
    this._coatColor;
    this._coatColorTexture;
    this._coatRoughness;
    this._coatRoughnessTexture;
    this._coatRoughnessAnisotropy;
    this._coatRoughnessAnisotropyTexture;
    this._coatIor;
    this._coatDarkening;
    this._coatDarkeningTexture;
    this._fuzzWeight;
    this._fuzzWeightTexture;
    this._fuzzColor;
    this._fuzzColorTexture;
    this._fuzzRoughness;
    this._fuzzRoughnessTexture;
    this._geometryNormalTexture;
    this._geometryTangent;
    this._geometryTangentTexture;
    this._geometryCoatNormalTexture;
    this._geometryCoatTangent;
    this._geometryCoatTangentTexture;
    this._geometryOpacity;
    this._geometryOpacityTexture;
    this._thinFilmWeight;
    this._thinFilmWeightTexture;
    this._thinFilmThickness;
    this._thinFilmThicknessMin;
    this._thinFilmThicknessTexture;
    this._thinFilmIor;
    this._emissionLuminance;
    this._emissionColor;
    this._emissionColorTexture;
    this._ambientOcclusionTexture;
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * @returns the name of the material class.
   */
  getClassName() {
    return "OpenPBRMaterial";
  }
  get transparencyMode() {
    return this._transparencyMode;
  }
  set transparencyMode(value) {
    if (this._transparencyMode === value) {
      return;
    }
    this._transparencyMode = value;
    this._markAllSubMeshesAsTexturesAndMiscDirty();
  }
  /**
   * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
   */
  _shouldUseAlphaFromBaseColorTexture() {
    return this._hasAlphaChannel() && this._transparencyMode !== Material.MATERIAL_OPAQUE && !this.geometryOpacityTexture;
  }
  /**
   * @returns whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this.baseColorTexture != null && this.baseColorTexture.hasAlpha && this._useAlphaFromBaseColorTexture || this.geometryOpacityTexture != null;
  }
  /**
   * Makes a duplicate of the current material.
   * @param name - name to use for the new material.
   * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g baseColor and opacity), only clone it once and reuse it on the other channels. Default false.
   * @param rootUrl defines the root URL to use to load textures
   * @returns cloned material instance
   */
  clone(name, cloneTexturesOnlyOnce = true, rootUrl = "") {
    const clone = SerializationHelper.Clone(() => new _OpenPBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });
    clone.id = name;
    clone.name = name;
    this.stencil.copyTo(clone.stencil);
    this._clonePlugins(clone, rootUrl);
    return clone;
  }
  /**
   * Serializes this PBR Material.
   * @returns - An object with the serialized material.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.OpenPBRMaterial";
    return serializationObject;
  }
  // Statics
  /**
   * Parses a PBR Material from a serialized object.
   * @param source - Serialized object.
   * @param scene - BJS scene instance.
   * @param rootUrl - url for the scene object
   * @returns - OpenPBRMaterial
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _OpenPBRMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    Material._ParsePlugins(source, material, scene, rootUrl);
    return material;
  }
  /**
   * Force shader compilation
   * @param mesh - Define the mesh we want to force the compilation for
   * @param onCompiled - Define a callback triggered when the compilation completes
   * @param options - Define the options used to create the compilation
   */
  forceCompilation(mesh, onCompiled, options) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    this._callbackPluginEventGeneric(4, this._eventInfo);
    const checkReady = () => {
      if (this._breakShaderLoadedCheck) {
        return;
      }
      const defines = new OpenPBRMaterialDefines({
        ...this._eventInfo.defineNames || {},
        ...this._samplerDefines || {}
      });
      const effect = this._prepareEffect(mesh, mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane);
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
      if (effect.isReady()) {
        if (onCompiled) {
          onCompiled(this);
        }
      } else {
        effect.onCompileObservable.add(() => {
          if (onCompiled) {
            onCompiled(this);
          }
        });
      }
    };
    checkReady();
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param mesh - BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
   * @param useInstances - Specifies that instances should be used.
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(4, this._eventInfo);
      subMesh.materialDefines = new OpenPBRMaterialDefines({
        ...this._eventInfo.defineNames || {},
        ...this._samplerDefines || {}
      });
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      if (scene.texturesEnabled) {
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value) {
            if (!sampler.value.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        const radianceTexture = this._getRadianceTexture();
        if (radianceTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!radianceTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (radianceTexture.irradianceTexture) {
            if (!radianceTexture.irradianceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else {
            if (!radianceTexture.sphericalPolynomial && radianceTexture.getInternalTexture()?._sphericalPolynomialPromise) {
              return false;
            }
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentFuzzBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentFuzzBRDFTexture.isReady()) {
            return false;
          }
        }
        if (_OpenPBRMaterial._noiseTextures[scene.uniqueId]) {
          if (!_OpenPBRMaterial._noiseTextures[scene.uniqueId].isReady()) {
            return false;
          }
        }
      }
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (defines["AREALIGHTUSED"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("OpenPBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    const previousEffect = subMesh.effect;
    const lightDisposed = defines._areLightsDisposed;
    let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);
    let forceWasNotReadyPreviously = false;
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        defines.markAsUnprocessed();
        forceWasNotReadyPreviously = this.isFrozen;
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines, this._materialContext);
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vDebugMode", 2);
    ubo.addUniform("cameraInfo", 4);
    PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);
    Object.values(this._uniformsList).forEach((uniform) => {
      ubo.addUniform(uniform.name, uniform.numComponents);
    });
    Object.values(this._samplersList).forEach((sampler) => {
      ubo.addUniform(sampler.samplerInfoName, 2);
      ubo.addUniform(sampler.samplerMatrixName, 16);
    });
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh data.
   * @param world - The world matrix.
   * @param mesh - The BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const engine = scene.getEngine();
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
    const camera = scene.activeCamera;
    if (camera) {
      this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
    } else {
      this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    let radianceTexture = null;
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      radianceTexture = this._getRadianceTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
        if (scene.texturesEnabled) {
          for (const key in this._samplersList) {
            const sampler = this._samplersList[key];
            if (sampler.value) {
              ubo.updateFloat2(sampler.samplerInfoName, sampler.value.coordinatesIndex, sampler.value.level);
              BindTextureMatrix(sampler.value, ubo, sampler.samplerPrefix);
            }
          }
          if (this.geometryNormalTexture) {
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          BindIBLParameters(scene, defines, ubo, Color3.White(), radianceTexture, this.realTimeFiltering, true, true, true, true, true);
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        Object.values(this._uniformsList).forEach((uniform) => {
          if (uniform.numComponents === 4) {
            uniform.populateVectorFromLinkedProperties(TmpVectors.Vector4[0]);
            ubo.updateVector4(uniform.name, TmpVectors.Vector4[0]);
          } else if (uniform.numComponents === 3) {
            uniform.populateVectorFromLinkedProperties(TmpVectors.Vector3[0]);
            ubo.updateVector3(uniform.name, TmpVectors.Vector3[0]);
          } else if (uniform.numComponents === 2) {
            uniform.populateVectorFromLinkedProperties(TmpVectors.Vector2[0]);
            ubo.updateFloat2(uniform.name, TmpVectors.Vector2[0].x, TmpVectors.Vector2[0].y);
          } else if (uniform.numComponents === 1) {
            ubo.updateFloat(uniform.name, uniform.linkedProperties[Object.keys(uniform.linkedProperties)[0]].value);
          }
        });
        this._lightingInfos.x = this.directIntensity;
        this._lightingInfos.y = this.emissionLuminance;
        this._lightingInfos.z = this.environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = 1;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
        ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
      }
      if (scene.texturesEnabled) {
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value) {
            ubo.setTexture(sampler.samplerName, sampler.value);
          }
        }
        BindIBLSamplers(scene, defines, ubo, radianceTexture, this.realTimeFiltering);
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (defines.FUZZENVIRONMENTBRDF) {
          ubo.setTexture("environmentFuzzBrdfSampler", this._environmentFuzzBRDFTexture);
        }
        if (defines.ANISOTROPIC || defines.FUZZ) {
          ubo.setTexture("blueNoiseSampler", _OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]);
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      BindClipPlane(this._activeEffect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || radianceTexture || mesh.receiveShadows || defines.PREPASS) {
        this.bindView(effect);
      }
      BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        BindMorphTargetParameters(mesh, this._activeEffect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      BindLogDepth(defines, this._activeEffect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
    ubo.update();
  }
  /**
   * Returns the animatable textures.
   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    const results = super.getAnimatables();
    for (const key in this._samplersList) {
      const sampler = this._samplersList[key];
      if (sampler.value && sampler.value.animations && sampler.value.animations.length > 0) {
        results.push(sampler.value);
      }
    }
    if (this._radianceTexture && this._radianceTexture.animations && this._radianceTexture.animations.length > 0) {
      results.push(this._radianceTexture);
    }
    return results;
  }
  /**
   * Returns an array of the actively used textures.
   * @returns - Array of BaseTextures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    for (const key in this._samplersList) {
      const sampler = this._samplersList[key];
      if (sampler.value) {
        activeTextures.push(sampler.value);
      }
    }
    if (this._radianceTexture) {
      activeTextures.push(this._radianceTexture);
    }
    return activeTextures;
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    for (const key in this._samplersList) {
      const sampler = this._samplersList[key];
      if (sampler.value === texture) {
        return true;
      }
    }
    if (this._radianceTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Sets the required values to the prepass renderer.
   * It can't be sets when subsurface scattering of this material is disabled.
   * When scene have ability to enable subsurface prepass effect, it will enable.
   * @returns - If prepass is enabled or not.
   */
  setPrePassRenderer() {
    return false;
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeEffect - Forces the disposal of effects.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    this._breakShaderLoadedCheck = true;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      if (this._environmentFuzzBRDFTexture && this.getScene().environmentFuzzBRDFTexture !== this._environmentFuzzBRDFTexture) {
        this._environmentFuzzBRDFTexture.dispose();
      }
      for (const key in this._samplersList) {
        const sampler = this._samplersList[key];
        sampler.value?.dispose();
      }
      this._radianceTexture?.dispose();
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
  /**
   * Returns the texture used for reflections.
   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
   */
  _getRadianceTexture() {
    if (this._radianceTexture) {
      return this._radianceTexture;
    }
    return this.getScene().environmentTexture;
  }
  _prepareEffect(mesh, renderingMesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null) {
    this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    const scene = this.getScene();
    const engine = scene.getEngine();
    const fallbacks = new EffectFallbacks();
    let fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAX_RHS) {
      fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    const attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    for (let i = 1; i <= 6; ++i) {
      if (defines["UV" + i]) {
        attribs.push(`uv${i === 1 ? "" : i}`);
      }
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    PrepareAttributesForInstances(attribs, defines);
    PrepareAttributesForMorphTargets(attribs, mesh, defines);
    PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    let shaderName = "openpbr";
    const uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "visibility",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "mBones",
      "normalMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices",
      "cameraInfo"
    ];
    for (const uniformName in this._uniformsList) {
      uniforms.push(uniformName);
    }
    const samplers = [
      "environmentBrdfSampler",
      "blueNoiseSampler",
      "boneSampler",
      "morphTargets",
      "oitDepthSampler",
      "oitFrontColorSampler",
      "areaLightsLTC1Sampler",
      "areaLightsLTC2Sampler"
    ];
    if (defines.FUZZENVIRONMENTBRDF) {
      samplers.push("environmentFuzzBrdfSampler");
    }
    for (const key in this._samplersList) {
      const sampler = this._samplersList[key];
      samplers.push(sampler.samplerName);
      uniforms.push(sampler.samplerInfoName);
      uniforms.push(sampler.samplerMatrixName);
    }
    PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);
    const uniformBuffers = ["Material", "Scene", "Mesh"];
    const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
    this._eventInfo.fallbacks = fallbacks;
    this._eventInfo.fallbackRank = fallbackRank;
    this._eventInfo.defines = defines;
    this._eventInfo.uniforms = uniforms;
    this._eventInfo.attributes = attribs;
    this._eventInfo.samplers = samplers;
    this._eventInfo.uniformBuffersNames = uniformBuffers;
    this._eventInfo.customCode = void 0;
    this._eventInfo.mesh = mesh;
    this._eventInfo.indexParameters = indexParameters;
    this._callbackPluginEventGeneric(128, this._eventInfo);
    MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(samplers);
    AddClipPlaneUniforms(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    const csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    const join = defines.toString();
    const effect = engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters,
      processFinalCode: csnrOptions.processFinalCode,
      processCodeAfterIncludes: this._eventInfo.customCode,
      multiTarget: defines.PREPASS,
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
        if (this.shaderLanguage === 1) {
          await Promise.all([import("./openpbr.vertex-5LGIVYGH.js"), import("./openpbr.fragment-47FOBAWU.js")]);
        } else {
          await Promise.all([import("./openpbr.vertex-CUPGRKHP.js"), import("./openpbr.fragment-25HVYHJ2.js")]);
        }
        this._shadersLoaded = true;
      }
    }, engine);
    this._eventInfo.customCode = void 0;
    return effect;
  }
  _prepareDefines(mesh, renderingMesh, defines, useInstances = null, useClipPlane = null) {
    const useThinInstances = renderingMesh.hasThinInstances;
    const scene = this.getScene();
    const engine = scene.getEngine();
    PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    PrepareDefinesForOIT(scene, defines, oit);
    MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
    defines.METALLICWORKFLOW = true;
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        for (const key in this._samplersList) {
          const sampler = this._samplersList[key];
          if (sampler.value) {
            PrepareDefinesForMergedUV(sampler.value, defines, sampler.textureDefine);
            defines[sampler.textureDefine + "_GAMMA"] = sampler.value.gammaSpace;
          } else {
            defines[sampler.textureDefine] = false;
          }
        }
        const radianceTexture = this._getRadianceTexture();
        const useSHInFragment = this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8 || this._baseDiffuseRoughnessTexture != null;
        PrepareDefinesForIBL(scene, radianceTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);
        if (this._baseMetalnessTexture) {
          defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
        }
        defines.SPECULAR_WEIGHT_IN_ALPHA = this._useSpecularWeightFromAlpha;
        defines.SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = this._useSpecularWeightFromSpecularColorTexture;
        defines.SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useSpecularRoughnessAnisotropyFromTangentTexture;
        defines.COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useCoatRoughnessAnisotropyFromTangentTexture;
        defines.ROUGHNESSSTOREINMETALMAPGREEN = this._useRoughnessFromMetallicTextureGreen;
        defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallicFromMetallicTextureBlue;
        defines.THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = this._useThinFilmThicknessFromTextureGreen;
        if (this.geometryNormalTexture) {
          if (this._useParallax && this.baseColorTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
          defines.OBJECTSPACE_NORMALMAP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._environmentFuzzBRDFTexture) {
          defines.FUZZENVIRONMENTBRDF = true;
        } else {
          defines.FUZZENVIRONMENTBRDF = false;
        }
        if (this._shouldUseAlphaFromBaseColorTexture()) {
          defines.ALPHA_FROM_BASE_COLOR_TEXTURE = true;
        } else {
          defines.ALPHA_FROM_BASE_COLOR_TEXTURE = false;
        }
      }
      if (this._lightFalloff === Material.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === Material.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.MIRRORED = !!scene._mirroredCameraPosition;
      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if ((this.specularRoughnessAnisotropy > 0 || this.coatRoughnessAnisotropy > 0) && _OpenPBRMaterial._noiseTextures[scene.uniqueId] && MaterialFlags.ReflectionTextureEnabled) {
      defines.ANISOTROPIC = true;
      if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (this._useGltfStyleAnisotropy) {
        defines.USE_GLTF_STYLE_ANISOTROPY = true;
      }
      defines.ANISOTROPIC_BASE = this.specularRoughnessAnisotropy > 0;
      defines.ANISOTROPIC_COAT = this.coatRoughnessAnisotropy > 0;
    } else {
      defines.ANISOTROPIC = false;
      defines.USE_GLTF_STYLE_ANISOTROPY = false;
      defines.ANISOTROPIC_BASE = false;
      defines.ANISOTROPIC_COAT = false;
    }
    defines.THIN_FILM = this.thinFilmWeight > 0;
    defines.IRIDESCENCE = this.thinFilmWeight > 0;
    defines.FUZZ = this.fuzzWeight > 0 && MaterialFlags.ReflectionTextureEnabled;
    if (defines.FUZZ) {
      if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());
      defines.FUZZ_IBL_SAMPLES = this.fuzzSampleNumber;
    } else {
      this._environmentFuzzBRDFTexture = null;
      defines.FUZZENVIRONMENTBRDF = false;
      defines.FUZZ_IBL_SAMPLES = 0;
    }
    if (defines._areMiscDirty) {
      PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, renderingMesh, this._isVertexOutputInvariant);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== Material.MATERIAL_OPAQUE);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
  }
};
OpenPBRMaterial._noiseTextures = {};
OpenPBRMaterial.ForceGLSL = false;
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseWeight")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseWeight", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseWeightTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseWeightTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseColor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseColor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseColorTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseColorTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseDiffuseRoughness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseDiffuseRoughness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseDiffuseRoughnessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseDiffuseRoughnessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseMetalness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseMetalness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "baseMetalnessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_baseMetalnessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularWeight")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularWeight", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularWeightTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularWeightTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularColor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularColor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularColorTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularColorTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularRoughness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularRoughnessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessAnisotropy")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularRoughnessAnisotropy", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularRoughnessAnisotropyTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularRoughnessAnisotropyTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "specularIor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_specularIor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatWeight")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatWeight", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatWeightTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatWeightTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatColor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatColor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatColorTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatColorTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatRoughness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatRoughnessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessAnisotropy")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatRoughnessAnisotropy", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatRoughnessAnisotropyTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatRoughnessAnisotropyTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatIor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatIor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatDarkening")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatDarkening", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "coatDarkeningTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_coatDarkeningTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzWeight")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzWeight", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzWeightTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzWeightTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzColor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzColor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzColorTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzColorTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzRoughness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzRoughness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "fuzzRoughnessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_fuzzRoughnessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryNormalTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryNormalTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryTangent")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryTangent", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryTangentTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryTangentTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatNormalTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryCoatNormalTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatTangent")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryCoatTangent", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryCoatTangentTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryCoatTangentTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryOpacity")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryOpacity", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "geometryOpacityTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_geometryOpacityTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionLuminance")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_emissionLuminance", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionColor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_emissionColor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "emissionColorTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_emissionColorTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmWeight")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmWeight", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmWeightTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmWeightTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThickness")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmThickness", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThicknessMin")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmThicknessMin", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmThicknessTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmThicknessTexture", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "thinFilmIor")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_thinFilmIor", void 0);
__decorate([
  addAccessorsForMaterialProperty("_markAllSubMeshesAsTexturesDirty", "ambientOcclusionTexture")
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
], OpenPBRMaterial.prototype, "_ambientOcclusionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "directIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "environmentIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useSpecularWeightFromTextureAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], OpenPBRMaterial.prototype, "forceAlphaTest", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], OpenPBRMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useAmbientInGrayScale", void 0);
__decorate([
  serialize()
], OpenPBRMaterial.prototype, "usePhysicalLightFalloff", null);
__decorate([
  serialize()
], OpenPBRMaterial.prototype, "useGLTFLightFalloff", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], OpenPBRMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "forceIrradianceInFragment", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], OpenPBRMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useAlphaFresnel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "environmentBRDFTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "forceNormalForward", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useHorizonOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], OpenPBRMaterial.prototype, "useRadianceOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], OpenPBRMaterial.prototype, "unlit", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], OpenPBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], OpenPBRMaterial.prototype, "debugMode", void 0);
__decorate([
  serialize()
], OpenPBRMaterial.prototype, "transparencyMode", null);
RegisterClass("BABYLON.OpenPBRMaterial", OpenPBRMaterial);

export {
  OpenPBRMaterialDefines,
  OpenPBRMaterial
};
//# sourceMappingURL=chunk-QTELHQU6.js.map
