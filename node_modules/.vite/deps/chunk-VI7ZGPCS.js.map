{
  "version": 3,
  "sources": ["../../../dev/core/src/Animations/runtimeAnimation.ts", "../../../dev/core/src/Animations/animatable.core.ts", "../../../dev/core/src/Animations/animatable.ts", "../../../dev/core/src/Animations/animationGroup.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { _IAnimationState } from \"./animation\";\r\nimport {\r\n    Animation,\r\n    _StaticOffsetValueColor3,\r\n    _StaticOffsetValueColor4,\r\n    _StaticOffsetValueQuaternion,\r\n    _StaticOffsetValueSize,\r\n    _StaticOffsetValueVector2,\r\n    _StaticOffsetValueVector3,\r\n} from \"./animation\";\r\nimport type { AnimationEvent } from \"./animationEvent\";\r\nimport type { Animatable } from \"./animatable\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\n/**\r\n * Defines a runtime animation\r\n */\r\nexport class RuntimeAnimation {\r\n    private _events = new Array<AnimationEvent>();\r\n\r\n    /**\r\n     * The current frame of the runtime animation\r\n     */\r\n    private _currentFrame: number = 0;\r\n\r\n    /**\r\n     * The animation used by the runtime animation\r\n     */\r\n    public _animation: Animation;\r\n\r\n    /**\r\n     * The target of the runtime animation\r\n     */\r\n    private _target: any;\r\n\r\n    /**\r\n     * The initiating animatable\r\n     */\r\n    private _host: Animatable;\r\n\r\n    /**\r\n     * The original value of the runtime animation\r\n     */\r\n    private _originalValue = new Array<any>();\r\n\r\n    /**\r\n     * The original blend value of the runtime animation\r\n     */\r\n    private _originalBlendValue: Nullable<any> = null;\r\n\r\n    /**\r\n     * The offsets cache of the runtime animation\r\n     */\r\n    private _offsetsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * The high limits cache of the runtime animation\r\n     */\r\n    private _highLimitsCache: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * Specifies if the runtime animation has been stopped\r\n     */\r\n    private _stopped = false;\r\n\r\n    /**\r\n     * The blending factor of the runtime animation\r\n     */\r\n    private _blendingFactor = 0;\r\n\r\n    /**\r\n     * The BabylonJS scene\r\n     */\r\n    private _scene: Scene;\r\n\r\n    /**\r\n     * The current value of the runtime animation\r\n     */\r\n    private _currentValue: Nullable<any> = null;\r\n\r\n    /** @internal */\r\n    public _animationState: _IAnimationState;\r\n\r\n    /**\r\n     * The active target of the runtime animation\r\n     */\r\n    private _activeTargets: any[];\r\n    private _currentActiveTarget: Nullable<any> = null;\r\n    private _directTarget: Nullable<any> = null;\r\n\r\n    /**\r\n     * The target path of the runtime animation\r\n     */\r\n    private _targetPath: string = \"\";\r\n\r\n    /**\r\n     * The weight of the runtime animation\r\n     */\r\n    private _weight = 1.0;\r\n\r\n    /**\r\n     * The absolute frame offset of the runtime animation\r\n     */\r\n    private _absoluteFrameOffset = 0;\r\n\r\n    /**\r\n     * The previous elapsed time (since start of animation) of the runtime animation\r\n     */\r\n    private _previousElapsedTime: number = 0;\r\n\r\n    private _yoyoDirection: number = 1;\r\n\r\n    /**\r\n     * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\r\n     */\r\n    private _previousAbsoluteFrame: number = 0;\r\n\r\n    private _enableBlending: boolean;\r\n\r\n    private _keys: IAnimationKey[];\r\n    private _minFrame: number;\r\n    private _maxFrame: number;\r\n    private _minValue: any;\r\n    private _maxValue: any;\r\n    private _targetIsArray = false;\r\n\r\n    /** @internal */\r\n    public _coreRuntimeAnimation: RuntimeAnimation | null = null;\r\n\r\n    /**\r\n     * Gets the current frame of the runtime animation\r\n     */\r\n    public get currentFrame(): number {\r\n        return this._currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets the weight of the runtime animation\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    /**\r\n     * Gets the current value of the runtime animation\r\n     */\r\n    public get currentValue(): any {\r\n        return this._currentValue;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the target path of the runtime animation\r\n     */\r\n    public get targetPath(): string {\r\n        return this._targetPath;\r\n    }\r\n\r\n    /**\r\n     * Gets the actual target of the runtime animation\r\n     */\r\n    public get target(): any {\r\n        return this._currentActiveTarget;\r\n    }\r\n\r\n    /**\r\n     * Gets the additive state of the runtime animation\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._host && this._host.isAdditive;\r\n    }\r\n\r\n    /** @internal */\r\n    public _onLoop: () => void;\r\n\r\n    /**\r\n     * Create a new RuntimeAnimation object\r\n     * @param target defines the target of the animation\r\n     * @param animation defines the source animation object\r\n     * @param scene defines the hosting scene\r\n     * @param host defines the initiating Animatable\r\n     */\r\n    public constructor(target: any, animation: Animation, scene: Scene, host: Animatable) {\r\n        this._animation = animation;\r\n        this._target = target;\r\n        this._scene = scene;\r\n        this._host = host;\r\n        this._activeTargets = [];\r\n\r\n        animation._runtimeAnimations.push(this);\r\n\r\n        // State\r\n        this._animationState = {\r\n            key: 0,\r\n            repeatCount: 0,\r\n            loopMode: this._getCorrectLoopMode(),\r\n        };\r\n\r\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\r\n            this._animationState.workValue = Matrix.Zero();\r\n        }\r\n\r\n        // Limits\r\n        this._keys = this._animation.getKeys();\r\n        this._minFrame = this._keys[0].frame;\r\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\r\n        this._minValue = this._keys[0].value;\r\n        this._maxValue = this._keys[this._keys.length - 1].value;\r\n\r\n        // Add a start key at frame 0 if missing\r\n        if (this._minFrame !== 0) {\r\n            const newKey = { frame: 0, value: this._minValue };\r\n            this._keys.splice(0, 0, newKey);\r\n        }\r\n\r\n        // Check data\r\n        if (this._target instanceof Array) {\r\n            let index = 0;\r\n            for (const target of this._target) {\r\n                this._preparePath(target, index);\r\n                this._getOriginalValues(index);\r\n                index++;\r\n            }\r\n            this._targetIsArray = true;\r\n        } else {\r\n            this._preparePath(this._target);\r\n            this._getOriginalValues();\r\n            this._targetIsArray = false;\r\n            this._directTarget = this._activeTargets[0];\r\n        }\r\n\r\n        // Cloning events locally\r\n        const events = animation.getEvents();\r\n        if (events && events.length > 0) {\r\n            for (const e of events) {\r\n                this._events.push(e._clone());\r\n            }\r\n        }\r\n\r\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\r\n    }\r\n\r\n    private _preparePath(target: any, targetIndex = 0) {\r\n        const targetPropertyPath = this._animation.targetPropertyPath;\r\n\r\n        if (targetPropertyPath.length > 1) {\r\n            let property = target;\r\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\r\n                const name = targetPropertyPath[index];\r\n                property = property[name];\r\n                if (property === undefined) {\r\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\r\n                }\r\n            }\r\n\r\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\r\n            this._activeTargets[targetIndex] = property;\r\n        } else {\r\n            this._targetPath = targetPropertyPath[0];\r\n            this._activeTargets[targetIndex] = target;\r\n        }\r\n\r\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\r\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the animation from the runtime animation\r\n     */\r\n    public get animation(): Animation {\r\n        return this._animation;\r\n    }\r\n\r\n    /**\r\n     * Resets the runtime animation to the beginning\r\n     * @param restoreOriginal defines whether to restore the target property to the original value\r\n     */\r\n    public reset(restoreOriginal = false): void {\r\n        if (restoreOriginal) {\r\n            if (this._target instanceof Array) {\r\n                let index = 0;\r\n                for (const target of this._target) {\r\n                    if (this._originalValue[index] !== undefined) {\r\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\r\n                    }\r\n                    index++;\r\n                }\r\n            } else {\r\n                if (this._originalValue[0] !== undefined) {\r\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\r\n                }\r\n            }\r\n        }\r\n\r\n        this._offsetsCache = {};\r\n        this._highLimitsCache = {};\r\n        this._currentFrame = 0;\r\n        this._blendingFactor = 0;\r\n\r\n        // Events\r\n        for (let index = 0; index < this._events.length; index++) {\r\n            this._events[index].isDone = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Specifies if the runtime animation is stopped\r\n     * @returns Boolean specifying if the runtime animation is stopped\r\n     */\r\n    public isStopped(): boolean {\r\n        return this._stopped;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the runtime animation\r\n     */\r\n    public dispose(): void {\r\n        const index = this._animation.runtimeAnimations.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._animation.runtimeAnimations.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Apply the interpolated value to the target\r\n     * @param currentValue defines the value computed by the animation\r\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\r\n     */\r\n    public setValue(currentValue: any, weight: number) {\r\n        if (this._targetIsArray) {\r\n            for (let index = 0; index < this._target.length; index++) {\r\n                const target = this._target[index];\r\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\r\n            }\r\n            return;\r\n        }\r\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\r\n    }\r\n\r\n    private _getOriginalValues(targetIndex = 0) {\r\n        let originalValue: any;\r\n        const target = this._activeTargets[targetIndex];\r\n\r\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\r\n            // For bones\r\n            originalValue = target.getLocalMatrix();\r\n        } else {\r\n            originalValue = target[this._targetPath];\r\n        }\r\n\r\n        if (originalValue && originalValue.clone) {\r\n            this._originalValue[targetIndex] = originalValue.clone();\r\n        } else {\r\n            this._originalValue[targetIndex] = originalValue;\r\n        }\r\n    }\r\n\r\n    private _registerTargetForLateAnimationBinding(runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n        const target = runtimeAnimation.target;\r\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n        if (!target._lateAnimationHolders) {\r\n            target._lateAnimationHolders = {};\r\n        }\r\n\r\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n                totalWeight: 0,\r\n                totalAdditiveWeight: 0,\r\n                animations: [],\r\n                additiveAnimations: [],\r\n                originalValue: originalValue,\r\n            };\r\n        }\r\n\r\n        if (runtimeAnimation.isAdditive) {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n        } else {\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n        }\r\n    }\r\n\r\n    private _setValue(target: any, destination: any, currentValue: any, weight: number, targetIndex: number): void {\r\n        // Set value\r\n        this._currentActiveTarget = destination;\r\n\r\n        this._weight = weight;\r\n\r\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\r\n            if (!this._originalBlendValue) {\r\n                const originalValue = destination[this._targetPath];\r\n\r\n                if (originalValue.clone) {\r\n                    this._originalBlendValue = originalValue.clone();\r\n                } else {\r\n                    this._originalBlendValue = originalValue;\r\n                }\r\n            }\r\n\r\n            if (this._originalBlendValue.m) {\r\n                // Matrix\r\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\r\n                    if (this._currentValue) {\r\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                } else {\r\n                    if (this._currentValue) {\r\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\r\n                    } else {\r\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n                    }\r\n                }\r\n            } else {\r\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\r\n            }\r\n\r\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\r\n            this._blendingFactor += blendingSpeed;\r\n        } else {\r\n            if (!this._currentValue) {\r\n                if (currentValue?.clone) {\r\n                    this._currentValue = currentValue.clone();\r\n                } else {\r\n                    this._currentValue = currentValue;\r\n                }\r\n            } else if (this._currentValue.copyFrom) {\r\n                this._currentValue.copyFrom(currentValue);\r\n            } else {\r\n                this._currentValue = currentValue;\r\n            }\r\n        }\r\n\r\n        if (weight !== -1.0) {\r\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\r\n        } else {\r\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\r\n                if (this._currentValue.addToRef) {\r\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\r\n                } else {\r\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\r\n                }\r\n            } else {\r\n                destination[this._targetPath] = this._currentValue;\r\n            }\r\n        }\r\n\r\n        if (target.markAsDirty) {\r\n            target.markAsDirty(this._animation.targetProperty);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the loop pmode of the runtime animation\r\n     * @returns Loop Mode\r\n     */\r\n    private _getCorrectLoopMode(): number | undefined {\r\n        if (this._target && this._target.animationPropertiesOverride) {\r\n            return this._target.animationPropertiesOverride.loopMode as number;\r\n        }\r\n\r\n        return this._animation.loopMode;\r\n    }\r\n\r\n    /**\r\n     * Move the current animation to a given frame\r\n     * @param frame defines the frame to move to\r\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\r\n     */\r\n    public goToFrame(frame: number, weight = -1): void {\r\n        const keys = this._animation.getKeys();\r\n\r\n        if (frame < keys[0].frame) {\r\n            frame = keys[0].frame;\r\n        } else if (frame > keys[keys.length - 1].frame) {\r\n            frame = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        // Need to reset animation events\r\n        const events = this._events;\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                if (!events[index].onlyOnce) {\r\n                    // reset events in the future\r\n                    events[index].isDone = events[index].frame < frame;\r\n                }\r\n            }\r\n        }\r\n\r\n        this._currentFrame = frame;\r\n        const currentValue = this._animation._interpolate(frame, this._animationState);\r\n\r\n        this.setValue(currentValue, weight);\r\n    }\r\n\r\n    /**\r\n     * @internal Internal use only\r\n     */\r\n    public _prepareForSpeedRatioChange(newSpeedRatio: number): void {\r\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\r\n\r\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\r\n    }\r\n\r\n    /**\r\n     * Execute the current animation\r\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\r\n     * @param from defines the lower frame of the animation range\r\n     * @param to defines the upper frame of the animation range\r\n     * @param loop defines if the current animation must loop\r\n     * @param speedRatio defines the current speed ratio\r\n     * @param weight defines the weight of the animation (default is -1 so no weight)\r\n     * @returns a boolean indicating if the animation is running\r\n     */\r\n    public animate(elapsedTimeSinceAnimationStart: number, from: number, to: number, loop: boolean, speedRatio: number, weight = -1.0): boolean {\r\n        const animation = this._animation;\r\n        const targetPropertyPath = animation.targetPropertyPath;\r\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\r\n            this._stopped = true;\r\n            return false;\r\n        }\r\n\r\n        let returnValue = true;\r\n        let currentFrame: number;\r\n        const events = this._events;\r\n        let frameRange = 0;\r\n\r\n        if (!this._coreRuntimeAnimation) {\r\n            // Check limits\r\n            if (from < this._minFrame || from > this._maxFrame) {\r\n                from = this._minFrame;\r\n            }\r\n            if (to < this._minFrame || to > this._maxFrame) {\r\n                to = this._maxFrame;\r\n            }\r\n\r\n            frameRange = to - from;\r\n            let offsetValue: any;\r\n\r\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\r\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\r\n            let highLimitValue = 0;\r\n\r\n            // Apply the yoyo function if required\r\n            let yoyoLoop = false;\r\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\r\n            if (yoyoMode) {\r\n                const position = (absoluteFrame - from) / frameRange;\r\n\r\n                // Apply the yoyo curve\r\n                const sin = Math.sin(position * Math.PI);\r\n                const yoyoPosition = Math.abs(sin);\r\n\r\n                // Map the yoyo position back to the range\r\n                absoluteFrame = yoyoPosition * frameRange + from;\r\n\r\n                const direction = sin >= 0 ? 1 : -1;\r\n                if (this._yoyoDirection !== direction) {\r\n                    yoyoLoop = true;\r\n                }\r\n\r\n                this._yoyoDirection = direction;\r\n            }\r\n\r\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\r\n            this._previousAbsoluteFrame = absoluteFrame;\r\n\r\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\r\n                // If we are out of range and not looping get back to caller\r\n                returnValue = false;\r\n                highLimitValue = animation._getKeyValue(this._maxValue);\r\n            } else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\r\n                returnValue = false;\r\n                highLimitValue = animation._getKeyValue(this._minValue);\r\n            } else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\r\n                const keyOffset = to.toString() + from.toString();\r\n                if (!this._offsetsCache[keyOffset]) {\r\n                    this._animationState.repeatCount = 0;\r\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\r\n                    const fromValue = animation._interpolate(from, this._animationState);\r\n                    const toValue = animation._interpolate(to, this._animationState);\r\n\r\n                    this._animationState.loopMode = this._getCorrectLoopMode();\r\n                    switch (animation.dataType) {\r\n                        // Float\r\n                        case Animation.ANIMATIONTYPE_FLOAT:\r\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\r\n                            break;\r\n                        // Quaternion\r\n                        case Animation.ANIMATIONTYPE_QUATERNION:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector3\r\n                        case Animation.ANIMATIONTYPE_VECTOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Vector2\r\n                        case Animation.ANIMATIONTYPE_VECTOR2:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Size\r\n                        case Animation.ANIMATIONTYPE_SIZE:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        // Color3\r\n                        case Animation.ANIMATIONTYPE_COLOR3:\r\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n\r\n                    this._highLimitsCache[keyOffset] = toValue;\r\n                }\r\n\r\n                highLimitValue = this._highLimitsCache[keyOffset];\r\n                offsetValue = this._offsetsCache[keyOffset];\r\n            }\r\n\r\n            if (offsetValue === undefined) {\r\n                switch (animation.dataType) {\r\n                    // Float\r\n                    case Animation.ANIMATIONTYPE_FLOAT:\r\n                        offsetValue = 0;\r\n                        break;\r\n                    // Quaternion\r\n                    case Animation.ANIMATIONTYPE_QUATERNION:\r\n                        offsetValue = _StaticOffsetValueQuaternion;\r\n                        break;\r\n                    // Vector3\r\n                    case Animation.ANIMATIONTYPE_VECTOR3:\r\n                        offsetValue = _StaticOffsetValueVector3;\r\n                        break;\r\n                    // Vector2\r\n                    case Animation.ANIMATIONTYPE_VECTOR2:\r\n                        offsetValue = _StaticOffsetValueVector2;\r\n                        break;\r\n                    // Size\r\n                    case Animation.ANIMATIONTYPE_SIZE:\r\n                        offsetValue = _StaticOffsetValueSize;\r\n                        break;\r\n                    // Color3\r\n                    case Animation.ANIMATIONTYPE_COLOR3:\r\n                        offsetValue = _StaticOffsetValueColor3;\r\n                        break;\r\n                    case Animation.ANIMATIONTYPE_COLOR4:\r\n                        offsetValue = _StaticOffsetValueColor4;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Compute value\r\n\r\n            if (this._host && this._host.syncRoot) {\r\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\r\n                const syncRoot = this._host.syncRoot;\r\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\r\n                currentFrame = from + frameRange * hostNormalizedFrame;\r\n            } else {\r\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\r\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\r\n                } else {\r\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\r\n                }\r\n            }\r\n\r\n            // Reset event/state if looping\r\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\r\n                this._onLoop();\r\n\r\n                // Need to reset animation events\r\n                for (let index = 0; index < events.length; index++) {\r\n                    if (!events[index].onlyOnce) {\r\n                        // reset event, the animation is looping\r\n                        events[index].isDone = false;\r\n                    }\r\n                }\r\n\r\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\r\n            }\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\r\n            this._animationState.highLimitValue = highLimitValue;\r\n            this._animationState.offsetValue = offsetValue;\r\n        } else {\r\n            frameRange = to - from;\r\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\r\n            this._currentFrame = currentFrame;\r\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\r\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\r\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\r\n        }\r\n\r\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\r\n\r\n        // Set value\r\n        this.setValue(currentValue, weight);\r\n\r\n        // Check events\r\n        if (events.length) {\r\n            for (let index = 0; index < events.length; index++) {\r\n                // Make sure current frame has passed event frame and that event frame is within the current range\r\n                // Also, handle both forward and reverse animations\r\n                if (\r\n                    (frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\r\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)\r\n                ) {\r\n                    const event = events[index];\r\n                    if (!event.isDone) {\r\n                        // If event should be done only once, remove it.\r\n                        if (event.onlyOnce) {\r\n                            events.splice(index, 1);\r\n                            index--;\r\n                        }\r\n                        event.isDone = true;\r\n                        event.action(currentFrame);\r\n                    } // Don't do anything if the event has already been done.\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!returnValue) {\r\n            this._stopped = true;\r\n        }\r\n\r\n        return returnValue;\r\n    }\r\n}\r\n", "import { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\r\nimport { Animation } from \"./animation\";\r\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Bone } from \"core/Bones/bone\";\r\nimport type { Node } from \"../node\";\r\n\r\n/**\r\n * Class used to store an actual running animation\r\n */\r\nexport class Animatable {\r\n    /**\r\n     * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\r\n     * This can be used to force the full processing of paused animatables in the animation engine.\r\n     * Default is false.\r\n     */\r\n    public static ProcessPausedAnimatables = false;\r\n\r\n    private _localDelayOffset: Nullable<number> = null;\r\n    private _pausedDelay: Nullable<number> = null;\r\n    private _manualJumpDelay: Nullable<number> = null;\r\n    /** @hidden */\r\n    public _runtimeAnimations = new Array<RuntimeAnimation>();\r\n    private _paused = false;\r\n    private _scene: Scene;\r\n    private _speedRatio = 1;\r\n    private _weight = -1.0;\r\n    private _previousWeight = -1.0;\r\n    private _syncRoot: Nullable<Animatable> = null;\r\n    private _frameToSyncFromJump: Nullable<number> = null;\r\n    private _goToFrame: Nullable<number> = null;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\r\n     * This will only apply for non looping animation (default is true)\r\n     */\r\n    public disposeOnEnd = true;\r\n\r\n    /**\r\n     * Gets a boolean indicating if the animation has started\r\n     */\r\n    public animationStarted = false;\r\n\r\n    /**\r\n     * Observer raised when the animation ends\r\n     */\r\n    public onAnimationEndObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Observer raised when the animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<Animatable>();\r\n\r\n    /**\r\n     * Gets the root Animatable used to synchronize and normalize animations\r\n     */\r\n    public get syncRoot(): Nullable<Animatable> {\r\n        return this._syncRoot;\r\n    }\r\n\r\n    /**\r\n     * Gets the current frame of the first RuntimeAnimation\r\n     * Used to synchronize Animatables\r\n     */\r\n    public get masterFrame(): number {\r\n        if (this._runtimeAnimations.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        return this._runtimeAnimations[0].currentFrame;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (value === -1) {\r\n            // -1 is ok and means no weight\r\n            this._weight = -1;\r\n            return;\r\n        }\r\n\r\n        // Else weight must be in [0, 1] range\r\n        this._weight = Math.min(Math.max(value, 0), 1.0);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    public set speedRatio(value: number) {\r\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\r\n            const animation = this._runtimeAnimations[index];\r\n\r\n            animation._prepareForSpeedRatioChange(value);\r\n        }\r\n        this._speedRatio = value;\r\n\r\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\r\n        if (this._goToFrame !== null) {\r\n            this.goToFrame(this._goToFrame);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the elapsed time since the animatable started in milliseconds\r\n     */\r\n    public get elapsedTime(): number {\r\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Animatable\r\n     * @param scene defines the hosting scene\r\n     * @param target defines the target object\r\n     * @param fromFrame defines the starting frame number (default is 0)\r\n     * @param toFrame defines the ending frame number (default is 100)\r\n     * @param loopAnimation defines if the animation must loop (default is false)\r\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\r\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\r\n     * @param animations defines a group of animation to add to the new Animatable\r\n     * @param onAnimationLoop defines a callback to call when animation loops\r\n     * @param isAdditive defines whether the animation should be evaluated additively\r\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        /** defines the target object */\r\n        public target: any,\r\n        /** [0] defines the starting frame number (default is 0) */\r\n        public fromFrame: number = 0,\r\n        /** [100] defines the ending frame number (default is 100) */\r\n        public toFrame: number = 100,\r\n        /** [false] defines if the animation must loop (default is false)  */\r\n        public loopAnimation: boolean = false,\r\n        speedRatio: number = 1.0,\r\n        /** defines a callback to call when animation ends if it is not looping */\r\n        public onAnimationEnd?: Nullable<() => void>,\r\n        animations?: Animation[],\r\n        /** defines a callback to call when animation loops */\r\n        public onAnimationLoop?: Nullable<() => void>,\r\n        /** [false] defines whether the animation should be evaluated additively */\r\n        public isAdditive: boolean = false,\r\n        /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\r\n        public playOrder = 0\r\n    ) {\r\n        this._scene = scene;\r\n        if (animations) {\r\n            this.appendAnimations(target, animations);\r\n        }\r\n\r\n        this._speedRatio = speedRatio;\r\n        scene._activeAnimatables.push(this);\r\n    }\r\n\r\n    // Methods\r\n    /**\r\n     * Synchronize and normalize current Animatable with a source Animatable\r\n     * This is useful when using animation weights and when animations are not of the same length\r\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the current Animatable\r\n     */\r\n    public syncWith(root: Nullable<Animatable>): Animatable {\r\n        this._syncRoot = root;\r\n\r\n        if (root) {\r\n            // Make sure this animatable will animate after the root\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n            if (index > -1) {\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n                this._scene._activeAnimatables.push(this);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of runtime animations\r\n     * @returns an array of RuntimeAnimation\r\n     */\r\n    public getAnimations(): RuntimeAnimation[] {\r\n        return this._runtimeAnimations;\r\n    }\r\n\r\n    /**\r\n     * Adds more animations to the current animatable\r\n     * @param target defines the target of the animations\r\n     * @param animations defines the new animations to add\r\n     */\r\n    public appendAnimations(target: any, animations: Animation[]): void {\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n\r\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\r\n            newRuntimeAnimation._onLoop = () => {\r\n                this.onAnimationLoopObservable.notifyObservers(this);\r\n                if (this.onAnimationLoop) {\r\n                    this.onAnimationLoop();\r\n                }\r\n            };\r\n\r\n            this._runtimeAnimations.push(newRuntimeAnimation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the source animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the source animation for the given property\r\n     */\r\n    public getAnimationByTargetProperty(property: string): Nullable<Animation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index].animation;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the runtime animation for a specific property\r\n     * @param property defines the property to look for\r\n     * @returns null or the runtime animation for the given property\r\n     */\r\n    public getRuntimeAnimationByTargetProperty(property: string): Nullable<RuntimeAnimation> {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            if (runtimeAnimations[index].animation.targetProperty === property) {\r\n                return runtimeAnimations[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Resets the animatable to its original state\r\n     */\r\n    public reset(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].reset(true);\r\n        }\r\n\r\n        this._localDelayOffset = null;\r\n        this._pausedDelay = null;\r\n    }\r\n\r\n    /**\r\n     * Allows the animatable to blend with current running animations\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     * @param blendingSpeed defines the blending speed to use\r\n     */\r\n    public enableBlending(blendingSpeed: number): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = true;\r\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disable animation blending\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\r\n     */\r\n    public disableBlending(): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].animation.enableBlending = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Jump directly to a given frame\r\n     * @param frame defines the frame to jump to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): void {\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n\r\n        if (runtimeAnimations[0]) {\r\n            const fps = runtimeAnimations[0].animation.framePerSecond;\r\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\r\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\r\n            this._manualJumpDelay = -delay;\r\n        }\r\n\r\n        for (let index = 0; index < runtimeAnimations.length; index++) {\r\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\r\n        }\r\n\r\n        this._goToFrame = frame;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the animations for this animatable are paused\r\n     */\r\n    public get paused() {\r\n        return this._paused;\r\n    }\r\n\r\n    /**\r\n     * Pause the animation\r\n     */\r\n    public pause(): void {\r\n        if (this._paused) {\r\n            return;\r\n        }\r\n        this._paused = true;\r\n    }\r\n\r\n    /**\r\n     * Restart the animation\r\n     */\r\n    public restart(): void {\r\n        this._paused = false;\r\n    }\r\n\r\n    private _raiseOnAnimationEnd() {\r\n        if (this.onAnimationEnd) {\r\n            this.onAnimationEnd();\r\n        }\r\n\r\n        this.onAnimationEndObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Stop and delete the current animation\r\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\r\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\r\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     */\r\n    public stop(animationName?: string, targetMask?: (target: any) => boolean, useGlobalSplice = false, skipOnAnimationEnd = false): void {\r\n        if (animationName || targetMask) {\r\n            const idx = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (idx > -1) {\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\r\n                    const runtimeAnimation = runtimeAnimations[index];\r\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\r\n                        continue;\r\n                    }\r\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\r\n                        continue;\r\n                    }\r\n\r\n                    runtimeAnimation.dispose();\r\n                    runtimeAnimations.splice(index, 1);\r\n                }\r\n\r\n                if (runtimeAnimations.length == 0) {\r\n                    if (!useGlobalSplice) {\r\n                        this._scene._activeAnimatables.splice(idx, 1);\r\n                    }\r\n                    if (!skipOnAnimationEnd) {\r\n                        this._raiseOnAnimationEnd();\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            const index = this._scene._activeAnimatables.indexOf(this);\r\n\r\n            if (index > -1) {\r\n                if (!useGlobalSplice) {\r\n                    this._scene._activeAnimatables.splice(index, 1);\r\n                }\r\n                const runtimeAnimations = this._runtimeAnimations;\r\n\r\n                for (let index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n\r\n                this._runtimeAnimations.length = 0;\r\n\r\n                if (!skipOnAnimationEnd) {\r\n                    this._raiseOnAnimationEnd();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Wait asynchronously for the animation to end\r\n     * @returns a promise which will be fulfilled when the animation ends\r\n     */\r\n    public async waitAsync(): Promise<Animatable> {\r\n        return await new Promise((resolve) => {\r\n            this.onAnimationEndObservable.add(\r\n                () => {\r\n                    resolve(this);\r\n                },\r\n                undefined,\r\n                undefined,\r\n                this,\r\n                true\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _animate(delay: number): boolean {\r\n        if (this._paused) {\r\n            this.animationStarted = false;\r\n            if (this._pausedDelay === null) {\r\n                this._pausedDelay = delay;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        if (this._localDelayOffset === null) {\r\n            this._localDelayOffset = delay;\r\n            this._pausedDelay = null;\r\n        } else if (this._pausedDelay !== null) {\r\n            this._localDelayOffset += delay - this._pausedDelay;\r\n            this._pausedDelay = null;\r\n        }\r\n\r\n        if (this._manualJumpDelay !== null) {\r\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\r\n            this._manualJumpDelay = null;\r\n            this._frameToSyncFromJump = null;\r\n        }\r\n\r\n        this._goToFrame = null;\r\n\r\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\r\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\r\n            return true;\r\n        }\r\n\r\n        this._previousWeight = this._weight;\r\n\r\n        // Animating\r\n        let running = false;\r\n        const runtimeAnimations = this._runtimeAnimations;\r\n        let index: number;\r\n\r\n        for (index = 0; index < runtimeAnimations.length; index++) {\r\n            const animation = runtimeAnimations[index];\r\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\r\n            running = running || isRunning;\r\n        }\r\n\r\n        this.animationStarted = running;\r\n\r\n        if (!running) {\r\n            if (this.disposeOnEnd) {\r\n                // Remove from active animatables\r\n                index = this._scene._activeAnimatables.indexOf(this);\r\n                this._scene._activeAnimatables.splice(index, 1);\r\n\r\n                // Dispose all runtime animations\r\n                for (index = 0; index < runtimeAnimations.length; index++) {\r\n                    runtimeAnimations[index].dispose();\r\n                }\r\n            }\r\n\r\n            this._raiseOnAnimationEnd();\r\n\r\n            if (this.disposeOnEnd) {\r\n                this.onAnimationEnd = null;\r\n                this.onAnimationLoop = null;\r\n                this.onAnimationLoopObservable.clear();\r\n                this.onAnimationEndObservable.clear();\r\n            }\r\n        }\r\n\r\n        return running;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForMatrices(holder: {\r\n    totalWeight: number;\r\n    totalAdditiveWeight: number;\r\n    animations: RuntimeAnimation[];\r\n    additiveAnimations: RuntimeAnimation[];\r\n    originalValue: Matrix;\r\n}): any {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return holder.originalValue;\r\n    }\r\n\r\n    let normalizer = 1.0;\r\n    const finalPosition = TmpVectors.Vector3[0];\r\n    const finalScaling = TmpVectors.Vector3[1];\r\n    const finalQuaternion = TmpVectors.Quaternion[0];\r\n    let startIndex = 0;\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n\r\n    let scale = 1;\r\n    let skipOverride = false;\r\n    if (holder.totalWeight < 1.0) {\r\n        // We need to mix the original value in\r\n        scale = 1.0 - holder.totalWeight;\r\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    } else {\r\n        startIndex = 1;\r\n        // We need to normalize the weights\r\n        normalizer = holder.totalWeight;\r\n        scale = originalAnimation.weight / normalizer;\r\n        if (scale == 1) {\r\n            if (holder.totalAdditiveWeight) {\r\n                skipOverride = true;\r\n            } else {\r\n                return originalAnimation.currentValue;\r\n            }\r\n        }\r\n\r\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\r\n    }\r\n\r\n    // Add up the override animations\r\n    if (!skipOverride) {\r\n        finalScaling.scaleInPlace(scale);\r\n        finalPosition.scaleInPlace(scale);\r\n        finalQuaternion.scaleInPlace(scale);\r\n\r\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            if (runtimeAnimation.weight === 0) {\r\n                continue;\r\n            }\r\n\r\n            scale = runtimeAnimation.weight / normalizer;\r\n            const currentPosition = TmpVectors.Vector3[2];\r\n            const currentScaling = TmpVectors.Vector3[3];\r\n            const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n\r\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\r\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\r\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\r\n        }\r\n\r\n        finalQuaternion.normalize();\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        const currentPosition = TmpVectors.Vector3[2];\r\n        const currentScaling = TmpVectors.Vector3[3];\r\n        const currentQuaternion = TmpVectors.Quaternion[1];\r\n\r\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\r\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\r\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\r\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\r\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\r\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\r\n    }\r\n\r\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\r\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\r\n    return workValue;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindingsForQuaternions(\r\n    holder: {\r\n        totalWeight: number;\r\n        totalAdditiveWeight: number;\r\n        animations: RuntimeAnimation[];\r\n        additiveAnimations: RuntimeAnimation[];\r\n        originalValue: Quaternion;\r\n    },\r\n    refQuaternion: Quaternion\r\n): Quaternion {\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\r\n        return refQuaternion;\r\n    }\r\n\r\n    const originalAnimation = holder.animations[0];\r\n    const originalValue = holder.originalValue;\r\n    let cumulativeQuaternion = refQuaternion;\r\n\r\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\r\n        cumulativeQuaternion.copyFrom(originalValue);\r\n    } else if (holder.animations.length === 1) {\r\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\r\n\r\n        if (holder.totalAdditiveWeight === 0) {\r\n            return cumulativeQuaternion;\r\n        }\r\n    } else if (holder.animations.length > 1) {\r\n        // Add up the override animations\r\n        let normalizer = 1.0;\r\n        let quaternions: Array<Quaternion>;\r\n        let weights: Array<number>;\r\n\r\n        if (holder.totalWeight < 1.0) {\r\n            const scale = 1.0 - holder.totalWeight;\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n\r\n            quaternions.push(originalValue);\r\n            weights.push(scale);\r\n        } else {\r\n            if (holder.animations.length === 2) {\r\n                // Slerp as soon as we can\r\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\r\n\r\n                if (holder.totalAdditiveWeight === 0) {\r\n                    return refQuaternion;\r\n                }\r\n            }\r\n\r\n            quaternions = [];\r\n            weights = [];\r\n            normalizer = holder.totalWeight;\r\n        }\r\n\r\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\r\n            const runtimeAnimation = holder.animations[animIndex];\r\n            quaternions.push(runtimeAnimation.currentValue);\r\n            weights.push(runtimeAnimation.weight / normalizer);\r\n        }\r\n\r\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\r\n\r\n        let cumulativeAmount = 0;\r\n        for (let index = 0; index < quaternions.length; ) {\r\n            if (!index) {\r\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\r\n                cumulativeQuaternion = refQuaternion;\r\n                cumulativeAmount = weights[index] + weights[index + 1];\r\n                index += 2;\r\n                continue;\r\n            }\r\n            cumulativeAmount += weights[index];\r\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\r\n            index++;\r\n        }\r\n    }\r\n\r\n    // Add up the additive animations\r\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n        if (runtimeAnimation.weight === 0) {\r\n            continue;\r\n        }\r\n\r\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\r\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\r\n    }\r\n\r\n    return cumulativeQuaternion;\r\n}\r\n\r\n/** @internal */\r\nfunction ProcessLateAnimationBindings(scene: Scene): void {\r\n    if (!scene._registeredForLateAnimationBindings.length) {\r\n        return;\r\n    }\r\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\r\n        const target = scene._registeredForLateAnimationBindings.data[index];\r\n\r\n        for (const path in target._lateAnimationHolders) {\r\n            const holder = target._lateAnimationHolders[path];\r\n            const originalAnimation: RuntimeAnimation = holder.animations[0];\r\n            const originalValue = holder.originalValue;\r\n            if (originalValue === undefined || originalValue === null) {\r\n                continue;\r\n            }\r\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\r\n\r\n            let finalValue: any = target[path];\r\n            if (matrixDecomposeMode) {\r\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\r\n            } else {\r\n                const quaternionMode = originalValue.w !== undefined;\r\n                if (quaternionMode) {\r\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\r\n                } else {\r\n                    let startIndex = 0;\r\n                    let normalizer = 1.0;\r\n\r\n                    const originalAnimationIsLoopRelativeFromCurrent =\r\n                        originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\r\n\r\n                    if (holder.totalWeight < 1.0) {\r\n                        // We need to mix the original value in\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\r\n                        } else if (originalAnimation && originalValue.scale) {\r\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\r\n                        } else if (originalAnimation) {\r\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\r\n                        } else if (originalValue.clone) {\r\n                            finalValue = originalValue.clone();\r\n                        } else {\r\n                            finalValue = originalValue;\r\n                        }\r\n                    } else if (originalAnimation) {\r\n                        // We need to normalize the weights\r\n                        normalizer = holder.totalWeight;\r\n                        const scale = originalAnimation.weight / normalizer;\r\n                        if (scale !== 1) {\r\n                            if (originalAnimation.currentValue.scale) {\r\n                                finalValue = originalAnimation.currentValue.scale(scale);\r\n                            } else {\r\n                                finalValue = originalAnimation.currentValue * scale;\r\n                            }\r\n                        } else {\r\n                            finalValue = originalAnimation.currentValue;\r\n                        }\r\n\r\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\r\n                            if (finalValue.addToRef) {\r\n                                finalValue.addToRef(originalValue, finalValue);\r\n                            } else {\r\n                                finalValue += originalValue;\r\n                            }\r\n                        }\r\n\r\n                        startIndex = 1;\r\n                    }\r\n\r\n                    // Add up the override animations\r\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.animations[animIndex];\r\n                        const scale = runtimeAnimation.weight / normalizer;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n\r\n                    // Add up the additive animations\r\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\r\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\r\n                        const scale: number = runtimeAnimation.weight;\r\n\r\n                        if (!scale) {\r\n                            continue;\r\n                        } else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\r\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\r\n                        } else {\r\n                            finalValue += runtimeAnimation.currentValue * scale;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            target[path] = finalValue;\r\n        }\r\n\r\n        target._lateAnimationHolders = {};\r\n    }\r\n    scene._registeredForLateAnimationBindings.reset();\r\n}\r\n\r\n/** @internal */\r\nexport function RegisterTargetForLateAnimationBinding(scene: Scene, runtimeAnimation: RuntimeAnimation, originalValue: any): void {\r\n    const target = runtimeAnimation.target;\r\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\r\n\r\n    if (!target._lateAnimationHolders) {\r\n        target._lateAnimationHolders = {};\r\n    }\r\n\r\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\r\n            totalWeight: 0,\r\n            totalAdditiveWeight: 0,\r\n            animations: [],\r\n            additiveAnimations: [],\r\n            originalValue: originalValue,\r\n        };\r\n    }\r\n\r\n    if (runtimeAnimation.isAdditive) {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\r\n    } else {\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\r\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize all the inter dependecies between the animations and Scene and Bone\r\n * @param sceneClass defines the scene prototype to use\r\n * @param boneClass defines the bone prototype to use\r\n */\r\nexport function AddAnimationExtensions(sceneClass: typeof Scene, boneClass: typeof Bone): void {\r\n    if (boneClass) {\r\n        boneClass.prototype.copyAnimationRange = function (\r\n            source: Bone,\r\n            rangeName: string,\r\n            frameOffset: number,\r\n            rescaleAsRequired = false,\r\n            skelDimensionsRatio: Nullable<Vector3> = null\r\n        ): boolean {\r\n            // all animation may be coming from a library skeleton, so may need to create animation\r\n            if (this.animations.length === 0) {\r\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\r\n                this.animations[0].setKeys([]);\r\n            }\r\n\r\n            // get animation info / verify there is such a range from the source bone\r\n            const sourceRange = source.animations[0].getRange(rangeName);\r\n            if (!sourceRange) {\r\n                return false;\r\n            }\r\n            const from = sourceRange.from;\r\n            const to = sourceRange.to;\r\n            const sourceKeys = source.animations[0].getKeys();\r\n\r\n            // rescaling prep\r\n            const sourceBoneLength = source.length;\r\n            const sourceParent = source.getParent();\r\n            const parent = this.getParent();\r\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\r\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\r\n\r\n            const dimensionsScalingReqd =\r\n                rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\r\n\r\n            const destKeys = this.animations[0].getKeys();\r\n\r\n            // loop vars declaration\r\n            let orig: { frame: number; value: Matrix };\r\n            let origTranslation: Vector3;\r\n            let mat: Matrix;\r\n\r\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\r\n                orig = sourceKeys[key];\r\n                if (orig.frame >= from && orig.frame <= to) {\r\n                    if (rescaleAsRequired) {\r\n                        mat = orig.value.clone();\r\n\r\n                        // scale based on parent ratio, when bone has parent\r\n                        if (parentScalingReqd) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\r\n\r\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\r\n                        } else if (dimensionsScalingReqd && skelDimensionsRatio) {\r\n                            origTranslation = mat.getTranslation();\r\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\r\n\r\n                            // use original when root bone, and no data for skelDimensionsRatio\r\n                        } else {\r\n                            mat = orig.value;\r\n                        }\r\n                    } else {\r\n                        mat = orig.value;\r\n                    }\r\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\r\n                }\r\n            }\r\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\r\n            return true;\r\n        };\r\n    }\r\n\r\n    if (!sceneClass) {\r\n        return;\r\n    }\r\n\r\n    sceneClass.prototype._animate = function (customDeltaTime?: number): void {\r\n        if (!this.animationsEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Getting time\r\n        const now = PrecisionDate.Now;\r\n        if (!this._animationTimeLast) {\r\n            if (this._pendingData.length > 0) {\r\n                return;\r\n            }\r\n            this._animationTimeLast = now;\r\n        }\r\n\r\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\r\n        this._animationTimeLast = now;\r\n\r\n        const animatables = this._activeAnimatables;\r\n        if (animatables.length === 0) {\r\n            return;\r\n        }\r\n\r\n        this._animationTime += this.deltaTime;\r\n        const animationTime = this._animationTime;\r\n\r\n        for (let index = 0; index < animatables.length; index++) {\r\n            const animatable = animatables[index];\r\n\r\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\r\n                index--; // Array was updated\r\n            }\r\n        }\r\n\r\n        // Late animation bindings\r\n        ProcessLateAnimationBindings(this);\r\n    };\r\n\r\n    sceneClass.prototype.sortActiveAnimatables = function (): void {\r\n        this._activeAnimatables.sort((a, b) => {\r\n            return a.playOrder - b.playOrder;\r\n        });\r\n    };\r\n\r\n    sceneClass.prototype.beginWeightedAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        weight = 1.0,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\r\n        returnedAnimatable.weight = weight;\r\n\r\n        return returnedAnimatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginAnimation = function (\r\n        target: any,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        if (stopCurrent) {\r\n            this.stopAnimation(target, undefined, targetMask);\r\n        }\r\n\r\n        if (!animatable) {\r\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\r\n        }\r\n\r\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\r\n        // Local animations\r\n        if (target.animations && shouldRunTargetAnimations) {\r\n            animatable.appendAnimations(target, target.animations);\r\n        }\r\n\r\n        // Children animations\r\n        if (target.getAnimatables) {\r\n            const animatables = target.getAnimatables();\r\n            for (let index = 0; index < animatables.length; index++) {\r\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\r\n            }\r\n        }\r\n\r\n        animatable.reset();\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginHierarchyAnimation = function (\r\n        target: any,\r\n        directDescendantsOnly: boolean,\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        animatable?: Animatable,\r\n        stopCurrent = true,\r\n        targetMask?: (target: any) => boolean,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectAnimation = function (\r\n        target: any,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio: number = 1.0,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable {\r\n        // get speed speedRatio, to and from, based on the sign and value(s)\r\n        if (speedRatio < 0) {\r\n            const tmp = from;\r\n            from = to;\r\n            to = tmp;\r\n            speedRatio = -speedRatio;\r\n        }\r\n        // if from > to switch speed ratio\r\n        if (from > to) {\r\n            speedRatio = -speedRatio;\r\n        }\r\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\r\n\r\n        return animatable;\r\n    };\r\n\r\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (\r\n        target: Node,\r\n        directDescendantsOnly: boolean,\r\n        animations: Animation[],\r\n        from: number,\r\n        to: number,\r\n        loop?: boolean,\r\n        speedRatio?: number,\r\n        onAnimationEnd?: () => void,\r\n        onAnimationLoop?: () => void,\r\n        isAdditive = false\r\n    ): Animatable[] {\r\n        const children = target.getDescendants(directDescendantsOnly);\r\n\r\n        const result = [];\r\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        for (const child of children) {\r\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.getAnimatableByTarget = function (target: any): Nullable<Animatable> {\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                return this._activeAnimatables[index];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target: any): Array<Animatable> {\r\n        const result = [];\r\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\r\n            if (this._activeAnimatables[index].target === target) {\r\n                result.push(this._activeAnimatables[index]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    sceneClass.prototype.stopAnimation = function (target: any, animationName?: string, targetMask?: (target: any) => boolean): void {\r\n        const animatables = this.getAllAnimatablesByTarget(target);\r\n\r\n        for (const animatable of animatables) {\r\n            animatable.stop(animationName, targetMask);\r\n        }\r\n    };\r\n\r\n    sceneClass.prototype.stopAllAnimations = function (): void {\r\n        if (this._activeAnimatables) {\r\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\r\n                this._activeAnimatables[i].stop(undefined, undefined, true);\r\n            }\r\n            this._activeAnimatables.length = 0;\r\n        }\r\n\r\n        for (const group of this.animationGroups) {\r\n            group.stop();\r\n        }\r\n    };\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport { Bone } from \"../Bones/bone\";\r\nimport type { Node } from \"../node\";\r\nimport { AddAnimationExtensions } from \"./animatable.core\";\r\nimport type { Animatable } from \"./animatable.core\";\r\nimport type { Animation } from \"./animation\";\r\nimport { Scene } from \"core/scene\";\r\n\r\nexport * from \"./animatable.core\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * Sort active animatables based on their playOrder property\r\n         */\r\n        sortActiveAnimatables(): void;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param weight defines the weight to apply to the animation (1.0 by default)\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginWeightedAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            weight: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animate if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the animatable object created for this animation\r\n         */\r\n        beginAnimation(\r\n            target: any,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Will start the animation sequence of a given target and its hierarchy\r\n         * @param target defines the target\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param from defines from which frame should animation start\r\n         * @param to defines until which frame should animation run.\r\n         * @param loop defines if the animation loops\r\n         * @param speedRatio defines the speed in which to run the animation (1.0 by default)\r\n         * @param onAnimationEnd defines the function to be executed when the animation ends\r\n         * @param animatable defines an animatable object. If not provided a new one will be created from the given params\r\n         * @param stopCurrent defines if the current animations must be stopped first (true by default)\r\n         * @param targetMask defines if the target should be animated if animations are present (this is called recursively on descendant animatables regardless of return value)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginHierarchyAnimation(\r\n            target: any,\r\n            directDescendantsOnly: boolean,\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            animatable?: Animatable,\r\n            stopCurrent?: boolean,\r\n            targetMask?: (target: any) => boolean,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Begin a new animation on a given node\r\n         *\r\n         * Note that it is possible that the value(s) of speedRatio from and to will be changed if the animation is inverted\r\n         * @param target defines the target where the animation will take place\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of created animatables\r\n         */\r\n        beginDirectAnimation(\r\n            target: any,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable;\r\n\r\n        /**\r\n         * Begin a new animation on a given node and its hierarchy\r\n         * @param target defines the root node where the animation will take place\r\n         * @param directDescendantsOnly if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.\r\n         * @param animations defines the list of animations to start\r\n         * @param from defines the initial value\r\n         * @param to defines the final value\r\n         * @param loop defines if you want animation to loop (off by default)\r\n         * @param speedRatio defines the speed ratio to apply to all animations\r\n         * @param onAnimationEnd defines the callback to call when an animation ends (will be called once per node)\r\n         * @param onAnimationLoop defines the callback to call when an animation loops\r\n         * @param isAdditive defines whether the animation should be evaluated additively (false by default)\r\n         * @returns the list of animatables created for all nodes\r\n         */\r\n        beginDirectHierarchyAnimation(\r\n            target: Node,\r\n            directDescendantsOnly: boolean,\r\n            animations: Animation[],\r\n            from: number,\r\n            to: number,\r\n            loop?: boolean,\r\n            speedRatio?: number,\r\n            onAnimationEnd?: () => void,\r\n            onAnimationLoop?: () => void,\r\n            isAdditive?: boolean\r\n        ): Animatable[];\r\n\r\n        /**\r\n         * Gets the animatable associated with a specific target\r\n         * @param target defines the target of the animatable\r\n         * @returns the required animatable if found\r\n         */\r\n        getAnimatableByTarget(target: any): Nullable<Animatable>;\r\n\r\n        /**\r\n         * Gets all animatables associated with a given target\r\n         * @param target defines the target to look animatables for\r\n         * @returns an array of Animatables\r\n         */\r\n        getAllAnimatablesByTarget(target: any): Array<Animatable>;\r\n\r\n        /**\r\n         * Stops and removes all animations that have been applied to the scene\r\n         */\r\n        stopAllAnimations(): void;\r\n    }\r\n}\r\n\r\ndeclare module \"../Bones/bone\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Bone {\r\n        /**\r\n         * Copy an animation range from another bone\r\n         * @param source defines the source bone\r\n         * @param rangeName defines the range name to copy\r\n         * @param frameOffset defines the frame offset\r\n         * @param rescaleAsRequired defines if rescaling must be applied if required\r\n         * @param skelDimensionsRatio defines the scaling ratio\r\n         * @returns true if operation was successful\r\n         */\r\n        copyAnimationRange(source: Bone, rangeName: string, frameOffset: number, rescaleAsRequired: boolean, skelDimensionsRatio: Nullable<Vector3>): boolean;\r\n    }\r\n}\r\n\r\n// Connect everything!\r\nAddAnimationExtensions(Scene, Bone);\r\n", "import type { Animatable } from \"./animatable.core\";\r\nimport { Animation } from \"./animation\";\r\nimport type { IMakeAnimationAdditiveOptions } from \"./animation\";\r\nimport type { IAnimationKey } from \"./animationKey\";\r\n\r\nimport type { Scene, IDisposable } from \"../scene\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Node } from \"../node\";\r\n\r\nimport { Tags } from \"../Misc/tags\";\r\nimport type { AnimationGroupMask } from \"./animationGroupMask\";\r\nimport \"./animatable\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\r\n\r\n/**\r\n * This class defines the direct association between an animation and a target\r\n */\r\nexport class TargetedAnimation {\r\n    /**\r\n     * Animation to perform\r\n     */\r\n    public animation: Animation;\r\n\r\n    /**\r\n     * Target to animate\r\n     */\r\n    public target: any;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the targeted animation\r\n     */\r\n    public readonly uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n    /**\r\n     * Returns the string \"TargetedAnimation\"\r\n     * @returns \"TargetedAnimation\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"TargetedAnimation\";\r\n    }\r\n\r\n    /**\r\n     * Creates a new targeted animation\r\n     * @param parent The animation group to which the animation belongs\r\n     */\r\n    constructor(public readonly parent: AnimationGroup) {}\r\n\r\n    /**\r\n     * Serialize the object\r\n     * @returns the JSON object representing the current entity\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.animation = this.animation.serialize();\r\n        serializationObject.targetId = this.target.id;\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n\r\n/**\r\n * Options to be used when creating an additive group animation\r\n */\r\nexport interface IMakeAnimationGroupAdditiveOptions extends IMakeAnimationAdditiveOptions {\r\n    /**\r\n     * Defines if the animation group should be cloned or not (default is false)\r\n     */\r\n    cloneOriginalAnimationGroup?: boolean;\r\n    /**\r\n     * The name of the cloned animation group if cloneOriginalAnimationGroup is true\r\n     */\r\n    clonedAnimationGroupName?: string;\r\n}\r\n\r\n/**\r\n * Use this class to create coordinated animations on multiple targets\r\n */\r\nexport class AnimationGroup implements IDisposable {\r\n    private _scene: Scene;\r\n\r\n    private _targetedAnimations = new Array<TargetedAnimation>();\r\n    private _animatables = new Array<Animatable>();\r\n    private _from = Number.MAX_VALUE;\r\n    private _to = -Number.MAX_VALUE;\r\n    private _isStarted: boolean;\r\n    private _isPaused: boolean;\r\n    private _speedRatio = 1;\r\n    private _loopAnimation = false;\r\n    private _isAdditive = false;\r\n    private _weight = -1;\r\n    private _playOrder = 0;\r\n    private _enableBlending: Nullable<boolean> = null;\r\n    private _blendingSpeed: Nullable<number> = null;\r\n    private _numActiveAnimatables = 0;\r\n    private _shouldStart = true;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Gets or sets the unique id of the node\r\n     */\r\n    public uniqueId: number;\r\n\r\n    /**\r\n     * This observable will notify when one animation have ended\r\n     */\r\n    public onAnimationEndObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when one animation loops\r\n     */\r\n    public onAnimationLoopObservable = new Observable<TargetedAnimation>();\r\n\r\n    /**\r\n     * Observer raised when all animations have looped\r\n     */\r\n    public onAnimationGroupLoopObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have ended.\r\n     */\r\n    public onAnimationGroupEndObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations have paused.\r\n     */\r\n    public onAnimationGroupPauseObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * This observable will notify when all animations are playing.\r\n     */\r\n    public onAnimationGroupPlayObservable = new Observable<AnimationGroup>();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the node\r\n     */\r\n    public metadata: any = null;\r\n\r\n    private _mask: Nullable<AnimationGroupMask> = null;\r\n\r\n    /**\r\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\r\n     */\r\n    public get mask() {\r\n        return this._mask;\r\n    }\r\n\r\n    public set mask(value: Nullable<AnimationGroupMask>) {\r\n        if (this._mask === value) {\r\n            return;\r\n        }\r\n\r\n        this._mask = value;\r\n\r\n        this.syncWithMask(true);\r\n    }\r\n\r\n    /**\r\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\r\n     * Note however that the call won't have any effect if the animation group has not been started yet.\r\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\r\n     */\r\n    public syncWithMask(forceUpdate = false) {\r\n        if (!this.mask && !forceUpdate) {\r\n            this._numActiveAnimatables = this._targetedAnimations.length;\r\n            return;\r\n        }\r\n\r\n        this._numActiveAnimatables = 0;\r\n\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\r\n                this._numActiveAnimatables++;\r\n                if (animatable.paused) {\r\n                    animatable.restart();\r\n                }\r\n            } else {\r\n                if (!animatable.paused) {\r\n                    animatable.pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all animations for the targets not retained by the animation group mask.\r\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\r\n     */\r\n    public removeUnmaskedAnimations() {\r\n        if (!this.mask || this.mask.disabled) {\r\n            return;\r\n        }\r\n\r\n        // Removes all animatables (in case the animation group has already been started)\r\n        for (let i = 0; i < this._animatables.length; ++i) {\r\n            const animatable = this._animatables[i];\r\n\r\n            if (!this.mask.retainsTarget(animatable.target.name)) {\r\n                animatable.stop();\r\n                this._animatables.splice(i, 1);\r\n                --i;\r\n            }\r\n        }\r\n\r\n        // Removes the targeted animations\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n\r\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\r\n                this._targetedAnimations.splice(index, 1);\r\n                --index;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the first frame\r\n     */\r\n    public get from(): number {\r\n        return this._from;\r\n    }\r\n\r\n    public set from(value: number) {\r\n        if (this._from === value) {\r\n            return;\r\n        }\r\n\r\n        this._from = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.fromFrame = this._from;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the last frame\r\n     */\r\n    public get to(): number {\r\n        return this._to;\r\n    }\r\n\r\n    public set to(value: number) {\r\n        if (this._to === value) {\r\n            return;\r\n        }\r\n\r\n        this._to = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.toFrame = this._to;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Define if the animations are started\r\n     */\r\n    public get isStarted(): boolean {\r\n        return this._isStarted;\r\n    }\r\n\r\n    /**\r\n     * Gets a value indicating that the current group is playing\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._isStarted && !this._isPaused;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public get speedRatio(): number {\r\n        return this._speedRatio;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the speed ratio to use for all animations\r\n     */\r\n    public set speedRatio(value: number) {\r\n        if (this._speedRatio === value) {\r\n            return;\r\n        }\r\n\r\n        this._speedRatio = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.speedRatio = this._speedRatio;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should loop or not\r\n     */\r\n    public get loopAnimation(): boolean {\r\n        return this._loopAnimation;\r\n    }\r\n\r\n    public set loopAnimation(value: boolean) {\r\n        if (this._loopAnimation === value) {\r\n            return;\r\n        }\r\n\r\n        this._loopAnimation = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.loopAnimation = this._loopAnimation;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets if all animations should be evaluated additively\r\n     */\r\n    public get isAdditive(): boolean {\r\n        return this._isAdditive;\r\n    }\r\n\r\n    public set isAdditive(value: boolean) {\r\n        if (this._isAdditive === value) {\r\n            return;\r\n        }\r\n\r\n        this._isAdditive = value;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.isAdditive = this._isAdditive;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the weight to apply to all animations of the group\r\n     */\r\n    public get weight(): number {\r\n        return this._weight;\r\n    }\r\n\r\n    public set weight(value: number) {\r\n        if (this._weight === value) {\r\n            return;\r\n        }\r\n\r\n        this._weight = value;\r\n        this.setWeightForAllAnimatables(this._weight);\r\n    }\r\n\r\n    /**\r\n     * Gets the targeted animations for this animation group\r\n     */\r\n    public get targetedAnimations(): Array<TargetedAnimation> {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * returning the list of animatables controlled by this animation group.\r\n     */\r\n    public get animatables(): Array<Animatable> {\r\n        return this._animatables;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of target animations\r\n     */\r\n    public get children() {\r\n        return this._targetedAnimations;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the order of play of the animation group (default: 0)\r\n     */\r\n    public get playOrder() {\r\n        return this._playOrder;\r\n    }\r\n\r\n    public set playOrder(value: number) {\r\n        if (this._playOrder === value) {\r\n            return;\r\n        }\r\n\r\n        this._playOrder = value;\r\n\r\n        if (this._animatables.length > 0) {\r\n            for (let i = 0; i < this._animatables.length; i++) {\r\n                this._animatables[i].playOrder = this._playOrder;\r\n            }\r\n\r\n            this._scene.sortActiveAnimatables();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows the animations of the animation group to blend with current running animations\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\r\n     */\r\n    public get enableBlending() {\r\n        return this._enableBlending;\r\n    }\r\n\r\n    public set enableBlending(value: Nullable<boolean>) {\r\n        if (this._enableBlending === value) {\r\n            return;\r\n        }\r\n\r\n        this._enableBlending = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.enableBlending = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the animation blending speed\r\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\r\n     */\r\n    public get blendingSpeed() {\r\n        return this._blendingSpeed;\r\n    }\r\n\r\n    public set blendingSpeed(value: Nullable<number>) {\r\n        if (this._blendingSpeed === value) {\r\n            return;\r\n        }\r\n\r\n        this._blendingSpeed = value;\r\n\r\n        if (value !== null) {\r\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\r\n                this._targetedAnimations[i].animation.blendingSpeed = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the length (in seconds) of the animation group\r\n     * This function assumes that all animations are played at the same framePerSecond speed!\r\n     * Note: you can only call this method after you've added at least one targeted animation!\r\n     * @param from Starting frame range (default is AnimationGroup.from)\r\n     * @param to Ending frame range (default is AnimationGroup.to)\r\n     * @returns The length in seconds\r\n     */\r\n    public getLength(from?: number, to?: number): number {\r\n        from = from ?? this._from;\r\n        to = to ?? this._to;\r\n\r\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\r\n\r\n        return (to - from) / fps;\r\n    }\r\n\r\n    /**\r\n     * Merge the array of animation groups into a new animation group\r\n     * @param animationGroups List of animation groups to merge\r\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\r\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\r\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\r\n     * @returns The new animation group or null if no animation groups were passed\r\n     */\r\n    public static MergeAnimationGroups(animationGroups: Array<AnimationGroup>, disposeSource = true, normalize = false, weight?: number): Nullable<AnimationGroup> {\r\n        if (animationGroups.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        weight = weight ?? animationGroups[0].weight;\r\n\r\n        let beginFrame = Number.MAX_VALUE;\r\n        let endFrame = -Number.MAX_VALUE;\r\n\r\n        if (normalize) {\r\n            for (const animationGroup of animationGroups) {\r\n                if (animationGroup.from < beginFrame) {\r\n                    beginFrame = animationGroup.from;\r\n                }\r\n\r\n                if (animationGroup.to > endFrame) {\r\n                    endFrame = animationGroup.to;\r\n                }\r\n            }\r\n        }\r\n\r\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\r\n\r\n        for (const animationGroup of animationGroups) {\r\n            if (normalize) {\r\n                animationGroup.normalize(beginFrame, endFrame);\r\n            }\r\n\r\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\r\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\r\n            }\r\n\r\n            if (disposeSource) {\r\n                animationGroup.dispose();\r\n            }\r\n        }\r\n\r\n        return mergedAnimationGroup;\r\n    }\r\n\r\n    /**\r\n     * Gets the scene the animation group belongs to\r\n     * @returns The scene the animation group belongs to\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Instantiates a new Animation Group.\r\n     * This helps managing several animations at once.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\r\n     * @param name Defines the name of the group\r\n     * @param scene Defines the scene the group belongs to\r\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\r\n     * @param playOrder Defines the order of play of the animation group (default is 0)\r\n     */\r\n    public constructor(\r\n        /** The name of the animation group */\r\n        public name: string,\r\n        scene: Nullable<Scene> = null,\r\n        weight = -1,\r\n        playOrder = 0\r\n    ) {\r\n        this._scene = scene || EngineStore.LastCreatedScene!;\r\n        this._weight = weight;\r\n        this._playOrder = playOrder;\r\n        this.uniqueId = this._scene.getUniqueId();\r\n\r\n        this._scene.addAnimationGroup(this);\r\n    }\r\n\r\n    /**\r\n     * Add an animation (with its target) in the group\r\n     * @param animation defines the animation we want to add\r\n     * @param target defines the target of the animation\r\n     * @returns the TargetedAnimation object\r\n     */\r\n    public addTargetedAnimation(animation: Animation, target: any): TargetedAnimation {\r\n        const targetedAnimation = new TargetedAnimation(this);\r\n        targetedAnimation.animation = animation;\r\n        targetedAnimation.target = target;\r\n\r\n        const keys = animation.getKeys();\r\n        if (this._from > keys[0].frame) {\r\n            this._from = keys[0].frame;\r\n        }\r\n\r\n        if (this._to < keys[keys.length - 1].frame) {\r\n            this._to = keys[keys.length - 1].frame;\r\n        }\r\n\r\n        if (this._enableBlending !== null) {\r\n            animation.enableBlending = this._enableBlending;\r\n        }\r\n\r\n        if (this._blendingSpeed !== null) {\r\n            animation.blendingSpeed = this._blendingSpeed;\r\n        }\r\n\r\n        this._targetedAnimations.push(targetedAnimation);\r\n        this._shouldStart = true;\r\n\r\n        return targetedAnimation;\r\n    }\r\n\r\n    /**\r\n     * Remove an animation from the group\r\n     * @param animation defines the animation we want to remove\r\n     */\r\n    public removeTargetedAnimation(animation: Animation) {\r\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            if (targetedAnimation.animation === animation) {\r\n                this._targetedAnimations.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\r\n     * It can add constant keys at begin or end\r\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\r\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\r\n     * @returns the animation group\r\n     */\r\n    public normalize(beginFrame: Nullable<number> = null, endFrame: Nullable<number> = null): AnimationGroup {\r\n        if (beginFrame == null) {\r\n            beginFrame = this._from;\r\n        }\r\n        if (endFrame == null) {\r\n            endFrame = this._to;\r\n        }\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const keys = targetedAnimation.animation.getKeys();\r\n            const startKey = keys[0];\r\n            const endKey = keys[keys.length - 1];\r\n\r\n            if (startKey.frame > beginFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: beginFrame,\r\n                    value: startKey.value,\r\n                    inTangent: startKey.inTangent,\r\n                    outTangent: startKey.outTangent,\r\n                    interpolation: startKey.interpolation,\r\n                };\r\n                keys.splice(0, 0, newKey);\r\n            }\r\n\r\n            if (endKey.frame < endFrame) {\r\n                const newKey: IAnimationKey = {\r\n                    frame: endFrame,\r\n                    value: endKey.value,\r\n                    inTangent: endKey.inTangent,\r\n                    outTangent: endKey.outTangent,\r\n                    interpolation: endKey.interpolation,\r\n                };\r\n                keys.push(newKey);\r\n            }\r\n        }\r\n\r\n        this._from = beginFrame;\r\n        this._to = endFrame;\r\n\r\n        return this;\r\n    }\r\n\r\n    private _animationLoopCount: number;\r\n    private _animationLoopFlags: boolean[] = [];\r\n\r\n    private _processLoop(animatable: Animatable, targetedAnimation: TargetedAnimation, index: number) {\r\n        animatable.onAnimationLoop = () => {\r\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\r\n\r\n            if (this._animationLoopFlags[index]) {\r\n                return;\r\n            }\r\n\r\n            this._animationLoopFlags[index] = true;\r\n\r\n            this._animationLoopCount++;\r\n            if (this._animationLoopCount === this._numActiveAnimatables) {\r\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\r\n                this._animationLoopCount = 0;\r\n                this._animationLoopFlags.length = 0;\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Start all animations on given targets\r\n     * @param loop defines if animations must loop\r\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\r\n     * @param from defines the from key (optional)\r\n     * @param to defines the to key (optional)\r\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\r\n     * @returns the current animation group\r\n     */\r\n    public start(loop = false, speedRatio = 1, from?: number, to?: number, isAdditive?: boolean): AnimationGroup {\r\n        if (this._isStarted || this._targetedAnimations.length === 0) {\r\n            return this;\r\n        }\r\n\r\n        this._loopAnimation = loop;\r\n\r\n        this._shouldStart = false;\r\n        this._animationLoopCount = 0;\r\n        this._animationLoopFlags.length = 0;\r\n\r\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\r\n            const targetedAnimation = this._targetedAnimations[index];\r\n            const animatable = this._scene.beginDirectAnimation(\r\n                targetedAnimation.target,\r\n                [targetedAnimation.animation],\r\n                from !== undefined ? from : this._from,\r\n                to !== undefined ? to : this._to,\r\n                loop,\r\n                speedRatio,\r\n                undefined,\r\n                undefined,\r\n                isAdditive !== undefined ? isAdditive : this._isAdditive\r\n            );\r\n            animatable.weight = this._weight;\r\n            animatable.playOrder = this._playOrder;\r\n            animatable.onAnimationEnd = () => {\r\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\r\n                this._checkAnimationGroupEnded(animatable);\r\n            };\r\n\r\n            this._processLoop(animatable, targetedAnimation, index);\r\n            this._animatables.push(animatable);\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._scene.sortActiveAnimatables();\r\n\r\n        this._speedRatio = speedRatio;\r\n\r\n        this._isStarted = true;\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Pause all animations\r\n     * @returns the animation group\r\n     */\r\n    public pause(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        this._isPaused = true;\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.pause();\r\n        }\r\n\r\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Play all animations to initial state\r\n     * This function will start() the animations if they were not started or will restart() them if they were paused\r\n     * @param loop defines if animations must loop\r\n     * @returns the animation group\r\n     */\r\n    public play(loop?: boolean): AnimationGroup {\r\n        // only if there are animatable available\r\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\r\n            if (loop !== undefined) {\r\n                this.loopAnimation = loop;\r\n            }\r\n            this.restart();\r\n        } else {\r\n            this.stop();\r\n            this.start(loop, this._speedRatio);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Reset all animations to initial state\r\n     * @returns the animation group\r\n     */\r\n    public reset(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            this.play();\r\n            this.goToFrame(0);\r\n            this.stop(true);\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.reset();\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Restart animations from after pausing it\r\n     * @returns the animation group\r\n     */\r\n    public restart(): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.restart();\r\n        }\r\n\r\n        this.syncWithMask();\r\n\r\n        this._isPaused = false;\r\n\r\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Stop all animations\r\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\r\n     * @returns the animation group\r\n     */\r\n    public stop(skipOnAnimationEnd = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        const list = this._animatables.slice();\r\n        for (let index = 0; index < list.length; index++) {\r\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\r\n        }\r\n\r\n        // We will take care of removing all stopped animatables\r\n        let curIndex = 0;\r\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\r\n            const animatable = this._scene._activeAnimatables[index];\r\n            if (animatable._runtimeAnimations.length > 0) {\r\n                this._scene._activeAnimatables[curIndex++] = animatable;\r\n            } else if (skipOnAnimationEnd) {\r\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\r\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\r\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\r\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\r\n            }\r\n        }\r\n        this._scene._activeAnimatables.length = curIndex;\r\n\r\n        this._isStarted = false;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set animation weight for all animatables\r\n     *\r\n     * @since 6.12.4\r\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\r\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\r\n     * @param weight defines the weight to use\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public setWeightForAllAnimatables(weight: number): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.weight = weight;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Synchronize and normalize all animatables with a source animatable\r\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\r\n     * @returns the animationGroup\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\r\n     */\r\n    public syncAllAnimationsWith(root: Nullable<Animatable>): AnimationGroup {\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.syncWith(root);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\r\n     * @param frame the frame number to go to\r\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\r\n     * @returns the animationGroup\r\n     */\r\n    public goToFrame(frame: number, useWeight = false): AnimationGroup {\r\n        if (!this._isStarted) {\r\n            return this;\r\n        }\r\n\r\n        for (let index = 0; index < this._animatables.length; index++) {\r\n            const animatable = this._animatables[index];\r\n            animatable.goToFrame(frame, useWeight);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\r\n     * @returns current animation frame.\r\n     */\r\n    public getCurrentFrame(): number {\r\n        return this.animatables[0]?.masterFrame || 0;\r\n    }\r\n\r\n    /**\r\n     * Dispose all associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (this.isStarted) {\r\n            this.stop();\r\n        }\r\n        this._targetedAnimations.length = 0;\r\n        this._animatables.length = 0;\r\n\r\n        // Remove from scene\r\n        const index = this._scene.animationGroups.indexOf(this);\r\n\r\n        if (index > -1) {\r\n            this._scene.animationGroups.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.animationGroups.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.animationGroups.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        this.onAnimationEndObservable.clear();\r\n        this.onAnimationGroupEndObservable.clear();\r\n        this.onAnimationGroupPauseObservable.clear();\r\n        this.onAnimationGroupPlayObservable.clear();\r\n        this.onAnimationLoopObservable.clear();\r\n        this.onAnimationGroupLoopObservable.clear();\r\n    }\r\n\r\n    private _checkAnimationGroupEnded(animatable: Animatable, skipOnAnimationEnd = false) {\r\n        // animatable should be taken out of the array\r\n        const idx = this._animatables.indexOf(animatable);\r\n        if (idx > -1) {\r\n            this._animatables.splice(idx, 1);\r\n        }\r\n\r\n        // all animatables were removed? animation group ended!\r\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\r\n            this._isStarted = false;\r\n            if (!skipOnAnimationEnd) {\r\n                this.onAnimationGroupEndObservable.notifyObservers(this);\r\n            }\r\n            this._animatables.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current animation group and returns a copy\r\n     * @param newName defines the name of the new group\r\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\r\n     * @param cloneAnimations defines if the animations should be cloned or referenced\r\n     * @returns the new animation group\r\n     */\r\n    public clone(newName: string, targetConverter?: (oldTarget: any) => any, cloneAnimations = false): AnimationGroup {\r\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\r\n\r\n        newGroup._from = this.from;\r\n        newGroup._to = this.to;\r\n        newGroup._speedRatio = this.speedRatio;\r\n        newGroup._loopAnimation = this.loopAnimation;\r\n        newGroup._isAdditive = this.isAdditive;\r\n        newGroup._enableBlending = this.enableBlending;\r\n        newGroup._blendingSpeed = this.blendingSpeed;\r\n        newGroup.metadata = this.metadata;\r\n        newGroup.mask = this.mask;\r\n\r\n        for (const targetAnimation of this._targetedAnimations) {\r\n            newGroup.addTargetedAnimation(\r\n                cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation,\r\n                targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target\r\n            );\r\n        }\r\n\r\n        return newGroup;\r\n    }\r\n\r\n    /**\r\n     * Serializes the animationGroup to an object\r\n     * @returns Serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.from = this.from;\r\n        serializationObject.to = this.to;\r\n        serializationObject.speedRatio = this.speedRatio;\r\n        serializationObject.loopAnimation = this.loopAnimation;\r\n        serializationObject.isAdditive = this.isAdditive;\r\n        serializationObject.weight = this.weight;\r\n        serializationObject.playOrder = this.playOrder;\r\n        serializationObject.enableBlending = this.enableBlending;\r\n        serializationObject.blendingSpeed = this.blendingSpeed;\r\n\r\n        serializationObject.targetedAnimations = [];\r\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\r\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\r\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\r\n        }\r\n\r\n        if (Tags && Tags.HasTags(this)) {\r\n            serializationObject.tags = Tags.GetTags(this);\r\n        }\r\n\r\n        // Metadata\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Returns a new AnimationGroup object parsed from the source provided.\r\n     * @param parsedAnimationGroup defines the source\r\n     * @param scene defines the scene that will receive the animationGroup\r\n     * @param nodeMap a map of node.id to node in this scene, to accelerate node lookup\r\n     * @returns a new AnimationGroup\r\n     */\r\n    public static Parse(parsedAnimationGroup: any, scene: Scene, nodeMap?: Map<Node[\"id\"], Node>): AnimationGroup {\r\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\r\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\r\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\r\n            const animation = Animation.Parse(targetedAnimation.animation);\r\n            const id = targetedAnimation.targetId;\r\n            if (targetedAnimation.animation.property === \"influence\") {\r\n                // morph target animation\r\n                const morphTarget = scene.getMorphTargetById(id);\r\n                if (morphTarget) {\r\n                    animationGroup.addTargetedAnimation(animation, morphTarget);\r\n                }\r\n            } else {\r\n                const targetNode = nodeMap ? nodeMap.get(id) : scene.getNodeById(id);\r\n\r\n                if (targetNode != null) {\r\n                    animationGroup.addTargetedAnimation(animation, targetNode);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (Tags) {\r\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\r\n        }\r\n\r\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\r\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\r\n        }\r\n\r\n        if (parsedAnimationGroup.speedRatio !== undefined) {\r\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\r\n        }\r\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\r\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\r\n        }\r\n\r\n        if (parsedAnimationGroup.isAdditive !== undefined) {\r\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\r\n        }\r\n\r\n        if (parsedAnimationGroup.weight !== undefined) {\r\n            animationGroup._weight = parsedAnimationGroup.weight;\r\n        }\r\n\r\n        if (parsedAnimationGroup.playOrder !== undefined) {\r\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\r\n        }\r\n\r\n        if (parsedAnimationGroup.enableBlending !== undefined) {\r\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\r\n        }\r\n\r\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\r\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\r\n        }\r\n\r\n        if (parsedAnimationGroup.metadata !== undefined) {\r\n            animationGroup.metadata = parsedAnimationGroup.metadata;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to (default: 0)\r\n     * @param range defines the name of the AnimationRange belonging to the animations in the group to convert\r\n     * @param cloneOriginal defines whether or not to clone the group and convert the clone or convert the original group (default is false)\r\n     * @param clonedName defines the name of the resulting cloned AnimationGroup if cloneOriginal is true\r\n     * @returns a new AnimationGroup if cloneOriginal is true or the original AnimationGroup if cloneOriginal is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, referenceFrame: number, range?: string, cloneOriginal?: boolean, clonedName?: string): AnimationGroup;\r\n\r\n    /**\r\n     * Convert the keyframes for all animations belonging to the group to be relative to a given reference frame.\r\n     * @param sourceAnimationGroup defines the AnimationGroup containing animations to convert\r\n     * @param options defines the options to use when converting keyframes\r\n     * @returns a new AnimationGroup if options.cloneOriginalAnimationGroup is true or the original AnimationGroup if options.cloneOriginalAnimationGroup is false\r\n     */\r\n    public static MakeAnimationAdditive(sourceAnimationGroup: AnimationGroup, options?: IMakeAnimationGroupAdditiveOptions): AnimationGroup;\r\n\r\n    /** @internal */\r\n    public static MakeAnimationAdditive(\r\n        sourceAnimationGroup: AnimationGroup,\r\n        referenceFrameOrOptions?: number | IMakeAnimationGroupAdditiveOptions,\r\n        range?: string,\r\n        cloneOriginal = false,\r\n        clonedName?: string\r\n    ): AnimationGroup {\r\n        let options: IMakeAnimationGroupAdditiveOptions;\r\n\r\n        if (typeof referenceFrameOrOptions === \"object\") {\r\n            options = referenceFrameOrOptions;\r\n        } else {\r\n            options = {\r\n                referenceFrame: referenceFrameOrOptions,\r\n                range: range,\r\n                cloneOriginalAnimationGroup: cloneOriginal,\r\n                clonedAnimationName: clonedName,\r\n            };\r\n        }\r\n\r\n        let animationGroup = sourceAnimationGroup;\r\n        if (options.cloneOriginalAnimationGroup) {\r\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\r\n        }\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\r\n        }\r\n\r\n        animationGroup.isAdditive = true;\r\n\r\n        if (options.clipKeys) {\r\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\r\n            let from = Number.MAX_VALUE;\r\n            let to = -Number.MAX_VALUE;\r\n\r\n            const targetedAnimations = animationGroup.targetedAnimations;\r\n            for (let index = 0; index < targetedAnimations.length; index++) {\r\n                const targetedAnimation = targetedAnimations[index];\r\n                const animation = targetedAnimation.animation;\r\n                const keys = animation.getKeys();\r\n\r\n                if (from > keys[0].frame) {\r\n                    from = keys[0].frame;\r\n                }\r\n\r\n                if (to < keys[keys.length - 1].frame) {\r\n                    to = keys[keys.length - 1].frame;\r\n                }\r\n            }\r\n\r\n            animationGroup._from = from;\r\n            animationGroup._to = to;\r\n        }\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the keys that are inside a given key range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeys(sourceAnimationGroup: AnimationGroup, fromKey: number, toKey: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromKey defines the lower bound of the range\r\n     * @param toKey defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipKeysInPlace(animationGroup: AnimationGroup, fromKey: number, toKey: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\r\n    }\r\n\r\n    /**\r\n     * Creates a new animation, keeping only the frames that are inside a given frame range\r\n     * @param sourceAnimationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns a new animation group stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFrames(sourceAnimationGroup: AnimationGroup, fromFrame: number, toFrame: number, name?: string, dontCloneAnimations?: boolean): AnimationGroup {\r\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\r\n\r\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param fromFrame defines the lower bound of the range\r\n     * @param toFrame defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\r\n     * @returns the animationGroup stripped from all the frames outside the given range\r\n     */\r\n    public static ClipFramesInPlace(animationGroup: AnimationGroup, fromFrame: number, toFrame: number, dontCloneAnimations?: boolean): AnimationGroup {\r\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\r\n    }\r\n\r\n    /**\r\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\r\n     * @param animationGroup defines the animation group on which to operate\r\n     * @param start defines the lower bound of the range\r\n     * @param end defines the upper bound of the range\r\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\r\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\r\n     * @returns the animationGroup stripped from all the keys outside the given range\r\n     */\r\n    public static ClipInPlace(animationGroup: AnimationGroup, start: number, end: number, dontCloneAnimations?: boolean, useFrame = false): AnimationGroup {\r\n        let from = Number.MAX_VALUE;\r\n        let to = -Number.MAX_VALUE;\r\n\r\n        const targetedAnimations = animationGroup.targetedAnimations;\r\n        for (let index = 0; index < targetedAnimations.length; index++) {\r\n            const targetedAnimation = targetedAnimations[index];\r\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\r\n\r\n            if (useFrame) {\r\n                // Make sure we have keys corresponding to the bounds of the frame range\r\n                animation.createKeyForFrame(start);\r\n                animation.createKeyForFrame(end);\r\n            }\r\n\r\n            const keys = animation.getKeys();\r\n            const newKeys: IAnimationKey[] = [];\r\n\r\n            let startFrame = Number.MAX_VALUE;\r\n            for (let k = 0; k < keys.length; k++) {\r\n                const key = keys[k];\r\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\r\n                    const newKey: IAnimationKey = {\r\n                        frame: key.frame,\r\n                        value: key.value.clone ? key.value.clone() : key.value,\r\n                        inTangent: key.inTangent,\r\n                        outTangent: key.outTangent,\r\n                        interpolation: key.interpolation,\r\n                        lockedTangent: key.lockedTangent,\r\n                    };\r\n                    if (startFrame === Number.MAX_VALUE) {\r\n                        startFrame = newKey.frame;\r\n                    }\r\n                    newKey.frame -= startFrame;\r\n                    newKeys.push(newKey);\r\n                }\r\n            }\r\n\r\n            if (newKeys.length === 0) {\r\n                targetedAnimations.splice(index, 1);\r\n                index--;\r\n                continue;\r\n            }\r\n\r\n            if (from > newKeys[0].frame) {\r\n                from = newKeys[0].frame;\r\n            }\r\n\r\n            if (to < newKeys[newKeys.length - 1].frame) {\r\n                to = newKeys[newKeys.length - 1].frame;\r\n            }\r\n\r\n            animation.setKeys(newKeys, true);\r\n            targetedAnimation.animation = animation; // in case the animation has been cloned\r\n        }\r\n\r\n        animationGroup._from = from;\r\n        animationGroup._to = to;\r\n\r\n        return animationGroup;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"AnimationGroup\"\r\n     * @returns \"AnimationGroup\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"AnimationGroup\";\r\n    }\r\n\r\n    /**\r\n     * Creates a detailed string about the object\r\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\r\n     * @returns a string representing the object\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n        ret += \", type: \" + this.getClassName();\r\n        if (fullDetails) {\r\n            ret += \", from: \" + this._from;\r\n            ret += \", to: \" + this._to;\r\n            ret += \", isStarted: \" + this._isStarted;\r\n            ret += \", speedRatio: \" + this._speedRatio;\r\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\r\n            ret += \", animatables length: \" + this._animatables;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["target", "index", "index", "targetedAnimations"]
}
