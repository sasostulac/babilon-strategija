import {
  FlowGraphCachedOperationBlock
} from "./chunk-I2ECT365.js";
import {
  FlowGraphInteger,
  RichTypeAny,
  RichTypeFlowGraphInteger
} from "./chunk-OCDSLKBA.js";
import {
  Color3,
  Color4
} from "./chunk-5HS37WJT.js";
import {
  Vector3,
  Vector4
} from "./chunk-EURVBQY7.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";

// node_modules/@babylonjs/core/FlowGraph/flowGraphPathConverterComponent.js
var PathHasTemplatesRegex = new RegExp(/\/\{(\w+)\}(?=\/|$)/g);
var FlowGraphPathConverterComponent = class {
  constructor(path, ownerBlock) {
    this.path = path;
    this.ownerBlock = ownerBlock;
    this.templatedInputs = [];
    let match = PathHasTemplatesRegex.exec(path);
    const templateSet = /* @__PURE__ */ new Set();
    while (match) {
      const [, matchGroup] = match;
      if (templateSet.has(matchGroup)) {
        throw new Error("Duplicate template variable detected.");
      }
      templateSet.add(matchGroup);
      this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));
      match = PathHasTemplatesRegex.exec(path);
    }
  }
  /**
   * Get the accessor for the path.
   * @param pathConverter the path converter to use to convert the path to an object accessor.
   * @param context the context to use.
   * @returns the accessor for the path.
   * @throws if the value for a templated input is invalid.
   */
  getAccessor(pathConverter, context) {
    let finalPath = this.path;
    for (const templatedInput of this.templatedInputs) {
      const valueToReplace = templatedInput.getValue(context).value;
      if (typeof valueToReplace !== "number" || valueToReplace < 0) {
        throw new Error("Invalid value for templated input.");
      }
      finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());
    }
    return pathConverter.convert(finalPath);
  }
};

// node_modules/@babylonjs/core/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.js
var FlowGraphJsonPointerParserBlock = class extends FlowGraphCachedOperationBlock {
  constructor(config) {
    super(RichTypeAny, config);
    this.config = config;
    this.object = this.registerDataOutput("object", RichTypeAny);
    this.propertyName = this.registerDataOutput("propertyName", RichTypeAny);
    this.setterFunction = this.registerDataOutput("setFunction", RichTypeAny, this._setPropertyValue.bind(this));
    this.getterFunction = this.registerDataOutput("getFunction", RichTypeAny, this._getPropertyValue.bind(this));
    this.generateAnimationsFunction = this.registerDataOutput("generateAnimationsFunction", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));
    this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);
  }
  _doOperation(context) {
    const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);
    const value = accessorContainer.info.get(accessorContainer.object);
    const object = accessorContainer.info.getTarget?.(accessorContainer.object);
    const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);
    if (!object) {
      throw new Error("Object is undefined");
    } else {
      this.object.setValue(object, context);
      if (propertyName) {
        this.propertyName.setValue(propertyName, context);
      }
    }
    return value;
  }
  _setPropertyValue(_target, _propertyName, value, context) {
    const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);
    const type = accessorContainer.info.type;
    if (type.startsWith("Color")) {
      value = ToColor(value, type);
    }
    accessorContainer.info.set?.(value, accessorContainer.object);
  }
  _getPropertyValue(_target, _propertyName, context) {
    const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);
    const type = accessorContainer.info.type;
    const value = accessorContainer.info.get(accessorContainer.object);
    if (type.startsWith("Color")) {
      return FromColor(value);
    }
    return value;
  }
  _getInterpolationAnimationPropertyInfo(_target, _propertyName, context) {
    const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);
    return (keys, fps, animationType, easingFunction) => {
      const animations = [];
      const type = accessorContainer.info.type;
      if (type.startsWith("Color")) {
        keys = keys.map((key) => {
          return {
            frame: key.frame,
            value: ToColor(key.value, type)
          };
        });
      }
      accessorContainer.info.interpolation?.forEach((info, index) => {
        const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || "Animation-interpolation-" + index;
        let newKeys = keys;
        if (animationType !== info.type) {
          newKeys = keys.map((key) => {
            return {
              frame: key.frame,
              value: info.getValue(void 0, key.value.asArray ? key.value.asArray() : [key.value], 0, 1)
            };
          });
        }
        const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);
        for (const animation of animationData) {
          if (easingFunction) {
            animation.babylonAnimation.setEasingFunction(easingFunction);
          }
          animations.push(animation.babylonAnimation);
        }
      });
      return animations;
    };
  }
  /**
   * Gets the class name of this block
   * @returns the class name
   */
  getClassName() {
    return "FlowGraphJsonPointerParserBlock";
  }
};
function ToColor(value, expectedValue) {
  if (value.getClassName().startsWith("Color")) {
    return value;
  }
  if (expectedValue === "Color3") {
    return new Color3(value.x, value.y, value.z);
  } else if (expectedValue === "Color4") {
    return new Color4(value.x, value.y, value.z, value.w);
  }
  return value;
}
function FromColor(value) {
  if (value instanceof Color3) {
    return new Vector3(value.r, value.g, value.b);
  } else if (value instanceof Color4) {
    return new Vector4(value.r, value.g, value.b, value.a);
  }
  throw new Error("Invalid color type");
}
RegisterClass("FlowGraphJsonPointerParserBlock", FlowGraphJsonPointerParserBlock);

export {
  FlowGraphPathConverterComponent,
  FlowGraphJsonPointerParserBlock
};
//# sourceMappingURL=chunk-VCHKU3XE.js.map
