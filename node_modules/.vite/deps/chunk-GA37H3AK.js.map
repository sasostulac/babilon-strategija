{
  "version": 3,
  "sources": ["../../../dev/core/src/AudioV2/audioUtils.ts", "../../../dev/core/src/AudioV2/webAudio/components/webAudioParameterComponent.ts", "../../../dev/core/src/AudioV2/abstractAudio/abstractAudioNode.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\nimport { AudioParameterRampShape } from \"./audioParameter\";\n\nexport const _FileExtensionRegex = new RegExp(\"\\\\.(\\\\w{3,4})($|\\\\?)\");\n\nconst CurveLength = 100;\n\nconst TmpLineValues = new Float32Array([0, 0]);\nlet TmpCurveValues: Nullable<Float32Array> = null;\n\nlet ExpCurve: Nullable<Float32Array> = null;\nlet LogCurve: Nullable<Float32Array> = null;\n\n/**\n * @returns A Float32Array representing an exponential ramp from (0, 0) to (1, 1).\n */\nfunction GetExpCurve(): Float32Array {\n    if (!ExpCurve) {\n        ExpCurve = new Float32Array(CurveLength);\n\n        const increment = 1 / (CurveLength - 1);\n        let x = increment;\n        for (let i = 1; i < CurveLength; i++) {\n            ExpCurve[i] = Math.exp(-11.512925464970227 * (1 - x));\n            x += increment;\n        }\n    }\n\n    return ExpCurve;\n}\n\n/**\n * @returns A Float32Array representing a logarithmic ramp from (0, 0) to (1, 1).\n */\nfunction GetLogCurve(): Float32Array {\n    if (!LogCurve) {\n        LogCurve = new Float32Array(CurveLength);\n\n        const increment = 1 / CurveLength;\n        let x = increment;\n        for (let i = 0; i < CurveLength; i++) {\n            LogCurve[i] = 1 + Math.log10(x) / Math.log10(CurveLength);\n            x += increment;\n        }\n    }\n\n    return LogCurve;\n}\n\n/** @internal */\nexport function _GetAudioParamCurveValues(shape: AudioParameterRampShape, from: number, to: number): Float32Array {\n    if (!TmpCurveValues) {\n        TmpCurveValues = new Float32Array(CurveLength);\n    }\n\n    let normalizedCurve: Float32Array;\n\n    if (shape === AudioParameterRampShape.Linear) {\n        TmpLineValues[0] = from;\n        TmpLineValues[1] = to;\n        return TmpLineValues;\n    } else if (shape === AudioParameterRampShape.Exponential) {\n        normalizedCurve = GetExpCurve();\n    } else if (shape === AudioParameterRampShape.Logarithmic) {\n        normalizedCurve = GetLogCurve();\n    } else {\n        throw new Error(`Unknown ramp shape: ${shape}`);\n    }\n\n    const direction = Math.sign(to - from);\n    const range = Math.abs(to - from);\n\n    if (direction === 1) {\n        for (let i = 0; i < normalizedCurve.length; i++) {\n            TmpCurveValues[i] = from + range * normalizedCurve[i];\n        }\n    } else {\n        let j = CurveLength - 1;\n        for (let i = 0; i < normalizedCurve.length; i++, j--) {\n            TmpCurveValues[i] = from - range * (1 - normalizedCurve[j]);\n        }\n    }\n\n    return TmpCurveValues;\n}\n\n/** @internal */\nexport function _CleanUrl(url: string) {\n    return url.replace(/#/gm, \"%23\");\n}\n", "import type { Nullable } from \"../../../types\";\nimport type { IAudioParameterRampOptions } from \"../../audioParameter\";\nimport { AudioParameterRampShape } from \"../../audioParameter\";\nimport { _GetAudioParamCurveValues } from \"../../audioUtils\";\nimport type { _WebAudioEngine } from \"../webAudioEngine\";\n\n/**\n * Maximum time in seconds to wait for an active ramp to finish before starting a new ramp.\n *\n * New ramps will throw an error if the active ramp has more than this amount of time remaining.\n *\n * This is needed because short ramps are used to avoid pops and clicks when setting audio parameters, and we\n * don't want to throw an error if a short ramp is active.\n *\n * This constant is set to 11 milliseconds, which is short enough to avoid perceptual differences in most cases, but\n * long enough to allow for short ramps to be completed in a reasonable time frame.\n */\nconst MaxWaitTime = 0.011;\n\n/**\n * Minimum duration in seconds for a ramp to be considered valid.\n *\n * If the duration is less than this value, the value will be set immediately instead of being ramped smoothly since\n * there is no perceptual difference for such short durations, so a ramp is not needed.\n */\nconst MinRampDuration = 0.000001;\n\n/** @internal */\nexport class _WebAudioParameterComponent {\n    private _deferredRampOptions = {\n        duration: 0,\n        shape: AudioParameterRampShape.Linear,\n    };\n    private _deferredTargetValue = -1;\n    private _isObservingUpdates = false;\n    private _rampEndTime: number = 0;\n    private _engine: _WebAudioEngine;\n    private _param: AudioParam;\n    private _targetValue: number;\n\n    /** @internal */\n    constructor(engine: _WebAudioEngine, param: AudioParam) {\n        this._engine = engine;\n        this._param = param;\n        this._targetValue = param.value;\n    }\n\n    /** @internal */\n    public get isRamping(): boolean {\n        return this._engine.currentTime < this._rampEndTime;\n    }\n\n    /** @internal */\n    public get targetValue(): number {\n        return this._targetValue;\n    }\n\n    public set targetValue(value: number) {\n        this.setTargetValue(value);\n    }\n\n    /** @internal */\n    public get value(): number {\n        return this._param.value;\n    }\n\n    /** @internal */\n    public dispose(): void {\n        this._clearDeferredRamp();\n\n        this._param = null!;\n        this._engine = null!;\n    }\n\n    /**\n     * Sets the target value of the audio parameter with an optional ramping duration and shape.\n     *\n     * If a ramp is close to finishing, it will wait for the ramp to finish before setting the new value; otherwise it\n     * will throw an error because of a bug in Firefox that prevents active ramps from being cancelled with\n     * `cancelScheduledValues`. See https://bugzilla.mozilla.org/show_bug.cgi?id=1752775. Other browsers do not have\n     * this issue, but we throw an error in all browsers to ensure consistent behavior.\n     *\n     * There are other similar WebAudio APIs for ramping parameters, (e.g. `linearRampToValueAtTime` and\n     * `exponentialRampToValueAtTime`) but they don't work in Firefox and Meta Quest Chrome.\n     *\n     * It may be better in the long run to implement our own ramping logic with a WASM audio worklet instead of using\n     * `setValueCurveAtTime`. Another alternative is to use `setValueAtTime` wtih a custom shape, but that will\n     * probably be a performance hit to maintain quality at audio rates.\n     *\n     * @internal\n     */\n    public setTargetValue(value: number, options: Nullable<Partial<IAudioParameterRampOptions>> = null): void {\n        if (this._targetValue === value) {\n            return;\n        }\n\n        const shape = typeof options?.shape === \"string\" ? options.shape : AudioParameterRampShape.Linear;\n\n        let duration = typeof options?.duration === \"number\" ? Math.max(options.duration, this._engine.parameterRampDuration) : this._engine.parameterRampDuration;\n        const startTime = this._engine.currentTime;\n\n        if (startTime < this._rampEndTime) {\n            const timeLeft = this._rampEndTime - startTime;\n\n            if (MaxWaitTime < timeLeft) {\n                throw new Error(\"Audio parameter not set. Wait for current ramp to finish.\");\n            } else {\n                this._deferRamp(value, duration, shape);\n                return;\n            }\n        }\n\n        if ((duration = Math.max(this._engine.parameterRampDuration, duration)) < MinRampDuration) {\n            this._param.setValueAtTime((this._targetValue = value), startTime);\n            return;\n        }\n\n        this._param.cancelScheduledValues(startTime);\n        this._param.setValueCurveAtTime(_GetAudioParamCurveValues(shape, this._targetValue, (this._targetValue = value)), startTime, duration);\n\n        this._clearDeferredRamp();\n\n        this._rampEndTime = startTime + duration;\n    }\n\n    private _deferRamp(value: number, duration: number, shape: AudioParameterRampShape): void {\n        this._deferredRampOptions.duration = duration;\n        this._deferredRampOptions.shape = shape;\n        this._deferredTargetValue = value;\n\n        if (!this._isObservingUpdates) {\n            this._engine._addUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = true;\n        }\n    }\n\n    private _applyDeferredRamp = () => {\n        if (0 < this._deferredRampOptions.duration && this._rampEndTime < this._engine.currentTime) {\n            this.setTargetValue(this._deferredTargetValue, this._deferredRampOptions);\n        }\n    };\n\n    private _clearDeferredRamp(): void {\n        this._deferredRampOptions.duration = 0;\n\n        if (this._isObservingUpdates) {\n            this._engine._removeUpdateObserver(this._applyDeferredRamp);\n            this._isObservingUpdates = false;\n        }\n    }\n}\n", "import { Observable } from \"../../Misc/observable\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\nexport const enum AudioNodeType {\n    HAS_INPUTS = 1,\n    HAS_OUTPUTS = 2,\n    HAS_INPUTS_AND_OUTPUTS = 3,\n}\n\n/**\n * Abstract class for an audio node.\n *\n * An audio node is a processing unit that can receive audio data from an upstream node and/or send audio data to a\n * downstream node.\n *\n * Nodes can be connected to other nodes to create an audio graph. The audio graph represents the flow of audio data.\n *\n * There are 3 types of audio nodes:\n * 1. Input: Receives audio data from upstream nodes.\n * 2. Output: Sends audio data to downstream nodes.\n * 3. Input/Output: Receives audio data from upstream nodes and sends audio data to downstream nodes.\n */\nexport abstract class AbstractAudioNode {\n    /**\n     * The connected downstream audio nodes.\n     * - Undefined for input nodes.\n     */\n    protected readonly _downstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The connected upstream audio nodes.\n     * - Undefined for output nodes.\n     */\n    protected readonly _upstreamNodes?: Set<AbstractAudioNode>;\n\n    /**\n     * The audio engine this node belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * Observable for when the audio node is disposed.\n     */\n    public readonly onDisposeObservable = new Observable<AbstractAudioNode>();\n\n    protected constructor(engine: AudioEngineV2, nodeType: AudioNodeType) {\n        this.engine = engine;\n\n        if (nodeType & AudioNodeType.HAS_INPUTS) {\n            this._upstreamNodes = new Set<AbstractAudioNode>();\n        }\n\n        if (nodeType & AudioNodeType.HAS_OUTPUTS) {\n            this._downstreamNodes = new Set<AbstractAudioNode>();\n        }\n    }\n\n    /**\n     * Releases associated resources.\n     * - Triggers `onDisposeObservable`.\n     * @see {@link onDisposeObservable}\n     */\n    public dispose(): void {\n        if (this._downstreamNodes) {\n            for (const node of Array.from(this._downstreamNodes)) {\n                if (!this._disconnect(node)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._downstreamNodes.clear();\n        }\n\n        if (this._upstreamNodes) {\n            for (const node of Array.from(this._upstreamNodes)) {\n                if (!node._disconnect(this)) {\n                    throw new Error(\"Disconnect failed\");\n                }\n            }\n            this._upstreamNodes.clear();\n        }\n\n        this.onDisposeObservable.notifyObservers(this);\n        this.onDisposeObservable.clear();\n    }\n\n    /**\n     * Gets a string identifying the name of the class\n     * @returns the class's name as a string\n     */\n    public abstract getClassName(): string;\n\n    /**\n     * Connect to a downstream audio input node.\n     * @param node - The downstream audio input node to connect\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    protected _connect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (this._downstreamNodes.has(node)) {\n            return false;\n        }\n\n        if (!node._onConnect(this)) {\n            return false;\n        }\n\n        this._downstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Disconnects a downstream audio input node.\n     * @param node - The downstream audio input node to disconnect\n     * @returns `true` if the node is successfully disconnected; otherwise `false`\n     */\n    protected _disconnect(node: AbstractAudioNode): boolean {\n        if (!this._downstreamNodes) {\n            return false;\n        }\n\n        if (!this._downstreamNodes.delete(node)) {\n            return false;\n        }\n\n        return node._onDisconnect(this);\n    }\n\n    /**\n     * Called when an upstream audio output node is connecting.\n     * @param node - The connecting upstream audio node\n     * @returns `true` if the node is successfully connected; otherwise `false`\n     */\n    private _onConnect(node: AbstractAudioNode): boolean {\n        if (!this._upstreamNodes) {\n            return false;\n        }\n\n        if (this._upstreamNodes.has(node)) {\n            return false;\n        }\n\n        this._upstreamNodes.add(node);\n\n        return true;\n    }\n\n    /**\n     * Called when an upstream audio output node disconnects.\n     * @param node - The disconnecting upstream audio node\n     * @returns `true` if node is sucessfully disconnected; otherwise `false`\n     */\n    private _onDisconnect(node: AbstractAudioNode): boolean {\n        return this._upstreamNodes?.delete(node) ?? false;\n    }\n}\n\n/**\n * Abstract class for a named audio node.\n */\nexport abstract class AbstractNamedAudioNode extends AbstractAudioNode {\n    private _name: string;\n\n    /**\n     * Observable for when the audio node is renamed.\n     */\n    public readonly onNameChangedObservable = new Observable<{ newName: string; oldName: string; node: AbstractNamedAudioNode }>();\n\n    protected constructor(name: string, engine: AudioEngineV2, nodeType: AudioNodeType) {\n        super(engine, nodeType);\n\n        this._name = name;\n    }\n\n    /**\n     * The name of the audio node.\n     * - Triggers `onNameChangedObservable` when changed.\n     * @see {@link onNameChangedObservable}\n     */\n    public get name(): string {\n        return this._name;\n    }\n\n    public set name(newName: string) {\n        if (this._name === newName) {\n            return;\n        }\n\n        const oldName = this._name;\n\n        this._name = newName;\n\n        this.onNameChangedObservable.notifyObservers({ newName, oldName, node: this });\n    }\n\n    public override dispose(): void {\n        super.dispose();\n\n        this.onNameChangedObservable.clear();\n    }\n}\n"],
  "mappings": ";;;;;AAGO,IAAM,sBAAsB,IAAI,OAAO,sBAAsB;AAEpE,IAAM,cAAc;AAEpB,IAAM,gBAAgB,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;AAC7C,IAAI,iBAAyC;AAE7C,IAAI,WAAmC;AACvC,IAAI,WAAmC;AAKvC,SAAS,cAAW;AAChB,MAAI,CAAC,UAAU;AACX,eAAW,IAAI,aAAa,WAAW;AAEvC,UAAM,YAAY,KAAK,cAAc;AACrC,QAAI,IAAI;AACR,aAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,eAAS,CAAC,IAAI,KAAK,IAAI,uBAAuB,IAAI,EAAE;AACpD,WAAK;IACT;EACJ;AAEA,SAAO;AACX;AAKA,SAAS,cAAW;AAChB,MAAI,CAAC,UAAU;AACX,eAAW,IAAI,aAAa,WAAW;AAEvC,UAAM,YAAY,IAAI;AACtB,QAAI,IAAI;AACR,aAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,eAAS,CAAC,IAAI,IAAI,KAAK,MAAM,CAAC,IAAI,KAAK,MAAM,WAAW;AACxD,WAAK;IACT;EACJ;AAEA,SAAO;AACX;AAGM,SAAU,0BAA0B,OAAgC,MAAc,IAAU;AAC9F,MAAI,CAAC,gBAAgB;AACjB,qBAAiB,IAAI,aAAa,WAAW;EACjD;AAEA,MAAI;AAEJ,MAAI,UAAK,UAAqC;AAC1C,kBAAc,CAAC,IAAI;AACnB,kBAAc,CAAC,IAAI;AACnB,WAAO;EACX,WAAW,UAAK,eAA0C;AACtD,sBAAkB,YAAW;EACjC,WAAW,UAAK,eAA0C;AACtD,sBAAkB,YAAW;EACjC,OAAO;AACH,UAAM,IAAI,MAAM,uBAAuB,KAAK,EAAE;EAClD;AAEA,QAAM,YAAY,KAAK,KAAK,KAAK,IAAI;AACrC,QAAM,QAAQ,KAAK,IAAI,KAAK,IAAI;AAEhC,MAAI,cAAc,GAAG;AACjB,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK;AAC7C,qBAAe,CAAC,IAAI,OAAO,QAAQ,gBAAgB,CAAC;IACxD;EACJ,OAAO;AACH,QAAI,IAAI,cAAc;AACtB,aAAS,IAAI,GAAG,IAAI,gBAAgB,QAAQ,KAAK,KAAK;AAClD,qBAAe,CAAC,IAAI,OAAO,SAAS,IAAI,gBAAgB,CAAC;IAC7D;EACJ;AAEA,SAAO;AACX;AAGM,SAAU,UAAU,KAAW;AACjC,SAAO,IAAI,QAAQ,OAAO,KAAK;AACnC;;;ACxEA,IAAM,cAAc;AAQpB,IAAM,kBAAkB;AAGlB,IAAO,8BAAP,MAAkC;;EAapC,YAAY,QAAyB,OAAiB;AAZ9C,SAAA,uBAAuB;MAC3B,UAAU;MACV,OAAK;;AAED,SAAA,uBAAuB;AACvB,SAAA,sBAAsB;AACtB,SAAA,eAAuB;AAqGvB,SAAA,qBAAqB,MAAK;AAC9B,UAAI,IAAI,KAAK,qBAAqB,YAAY,KAAK,eAAe,KAAK,QAAQ,aAAa;AACxF,aAAK,eAAe,KAAK,sBAAsB,KAAK,oBAAoB;MAC5E;IACJ;AAlGI,SAAK,UAAU;AACf,SAAK,SAAS;AACd,SAAK,eAAe,MAAM;EAC9B;;EAGA,IAAW,YAAS;AAChB,WAAO,KAAK,QAAQ,cAAc,KAAK;EAC3C;;EAGA,IAAW,cAAW;AAClB,WAAO,KAAK;EAChB;EAEA,IAAW,YAAY,OAAa;AAChC,SAAK,eAAe,KAAK;EAC7B;;EAGA,IAAW,QAAK;AACZ,WAAO,KAAK,OAAO;EACvB;;EAGO,UAAO;AACV,SAAK,mBAAkB;AAEvB,SAAK,SAAS;AACd,SAAK,UAAU;EACnB;;;;;;;;;;;;;;;;;;EAmBO,eAAe,OAAe,UAAyD,MAAI;AAC9F,QAAI,KAAK,iBAAiB,OAAO;AAC7B;IACJ;AAEA,UAAM,QAAQ,OAAO,SAAS,UAAU,WAAW,QAAQ,QAAO;AAElE,QAAI,WAAW,OAAO,SAAS,aAAa,WAAW,KAAK,IAAI,QAAQ,UAAU,KAAK,QAAQ,qBAAqB,IAAI,KAAK,QAAQ;AACrI,UAAM,YAAY,KAAK,QAAQ;AAE/B,QAAI,YAAY,KAAK,cAAc;AAC/B,YAAM,WAAW,KAAK,eAAe;AAErC,UAAI,cAAc,UAAU;AACxB,cAAM,IAAI,MAAM,2DAA2D;MAC/E,OAAO;AACH,aAAK,WAAW,OAAO,UAAU,KAAK;AACtC;MACJ;IACJ;AAEA,SAAK,WAAW,KAAK,IAAI,KAAK,QAAQ,uBAAuB,QAAQ,KAAK,iBAAiB;AACvF,WAAK,OAAO,eAAgB,KAAK,eAAe,OAAQ,SAAS;AACjE;IACJ;AAEA,SAAK,OAAO,sBAAsB,SAAS;AAC3C,SAAK,OAAO,oBAAoB,0BAA0B,OAAO,KAAK,cAAe,KAAK,eAAe,KAAM,GAAG,WAAW,QAAQ;AAErI,SAAK,mBAAkB;AAEvB,SAAK,eAAe,YAAY;EACpC;EAEQ,WAAW,OAAe,UAAkB,OAA8B;AAC9E,SAAK,qBAAqB,WAAW;AACrC,SAAK,qBAAqB,QAAQ;AAClC,SAAK,uBAAuB;AAE5B,QAAI,CAAC,KAAK,qBAAqB;AAC3B,WAAK,QAAQ,mBAAmB,KAAK,kBAAkB;AACvD,WAAK,sBAAsB;IAC/B;EACJ;EAQQ,qBAAkB;AACtB,SAAK,qBAAqB,WAAW;AAErC,QAAI,KAAK,qBAAqB;AAC1B,WAAK,QAAQ,sBAAsB,KAAK,kBAAkB;AAC1D,WAAK,sBAAsB;IAC/B;EACJ;;;;AClJJ,IAAkB;CAAlB,SAAkBA,gBAAa;AAC3B,EAAAA,eAAAA,eAAA,YAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,aAAA,IAAA,CAAA,IAAA;AACA,EAAAA,eAAAA,eAAA,wBAAA,IAAA,CAAA,IAAA;AACJ,GAJkB,kBAAA,gBAAa,CAAA,EAAA;AAmBzB,IAAgB,oBAAhB,MAAiC;EAuBnC,YAAsB,QAAuB,UAAuB;AAFpD,SAAA,sBAAsB,IAAI,WAAU;AAGhD,SAAK,SAAS;AAEd,QAAI,WAAQ,GAA6B;AACrC,WAAK,iBAAiB,oBAAI,IAAG;IACjC;AAEA,QAAI,WAAQ,GAA8B;AACtC,WAAK,mBAAmB,oBAAI,IAAG;IACnC;EACJ;;;;;;EAOO,UAAO;AACV,QAAI,KAAK,kBAAkB;AACvB,iBAAW,QAAQ,MAAM,KAAK,KAAK,gBAAgB,GAAG;AAClD,YAAI,CAAC,KAAK,YAAY,IAAI,GAAG;AACzB,gBAAM,IAAI,MAAM,mBAAmB;QACvC;MACJ;AACA,WAAK,iBAAiB,MAAK;IAC/B;AAEA,QAAI,KAAK,gBAAgB;AACrB,iBAAW,QAAQ,MAAM,KAAK,KAAK,cAAc,GAAG;AAChD,YAAI,CAAC,KAAK,YAAY,IAAI,GAAG;AACzB,gBAAM,IAAI,MAAM,mBAAmB;QACvC;MACJ;AACA,WAAK,eAAe,MAAK;IAC7B;AAEA,SAAK,oBAAoB,gBAAgB,IAAI;AAC7C,SAAK,oBAAoB,MAAK;EAClC;;;;;;EAaU,SAAS,MAAuB;AACtC,QAAI,CAAC,KAAK,kBAAkB;AACxB,aAAO;IACX;AAEA,QAAI,KAAK,iBAAiB,IAAI,IAAI,GAAG;AACjC,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,WAAW,IAAI,GAAG;AACxB,aAAO;IACX;AAEA,SAAK,iBAAiB,IAAI,IAAI;AAE9B,WAAO;EACX;;;;;;EAOU,YAAY,MAAuB;AACzC,QAAI,CAAC,KAAK,kBAAkB;AACxB,aAAO;IACX;AAEA,QAAI,CAAC,KAAK,iBAAiB,OAAO,IAAI,GAAG;AACrC,aAAO;IACX;AAEA,WAAO,KAAK,cAAc,IAAI;EAClC;;;;;;EAOQ,WAAW,MAAuB;AACtC,QAAI,CAAC,KAAK,gBAAgB;AACtB,aAAO;IACX;AAEA,QAAI,KAAK,eAAe,IAAI,IAAI,GAAG;AAC/B,aAAO;IACX;AAEA,SAAK,eAAe,IAAI,IAAI;AAE5B,WAAO;EACX;;;;;;EAOQ,cAAc,MAAuB;AACzC,WAAO,KAAK,gBAAgB,OAAO,IAAI,KAAK;EAChD;;AAME,IAAgB,yBAAhB,cAA+C,kBAAiB;EAQlE,YAAsB,MAAc,QAAuB,UAAuB;AAC9E,UAAM,QAAQ,QAAQ;AAHV,SAAA,0BAA0B,IAAI,WAAU;AAKpD,SAAK,QAAQ;EACjB;;;;;;EAOA,IAAW,OAAI;AACX,WAAO,KAAK;EAChB;EAEA,IAAW,KAAK,SAAe;AAC3B,QAAI,KAAK,UAAU,SAAS;AACxB;IACJ;AAEA,UAAM,UAAU,KAAK;AAErB,SAAK,QAAQ;AAEb,SAAK,wBAAwB,gBAAgB,EAAE,SAAS,SAAS,MAAM,KAAI,CAAE;EACjF;EAEgB,UAAO;AACnB,UAAM,QAAO;AAEb,SAAK,wBAAwB,MAAK;EACtC;;",
  "names": ["AudioNodeType"]
}
