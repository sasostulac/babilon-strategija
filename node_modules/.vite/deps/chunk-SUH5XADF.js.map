{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/urlTools.ts", "../../../dev/core/src/Engines/AbstractEngine/abstractEngine.cubeTexture.ts"],
  "sourcesContent": ["/**\r\n * Gets the file extension from a URL.\r\n * @param url The URL to get the file extension from.\r\n * @returns The file extension, or an empty string if no extension is found.\r\n */\r\nexport function GetExtensionFromUrl(url: string) {\r\n    const urlWithoutUriParams = url.split(\"?\")[0];\r\n    const lastDot = urlWithoutUriParams.lastIndexOf(\".\");\r\n    const extension = lastDot > -1 ? urlWithoutUriParams.substring(lastDot).toLowerCase() : \"\";\r\n    return extension;\r\n}\r\n", "import { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { LoadImage } from \"../../Misc/fileTools\";\r\nimport { RandomGUID } from \"../../Misc/guid\";\r\nimport type { IWebRequest } from \"../../Misc/interfaces/iWebRequest\";\r\nimport { AbstractEngine } from \"../abstractEngine\";\r\nimport { _GetCompatibleTextureLoader } from \"core/Materials/Textures/Loaders/textureLoaderManager\";\r\nimport { GetExtensionFromUrl } from \"core/Misc/urlTools\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /** @internal */\r\n        createCubeTextureBase(\r\n            rootUrl: string,\r\n            scene: Nullable<Scene>,\r\n            files: Nullable<string[]>,\r\n            noMipmap: boolean,\r\n            onLoad: Nullable<(data?: any) => void>,\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            format: number | undefined,\r\n            forcedExtension: any,\r\n            createPolynomials: boolean,\r\n            lodScale: number,\r\n            lodOffset: number,\r\n            fallback: Nullable<InternalTexture>,\r\n            beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void>,\r\n            imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            useSRGBBuffer: boolean,\r\n            buffer: Nullable<ArrayBufferView>\r\n        ): InternalTexture;\r\n\r\n        /** @internal */\r\n        _partialLoadFile(\r\n            url: string,\r\n            index: number,\r\n            loadedFiles: ArrayBuffer[],\r\n            onfinish: (files: ArrayBuffer[]) => void,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadFiles(scene: Nullable<Scene>, onfinish: (images: ArrayBuffer[]) => void, files: string[], onError: Nullable<(message?: string, exception?: any) => void>): void;\r\n\r\n        /** @internal */\r\n        _cascadeLoadImgs(\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            files: string[],\r\n            onError: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n\r\n        /** @internal */\r\n        _partialLoadImg(\r\n            url: string,\r\n            index: number,\r\n            loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n            scene: Nullable<Scene>,\r\n            texture: InternalTexture,\r\n            onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n            onErrorCallBack: Nullable<(message?: string, exception?: any) => void>,\r\n            mimeType?: string\r\n        ): void;\r\n    }\r\n}\r\n\r\nAbstractEngine.prototype._partialLoadFile = function (\r\n    url: string,\r\n    index: number,\r\n    loadedFiles: ArrayBuffer[],\r\n    onfinish: (files: ArrayBuffer[]) => void,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const onload = (data: ArrayBuffer) => {\r\n        loadedFiles[index] = data;\r\n        (<any>loadedFiles)._internalCount++;\r\n\r\n        if ((<any>loadedFiles)._internalCount === 6) {\r\n            onfinish(loadedFiles);\r\n        }\r\n    };\r\n\r\n    const onerror = (request?: IWebRequest, exception?: any) => {\r\n        if (onErrorCallBack && request) {\r\n            onErrorCallBack(request.status + \" \" + request.statusText, exception);\r\n        }\r\n    };\r\n\r\n    this._loadFile(url, onload as (data: string | ArrayBuffer) => void, undefined, undefined, true, onerror);\r\n};\r\n\r\nAbstractEngine.prototype._cascadeLoadFiles = function (\r\n    scene: Nullable<Scene>,\r\n    onfinish: (images: ArrayBuffer[]) => void,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null\r\n): void {\r\n    const loadedFiles: ArrayBuffer[] = [];\r\n    (<any>loadedFiles)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype._cascadeLoadImgs = function (\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    files: string[],\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const loadedImages: HTMLImageElement[] | ImageBitmap[] = [];\r\n    (<any>loadedImages)._internalCount = 0;\r\n\r\n    for (let index = 0; index < 6; index++) {\r\n        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype._partialLoadImg = function (\r\n    url: string,\r\n    index: number,\r\n    loadedImages: HTMLImageElement[] | ImageBitmap[],\r\n    scene: Nullable<Scene>,\r\n    texture: InternalTexture,\r\n    onfinish: Nullable<(texture: InternalTexture, images: HTMLImageElement[] | ImageBitmap[]) => void>,\r\n    onErrorCallBack: Nullable<(message?: string, exception?: any) => void> = null,\r\n    mimeType?: string\r\n) {\r\n    const tokenPendingData = RandomGUID();\r\n\r\n    const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n        loadedImages[index] = img;\r\n        (<any>loadedImages)._internalCount++;\r\n\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if ((<any>loadedImages)._internalCount === 6 && onfinish) {\r\n            onfinish(texture, loadedImages);\r\n        }\r\n    };\r\n\r\n    const onerror = (message?: string, exception?: any) => {\r\n        if (scene) {\r\n            scene.removePendingData(tokenPendingData);\r\n        }\r\n\r\n        if (onErrorCallBack) {\r\n            onErrorCallBack(message, exception);\r\n        }\r\n    };\r\n\r\n    LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);\r\n    if (scene) {\r\n        scene.addPendingData(tokenPendingData);\r\n    }\r\n};\r\n\r\nAbstractEngine.prototype.createCubeTextureBase = function (\r\n    rootUrl: string,\r\n    scene: Nullable<Scene>,\r\n    files: Nullable<string[]>,\r\n    noMipmap?: boolean,\r\n    onLoad: Nullable<(data?: any) => void> = null,\r\n    onError: Nullable<(message?: string, exception?: any) => void> = null,\r\n    format?: number,\r\n    forcedExtension: any = null,\r\n    createPolynomials: boolean = false,\r\n    lodScale: number = 0,\r\n    lodOffset: number = 0,\r\n    fallback: Nullable<InternalTexture> = null,\r\n    beforeLoadCubeDataCallback: Nullable<(texture: InternalTexture, data: ArrayBufferView | ArrayBufferView[]) => void> = null,\r\n    imageHandler: Nullable<(texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => void> = null,\r\n    useSRGBBuffer = false,\r\n    buffer: Nullable<ArrayBufferView> = null\r\n): InternalTexture {\r\n    const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);\r\n    texture.isCube = true;\r\n    texture.url = rootUrl;\r\n    texture.generateMipMaps = !noMipmap;\r\n    texture._lodGenerationScale = lodScale;\r\n    texture._lodGenerationOffset = lodOffset;\r\n    texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!noMipmap);\r\n    if (texture !== fallback) {\r\n        texture.label = rootUrl.substring(0, 60); // default label, can be overriden by the caller\r\n    }\r\n\r\n    if (!this._doNotHandleContextLost) {\r\n        texture._extension = forcedExtension;\r\n        texture._files = files;\r\n        texture._buffer = buffer;\r\n    }\r\n\r\n    const originalRootUrl = rootUrl;\r\n    if (this._transformTextureUrl && !fallback) {\r\n        rootUrl = this._transformTextureUrl(rootUrl);\r\n    }\r\n\r\n    const extension = forcedExtension ?? GetExtensionFromUrl(rootUrl);\r\n\r\n    const loaderPromise = _GetCompatibleTextureLoader(extension);\r\n\r\n    const localOnError = (message?: string, exception?: any) => {\r\n        // if an error was thrown during load, dispose the texture, otherwise it will stay in the cache\r\n        texture.dispose();\r\n        if (onError) {\r\n            onError(message, exception);\r\n        } else if (message) {\r\n            Logger.Warn(message);\r\n        }\r\n    };\r\n\r\n    const onInternalError = (request?: IWebRequest, exception?: any) => {\r\n        if (rootUrl === originalRootUrl) {\r\n            if (request) {\r\n                localOnError(request.status + \" \" + request.statusText, exception);\r\n            }\r\n        } else {\r\n            // fall back to the original url if the transformed url fails to load\r\n            Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);\r\n            this.createCubeTextureBase(\r\n                originalRootUrl,\r\n                scene,\r\n                files,\r\n                !!noMipmap,\r\n                onLoad,\r\n                localOnError,\r\n                format,\r\n                forcedExtension,\r\n                createPolynomials,\r\n                lodScale,\r\n                lodOffset,\r\n                texture,\r\n                beforeLoadCubeDataCallback,\r\n                imageHandler,\r\n                useSRGBBuffer,\r\n                buffer\r\n            );\r\n        }\r\n    };\r\n\r\n    if (loaderPromise) {\r\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n        loaderPromise.then((loader) => {\r\n            const onLoadData = (data: ArrayBufferView | ArrayBufferView[]) => {\r\n                if (beforeLoadCubeDataCallback) {\r\n                    beforeLoadCubeDataCallback(texture, data);\r\n                }\r\n                loader.loadCubeData(data, texture, createPolynomials, onLoad, (message?: string, exception?: any) => {\r\n                    localOnError(message, exception);\r\n                });\r\n            };\r\n            if (buffer) {\r\n                onLoadData(buffer);\r\n            } else if (files && files.length === 6) {\r\n                if (loader.supportCascades) {\r\n                    this._cascadeLoadFiles(scene, (images) => onLoadData(images.map((image) => new Uint8Array(image))), files, localOnError);\r\n                } else {\r\n                    localOnError(\"Textures type does not support cascades.\");\r\n                }\r\n            } else {\r\n                this._loadFile(\r\n                    rootUrl,\r\n                    (data) => onLoadData(new Uint8Array(data as ArrayBuffer)),\r\n                    undefined,\r\n                    scene ? scene.offlineProvider || null : undefined,\r\n                    true,\r\n                    onInternalError\r\n                );\r\n            }\r\n        });\r\n    } else {\r\n        if (!files || files.length === 0) {\r\n            throw new Error(\"Cannot load cubemap because files were not defined, or the correct loader was not found.\");\r\n        }\r\n\r\n        this._cascadeLoadImgs(\r\n            scene,\r\n            texture,\r\n            (texture: InternalTexture, imgs: HTMLImageElement[] | ImageBitmap[]) => {\r\n                if (imageHandler) {\r\n                    imageHandler(texture, imgs);\r\n                }\r\n            },\r\n            files,\r\n            localOnError\r\n        );\r\n    }\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n"],
  "mappings": "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",
  "names": ["texture"]
}
