import {
  EffectRenderer,
  EffectWrapper
} from "./chunk-SMWNVZJL.js";
import {
  Tools
} from "./chunk-LNRVDUKV.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import {
  Clamp
} from "./chunk-QCCD6NMF.js";

// node_modules/@babylonjs/core/Misc/dumpTools.js
var ResourcesPromise = null;
async function _CreateDumpResourcesAsync() {
  const canvas = EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100);
  if (canvas instanceof OffscreenCanvas) {
    Logger.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");
  }
  const { ThinEngine: thinEngineClass } = await import("./thinEngine-H2J67C6U.js");
  if (!thinEngineClass.IsSupported) {
    if (!canvas.getContext("bitmaprenderer")) {
      throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");
    }
    return { canvas };
  }
  const options = {
    preserveDrawingBuffer: true,
    depth: false,
    stencil: false,
    alpha: true,
    premultipliedAlpha: false,
    antialias: false,
    failIfMajorPerformanceCaveat: false
  };
  const engine = new thinEngineClass(canvas, false, options);
  EngineStore.Instances.pop();
  EngineStore.OnEnginesDisposedObservable.add((e) => {
    if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {
      Dispose();
    }
  });
  engine.getCaps().parallelShaderCompile = void 0;
  const renderer = new EffectRenderer(engine);
  const { passPixelShader } = await import("./pass.fragment-5HHADSLF.js");
  const wrapper = new EffectWrapper({
    engine,
    name: passPixelShader.name,
    fragmentShader: passPixelShader.shader,
    samplerNames: ["textureSampler"]
  });
  return {
    canvas,
    dumpEngine: { engine, renderer, wrapper }
  };
}
async function _GetDumpResourcesAsync() {
  if (!ResourcesPromise) {
    ResourcesPromise = _CreateDumpResourcesAsync();
  }
  return await ResourcesPromise;
}
async function DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
  const bufferView = await engine.readPixels(0, 0, width, height);
  const data = new Uint8Array(bufferView.buffer);
  DumpData(width, height, data, successCallback, mimeType, fileName, true, void 0, quality);
}
async function DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  if (data instanceof Float32Array) {
    const data2 = new Uint8Array(data.length);
    let n = data.length;
    while (n--) {
      const v = data[n];
      data2[n] = Math.round(Clamp(v) * 255);
    }
    data = data2;
  }
  const resources = await _GetDumpResourcesAsync();
  return await new Promise(async (resolve) => {
    if (resources.dumpEngine) {
      const dumpEngine = resources.dumpEngine;
      dumpEngine.engine.setSize(width, height, true);
      const texture = dumpEngine.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
      dumpEngine.renderer.setViewport();
      dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);
      dumpEngine.wrapper.effect._bindTexture("textureSampler", texture);
      dumpEngine.renderer.draw();
      texture.dispose();
    } else {
      const ctx = resources.canvas.getContext("bitmaprenderer");
      resources.canvas.width = width;
      resources.canvas.height = height;
      const imageData = new ImageData(width, height);
      imageData.data.set(data);
      const imageBitmap = await createImageBitmap(imageData, { premultiplyAlpha: "none", imageOrientation: invertY ? "flipY" : "from-image" });
      ctx.transferFromImageBitmap(imageBitmap);
    }
    Tools.ToBlob(resources.canvas, (blob) => {
      if (!blob) {
        throw new Error("DumpData: Failed to convert canvas to blob.");
      }
      if (fileName !== void 0) {
        Tools.DownloadBlob(blob, fileName);
      }
      const fileReader = new FileReader();
      fileReader.onload = (event) => {
        const result = event.target.result;
        resolve(result);
      };
      if (toArrayBuffer) {
        fileReader.readAsArrayBuffer(blob);
      } else {
        fileReader.readAsDataURL(blob);
      }
    }, mimeType, quality);
  });
}
function DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
  if (fileName === void 0 && !successCallback) {
    fileName = "";
  }
  DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality).then((result) => {
    if (successCallback) {
      successCallback(result);
    }
  });
}
function Dispose() {
  if (!ResourcesPromise) {
    return;
  }
  ResourcesPromise?.then((resources) => {
    if (resources.canvas instanceof HTMLCanvasElement) {
      resources.canvas.remove();
    }
    if (resources.dumpEngine) {
      resources.dumpEngine.engine.dispose();
      resources.dumpEngine.renderer.dispose();
      resources.dumpEngine.wrapper.dispose();
    }
  });
  ResourcesPromise = null;
}
var DumpTools = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpData,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpDataAsync,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  DumpFramebuffer,
  // eslint-disable-next-line @typescript-eslint/naming-convention
  Dispose
};
var InitSideEffects = () => {
  Tools.DumpData = DumpData;
  Tools.DumpDataAsync = DumpDataAsync;
  Tools.DumpFramebuffer = DumpFramebuffer;
};
InitSideEffects();

export {
  DumpFramebuffer,
  DumpDataAsync,
  DumpData,
  Dispose,
  DumpTools
};
//# sourceMappingURL=chunk-2G4OJXXX.js.map
