{
  "version": 3,
  "sources": ["../../../dev/core/src/Meshes/linesMesh.ts", "../../../dev/core/src/Meshes/polygonMesh.ts", "../../../dev/core/src/Meshes/Builders/polygonBuilder.ts", "../../../dev/core/src/Meshes/Builders/textBuilder.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTextureSceneComponent.ts", "../../../dev/core/src/Materials/Textures/Procedurals/proceduralTexture.ts", "../../../dev/core/src/Helpers/materialConversionHelper.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLineMaterialDefaults.ts", "../../../dev/core/src/Misc/greasedLineTools.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLinePluginMaterial.ts", "../../../dev/core/src/Materials/GreasedLine/greasedLineSimpleMaterial.ts", "../../../dev/core/src/Meshes/Compression/dracoEncoder.ts", "../../../dev/core/src/Meshes/GreasedLine/greasedLineBaseMesh.ts"],
  "sourcesContent": ["import type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport type { Node } from \"../node\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../Meshes/instancedMesh\";\r\nimport { Material } from \"../Materials/material\";\r\nimport type { IShaderMaterialOptions } from \"../Materials/shaderMaterial\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { MeshCreationOptions } from \"./mesh\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nMesh._LinesMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return LinesMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Line mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param\r\n */\r\nexport class LinesMesh extends Mesh {\r\n    /**\r\n     * Force all the LineMeshes to compile their default color material to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Color of the line (Default: White)\r\n     */\r\n    public color = new Color3(1, 1, 1);\r\n\r\n    /**\r\n     * Alpha of the line (Default: 1)\r\n     */\r\n    public alpha = 1;\r\n\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Default value is 0.1\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    private _isShaderMaterial(shader: Nullable<Material>): shader is ShaderMaterial {\r\n        if (!shader) {\r\n            return false;\r\n        }\r\n\r\n        return shader.getClassName() === \"ShaderMaterial\";\r\n    }\r\n\r\n    private _color4: Color4;\r\n\r\n    /** Shader language used by the material */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    private _ownsMaterial: boolean = false;\r\n\r\n    /**\r\n     * Creates a new LinesMesh\r\n     * @param name defines the name\r\n     * @param scene defines the hosting scene\r\n     * @param parent defines the parent mesh if any\r\n     * @param source defines the optional source LinesMesh used to clone data from\r\n     * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.\r\n     * When false, achieved by calling a clone(), also passing False.\r\n     * This will make creation of children, recursive.\r\n     * @param useVertexColor defines if this LinesMesh supports vertex color\r\n     * @param useVertexAlpha defines if this LinesMesh supports vertex alpha\r\n     * @param material material to use to draw the line. If not provided, will create a new one\r\n     */\r\n    constructor(\r\n        name: string,\r\n        scene: Nullable<Scene> = null,\r\n        parent: Nullable<Node> = null,\r\n        source: Nullable<LinesMesh> = null,\r\n        doNotCloneChildren?: boolean,\r\n        /**\r\n         * If vertex color should be applied to the mesh\r\n         */\r\n        public readonly useVertexColor?: boolean,\r\n        /**\r\n         * If vertex alpha should be applied to the mesh\r\n         */\r\n        public readonly useVertexAlpha?: boolean,\r\n        material?: Material\r\n    ) {\r\n        super(name, scene, parent, source, doNotCloneChildren);\r\n\r\n        if (source) {\r\n            this.color = source.color.clone();\r\n            this.alpha = source.alpha;\r\n            this.useVertexColor = source.useVertexColor;\r\n            this.useVertexAlpha = source.useVertexAlpha;\r\n        }\r\n\r\n        this.intersectionThreshold = 0.1;\r\n\r\n        const defines: string[] = [];\r\n        const options: Partial<IShaderMaterialOptions> = {\r\n            attributes: [VertexBuffer.PositionKind],\r\n            uniforms: [\"world\", \"viewProjection\"],\r\n            needAlphaBlending: true,\r\n            defines: defines,\r\n            useClipPlane: null,\r\n            shaderLanguage: ShaderLanguage.GLSL,\r\n        };\r\n\r\n        if (!this.useVertexAlpha) {\r\n            options.needAlphaBlending = false;\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXALPHA\");\r\n        }\r\n\r\n        if (!this.useVertexColor) {\r\n            options.uniforms!.push(\"color\");\r\n            this._color4 = new Color4();\r\n        } else {\r\n            options.defines!.push(\"#define VERTEXCOLOR\");\r\n            options.attributes!.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        if (material) {\r\n            this.material = material;\r\n        } else {\r\n            const engine = this.getScene().getEngine();\r\n\r\n            if (engine.isWebGPU && !LinesMesh.ForceGLSL) {\r\n                this._shaderLanguage = ShaderLanguage.WGSL;\r\n            }\r\n\r\n            options.shaderLanguage = this._shaderLanguage;\r\n            options.extraInitializationsAsync = async () => {\r\n                if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                    await Promise.all([import(\"../ShadersWGSL/color.vertex\"), import(\"../ShadersWGSL/color.fragment\")]);\r\n                } else {\r\n                    await Promise.all([import(\"../Shaders/color.vertex\"), import(\"../Shaders/color.fragment\")]);\r\n                }\r\n            };\r\n\r\n            const material = new ShaderMaterial(\"colorShader\", this.getScene(), \"color\", options, false);\r\n            material.doNotSerialize = true;\r\n\r\n            this._ownsMaterial = true;\r\n            this._setInternalMaterial(material);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"LineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"LinesMesh\";\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get material(): Nullable<Material> {\r\n        return this._internalAbstractMeshDataInfo._material as Material;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override set material(value: Nullable<Material>) {\r\n        const currentMaterial = this.material;\r\n        if (currentMaterial === value) {\r\n            return;\r\n        }\r\n\r\n        const shouldDispose = currentMaterial && this._ownsMaterial;\r\n        this._ownsMaterial = false;\r\n        this._setInternalMaterial(value);\r\n\r\n        if (shouldDispose) {\r\n            currentMaterial?.dispose();\r\n        }\r\n    }\r\n\r\n    private _setInternalMaterial(material: Nullable<Material>) {\r\n        this._setMaterial(material);\r\n        if (this.material) {\r\n            this.material.fillMode = Material.LineListDrawMode;\r\n            (this.material as any).disableLighting = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override get checkCollisions(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override set checkCollisions(value: boolean) {\r\n        // Just ignore it\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _bind(_subMesh: SubMesh, colorEffect: Effect): Mesh {\r\n        if (!this._geometry) {\r\n            return this;\r\n        }\r\n\r\n        // VBOs\r\n        const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();\r\n        if (!this._userInstancedBuffersStorage || this.hasThinInstances) {\r\n            this._geometry._bind(colorEffect, indexToBind);\r\n        } else {\r\n            this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);\r\n        }\r\n\r\n        // Color\r\n        if (!this.useVertexColor && this._isShaderMaterial(this.material)) {\r\n            const { r, g, b } = this.color;\r\n            this._color4.set(r, g, b, this.alpha);\r\n            this.material.setColor4(\"color\", this._color4);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(subMesh: SubMesh, fillMode: number, instancesCount?: number): Mesh {\r\n        if (!this._geometry || !this._geometry.getVertexBuffers() || (!this._unIndexed && !this._geometry.getIndexBuffer())) {\r\n            return this;\r\n        }\r\n\r\n        const engine = this.getScene().getEngine();\r\n\r\n        // Draw order\r\n\r\n        if (this._unIndexed) {\r\n            engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);\r\n        } else {\r\n            engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the line mesh (this disposes of the automatically created material if not instructed otherwise).\r\n     * @param doNotRecurse If children should be disposed\r\n     * @param disposeMaterialAndTextures This parameter is used to force disposing the material in case it is not the default one\r\n     * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material might be disposed)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false, doNotDisposeMaterial?: boolean): void {\r\n        if (!doNotDisposeMaterial) {\r\n            if (this._ownsMaterial) {\r\n                this.material?.dispose(false, false, true);\r\n            } else if (disposeMaterialAndTextures) {\r\n                this.material?.dispose(false, false, true);\r\n            }\r\n        }\r\n\r\n        super.dispose(doNotRecurse);\r\n    }\r\n\r\n    /**\r\n     * Returns a new LineMesh object cloned from the current one.\r\n     * @param name defines the cloned mesh name\r\n     * @param newParent defines the new mesh parent\r\n     * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)\r\n     * @returns the new mesh\r\n     */\r\n    public override clone(name: string, newParent: Nullable<Node> | MeshCreationOptions = null, doNotCloneChildren?: boolean): LinesMesh {\r\n        if (newParent && (newParent as Node)._addToSceneRootNodes === undefined) {\r\n            const createOptions = newParent as MeshCreationOptions;\r\n            createOptions.source = this;\r\n\r\n            return new LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source as Nullable<LinesMesh>, createOptions.doNotCloneChildren);\r\n        }\r\n\r\n        return new LinesMesh(name, this.getScene(), newParent as Nullable<Node>, this, doNotCloneChildren);\r\n    }\r\n\r\n    /**\r\n     * Creates a new InstancedLinesMesh object from the mesh model.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances\r\n     * @param name defines the name of the new instance\r\n     * @returns a new InstancedLinesMesh\r\n     */\r\n    public override createInstance(name: string): InstancedLinesMesh {\r\n        const instance = new InstancedLinesMesh(name, this);\r\n\r\n        if (this.instancedBuffers) {\r\n            instance.instancedBuffers = {};\r\n\r\n            for (const key in this.instancedBuffers) {\r\n                instance.instancedBuffers[key] = this.instancedBuffers[key];\r\n            }\r\n        }\r\n\r\n        return instance;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.color = this.color.asArray();\r\n        serializationObject.alpha = this.alpha;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): LinesMesh {\r\n        const result = new LinesMesh(parsedMesh.name, scene);\r\n\r\n        result.color = Color3.FromArray(parsedMesh.color);\r\n        result.alpha = parsedMesh.alpha;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an instance based on a source LinesMesh\r\n */\r\nexport class InstancedLinesMesh extends InstancedMesh {\r\n    /**\r\n     * The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.\r\n     * This margin is expressed in world space coordinates, so its value may vary.\r\n     * Initialized with the intersectionThreshold value of the source LinesMesh\r\n     */\r\n    public intersectionThreshold: number;\r\n\r\n    constructor(name: string, source: LinesMesh) {\r\n        super(name, source);\r\n        this.intersectionThreshold = source.intersectionThreshold;\r\n    }\r\n\r\n    /**\r\n     * @returns the string \"InstancedLinesMesh\".\r\n     */\r\n    public override getClassName(): string {\r\n        return \"InstancedLinesMesh\";\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Path2 } from \"../Maths/math.path\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let earcut: any;\r\n/**\r\n * Vector2 wth index property\r\n */\r\nclass IndexedVector2 extends Vector2 {\r\n    constructor(\r\n        original: Vector2,\r\n        /** Index of the vector2 */\r\n        public index: number\r\n    ) {\r\n        super(original.x, original.y);\r\n    }\r\n}\r\n\r\n/**\r\n * Defines points to create a polygon\r\n */\r\nclass PolygonPoints {\r\n    elements = [] as IndexedVector2[];\r\n\r\n    add(originalPoints: Array<Vector2>): Array<IndexedVector2> {\r\n        const result: IndexedVector2[] = [];\r\n        for (const point of originalPoints) {\r\n            const newPoint = new IndexedVector2(point, this.elements.length);\r\n            result.push(newPoint);\r\n            this.elements.push(newPoint);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    computeBounds(): { min: Vector2; max: Vector2; width: number; height: number } {\r\n        const lmin = new Vector2(this.elements[0].x, this.elements[0].y);\r\n        const lmax = new Vector2(this.elements[0].x, this.elements[0].y);\r\n\r\n        for (const point of this.elements) {\r\n            // x\r\n            if (point.x < lmin.x) {\r\n                lmin.x = point.x;\r\n            } else if (point.x > lmax.x) {\r\n                lmax.x = point.x;\r\n            }\r\n\r\n            // y\r\n            if (point.y < lmin.y) {\r\n                lmin.y = point.y;\r\n            } else if (point.y > lmax.y) {\r\n                lmax.y = point.y;\r\n            }\r\n        }\r\n\r\n        return {\r\n            min: lmin,\r\n            max: lmax,\r\n            width: lmax.x - lmin.x,\r\n            height: lmax.y - lmin.y,\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param#non-regular-polygon\r\n */\r\nexport class Polygon {\r\n    /**\r\n     * Creates a rectangle\r\n     * @param xmin bottom X coord\r\n     * @param ymin bottom Y coord\r\n     * @param xmax top X coord\r\n     * @param ymax top Y coord\r\n     * @returns points that make the resulting rectangle\r\n     */\r\n    static Rectangle(xmin: number, ymin: number, xmax: number, ymax: number): Vector2[] {\r\n        return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];\r\n    }\r\n\r\n    /**\r\n     * Creates a circle\r\n     * @param radius radius of circle\r\n     * @param cx scale in x\r\n     * @param cy scale in y\r\n     * @param numberOfSides number of sides that make up the circle\r\n     * @returns points that make the resulting circle\r\n     */\r\n    static Circle(radius: number, cx: number = 0, cy: number = 0, numberOfSides: number = 32): Vector2[] {\r\n        const result: Vector2[] = [];\r\n\r\n        let angle = 0;\r\n        const increment = (Math.PI * 2) / numberOfSides;\r\n\r\n        for (let i = 0; i < numberOfSides; i++) {\r\n            result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));\r\n            angle -= increment;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a polygon from input string\r\n     * @param input Input polygon data\r\n     * @returns the parsed points\r\n     */\r\n    static Parse(input: string): Vector2[] {\r\n        const floats = input\r\n            .split(/[^-+eE.\\d]+/)\r\n            .map(parseFloat)\r\n            .filter((val) => !isNaN(val));\r\n        let i: number;\r\n        const result = [];\r\n        for (i = 0; i < (floats.length & 0x7ffffffe); i += 2) {\r\n            result.push(new Vector2(floats[i], floats[i + 1]));\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Starts building a polygon from x and y coordinates\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @returns the started path2\r\n     */\r\n    static StartingAt(x: number, y: number): Path2 {\r\n        return Path2.StartingAt(x, y);\r\n    }\r\n}\r\n\r\n/**\r\n * Builds a polygon\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/param/polyMeshBuilder\r\n */\r\nexport class PolygonMeshBuilder {\r\n    private _points = new PolygonPoints();\r\n    private _outlinepoints = new PolygonPoints();\r\n    private _holes = new Array<PolygonPoints>();\r\n\r\n    private _name: string;\r\n    private _scene: Nullable<Scene>;\r\n\r\n    private _epoints: number[] = new Array<number>();\r\n    private _eholes: number[] = new Array<number>();\r\n\r\n    private _addToepoint(points: Vector2[]) {\r\n        for (const p of points) {\r\n            this._epoints.push(p.x, p.y);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Babylon reference to the earcut plugin.\r\n     */\r\n    public bjsEarcut: any;\r\n\r\n    /**\r\n     * Creates a PolygonMeshBuilder\r\n     * @param name name of the builder\r\n     * @param contours Path of the polygon\r\n     * @param scene scene to add to when creating the mesh\r\n     * @param earcutInjection can be used to inject your own earcut reference\r\n     */\r\n    constructor(name: string, contours: Path2 | Vector2[] | any, scene?: Scene, earcutInjection = earcut) {\r\n        this.bjsEarcut = earcutInjection;\r\n        this._name = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n\r\n        let points: Vector2[];\r\n        if (contours instanceof Path2) {\r\n            points = contours.getPoints();\r\n        } else {\r\n            points = <Vector2[]>contours;\r\n        }\r\n\r\n        this._addToepoint(points);\r\n\r\n        this._points.add(points);\r\n        this._outlinepoints.add(points);\r\n\r\n        if (typeof this.bjsEarcut === \"undefined\") {\r\n            Logger.Warn(\"Earcut was not found, the polygon will not be built.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a hole within the polygon\r\n     * @param hole Array of points defining the hole\r\n     * @returns this\r\n     */\r\n    addHole(hole: Vector2[]): PolygonMeshBuilder {\r\n        this._points.add(hole);\r\n        const holepoints = new PolygonPoints();\r\n        holepoints.add(hole);\r\n        this._holes.push(holepoints);\r\n\r\n        this._eholes.push(this._epoints.length / 2);\r\n        this._addToepoint(hole);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param updatable If the mesh should be updatable\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created mesh\r\n     */\r\n    build(updatable: boolean = false, depth: number = 0, smoothingThreshold: number = 2): Mesh {\r\n        const result = new Mesh(this._name, this._scene);\r\n\r\n        const vertexData = this.buildVertexData(depth, smoothingThreshold);\r\n\r\n        result.setVerticesData(VertexBuffer.PositionKind, <number[]>vertexData.positions, updatable);\r\n        result.setVerticesData(VertexBuffer.NormalKind, <number[]>vertexData.normals, updatable);\r\n        result.setVerticesData(VertexBuffer.UVKind, <number[]>vertexData.uvs, updatable);\r\n        result.setIndices(<number[]>vertexData.indices);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates the polygon\r\n     * @param depth The depth of the mesh created\r\n     * @param smoothingThreshold Dot product threshold for smoothed normals\r\n     * @returns the created VertexData\r\n     */\r\n    buildVertexData(depth: number = 0, smoothingThreshold: number = 2): VertexData {\r\n        const result = new VertexData();\r\n\r\n        const normals: number[] = [];\r\n        const positions: number[] = [];\r\n        const uvs: number[] = [];\r\n\r\n        const bounds = this._points.computeBounds();\r\n        for (const p of this._points.elements) {\r\n            normals.push(0, 1.0, 0);\r\n            positions.push(p.x, 0, p.y);\r\n            uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);\r\n        }\r\n\r\n        const indices: number[] = [];\r\n\r\n        const res = this.bjsEarcut(this._epoints, this._eholes, 2);\r\n\r\n        for (let i = 0; i < res.length; i++) {\r\n            indices.push(res[i]);\r\n        }\r\n\r\n        if (depth > 0) {\r\n            const positionscount = positions.length / 3; //get the current pointcount\r\n\r\n            for (const p of this._points.elements) {\r\n                //add the elements at the depth\r\n                normals.push(0, -1.0, 0);\r\n                positions.push(p.x, -depth, p.y);\r\n                uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);\r\n            }\r\n\r\n            const totalCount = indices.length;\r\n            for (let i = 0; i < totalCount; i += 3) {\r\n                const i0 = indices[i + 0];\r\n                const i1 = indices[i + 1];\r\n                const i2 = indices[i + 2];\r\n\r\n                indices.push(i2 + positionscount);\r\n                indices.push(i1 + positionscount);\r\n                indices.push(i0 + positionscount);\r\n            }\r\n\r\n            //Add the sides\r\n            this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);\r\n\r\n            for (const hole of this._holes) {\r\n                this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);\r\n            }\r\n        }\r\n\r\n        result.indices = indices;\r\n        result.positions = positions;\r\n        result.normals = normals;\r\n        result.uvs = uvs;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Adds a side to the polygon\r\n     * @param positions points that make the polygon\r\n     * @param normals normals of the polygon\r\n     * @param uvs uvs of the polygon\r\n     * @param indices indices of the polygon\r\n     * @param bounds bounds of the polygon\r\n     * @param points points of the polygon\r\n     * @param depth depth of the polygon\r\n     * @param flip flip of the polygon\r\n     * @param smoothingThreshold\r\n     */\r\n    private _addSide(positions: any[], normals: any[], uvs: any[], indices: any[], bounds: any, points: PolygonPoints, depth: number, flip: boolean, smoothingThreshold: number) {\r\n        let startIndex: number = positions.length / 3;\r\n        let ulength: number = 0;\r\n        for (let i: number = 0; i < points.elements.length; i++) {\r\n            const p: IndexedVector2 = points.elements[i];\r\n            const p1: IndexedVector2 = points.elements[(i + 1) % points.elements.length];\r\n\r\n            positions.push(p.x, 0, p.y);\r\n            positions.push(p.x, -depth, p.y);\r\n            positions.push(p1.x, 0, p1.y);\r\n            positions.push(p1.x, -depth, p1.y);\r\n\r\n            const p0: IndexedVector2 = points.elements[(i + points.elements.length - 1) % points.elements.length];\r\n            const p2: IndexedVector2 = points.elements[(i + 2) % points.elements.length];\r\n\r\n            let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);\r\n            let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);\r\n            let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);\r\n\r\n            if (!flip) {\r\n                vc = vc.scale(-1);\r\n                vp = vp.scale(-1);\r\n                vn = vn.scale(-1);\r\n            }\r\n\r\n            const vcNorm = vc.normalizeToNew();\r\n            let vpNorm = vp.normalizeToNew();\r\n            let vnNorm = vn.normalizeToNew();\r\n\r\n            const dotp = Vector3.Dot(vpNorm, vcNorm);\r\n            if (dotp > smoothingThreshold) {\r\n                if (dotp < Epsilon - 1) {\r\n                    vpNorm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vpNorm = vp.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vpNorm = vcNorm;\r\n            }\r\n\r\n            const dotn = Vector3.Dot(vn, vc);\r\n            if (dotn > smoothingThreshold) {\r\n                if (dotn < Epsilon - 1) {\r\n                    // back to back\r\n                    vnNorm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();\r\n                } else {\r\n                    // cheap average weighed by side length\r\n                    vnNorm = vn.add(vc).normalize();\r\n                }\r\n            } else {\r\n                vnNorm = vcNorm;\r\n            }\r\n\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n            ulength += vc.length();\r\n            uvs.push(ulength / bounds.width, 0);\r\n            uvs.push(ulength / bounds.width, 1);\r\n\r\n            normals.push(vpNorm.x, vpNorm.y, vpNorm.z);\r\n            normals.push(vpNorm.x, vpNorm.y, vpNorm.z);\r\n            normals.push(vnNorm.x, vnNorm.y, vnNorm.z);\r\n            normals.push(vnNorm.x, vnNorm.y, vnNorm.z);\r\n\r\n            if (!flip) {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 3);\r\n                indices.push(startIndex + 2);\r\n            } else {\r\n                indices.push(startIndex);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 1);\r\n\r\n                indices.push(startIndex + 1);\r\n                indices.push(startIndex + 2);\r\n                indices.push(startIndex + 3);\r\n            }\r\n            startIndex += 4;\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Vector2, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { PolygonMeshBuilder } from \"../polygonMesh\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"../../types\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()\r\n * All parameters are provided by CreatePolygon as needed\r\n * @param polygon a mesh built from polygonTriangulation.build()\r\n * @param sideOrientation takes the values Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * @param fUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively\r\n * @param fColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively\r\n * @param frontUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * @param backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @param wrp a boolean, default false, when true and fUVs used texture is wrapped around all sides, when false texture is applied side\r\n * @returns the VertexData of the Polygon\r\n */\r\nexport function CreatePolygonVertexData(polygon: Mesh, sideOrientation: number, fUV?: Vector4[], fColors?: Color4[], frontUVs?: Vector4, backUVs?: Vector4, wrp?: boolean) {\r\n    const faceUV: Vector4[] = fUV || new Array<Vector4>(3);\r\n    const faceColors = fColors;\r\n    const colors = [];\r\n    const wrap: boolean = wrp || false;\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 3; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    const positions = <FloatArray>polygon.getVerticesData(VertexBuffer.PositionKind);\r\n    const normals = <FloatArray>polygon.getVerticesData(VertexBuffer.NormalKind);\r\n    const uvs = <FloatArray>polygon.getVerticesData(VertexBuffer.UVKind);\r\n    const indices = <IndicesArray>polygon.getIndices();\r\n    const startIndex = positions.length / 9;\r\n    let disp = 0;\r\n    let distX = 0;\r\n    let distZ = 0;\r\n    let dist = 0;\r\n    let totalLen = 0;\r\n    const cumulate = [0];\r\n    if (wrap) {\r\n        for (let idx = startIndex; idx < positions.length / 3; idx += 4) {\r\n            distX = positions[3 * (idx + 2)] - positions[3 * idx];\r\n            distZ = positions[3 * (idx + 2) + 2] - positions[3 * idx + 2];\r\n            dist = Math.sqrt(distX * distX + distZ * distZ);\r\n            totalLen += dist;\r\n            cumulate.push(totalLen);\r\n        }\r\n    }\r\n    // set face colours and textures\r\n    let idx: number = 0;\r\n    let face: number = 0;\r\n    for (let index = 0; index < normals.length; index += 3) {\r\n        //Edge Face  no. 1\r\n        if (Math.abs(normals[index + 1]) < 0.001) {\r\n            face = 1;\r\n        }\r\n        //Top Face  no. 0\r\n        if (Math.abs(normals[index + 1] - 1) < 0.001) {\r\n            face = 0;\r\n        }\r\n        //Bottom Face  no. 2\r\n        if (Math.abs(normals[index + 1] + 1) < 0.001) {\r\n            face = 2;\r\n        }\r\n        idx = index / 3;\r\n        if (face === 1) {\r\n            disp = idx - startIndex;\r\n            if (disp % 4 < 1.5) {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].x;\r\n                }\r\n            } else {\r\n                if (wrap) {\r\n                    uvs[2 * idx] = faceUV[face].x + ((faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1]) / totalLen;\r\n                } else {\r\n                    uvs[2 * idx] = faceUV[face].z;\r\n                }\r\n            }\r\n            if (disp % 2 === 0) {\r\n                uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1.0 - faceUV[face].w : faceUV[face].w;\r\n            } else {\r\n                uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1.0 - faceUV[face].y : faceUV[face].y;\r\n            }\r\n        } else {\r\n            uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;\r\n            uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;\r\n\r\n            if (useOpenGLOrientationForUV) {\r\n                uvs[2 * idx + 1] = 1.0 - uvs[2 * idx + 1];\r\n            }\r\n        }\r\n        if (faceColors) {\r\n            colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a polygon mesh\r\n * The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh\r\n * * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors\r\n * * You can set the mesh side orientation with the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)\r\n * * Remember you can only change the shape positions, not their number when updating a polygon\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function CreatePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        smoothingThreshold?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    const shape = options.shape;\r\n    const holes = options.holes || [];\r\n    const depth = options.depth || 0;\r\n    const smoothingThreshold = options.smoothingThreshold || 2;\r\n    const contours: Array<Vector2> = [];\r\n    let hole: Array<Vector2> = [];\r\n\r\n    for (let i = 0; i < shape.length; i++) {\r\n        contours[i] = new Vector2(shape[i].x, shape[i].z);\r\n    }\r\n    const epsilon = 0.00000001;\r\n    if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {\r\n        contours.pop();\r\n    }\r\n\r\n    const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene!, earcutInjection);\r\n    for (let hNb = 0; hNb < holes.length; hNb++) {\r\n        hole = [];\r\n        for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {\r\n            hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));\r\n        }\r\n        polygonTriangulation.addHole(hole);\r\n    }\r\n    //updatability is set during applyToMesh; setting to true in triangulation build produces errors\r\n    const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);\r\n    polygon._originalBuilderSideOrientation = options.sideOrientation;\r\n    const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);\r\n    vertexData.applyToMesh(polygon, options.updatable);\r\n\r\n    return polygon;\r\n}\r\n\r\n/**\r\n * Creates an extruded polygon mesh, with depth in the Y direction.\r\n * * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns the polygon mesh\r\n */\r\nexport function ExtrudePolygon(\r\n    name: string,\r\n    options: {\r\n        shape: Vector3[];\r\n        holes?: Vector3[][];\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        updatable?: boolean;\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Mesh {\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const PolygonBuilder = {\r\n    ExtrudePolygon,\r\n    CreatePolygon,\r\n};\r\n\r\nVertexData.CreatePolygon = CreatePolygonVertexData;\r\nMesh.CreatePolygon = (name: string, shape: Vector3[], scene: Scene, holes?: Vector3[][], updatable?: boolean, sideOrientation?: number, earcutInjection = earcut): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return CreatePolygon(name, options, scene, earcutInjection);\r\n};\r\n\r\nMesh.ExtrudePolygon = (\r\n    name: string,\r\n    shape: Vector3[],\r\n    depth: number,\r\n    scene: Scene,\r\n    holes?: Vector3[][],\r\n    updatable?: boolean,\r\n    sideOrientation?: number,\r\n    earcutInjection = earcut\r\n): Mesh => {\r\n    const options = {\r\n        shape: shape,\r\n        holes: holes,\r\n        depth: depth,\r\n        updatable: updatable,\r\n        sideOrientation: sideOrientation,\r\n    };\r\n    return ExtrudePolygon(name, options, scene, earcutInjection);\r\n};\r\n", "import type { Color4 } from \"../../Maths/math.color\";\r\nimport { Path2 } from \"../../Maths/math.path\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Vector4 } from \"../../Maths/math.vector\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { TransformNode } from \"../transformNode\";\r\nimport { ExtrudePolygon } from \"./polygonBuilder\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let earcut: any;\r\n\r\n/**\r\n * Parser inspired by https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/FontLoader.js\r\n */\r\n\r\n// Interfaces\r\n\r\n/**\r\n * Represents glyph data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IGlyphData {\r\n    /** Commands used to draw (line, move, curve, etc..) */\r\n    o: string;\r\n\r\n    /** Width */\r\n    ha: number;\r\n}\r\n\r\n/**\r\n * Represents font data generated by http://gero3.github.io/facetype.js/\r\n */\r\nexport interface IFontData {\r\n    /**\r\n     * Font resolution\r\n     */\r\n    resolution: number;\r\n    /** Underline tickness */\r\n    underlineThickness: number;\r\n    /** Bounding box */\r\n    boundingBox: {\r\n        yMax: number;\r\n        yMin: number;\r\n    };\r\n    /** List of supported glyphs */\r\n    glyphs: { [key: string]: IGlyphData };\r\n}\r\n\r\n// Shape functions\r\nclass ShapePath {\r\n    private _paths: Path2[] = [];\r\n    private _tempPaths: Path2[] = [];\r\n    private _holes: Path2[] = [];\r\n    private _currentPath: Path2;\r\n    private _resolution: number;\r\n\r\n    /** Create the ShapePath used to support glyphs\r\n     * @param resolution defines the resolution used to determine the number of points per curve (default is 4)\r\n     */\r\n    constructor(resolution: number) {\r\n        this._resolution = resolution;\r\n    }\r\n\r\n    /** Move the virtual cursor to a coordinate\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     */\r\n    moveTo(x: number, y: number) {\r\n        this._currentPath = new Path2(x, y);\r\n        this._tempPaths.push(this._currentPath);\r\n    }\r\n\r\n    /** Draw a line from the virtual cursor to a given coordinate\r\n     * @param x defines the x coordinate\r\n     * @param y defines the y coordinate\r\n     */\r\n    lineTo(x: number, y: number) {\r\n        this._currentPath.addLineTo(x, y);\r\n    }\r\n\r\n    /** Create a quadratic curve from the virtual cursor to a given coordinate\r\n     * @param cpx defines the x coordinate of the control point\r\n     * @param cpy defines the y coordinate of the control point\r\n     * @param x defines the x coordinate of the end point\r\n     * @param y defines the y coordinate of the end point\r\n     */\r\n    quadraticCurveTo(cpx: number, cpy: number, x: number, y: number) {\r\n        this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);\r\n    }\r\n\r\n    /**\r\n     * Create a bezier curve from the virtual cursor to a given coordinate\r\n     * @param cpx1 defines the x coordinate of the first control point\r\n     * @param cpy1 defines the y coordinate of the first control point\r\n     * @param cpx2 defines the x coordinate of the second control point\r\n     * @param cpy2 defines the y coordinate of the second control point\r\n     * @param x defines the x coordinate of the end point\r\n     * @param y defines the y coordinate of the end point\r\n     */\r\n    bezierCurveTo(cpx1: number, cpy1: number, cpx2: number, cpy2: number, x: number, y: number) {\r\n        this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);\r\n    }\r\n\r\n    /** Extract holes based on CW / CCW */\r\n    extractHoles() {\r\n        for (const path of this._tempPaths) {\r\n            if (path.area() > 0) {\r\n                this._holes.push(path);\r\n            } else {\r\n                this._paths.push(path);\r\n            }\r\n        }\r\n\r\n        if (!this._paths.length && this._holes.length) {\r\n            const temp = this._holes;\r\n            this._holes = this._paths;\r\n            this._paths = temp;\r\n        }\r\n\r\n        this._tempPaths.length = 0;\r\n    }\r\n\r\n    /** Gets the list of paths */\r\n    get paths() {\r\n        return this._paths;\r\n    }\r\n\r\n    /** Gets the list of holes */\r\n    get holes() {\r\n        return this._holes;\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction CreateShapePath(\r\n    char: string,\r\n    scale: number,\r\n    offsetX: number,\r\n    offsetY: number,\r\n    resolution: number,\r\n    fontData: IFontData\r\n): Nullable<{\r\n    offsetX: number;\r\n    shapePath: ShapePath;\r\n}> {\r\n    const glyph = fontData.glyphs[char] || fontData.glyphs[\"?\"];\r\n\r\n    if (!glyph) {\r\n        // return if there is no glyph data\r\n        return null;\r\n    }\r\n\r\n    const shapePath = new ShapePath(resolution);\r\n\r\n    if (glyph.o) {\r\n        const outline = glyph.o.split(\" \");\r\n\r\n        for (let i = 0, l = outline.length; i < l; ) {\r\n            const action = outline[i++];\r\n\r\n            switch (action) {\r\n                case \"m\": {\r\n                    // moveTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.moveTo(x, y);\r\n                    break;\r\n                }\r\n                case \"l\": {\r\n                    // lineTo\r\n                    const x = parseInt(outline[i++]) * scale + offsetX;\r\n                    const y = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.lineTo(x, y);\r\n                    break;\r\n                }\r\n                case \"q\": {\r\n                    // quadraticCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\r\n                    break;\r\n                }\r\n                case \"b\": {\r\n                    // bezierCurveTo\r\n                    const cpx = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx1 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy1 = parseInt(outline[i++]) * scale + offsetY;\r\n                    const cpx2 = parseInt(outline[i++]) * scale + offsetX;\r\n                    const cpy2 = parseInt(outline[i++]) * scale + offsetY;\r\n\r\n                    shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Extract holes (based on clockwise data)\r\n    shapePath.extractHoles();\r\n\r\n    return { offsetX: glyph.ha * scale, shapePath: shapePath };\r\n}\r\n\r\n/**\r\n * Creates shape paths from a text and font\r\n * @param text the text\r\n * @param size size of the font\r\n * @param resolution resolution of the font\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @returns array of ShapePath objects\r\n */\r\nexport function CreateTextShapePaths(text: string, size: number, resolution: number, fontData: IFontData) {\r\n    const chars = Array.from(text);\r\n    const scale = size / fontData.resolution;\r\n    const lineHeight = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;\r\n\r\n    const shapePaths: ShapePath[] = [];\r\n\r\n    let offsetX = 0,\r\n        offsetY = 0;\r\n\r\n    for (let i = 0; i < chars.length; i++) {\r\n        const char = chars[i];\r\n\r\n        if (char === \"\\n\") {\r\n            offsetX = 0;\r\n            offsetY -= lineHeight;\r\n        } else {\r\n            const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);\r\n\r\n            if (ret) {\r\n                offsetX += ret.offsetX;\r\n                shapePaths.push(ret.shapePath);\r\n            }\r\n        }\r\n    }\r\n\r\n    return shapePaths;\r\n}\r\n\r\n/**\r\n * Create a text mesh\r\n * @param name defines the name of the mesh\r\n * @param text defines the text to use to build the mesh\r\n * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n * @param options defines options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @param earcutInjection can be used to inject your own earcut reference\r\n * @returns a new Mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/text\r\n */\r\nexport function CreateText(\r\n    name: string,\r\n    text: string,\r\n    fontData: IFontData,\r\n    options: {\r\n        size?: number;\r\n        resolution?: number;\r\n        depth?: number;\r\n        sideOrientation?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        perLetterFaceUV?: (letterIndex: number) => Vector4[];\r\n        perLetterFaceColors?: (letterIndex: number) => Color4[];\r\n    } = {\r\n        size: 50,\r\n        resolution: 8,\r\n        depth: 1.0,\r\n    },\r\n    scene: Nullable<Scene> = null,\r\n    earcutInjection = earcut\r\n): Nullable<Mesh> {\r\n    // First we need to generate the paths\r\n    const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);\r\n\r\n    // And extrude them\r\n    const meshes: Mesh[] = [];\r\n    let letterIndex = 0;\r\n    for (const shapePath of shapePaths) {\r\n        if (!shapePath.paths.length) {\r\n            continue;\r\n        }\r\n\r\n        const holes = shapePath.holes.slice(); // Copy it as we will update the copy\r\n        for (const path of shapePath.paths) {\r\n            const holeVectors: Vector3[][] = [];\r\n            const shapeVectors: Vector3[] = [];\r\n            const points = path.getPoints();\r\n            for (const point of points) {\r\n                shapeVectors.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n            }\r\n\r\n            // Holes\r\n            const localHolesCopy = holes.slice();\r\n            for (const hole of localHolesCopy) {\r\n                const points = hole.getPoints();\r\n\r\n                let found = false;\r\n                for (const point of points) {\r\n                    if (path.isPointInside(point)) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    continue;\r\n                }\r\n\r\n                const holePoints: Vector3[] = [];\r\n                for (const point of points) {\r\n                    holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                }\r\n                holeVectors.push(holePoints);\r\n\r\n                // Remove the hole as it was already used\r\n                holes.splice(holes.indexOf(hole), 1);\r\n            }\r\n\r\n            // There is at least a hole but it was unaffected\r\n            if (!holeVectors.length && holes.length) {\r\n                for (const hole of holes) {\r\n                    const points = hole.getPoints();\r\n                    const holePoints: Vector3[] = [];\r\n                    for (const point of points) {\r\n                        holePoints.push(new Vector3(point.x, 0, point.y)); // ExtrudePolygon expects data on the xz plane\r\n                    }\r\n                    holeVectors.push(holePoints);\r\n                }\r\n            }\r\n\r\n            // Extrusion!\r\n            const mesh = ExtrudePolygon(\r\n                name,\r\n                {\r\n                    shape: shapeVectors,\r\n                    holes: holeVectors.length ? holeVectors : undefined,\r\n                    depth: options.depth || 1.0,\r\n                    faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),\r\n                    faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),\r\n                    sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE),\r\n                },\r\n                scene,\r\n                earcutInjection\r\n            );\r\n            meshes.push(mesh);\r\n            letterIndex++;\r\n        }\r\n    }\r\n\r\n    // Then we can merge everyone into one single mesh\r\n    const newMesh = Mesh.MergeMeshes(meshes, true, true);\r\n\r\n    if (newMesh) {\r\n        // Move pivot to desired center / bottom / center position\r\n        const bbox = newMesh.getBoundingInfo().boundingBox;\r\n        newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2; // Mid X\r\n        newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2; // Mid Z as it will rotate\r\n        newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z; // Bottom Y as it will rotate\r\n        newMesh.name = name;\r\n\r\n        // Rotate 90 Up\r\n        const pivot = new TransformNode(\"pivot\", scene);\r\n        pivot.rotation.x = -Math.PI / 2;\r\n        newMesh.parent = pivot;\r\n\r\n        newMesh.bakeCurrentTransformIntoVertices();\r\n\r\n        // Remove the pivot\r\n        newMesh.parent = null;\r\n        pivot.dispose();\r\n    }\r\n\r\n    return newMesh;\r\n}\r\n", "import { Tools } from \"../../../Misc/tools\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { ISceneComponent } from \"../../../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\n/**\r\n * Defines the Procedural Texture scene component responsible to manage any Procedural Texture\r\n * in a given scene.\r\n */\r\nexport class ProceduralTextureSceneComponent implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        // Nothing to do here.\r\n    }\r\n\r\n    private _beforeClear(): void {\r\n        if (this.scene.proceduralTexturesEnabled) {\r\n            Tools.StartPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n            for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {\r\n                const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];\r\n                if (proceduralTexture._shouldRender()) {\r\n                    proceduralTexture.render();\r\n                }\r\n            }\r\n            Tools.EndPerformanceCounter(\"Procedural textures\", this.scene.proceduralTextures.length > 0);\r\n        }\r\n    }\r\n}\r\n", "import { serialize } from \"../../../Misc/decorators\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport type { Matrix, Vector4, Vector3, Vector2 } from \"../../../Maths/math.vector\";\r\nimport type { Color4, Color3 } from \"../../../Maths/math.color\";\r\nimport type { AbstractEngine } from \"../../../Engines/abstractEngine\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { SceneComponentConstants } from \"../../../sceneComponent\";\r\n\r\nimport { Material } from \"../../../Materials/material\";\r\nimport type { Effect } from \"../../../Materials/effect\";\r\nimport { Texture } from \"../../../Materials/Textures/texture\";\r\nimport type { RenderTargetTextureOptions } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { RenderTargetTexture } from \"../../../Materials/Textures/renderTargetTexture\";\r\nimport { ProceduralTextureSceneComponent } from \"./proceduralTextureSceneComponent\";\r\n\r\nimport type { DataBuffer } from \"../../../Buffers/dataBuffer\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport type { NodeMaterial } from \"../../Node/nodeMaterial\";\r\nimport type { TextureSize } from \"../../../Materials/Textures/textureCreationOptions\";\r\nimport { EngineStore } from \"../../../Engines/engineStore\";\r\nimport { Constants } from \"../../../Engines/constants\";\r\nimport { DrawWrapper } from \"../../drawWrapper\";\r\nimport type { RenderTargetWrapper } from \"../../../Engines/renderTargetWrapper\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\n\r\n/**\r\n * Options to create a procedural texture\r\n */\r\nexport interface IProceduralTextureCreationOptions extends RenderTargetTextureOptions {\r\n    /**\r\n     * Defines a fallback texture in case there were issues to create the custom texture\r\n     */\r\n    fallbackTexture?: Nullable<Texture>;\r\n    /**\r\n     * The shader language of the shader. (default: GLSL)\r\n     */\r\n    shaderLanguage?: ShaderLanguage;\r\n    /**\r\n     * Additional async code to run before preparing the effect\r\n     */\r\n    extraInitializationsAsync?: () => Promise<void>;\r\n}\r\n\r\n/**\r\n * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes calmpler' images.\r\n * This is the base class of any Procedural texture and contains most of the shareable code.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n */\r\nexport class ProceduralTexture extends Texture {\r\n    /**\r\n     * Define if the texture is enabled or not (disabled texture will not render)\r\n     */\r\n    @serialize()\r\n    public isEnabled = true;\r\n\r\n    /**\r\n     * Define if the texture must be cleared before rendering (default is true)\r\n     */\r\n    @serialize()\r\n    public autoClear = true;\r\n\r\n    /**\r\n     * Callback called when the texture is generated\r\n     */\r\n    public onGenerated: () => void;\r\n\r\n    /**\r\n     * Event raised when the texture is generated\r\n     */\r\n    public onGeneratedObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Event raised before the texture is generated\r\n     */\r\n    public onBeforeGenerationObservable = new Observable<ProceduralTexture>();\r\n\r\n    /**\r\n     * Gets or sets the node material used to create this texture (null if the texture was manually created)\r\n     */\r\n    public nodeMaterialSource: Nullable<NodeMaterial> = null;\r\n\r\n    /**\r\n     * Define the list of custom preprocessor defines used in the shader\r\n     */\r\n    public defines: string = \"\";\r\n\r\n    /** @internal */\r\n    @serialize()\r\n    public _generateMipMaps: boolean;\r\n\r\n    private _drawWrapper: DrawWrapper;\r\n\r\n    /** @internal */\r\n    public _textures: { [key: string]: ThinTexture } = {};\r\n\r\n    /** @internal */\r\n    protected _fallbackTexture: Nullable<Texture>;\r\n\r\n    /** @internal */\r\n    private _shaderLanguage: ShaderLanguage;\r\n\r\n    /**\r\n     * Gets the shader language type used to generate vertex and fragment source code.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    @serialize()\r\n    private _size: TextureSize;\r\n    private _textureType: number;\r\n    private _currentRefreshId = -1;\r\n    private _frameId = -1;\r\n    private _refreshRate = 1;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: Nullable<DataBuffer>;\r\n    private _uniforms = new Array<string>();\r\n    private _samplers = new Array<string>();\r\n    private _fragment: any;\r\n\r\n    private _floats: { [key: string]: number } = {};\r\n    private _ints: { [key: string]: number } = {};\r\n    private _floatsArrays: { [key: string]: number[] } = {};\r\n    private _colors3: { [key: string]: Color3 } = {};\r\n    private _colors4: { [key: string]: Color4 } = {};\r\n    private _vectors2: { [key: string]: Vector2 } = {};\r\n    private _vectors3: { [key: string]: Vector3 } = {};\r\n    private _vectors4: { [key: string]: Vector4 } = {};\r\n    private _matrices: { [key: string]: Matrix } = {};\r\n\r\n    private _fallbackTextureUsed = false;\r\n    private _fullEngine: AbstractEngine;\r\n\r\n    private _cachedDefines: Nullable<string> = null;\r\n\r\n    private _contentUpdateId = -1;\r\n    private _contentData: Nullable<Promise<ArrayBufferView>>;\r\n\r\n    private _rtWrapper: Nullable<RenderTargetWrapper> = null;\r\n    private _options: IProceduralTextureCreationOptions;\r\n\r\n    /**\r\n     * Instantiates a new procedural texture.\r\n     * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.\r\n     * This is the base class of any Procedural texture and contains most of the shareable code.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures\r\n     * @param name  Define the name of the texture\r\n     * @param size Define the size of the texture to create\r\n     * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:\r\n     *  * object: \\{ fragmentElement: \"fragmentShaderCode\" \\}, used with shader code in script tags\r\n     *  * object: \\{ fragmentSource: \"fragment shader code string\" \\}, the string contains the shader code\r\n     *  * string: the string contains a name \"XXX\" to lookup in Effect.ShadersStore[\"XXXFragmentShader\"]\r\n     * @param scene Define the scene the texture belongs to\r\n     * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture\r\n     * @param generateMipMaps Define if the texture should creates mip maps or not\r\n     * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)\r\n     * @param textureType The FBO internal texture type\r\n     */\r\n    constructor(\r\n        name: string,\r\n        size: TextureSize,\r\n        fragment: any,\r\n        scene: Nullable<Scene>,\r\n        fallbackTexture: Nullable<Texture> | IProceduralTextureCreationOptions = null,\r\n        generateMipMaps = true,\r\n        isCube = false,\r\n        textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    ) {\r\n        super(null, scene, !generateMipMaps);\r\n\r\n        if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {\r\n            this._options = fallbackTexture;\r\n            this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;\r\n        } else {\r\n            this._options = {};\r\n            this._fallbackTexture = fallbackTexture;\r\n        }\r\n\r\n        this._shaderLanguage = this._options.shaderLanguage ?? ShaderLanguage.GLSL;\r\n\r\n        scene = this.getScene() || EngineStore.LastCreatedScene!;\r\n        let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);\r\n        if (!component) {\r\n            component = new ProceduralTextureSceneComponent(scene);\r\n            scene._addComponent(component);\r\n        }\r\n        scene.proceduralTextures.push(this);\r\n\r\n        this._fullEngine = scene.getEngine();\r\n\r\n        this.name = name;\r\n        this.isRenderTarget = true;\r\n        this._size = size;\r\n        this._textureType = textureType;\r\n        this._generateMipMaps = generateMipMaps;\r\n        this._drawWrapper = new DrawWrapper(this._fullEngine);\r\n\r\n        this.setFragment(fragment);\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // VBO\r\n        const vertices = [];\r\n        vertices.push(1, 1);\r\n        vertices.push(-1, 1);\r\n        vertices.push(-1, -1);\r\n        vertices.push(1, -1);\r\n\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);\r\n\r\n        this._createIndexBuffer();\r\n    }\r\n\r\n    private _createRtWrapper(isCube: boolean, size: TextureSize, generateMipMaps: boolean, textureType: number) {\r\n        if (isCube) {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size as number, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            this.setFloat(\"face\", 0);\r\n        } else {\r\n            this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {\r\n                generateMipMaps: generateMipMaps,\r\n                generateDepthBuffer: false,\r\n                generateStencilBuffer: false,\r\n                type: textureType,\r\n                ...this._options,\r\n            });\r\n            if (this._rtWrapper.is3D) {\r\n                this.setFloat(\"layer\", 0);\r\n                this.setInt(\"layerNum\", 0);\r\n            }\r\n        }\r\n        return this._rtWrapper;\r\n    }\r\n\r\n    /**\r\n     * The effect that is created when initializing the post process.\r\n     * @returns The created effect corresponding the postprocess.\r\n     */\r\n    public getEffect(): Effect {\r\n        return this._drawWrapper.effect!;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setEffect(effect: Effect) {\r\n        this._drawWrapper.effect = effect;\r\n    }\r\n\r\n    /**\r\n     * Gets texture content (Use this function wisely as reading from a texture can be slow)\r\n     * @returns an ArrayBufferView promise (Uint8Array or Float32Array)\r\n     */\r\n    public getContent(): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._contentData && this._frameId === this._contentUpdateId) {\r\n            return this._contentData;\r\n        }\r\n\r\n        if (this._contentData) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._contentData.then((buffer) => {\r\n                this._contentData = this.readPixels(0, 0, buffer);\r\n                this._contentUpdateId = this._frameId;\r\n            });\r\n        } else {\r\n            this._contentData = this.readPixels(0, 0);\r\n            this._contentUpdateId = this._frameId;\r\n        }\r\n\r\n        return this._contentData;\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this._fullEngine;\r\n\r\n        // Indices\r\n        const indices = [];\r\n        indices.push(0);\r\n        indices.push(1);\r\n        indices.push(2);\r\n\r\n        indices.push(0);\r\n        indices.push(2);\r\n        indices.push(3);\r\n\r\n        this._indexBuffer = engine.createIndexBuffer(indices);\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n\r\n        this._createIndexBuffer();\r\n\r\n        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {\r\n            this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resets the texture in order to recreate its associated resources.\r\n     * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code\r\n     */\r\n    public reset(): void {\r\n        this._drawWrapper.effect?.dispose();\r\n        this._drawWrapper.effect = null;\r\n        this._cachedDefines = null;\r\n    }\r\n\r\n    protected _getDefines(): string {\r\n        return this.defines;\r\n    }\r\n\r\n    /**\r\n     * Executes a function when the texture will be ready to be drawn.\r\n     * @param func The callback to be used.\r\n     */\r\n    public executeWhenReady(func: (texture: ProceduralTexture) => void): void {\r\n        if (this.isReady()) {\r\n            func(this);\r\n            return;\r\n        }\r\n\r\n        const effect = this.getEffect();\r\n        if (effect) {\r\n            effect.executeWhenCompiled(() => {\r\n                func(this);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is the texture ready to be used ? (rendered at least once)\r\n     * @returns true if ready, otherwise, false.\r\n     */\r\n    public override isReady(): boolean {\r\n        const engine = this._fullEngine;\r\n\r\n        if (this.nodeMaterialSource) {\r\n            return this._drawWrapper.effect!.isReady();\r\n        }\r\n\r\n        if (!this._fragment) {\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return true;\r\n        }\r\n\r\n        if (!this._texture) {\r\n            return false;\r\n        }\r\n\r\n        const defines = this._getDefines();\r\n        if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {\r\n            return true;\r\n        }\r\n\r\n        const shaders = {\r\n            vertex: \"procedural\",\r\n            fragmentElement: this._fragment.fragmentElement,\r\n            fragmentSource: this._fragment.fragmentSource,\r\n            fragment: typeof this._fragment === \"string\" ? this._fragment : undefined,\r\n        };\r\n\r\n        if (this._cachedDefines !== defines) {\r\n            this._cachedDefines = defines;\r\n\r\n            this._drawWrapper.effect = engine.createEffect(\r\n                shaders,\r\n                [VertexBuffer.PositionKind],\r\n                this._uniforms,\r\n                this._samplers,\r\n                defines,\r\n                undefined,\r\n                undefined,\r\n                () => {\r\n                    this._rtWrapper?.dispose();\r\n                    this._rtWrapper = this._texture = null;\r\n\r\n                    if (this._fallbackTexture) {\r\n                        this._texture = this._fallbackTexture._texture;\r\n\r\n                        if (this._texture) {\r\n                            this._texture.incrementReferences();\r\n                        }\r\n                    }\r\n\r\n                    this._fallbackTextureUsed = true;\r\n                },\r\n                undefined,\r\n                this._shaderLanguage,\r\n                async () => {\r\n                    if (this._options.extraInitializationsAsync) {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await Promise.all([import(\"../../../ShadersWGSL/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        } else {\r\n                            await Promise.all([import(\"../../../Shaders/procedural.vertex\"), this._options.extraInitializationsAsync()]);\r\n                        }\r\n                    } else {\r\n                        if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                            await import(\"../../../ShadersWGSL/procedural.vertex\");\r\n                        } else {\r\n                            await import(\"../../../Shaders/procedural.vertex\");\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return this._drawWrapper.effect!.isReady();\r\n    }\r\n\r\n    /**\r\n     * Resets the refresh counter of the texture and start bak from scratch.\r\n     * Could be useful to regenerate the texture if it is setup to render only once.\r\n     */\r\n    public resetRefreshCounter(): void {\r\n        this._currentRefreshId = -1;\r\n    }\r\n\r\n    /**\r\n     * Set the fragment shader to use in order to render the texture.\r\n     * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.\r\n     */\r\n    public setFragment(fragment: any) {\r\n        this._fragment = fragment;\r\n    }\r\n\r\n    /**\r\n     * Define the refresh rate of the texture or the rendering frequency.\r\n     * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...\r\n     */\r\n    @serialize()\r\n    public get refreshRate(): number {\r\n        return this._refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._refreshRate = value;\r\n        this.resetRefreshCounter();\r\n    }\r\n\r\n    /** @internal */\r\n    public _shouldRender(): boolean {\r\n        if (!this.isEnabled || !this.isReady() || !this._texture) {\r\n            if (this._texture) {\r\n                this._texture.isReady = false;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        if (this._fallbackTextureUsed) {\r\n            return false;\r\n        }\r\n\r\n        if (this._currentRefreshId === -1) {\r\n            // At least render once\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        if (this.refreshRate === this._currentRefreshId) {\r\n            this._currentRefreshId = 1;\r\n            this._frameId++;\r\n            return true;\r\n        }\r\n\r\n        this._currentRefreshId++;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the size the texture is rendering at.\r\n     * @returns the size (on cube texture it is always squared)\r\n     */\r\n    public getRenderSize(): TextureSize {\r\n        return this._size;\r\n    }\r\n\r\n    /**\r\n     * Resize the texture to new value.\r\n     * @param size Define the new size the texture should have\r\n     * @param generateMipMaps Define whether the new texture should create mip maps\r\n     */\r\n    public resize(size: TextureSize, generateMipMaps: boolean): void {\r\n        if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {\r\n            return;\r\n        }\r\n\r\n        const isCube = this._texture.isCube;\r\n        this._rtWrapper.dispose();\r\n\r\n        const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);\r\n        this._texture = rtWrapper.texture;\r\n\r\n        // Update properties\r\n        this._size = size;\r\n        this._generateMipMaps = generateMipMaps;\r\n    }\r\n\r\n    private _checkUniform(uniformName: string): void {\r\n        if (this._uniforms.indexOf(uniformName) === -1) {\r\n            this._uniforms.push(uniformName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a texture in the shader program used to render.\r\n     * @param name Define the name of the uniform samplers as defined in the shader\r\n     * @param texture Define the texture to bind to this sampler\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setTexture(name: string, texture: ThinTexture): ProceduralTexture {\r\n        if (this._samplers.indexOf(name) === -1) {\r\n            this._samplers.push(name);\r\n        }\r\n        this._textures[name] = texture;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a float in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloat(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floats[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a int in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setInt(name: string, value: number): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._ints[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set an array of floats in the shader.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setFloats(name: string, value: number[]): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._floatsArrays[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Color3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor3(name: string, value: Color3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Color4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setColor4(name: string, value: Color4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._colors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec2 in the shader from a Vector2.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector2(name: string, value: Vector2): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors2[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec3 in the shader from a Vector3.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector3(name: string, value: Vector3): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors3[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a vec4 in the shader from a Vector4.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setVector4(name: string, value: Vector4): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._vectors4[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Set a mat4 in the shader from a MAtrix.\r\n     * @param name Define the name of the uniform as defined in the shader\r\n     * @param value Define the value to give to the uniform\r\n     * @returns the texture itself allowing \"fluent\" like uniform updates\r\n     */\r\n    public setMatrix(name: string, value: Matrix): ProceduralTexture {\r\n        this._checkUniform(name);\r\n        this._matrices[name] = value;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Render the texture to its associated render target.\r\n     * @param useCameraPostProcess Define if camera post process should be applied to the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public render(useCameraPostProcess?: boolean): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._fullEngine;\r\n\r\n        // Render\r\n        engine.enableEffect(this._drawWrapper);\r\n        this.onBeforeGenerationObservable.notifyObservers(this);\r\n        engine.setState(false);\r\n\r\n        if (!this.nodeMaterialSource) {\r\n            // Texture\r\n            for (const name in this._textures) {\r\n                this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._ints) {\r\n                this._drawWrapper.effect!.setInt(name, this._ints[name]);\r\n            }\r\n\r\n            // Float\r\n            for (const name in this._floats) {\r\n                this._drawWrapper.effect!.setFloat(name, this._floats[name]);\r\n            }\r\n\r\n            // Floats\r\n            for (const name in this._floatsArrays) {\r\n                this._drawWrapper.effect!.setArray(name, this._floatsArrays[name]);\r\n            }\r\n\r\n            // Color3\r\n            for (const name in this._colors3) {\r\n                this._drawWrapper.effect!.setColor3(name, this._colors3[name]);\r\n            }\r\n\r\n            // Color4\r\n            for (const name in this._colors4) {\r\n                const color = this._colors4[name];\r\n                this._drawWrapper.effect!.setFloat4(name, color.r, color.g, color.b, color.a);\r\n            }\r\n\r\n            // Vector2\r\n            for (const name in this._vectors2) {\r\n                this._drawWrapper.effect!.setVector2(name, this._vectors2[name]);\r\n            }\r\n\r\n            // Vector3\r\n            for (const name in this._vectors3) {\r\n                this._drawWrapper.effect!.setVector3(name, this._vectors3[name]);\r\n            }\r\n\r\n            // Vector4\r\n            for (const name in this._vectors4) {\r\n                this._drawWrapper.effect!.setVector4(name, this._vectors4[name]);\r\n            }\r\n\r\n            // Matrix\r\n            for (const name in this._matrices) {\r\n                this._drawWrapper.effect!.setMatrix(name, this._matrices[name]);\r\n            }\r\n        }\r\n\r\n        if (!this._texture || !this._rtWrapper) {\r\n            return;\r\n        }\r\n\r\n        engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);\r\n\r\n        const viewPort = engine.currentViewport;\r\n        if (this.isCube) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine.bindFramebuffer(this._rtWrapper, face, undefined, undefined, true);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                this._drawWrapper.effect!.setFloat(\"face\", face);\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, true);\r\n            }\r\n        } else {\r\n            let numLayers = 1;\r\n            if (this._rtWrapper.is3D) {\r\n                numLayers = this._rtWrapper.depth;\r\n            } else if (this._rtWrapper.is2DArray) {\r\n                numLayers = this._rtWrapper.layers;\r\n            }\r\n            for (let layer = 0; layer < numLayers; layer++) {\r\n                engine.bindFramebuffer(this._rtWrapper, 0, undefined, undefined, true, 0, layer);\r\n\r\n                // VBOs\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect!);\r\n\r\n                if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {\r\n                    this._drawWrapper.effect?.setFloat(\"layer\", numLayers !== 1 ? layer / (numLayers - 1) : 0);\r\n                    this._drawWrapper.effect?.setInt(\"layerNum\", layer);\r\n                    for (const name in this._textures) {\r\n                        this._drawWrapper.effect!.setTexture(name, this._textures[name]);\r\n                    }\r\n                }\r\n\r\n                // Clear\r\n                if (this.autoClear) {\r\n                    engine.clear(scene.clearColor, true, false, false);\r\n                }\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.TriangleFillMode, 0, 6);\r\n                // Unbind and restore viewport\r\n                engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);\r\n            }\r\n        }\r\n\r\n        if (viewPort) {\r\n            engine.setViewport(viewPort);\r\n        }\r\n\r\n        // Mipmaps\r\n        if (this.isCube) {\r\n            engine.generateMipMapsForCubemap(this._texture, true);\r\n        }\r\n\r\n        engine._debugPopGroup?.(1);\r\n\r\n        if (this.onGenerated) {\r\n            this.onGenerated();\r\n        }\r\n\r\n        this.onGeneratedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Clone the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): ProceduralTexture {\r\n        const textureSize = this.getSize();\r\n        const newTexture = new ProceduralTexture(this.name, textureSize.width, this._fragment, <Scene>this.getScene(), this._fallbackTexture, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // RenderTarget Texture\r\n        newTexture.coordinatesMode = this.coordinatesMode;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Dispose the texture and release its associated resources.\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const index = scene.proceduralTextures.indexOf(this);\r\n\r\n        if (index >= 0) {\r\n            scene.proceduralTextures.splice(index, 1);\r\n        }\r\n\r\n        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vertexBuffer) {\r\n            vertexBuffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n\r\n        if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {\r\n            this._indexBuffer = null;\r\n        }\r\n\r\n        this.onGeneratedObservable.clear();\r\n        this.onBeforeGenerationObservable.clear();\r\n\r\n        super.dispose();\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.ProceduralTexture\", ProceduralTexture);\r\n", "import { Vector2 } from \"core/Maths/math.vector\";\r\n\r\n/**\r\n * Given the control points, solve for x based on a given t for a cubic bezier curve\r\n * @param t a value between 0 and 1\r\n * @param p0 first control point\r\n * @param p1 second control point\r\n * @param p2 third control point\r\n * @param p3 fourth control point\r\n * @returns number result of cubic bezier curve at the specified t\r\n */\r\nfunction CubicBezierCurve(t: number, p0: number, p1: number, p2: number, p3: number): number {\r\n    return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;\r\n}\r\n\r\n/**\r\n * Evaluates a specified specular power value to determine the appropriate roughness value,\r\n * based on a pre-defined cubic bezier curve with specular on the abscissa axis (x-axis)\r\n * and roughness on the ordinant axis (y-axis)\r\n * @param specularPower specular power of standard material\r\n * @param p0 first control point\r\n * @param p1 second control point\r\n * @param p2 third control point\r\n * @param p3 fourth control point\r\n * @returns Number representing the roughness value\r\n */\r\nexport function SpecularPowerToRoughness(specularPower: number, p0 = new Vector2(0, 1), p1 = new Vector2(0, 0.1), p2 = new Vector2(0, 0.1), p3 = new Vector2(1300, 0.1)): number {\r\n    // Given P0.x = 0, P1.x = 0, P2.x = 0\r\n    //   x = t * t * t * P3.x\r\n    //   t = (x / P3.x)^(1/3)\r\n    const t = Math.pow(specularPower / p3.x, 0.333333);\r\n    return CubicBezierCurve(t, p0.y, p1.y, p2.y, p3.y);\r\n}\r\n", "import type { RawTexture } from \"../Textures/rawTexture\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\n\r\n/**\r\n * Default settings for GreasedLine materials\r\n */\r\nexport class GreasedLineMaterialDefaults {\r\n    /**\r\n     * Default line color for newly created lines\r\n     */\r\n    public static DEFAULT_COLOR = Color3.White();\r\n    /**\r\n     * Default line width when sizeAttenuation is true\r\n     */\r\n    public static DEFAULT_WIDTH_ATTENUATED = 1;\r\n    /**\r\n     * Defaule line width\r\n     */\r\n    public static DEFAULT_WIDTH = 0.1;\r\n    /**\r\n     * Empty colors texture for WebGPU\r\n     */\r\n    public static EmptyColorsTexture: Nullable<RawTexture>;\r\n}\r\n", "import { Curve3 } from \"../Maths/math.path\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { IFontData } from \"../Meshes/Builders/textBuilder\";\r\nimport { CreateTextShapePaths } from \"../Meshes/Builders/textBuilder\";\r\nimport type { FloatArray, IndicesArray } from \"../types\";\r\nimport type { GreasedLinePoints, GreasedLinePointsOptions } from \"../Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Engine } from \"../Engines/engine\";\r\nimport { GreasedLineMaterialDefaults } from \"../Materials/GreasedLine/greasedLineMaterialDefaults\";\r\n\r\n/**\r\n * Tool functions for GreasedLine\r\n */\r\nexport class GreasedLineTools {\r\n    /**\r\n     * Converts GreasedLinePoints to number[][]\r\n     * @param points GreasedLinePoints\r\n     * @param options GreasedLineToolsConvertPointsOptions\r\n     * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]\r\n     */\r\n    public static ConvertPoints(points: GreasedLinePoints, options?: GreasedLinePointsOptions): number[][] {\r\n        if (points.length && Array.isArray(points) && typeof points[0] === \"number\") {\r\n            return [<number[]>points];\r\n        } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === \"number\") {\r\n            return <number[][]>points;\r\n        } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {\r\n            const positions: number[] = [];\r\n            for (let j = 0; j < points.length; j++) {\r\n                const p = points[j] as Vector3;\r\n                positions.push(p.x, p.y, p.z);\r\n            }\r\n            return [positions];\r\n        } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {\r\n            const positions: number[][] = [];\r\n            const vectorPoints = points as Vector3[][];\r\n            for (const p of vectorPoints) {\r\n                positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));\r\n            }\r\n            return positions;\r\n        } else if (points instanceof Float32Array) {\r\n            if (options?.floatArrayStride) {\r\n                const positions: number[][] = [];\r\n                const stride = options.floatArrayStride * 3;\r\n                for (let i = 0; i < points.length; i += stride) {\r\n                    const linePoints = new Array(stride); // Pre-allocate memory for the line\r\n                    for (let j = 0; j < stride; j++) {\r\n                        linePoints[j] = points[i + j];\r\n                    }\r\n                    positions.push(linePoints);\r\n                }\r\n                return positions;\r\n            } else {\r\n                return [Array.from(points)];\r\n            }\r\n        } else if (points.length && points[0] instanceof Float32Array) {\r\n            const positions: number[][] = [];\r\n            for (const p of points) {\r\n                positions.push(Array.from(p as Float32Array));\r\n            }\r\n\r\n            return positions;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Omit zero length lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitZeroLengthPredicate(p1: Vector3, p2: Vector3, p3: Vector3) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (p2.subtract(p1).lengthSquared() > 0) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (p3.subtract(p2).lengthSquared() > 0) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (p1.subtract(p3).lengthSquared() > 0) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    /**\r\n     * Omit duplicate lines predicate for the MeshesToLines function\r\n     * @param p1 point1 position of the face\r\n     * @param p2 point2 position of the face\r\n     * @param p3 point3 position of the face\r\n     * @param points array of points to search in\r\n     * @returns original points or null if any edge length is zero\r\n     */\r\n    public static OmitDuplicatesPredicate(p1: Vector3, p2: Vector3, p3: Vector3, points: Vector3[][]) {\r\n        const fileredPoints = [];\r\n        // edge1\r\n        if (!GreasedLineTools._SearchInPoints(p1, p2, points)) {\r\n            fileredPoints.push([p1, p2]);\r\n        }\r\n        // edge2\r\n        if (!GreasedLineTools._SearchInPoints(p2, p3, points)) {\r\n            fileredPoints.push([p2, p3]);\r\n        }\r\n        // edge3\r\n        if (!GreasedLineTools._SearchInPoints(p3, p1, points)) {\r\n            fileredPoints.push([p3, p1]);\r\n        }\r\n        return fileredPoints.length === 0 ? null : fileredPoints;\r\n    }\r\n\r\n    private static _SearchInPoints(p1: Vector3, p2: Vector3, points: Vector3[][]) {\r\n        for (const ps of points) {\r\n            for (let i = 0; i < ps.length; i++) {\r\n                if (ps[i]?.equals(p1)) {\r\n                    // find the first point\r\n                    // if it has a sibling of p2 the line already exists\r\n                    if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Gets mesh triangles as line positions\r\n     * @param meshes array of meshes\r\n     * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput\r\n     * @returns array of arrays of points\r\n     */\r\n    public static MeshesToLines(\r\n        meshes: AbstractMesh[],\r\n        predicate?: (\r\n            p1: Vector3,\r\n            p2: Vector3,\r\n            p3: Vector3,\r\n            points: Vector3[][],\r\n            indiceIndex: number,\r\n            vertexIndex: number,\r\n            mesh: AbstractMesh,\r\n            meshIndex: number,\r\n            vertices: FloatArray,\r\n            indices: IndicesArray\r\n        ) => Vector3[][]\r\n    ) {\r\n        const points: Vector3[][] = [];\r\n\r\n        for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {\r\n            const mesh = meshes[meshIndex];\r\n            const vertices = mesh.getVerticesData(VertexBuffer.PositionKind);\r\n            const indices = mesh.getIndices();\r\n            if (vertices && indices) {\r\n                for (let i = 0, ii = 0; i < indices.length; i++) {\r\n                    const vi1 = indices[ii++] * 3;\r\n                    const vi2 = indices[ii++] * 3;\r\n                    const vi3 = indices[ii++] * 3;\r\n\r\n                    const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);\r\n                    const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);\r\n                    const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);\r\n\r\n                    if (predicate) {\r\n                        const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, mesh, meshIndex, vertices, indices);\r\n                        if (pointsFromPredicate) {\r\n                            for (const p of pointsFromPredicate) {\r\n                                points.push(p);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        points.push([p1, p2], [p2, p3], [p3, p1]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Converts number coordinates to Vector3s\r\n     * @param points number array of x, y, z, x, y z, ... coordinates\r\n     * @returns Vector3 array\r\n     */\r\n    public static ToVector3Array(points: number[] | number[][]) {\r\n        if (Array.isArray(points[0])) {\r\n            const array: Vector3[][] = [];\r\n            const inputArray = points as number[][];\r\n            for (const subInputArray of inputArray) {\r\n                const subArray: Vector3[] = [];\r\n                for (let i = 0; i < subInputArray.length; i += 3) {\r\n                    subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));\r\n                }\r\n                array.push(subArray);\r\n            }\r\n            return array;\r\n        }\r\n\r\n        const inputArray = points as number[];\r\n        const array: Vector3[] = [];\r\n        for (let i = 0; i < inputArray.length; i += 3) {\r\n            array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Gets a number array from a Vector3 array.\r\n     * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.\r\n     * @param points Vector3 array\r\n     * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]\r\n     */\r\n    public static ToNumberArray(points: Vector3[]) {\r\n        return points.flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     * Calculates the sum of points of every line and the number of points in each line.\r\n     * This function is useful when you are drawing multiple lines in one mesh and you want\r\n     * to know the counts. For example for creating an offsets table.\r\n     * @param points point array\r\n     * @returns points count info\r\n     */\r\n    public static GetPointsCountInfo(points: number[][]): { total: number; counts: number[] } {\r\n        const counts = new Array(points.length);\r\n        let total = 0;\r\n        for (let n = points.length; n--; ) {\r\n            counts[n] = points[n].length / 3;\r\n            total += counts[n];\r\n        }\r\n        return { total, counts };\r\n    }\r\n\r\n    /**\r\n     * Gets the length of the line counting all it's segments length\r\n     * @param data array of line points\r\n     * @returns length of the line\r\n     */\r\n    public static GetLineLength(data: Vector3[] | number[]): number {\r\n        if (data.length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let points: Vector3[];\r\n        if (typeof data[0] === \"number\") {\r\n            points = GreasedLineTools.ToVector3Array(<number[]>data) as Vector3[];\r\n        } else {\r\n            points = data as Vector3[];\r\n        }\r\n\r\n        const tmp = TmpVectors.Vector3[0];\r\n        let length = 0;\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            length += point2.subtractToRef(point1, tmp).length();\r\n        }\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * Gets the length from the beginning to each point of the line as array.\r\n     * @param data array of line points\r\n     * @param buf optional pre-allocated buffer to reduce memory pressure, should be at least `data.length * 4 / 3` bytes\r\n     * @returns length array of the line\r\n     */\r\n    public static GetLineLengthArray(data: number[], buf?: ArrayBuffer): Float32Array {\r\n        const out = buf ? new Float32Array(buf, 0, data.length / 3) : new Float32Array(data.length / 3);\r\n        let length = 0;\r\n        for (let index = 0, pointsLength = data.length / 3 - 1; index < pointsLength; index++) {\r\n            let x = data[index * 3 + 0];\r\n            let y = data[index * 3 + 1];\r\n            let z = data[index * 3 + 2];\r\n            x -= data[index * 3 + 3];\r\n            y -= data[index * 3 + 4];\r\n            z -= data[index * 3 + 5];\r\n            const currentLength = Math.sqrt(x * x + y * y + z * z);\r\n            length += currentLength;\r\n            out[index + 1] = length;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    /**\r\n     * Divides a segment into smaller segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param point1 first point of the line\r\n     * @param point2 second point of the line\r\n     * @param segmentCount number of segments we want to have in the divided line\r\n     * @returns\r\n     */\r\n    public static SegmentizeSegmentByCount(point1: Vector3, point2: Vector3, segmentCount: number): Vector3[] {\r\n        const dividedLinePoints: Vector3[] = [];\r\n        const diff = point2.subtract(point1);\r\n        const divisor = TmpVectors.Vector3[0];\r\n        divisor.setAll(segmentCount);\r\n        const segmentVector = TmpVectors.Vector3[1];\r\n        diff.divideToRef(divisor, segmentVector);\r\n\r\n        let nextPoint = point1.clone();\r\n        dividedLinePoints.push(nextPoint);\r\n        for (let index = 0; index < segmentCount; index++) {\r\n            nextPoint = nextPoint.clone();\r\n            dividedLinePoints.push(nextPoint.addInPlace(segmentVector));\r\n        }\r\n\r\n        return dividedLinePoints;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentLength length of each segment of the resulting line (distance between two line points)\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentLength(what: Vector3[] | number[] | { point1: Vector3; point2: Vector3; length: number }[], segmentLength: number): Vector3[] {\r\n        const subLines =\r\n            what[0] instanceof Vector3\r\n                ? GreasedLineTools.GetLineSegments(what as Vector3[])\r\n                : typeof what[0] === \"number\"\r\n                  ? GreasedLineTools.GetLineSegments(GreasedLineTools.ToVector3Array(what as number[]) as Vector3[])\r\n                  : (what as { point1: Vector3; point2: Vector3; length: number }[]);\r\n        const points: Vector3[] = [];\r\n        for (const s of subLines) {\r\n            if (s.length > segmentLength) {\r\n                const segments = GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));\r\n                for (const seg of segments) {\r\n                    points.push(seg);\r\n                }\r\n            } else {\r\n                points.push(s.point1);\r\n                points.push(s.point2);\r\n            }\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Divides a line into segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param what line points\r\n     * @param segmentCount number of segments\r\n     * @returns line point\r\n     */\r\n    public static SegmentizeLineBySegmentCount(what: Vector3[] | number[], segmentCount: number): Vector3[] {\r\n        const points = <Vector3[]>(typeof what[0] === \"number\" ? GreasedLineTools.ToVector3Array(<number[]>what) : what);\r\n        const segmentLength = GreasedLineTools.GetLineLength(points) / segmentCount;\r\n        return GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);\r\n    }\r\n    /**\r\n     * Gets line segments.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns segments information of the line segment including starting point, ending point and the distance between them\r\n     */\r\n    public static GetLineSegments(points: Vector3[]): { point1: Vector3; point2: Vector3; length: number }[] {\r\n        const segments = [];\r\n        for (let index = 0; index < points.length - 1; index++) {\r\n            const point1 = points[index];\r\n            const point2 = points[index + 1];\r\n            const length = point2.subtract(point1).length();\r\n            segments.push({ point1, point2, length });\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum and the maximum length of a line segment in the line.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param points line points\r\n     * @returns\r\n     */\r\n    public static GetMinMaxSegmentLength(points: Vector3[]): { min: number; max: number } {\r\n        const subLines = GreasedLineTools.GetLineSegments(points);\r\n        const sorted = subLines.sort((s) => s.length);\r\n        return {\r\n            min: sorted[0].length,\r\n            max: sorted[sorted.length - 1].length,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Finds the last visible position in world space of the line according to the visibility parameter\r\n     * @param lineSegments segments of the line\r\n     * @param lineLength total length of the line\r\n     * @param visbility normalized value of visibility\r\n     * @param localSpace if true the result will be in local space (default is false)\r\n     * @returns world space coordinate of the last visible piece of the line\r\n     */\r\n    public static GetPositionOnLineByVisibility(lineSegments: { point1: Vector3; point2: Vector3; length: number }[], lineLength: number, visbility: number, localSpace = false) {\r\n        const lengthVisibilityRatio = lineLength * visbility;\r\n        let sumSegmentLengths = 0;\r\n        let segmentIndex = 0;\r\n\r\n        const lineSegmentsLength = lineSegments.length;\r\n        for (let i = 0; i < lineSegmentsLength; i++) {\r\n            if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {\r\n                segmentIndex = i;\r\n                break;\r\n            }\r\n            sumSegmentLengths += lineSegments[i].length;\r\n        }\r\n\r\n        const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;\r\n\r\n        lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);\r\n        TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);\r\n        if (!localSpace) {\r\n            TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);\r\n        }\r\n\r\n        return TmpVectors.Vector3[1].clone();\r\n    }\r\n\r\n    /**\r\n     * Creates lines in a shape of circle/arc.\r\n     * A segment is a part of the line between it's two points.\r\n     * @param radiusX radiusX of the circle\r\n     * @param segments number of segments in the circle\r\n     * @param z z coordinate of the points. Defaults to 0.\r\n     * @param radiusY radiusY of the circle - you can draw an oval if using different values\r\n     * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.\r\n     * @returns line points\r\n     */\r\n    public static GetCircleLinePoints(radiusX: number, segments: number, z = 0, radiusY = radiusX, segmentAngle = (Math.PI * 2) / segments) {\r\n        const points: Vector3[] = [];\r\n        for (let i = 0; i <= segments; i++) {\r\n            points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));\r\n        }\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Gets line points in a shape of a bezier curve\r\n     * @param p0 bezier point0\r\n     * @param p1 bezier point1\r\n     * @param p2 bezier point2\r\n     * @param segments number of segments in the curve\r\n     * @returns\r\n     */\r\n    public static GetBezierLinePoints(p0: Vector3, p1: Vector3, p2: Vector3, segments: number) {\r\n        return Curve3.CreateQuadraticBezier(p0, p1, p2, segments)\r\n            .getPoints()\r\n            .flatMap((v) => [v.x, v.y, v.z]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)\r\n     * @param direction direction which the arrow points to\r\n     * @param length length (size) of the arrow cap itself\r\n     * @param widthUp the arrow width above the line\r\n     * @param widthDown the arrow width belove the line\r\n     * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.\r\n     * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.\r\n     * @returns\r\n     */\r\n    public static GetArrowCap(position: Vector3, direction: Vector3, length: number, widthUp: number, widthDown: number, widthStartUp = 0, widthStartDown = 0) {\r\n        const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];\r\n        const widths = [widthUp, widthDown, widthStartUp, widthStartDown];\r\n\r\n        return {\r\n            points,\r\n            widths,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Gets 3D positions of points from a text and font\r\n     * @param text Text\r\n     * @param size Size of the font\r\n     * @param resolution Resolution of the font\r\n     * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)\r\n     * @param z z coordinate\r\n     * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.\r\n     * @returns number[][] of 3D positions\r\n     */\r\n    public static GetPointsFromText(text: string, size: number, resolution: number, fontData: IFontData, z = 0, includeInner = true) {\r\n        const allPoints = [];\r\n        const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);\r\n\r\n        for (const sp of shapePaths) {\r\n            for (const p of sp.paths) {\r\n                const points = [];\r\n                const points2d = p.getPoints();\r\n                for (const p2d of points2d) {\r\n                    points.push(p2d.x, p2d.y, z);\r\n                }\r\n                allPoints.push(points);\r\n            }\r\n\r\n            if (includeInner) {\r\n                for (const h of sp.holes) {\r\n                    const holes = [];\r\n                    const points2d = h.getPoints();\r\n                    for (const p2d of points2d) {\r\n                        holes.push(p2d.x, p2d.y, z);\r\n                    }\r\n                    allPoints.push(holes);\r\n                }\r\n            }\r\n        }\r\n\r\n        return allPoints;\r\n    }\r\n\r\n    /**\r\n     * Converts an array of Color3 to Uint8Array\r\n     * @param colors Arrray of Color3\r\n     * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]\r\n     */\r\n    public static Color3toRGBAUint8(colors: Color3[]): Uint8Array {\r\n        const colorTable: Uint8Array = new Uint8Array(colors.length * 4);\r\n        for (let i = 0, j = 0; i < colors.length; i++) {\r\n            colorTable[j++] = colors[i].r * 255;\r\n            colorTable[j++] = colors[i].g * 255;\r\n            colorTable[j++] = colors[i].b * 255;\r\n            colorTable[j++] = 255;\r\n        }\r\n\r\n        return colorTable;\r\n    }\r\n\r\n    /**\r\n     * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.\r\n     * @param name name of the texture\r\n     * @param colors Uint8Array of colors\r\n     * @param colorsSampling sampling mode of the created texture\r\n     * @param scene Scene\r\n     * @returns the colors texture\r\n     */\r\n    public static CreateColorsTexture(name: string, colors: Color3[], colorsSampling: number, scene: Scene) {\r\n        const maxTextureSize = scene.getEngine().getCaps().maxTextureSize ?? 1;\r\n        const width = colors.length > maxTextureSize ? maxTextureSize : colors.length;\r\n        const height = Math.ceil(colors.length / maxTextureSize);\r\n        if (height > 1) {\r\n            colors = [...colors, ...Array(width * height - colors.length).fill(colors[0])];\r\n        }\r\n        const colorsArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n        const colorsTexture = new RawTexture(colorsArray, width, height, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);\r\n        colorsTexture.name = name;\r\n        return colorsTexture;\r\n    }\r\n\r\n    /**\r\n     * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.\r\n     * For fast switching using the useColors property without the need to use defines.\r\n     * @param scene Scene\r\n     * @returns empty colors texture\r\n     */\r\n    public static PrepareEmptyColorsTexture(scene: Scene) {\r\n        if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {\r\n            const colorsArray = new Uint8Array(4);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);\r\n            GreasedLineMaterialDefaults.EmptyColorsTexture.name = \"grlEmptyColorsTexture\";\r\n        }\r\n\r\n        return GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n    }\r\n\r\n    /**\r\n     * Diposes the shared empty colors texture\r\n     */\r\n    public static DisposeEmptyColorsTexture() {\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();\r\n        GreasedLineMaterialDefaults.EmptyColorsTexture = null;\r\n    }\r\n\r\n    /**\r\n     * Converts boolean to number.\r\n     * @param bool the bool value\r\n     * @returns 1 if true, 0 if false.\r\n     */\r\n    public static BooleanToNumber(bool?: boolean) {\r\n        return bool ? 1 : 0;\r\n    }\r\n}\r\n", "import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns GLSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns GLSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.01);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                `,\n        };\n        if (cameraFacing) {\n            obj[\"!gl_Position\\\\=viewProjection\\\\*worldPos;\"] = \"//\"; // not needed for camera facing GRL\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                `,\n        };\n    }\n\n    return null;\n}\n", "import type { Nullable } from \"../../types\";\nimport { GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\n\n/**\n * Returns WGSL custom shader code\n * @param shaderType vertex or fragment\n * @param cameraFacing is in camera facing mode?\n * @returns WGSL custom shader code\n */\n/** @internal */\nexport function GetCustomCode(shaderType: string, cameraFacing: boolean): Nullable<{ [pointName: string]: string }> {\n    if (shaderType === \"vertex\") {\n        const obj: any = {\n            CUSTOM_VERTEX_DEFINITIONS: `\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                `,\n            CUSTOM_VERTEX_UPDATE_POSITION: `\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                `,\n            CUSTOM_VERTEX_MAIN_END: `\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.01);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                `,\n        };\n\n        if (cameraFacing) {\n            obj[\"!vertexOutputs\\\\.position\\\\s=\\\\sscene\\\\.viewProjection\\\\s\\\\*\\\\sworldPos;\"] = \"//\"; // not needed for camera facing GRL\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return obj;\n    }\n\n    if (shaderType === \"fragment\") {\n        return {\n            CUSTOM_FRAGMENT_DEFINITIONS: `\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                `,\n            CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_SET}.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                `,\n        };\n    }\n\n    return null;\n}\n", "import type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport { Vector2, TmpVectors } from \"../../Maths/math.vector\";\r\nimport type { Color3 } from \"../../Maths/math.color\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Material } from \"../material\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { BaseTexture } from \"../Textures/baseTexture\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\n\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport { GetCustomCode as getCustomCodeGLSL } from \"./greasedLinePluginMaterialShadersGLSL\";\r\nimport { GetCustomCode as getCustomCodeWGSL } from \"./greasedLinePluginMaterialShadersWGSL\";\r\nimport type { GreasedLineBaseMesh } from \"../../Meshes\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class MaterialGreasedLineDefines extends MaterialDefines {\r\n    /**\r\n     * The material has a color option specified\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_HAS_COLOR = false;\r\n    /**\r\n     * The material's size attenuation optiom\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_SIZE_ATTENUATION = false;\r\n    /**\r\n     * The type of color distribution is set to line this value equals to true.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;\r\n    /**\r\n     * True if scene is in right handed coordinate system.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;\r\n\r\n    /**\r\n     * True if the line is in camera facing mode\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_CAMERA_FACING = true;\r\n\r\n    /**\r\n     * True if the line uses offsets\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    GREASED_LINE_USE_OFFSETS = false;\r\n}\r\n\r\n/**\r\n * GreasedLinePluginMaterial for GreasedLineMesh/GreasedLineRibbonMesh.\r\n * Use the GreasedLineBuilder.CreateGreasedLineMaterial function to create and instance of this class.\r\n */\r\nexport class GreasedLinePluginMaterial extends MaterialPluginBase implements IGreasedLineMaterial {\r\n    /**\r\n     * Plugin name\r\n     */\r\n    public static readonly GREASED_LINE_MATERIAL_NAME = \"GreasedLinePluginMaterial\";\r\n\r\n    /**\r\n     * Force all the greased lines to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    public useColors: boolean;\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    public visibility: number;\r\n\r\n    /**\r\n     * Dash offset\r\n     */\r\n    public dashOffset: number;\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    public dashRatio: number;\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    public width: number;\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    public colorsSampling: number;\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    public useDash: boolean;\r\n\r\n    /**\r\n     * The mixing mode of the color paramater. Default value is GreasedLineMeshColorMode.SET\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    public colorMode: GreasedLineMeshColorMode;\r\n\r\n    /**\r\n     * You can provide a colorsTexture to use instead of one generated from the 'colors' option\r\n     */\r\n    public colorsTexture: Nullable<RawTexture> = null;\r\n\r\n    private _scene: Scene;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _color: Nullable<Color3>;\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType;\r\n    private _resolution: Vector2;\r\n    private _aspect: number;\r\n    private _sizeAttenuation: boolean;\r\n\r\n    private _cameraFacing: boolean;\r\n\r\n    private _engine: AbstractEngine;\r\n\r\n    private _forceGLSL = false;\r\n\r\n    /**\r\n     * Gets a boolean indicating that the plugin is compatible with a given shader language\r\n     * @param _shaderLanguage The shader language to use\r\n     * @returns true if the plugin is compatible with the shader language. Return always true since both GLSL and WGSL are supported\r\n     */\r\n    public override isCompatible(_shaderLanguage: ShaderLanguage): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Creates a new instance of the GreasedLinePluginMaterial\r\n     * @param material Base material for the plugin\r\n     * @param scene The scene\r\n     * @param options Plugin options\r\n     */\r\n    constructor(material: Material, scene?: Scene, options?: GreasedLineMaterialOptions) {\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        const defines = new MaterialGreasedLineDefines();\r\n        defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;\r\n        super(material, GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines, true, true);\r\n\r\n        this._forceGLSL = options?.forceGLSL || GreasedLinePluginMaterial.ForceGLSL;\r\n\r\n        this._scene = scene ?? material.getScene();\r\n        this._engine = this._scene.getEngine();\r\n\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this._sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._color = options.color ?? null;\r\n        this.useColors = options.useColors ?? false;\r\n        this._colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this._colors = options.colors ?? null;\r\n\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture; // colorsTexture from options takes precedence\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                GreasedLineTools.PrepareEmptyColorsTexture(this._scene);\r\n            }\r\n        }\r\n\r\n        this._engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the shader attributes\r\n     * @param attributes array which will be filled with the attributes\r\n     */\r\n    override getAttributes(attributes: string[]) {\r\n        attributes.push(\"grl_offsets\");\r\n        attributes.push(\"grl_widths\");\r\n        attributes.push(\"grl_colorPointers\");\r\n        attributes.push(\"grl_counters\");\r\n        if (this._cameraFacing) {\r\n            attributes.push(\"grl_previousAndSide\");\r\n            attributes.push(\"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader samplers\r\n     * @param samplers\r\n     */\r\n    override getSamplers(samplers: string[]) {\r\n        samplers.push(\"grl_colors\");\r\n    }\r\n\r\n    /**\r\n     * Get the shader textures\r\n     * @param activeTextures array which will be filled with the textures\r\n     */\r\n    public override getActiveTextures(activeTextures: BaseTexture[]): void {\r\n        if (this.colorsTexture) {\r\n            activeTextures.push(this.colorsTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the shader uniforms\r\n     * @param shaderLanguage The shader language to use\r\n     * @returns uniforms\r\n     */\r\n    override getUniforms(shaderLanguage = ShaderLanguage.GLSL) {\r\n        const ubo = [\r\n            { name: \"grl_singleColor\", size: 3, type: \"vec3\" },\r\n            { name: \"grl_textureSize\", size: 2, type: \"vec2\" },\r\n            { name: \"grl_dashOptions\", size: 4, type: \"vec4\" },\r\n            { name: \"grl_colorMode_visibility_colorsWidth_useColors\", size: 4, type: \"vec4\" },\r\n        ];\r\n        if (this._cameraFacing) {\r\n            ubo.push({ name: \"grl_projection\", size: 16, type: \"mat4\" }, { name: \"grl_aspect_resolution_lineWidth\", size: 4, type: \"vec4\" });\r\n        }\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            ubo.push({\r\n                name: \"viewProjection\",\r\n                size: 16,\r\n                type: \"mat4\",\r\n            });\r\n        }\r\n\r\n        return {\r\n            ubo,\r\n            vertex:\r\n                this._cameraFacing && this._isGLSL(shaderLanguage)\r\n                    ? `\r\n                    uniform vec4 grl_aspect_resolution_lineWidth;\r\n                    uniform mat4 grl_projection;\r\n    `\r\n                    : \"\",\r\n            fragment: this._isGLSL(shaderLanguage)\r\n                ? `\r\n                    uniform vec4 grl_dashOptions;\r\n                    uniform vec2 grl_textureSize;\r\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\r\n                    uniform vec3 grl_singleColor;\r\n    `\r\n                : \"\",\r\n        };\r\n    }\r\n\r\n    // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh\r\n    // and it doesn't make sense to disable it on the mesh\r\n    get isEnabled() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Bind the uniform buffer\r\n     * @param uniformBuffer\r\n     */\r\n    override bindForSubMesh(uniformBuffer: UniformBuffer) {\r\n        if (this._cameraFacing) {\r\n            uniformBuffer.updateMatrix(\"grl_projection\", this._scene.getProjectionMatrix());\r\n            if (!this._isGLSL(this._material.shaderLanguage)) {\r\n                uniformBuffer.updateMatrix(\"viewProjection\", this._scene.getTransformMatrix());\r\n            }\r\n\r\n            const resolutionLineWidth = TmpVectors.Vector4[0];\r\n            resolutionLineWidth.x = this._aspect;\r\n            resolutionLineWidth.y = this._resolution.x;\r\n            resolutionLineWidth.z = this._resolution.y;\r\n            resolutionLineWidth.w = this.width;\r\n            uniformBuffer.updateVector4(\"grl_aspect_resolution_lineWidth\", resolutionLineWidth);\r\n        }\r\n\r\n        const dashOptions = TmpVectors.Vector4[0];\r\n        dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);\r\n        dashOptions.y = this._dashArray;\r\n        dashOptions.z = this.dashOffset;\r\n        dashOptions.w = this.dashRatio;\r\n        uniformBuffer.updateVector4(\"grl_dashOptions\", dashOptions);\r\n\r\n        const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];\r\n        colorModeVisibilityColorsWidthUseColors.x = this.colorMode;\r\n        colorModeVisibilityColorsWidthUseColors.y = this.visibility;\r\n        colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;\r\n        colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);\r\n        uniformBuffer.updateVector4(\"grl_colorMode_visibility_colorsWidth_useColors\", colorModeVisibilityColorsWidthUseColors);\r\n\r\n        if (this._color) {\r\n            uniformBuffer.updateColor3(\"grl_singleColor\", this._color);\r\n        }\r\n        const texture = this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture;\r\n        uniformBuffer.setTexture(\"grl_colors\", texture);\r\n        uniformBuffer.updateFloat2(\"grl_textureSize\", texture?.getSize().width ?? 1, texture?.getSize().height ?? 1);\r\n    }\r\n\r\n    /**\r\n     * Prepare the defines\r\n     * @param defines\r\n     * @param _scene\r\n     * @param mesh\r\n     */\r\n    override prepareDefines(defines: MaterialGreasedLineDefines, _scene: Scene, mesh: AbstractMesh) {\r\n        defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;\r\n        defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;\r\n        defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE;\r\n        defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;\r\n        defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;\r\n        defines.GREASED_LINE_USE_OFFSETS = !!(mesh as GreasedLineBaseMesh).offsets;\r\n    }\r\n\r\n    /**\r\n     * Get the class name\r\n     * @returns class name\r\n     */\r\n    override getClassName() {\r\n        return GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;\r\n    }\r\n\r\n    /**\r\n     * Get shader code\r\n     * @param shaderType vertex/fragment\r\n     * @param shaderLanguage GLSL or WGSL\r\n     * @returns shader code\r\n     */\r\n    override getCustomCode(shaderType: string, shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        if (this._isGLSL(shaderLanguage)) {\r\n            return getCustomCodeGLSL(shaderType, this._cameraFacing);\r\n        }\r\n        return getCustomCodeWGSL(shaderType, this._cameraFacing);\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public override dispose(): void {\r\n        this.colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this.colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this.colorsTexture.update(colorArray);\r\n        } else {\r\n            this.colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n    }\r\n\r\n    /**\r\n     * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     * Not supported for non camera facing lines.\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off size attenuation of the width option and widths array.\r\n     * Not supported for non camera facing lines.\r\n     * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true\r\n     */\r\n    set color(value: Nullable<Color3>) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * @param value color\r\n     * @param doNotMarkDirty if true, the material will not be marked as dirty\r\n     */\r\n    public setColor(value: Nullable<Color3>, doNotMarkDirty = false) {\r\n        if ((this._color === null && value !== null) || (this._color !== null && value === null)) {\r\n            this._color = value;\r\n            if (!doNotMarkDirty) {\r\n                this.markAllDefinesAsDirty();\r\n            }\r\n        } else {\r\n            this._color = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._aspect = value.x / value.y;\r\n        this._resolution = value;\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this.colorsSampling,\r\n            colorMode: this.colorMode,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this.dashOffset,\r\n            dashRatio: this.dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this.useColors,\r\n            useDash: this.useDash,\r\n            visibility: this.visibility,\r\n            width: this.width,\r\n        };\r\n\r\n        if (this._colors) {\r\n            greasedLineMaterialOptions.colors = this._colors;\r\n        }\r\n        if (this._color) {\r\n            greasedLineMaterialOptions.color = this._color;\r\n        }\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param rootUrl root url for textures\r\n     */\r\n    public override parse(source: any, scene: Scene, rootUrl: string): void {\r\n        super.parse(source, scene, rootUrl);\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this.colorsTexture?.dispose();\r\n\r\n        if (greasedLineMaterialOptions.color) {\r\n            this.setColor(greasedLineMaterialOptions.color, true);\r\n        }\r\n        if (greasedLineMaterialOptions.colorDistributionType) {\r\n            this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;\r\n        }\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this.colors = greasedLineMaterialOptions.colors;\r\n        }\r\n        if (greasedLineMaterialOptions.colorsSampling) {\r\n            this.colorsSampling = greasedLineMaterialOptions.colorsSampling;\r\n        }\r\n        if (greasedLineMaterialOptions.colorMode) {\r\n            this.colorMode = greasedLineMaterialOptions.colorMode;\r\n        }\r\n        if (greasedLineMaterialOptions.useColors) {\r\n            this.useColors = greasedLineMaterialOptions.useColors;\r\n        }\r\n        if (greasedLineMaterialOptions.visibility) {\r\n            this.visibility = greasedLineMaterialOptions.visibility;\r\n        }\r\n        if (greasedLineMaterialOptions.useDash) {\r\n            this.useDash = greasedLineMaterialOptions.useDash;\r\n        }\r\n        if (greasedLineMaterialOptions.dashCount) {\r\n            this.dashCount = greasedLineMaterialOptions.dashCount;\r\n        }\r\n        if (greasedLineMaterialOptions.dashRatio) {\r\n            this.dashRatio = greasedLineMaterialOptions.dashRatio;\r\n        }\r\n        if (greasedLineMaterialOptions.dashOffset) {\r\n            this.dashOffset = greasedLineMaterialOptions.dashOffset;\r\n        }\r\n        if (greasedLineMaterialOptions.width) {\r\n            this.width = greasedLineMaterialOptions.width;\r\n        }\r\n        if (greasedLineMaterialOptions.sizeAttenuation) {\r\n            this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;\r\n        }\r\n        if (greasedLineMaterialOptions.resolution) {\r\n            this.resolution = greasedLineMaterialOptions.resolution;\r\n        }\r\n        if (this.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);\r\n        } else {\r\n            GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current configuration into another one.\r\n     * @param plugin define the config where to copy the info\r\n     */\r\n    public override copyTo(plugin: MaterialPluginBase): void {\r\n        const dest = plugin as GreasedLinePluginMaterial;\r\n\r\n        dest.colorsTexture?.dispose();\r\n\r\n        if (this._colors) {\r\n            dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);\r\n        }\r\n\r\n        dest.setColor(this.color, true);\r\n        dest.colorsDistributionType = this.colorsDistributionType;\r\n        dest.colorsSampling = this.colorsSampling;\r\n        dest.colorMode = this.colorMode;\r\n        dest.useColors = this.useColors;\r\n        dest.visibility = this.visibility;\r\n        dest.useDash = this.useDash;\r\n        dest.dashCount = this.dashCount;\r\n        dest.dashRatio = this.dashRatio;\r\n        dest.dashOffset = this.dashOffset;\r\n        dest.width = this.width;\r\n        dest.sizeAttenuation = this.sizeAttenuation;\r\n        dest.resolution = this.resolution;\r\n\r\n        dest.markAllDefinesAsDirty();\r\n    }\r\n\r\n    private _isGLSL(shaderLanguage: ShaderLanguage) {\r\n        return shaderLanguage === ShaderLanguage.GLSL || this._forceGLSL;\r\n    }\r\n}\r\n\r\nRegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);\r\n", "import type { Scene } from \"../../scene\";\r\nimport { RawTexture } from \"../Textures/rawTexture\";\r\nimport { ShaderMaterial } from \"../shaderMaterial\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Vector2 } from \"../../Maths/math.vector\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { TextureSampler } from \"../Textures/textureSampler\";\r\n\r\nimport type { GreasedLineMaterialOptions, IGreasedLineMaterial } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineMeshColorDistributionType, GreasedLineMeshColorMode } from \"./greasedLineMaterialInterfaces\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\nimport { GreasedLineMaterialDefaults } from \"./greasedLineMaterialDefaults\";\r\n\r\nexport const GreasedLineUseOffsetsSimpleMaterialDefine = \"GREASED_LINE_USE_OFFSETS\";\r\n\r\n/**\r\n * GreasedLineSimpleMaterial\r\n */\r\nexport class GreasedLineSimpleMaterial extends ShaderMaterial implements IGreasedLineMaterial {\r\n    /**\r\n     * Force to use GLSL in WebGPU\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    private _visibility: number;\r\n    private _width: number;\r\n    private _useDash: boolean;\r\n    private _dashCount: number;\r\n    private _dashArray: number;\r\n    private _dashRatio: number;\r\n    private _dashOffset: number;\r\n    private _useColors: boolean;\r\n    private _color: Color3 = Color3.White();\r\n    private _colors: Nullable<Color3[]>;\r\n    private _colorsDistributionType: GreasedLineMeshColorDistributionType = GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n    private _colorMode: GreasedLineMeshColorMode;\r\n    private _colorsSampling: number;\r\n    private _resolution: Vector2;\r\n    private _sizeAttenuation: boolean;\r\n    private _colorsTexture: Nullable<RawTexture> = null;\r\n    private _cameraFacing: boolean;\r\n\r\n    /**\r\n     * GreasedLineSimple material constructor\r\n     * @param name material name\r\n     * @param scene the scene\r\n     * @param options material options\r\n     */\r\n    constructor(name: string, scene: Scene, options: GreasedLineMaterialOptions) {\r\n        const engine = scene.getEngine();\r\n        const isWGSL = engine.isWebGPU && !(options.forceGLSL || GreasedLineSimpleMaterial.ForceGLSL);\r\n\r\n        const defines = [\r\n            `COLOR_DISTRIBUTION_TYPE_LINE ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_LINE}.`,\r\n            `COLOR_DISTRIBUTION_TYPE_SEGMENT ${GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT}.`,\r\n            `COLOR_MODE_SET ${GreasedLineMeshColorMode.COLOR_MODE_SET}.`,\r\n            `COLOR_MODE_ADD ${GreasedLineMeshColorMode.COLOR_MODE_ADD}.`,\r\n            `COLOR_MODE_MULTIPLY ${GreasedLineMeshColorMode.COLOR_MODE_MULTIPLY}.`,\r\n        ];\r\n        if (scene.useRightHandedSystem) {\r\n            defines.push(\"GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\");\r\n        }\r\n\r\n        const attributes = [\"position\", \"grl_widths\", \"grl_offsets\", \"grl_colorPointers\"];\r\n\r\n        if (options.cameraFacing) {\r\n            defines.push(\"GREASED_LINE_CAMERA_FACING\");\r\n            attributes.push(\"grl_previousAndSide\", \"grl_nextAndCounters\");\r\n        } else {\r\n            attributes.push(\"grl_slopes\");\r\n            attributes.push(\"grl_counters\");\r\n        }\r\n\r\n        const uniforms = [\r\n            \"grlColorsWidth\",\r\n            \"grlUseColors\",\r\n            \"grlWidth\",\r\n            \"grlColor\",\r\n            \"grl_colorModeAndColorDistributionType\",\r\n            \"grlResolution\",\r\n            \"grlAspect\",\r\n            \"grlAizeAttenuation\",\r\n            \"grlDashArray\",\r\n            \"grlDashOffset\",\r\n            \"grlDashRatio\",\r\n            \"grlUseDash\",\r\n            \"grlVisibility\",\r\n            \"grlColors\",\r\n        ];\r\n\r\n        if (!isWGSL) {\r\n            uniforms.push(\"world\", \"viewProjection\", \"view\", \"projection\");\r\n        }\r\n\r\n        super(\r\n            name,\r\n            scene,\r\n            {\r\n                vertex: \"greasedLine\",\r\n                fragment: \"greasedLine\",\r\n            },\r\n            {\r\n                uniformBuffers: isWGSL ? [\"Scene\", \"Mesh\"] : undefined,\r\n                attributes,\r\n                uniforms,\r\n                samplers: isWGSL ? [] : [\"grlColors\"],\r\n                defines,\r\n                extraInitializationsAsync: async () => {\r\n                    if (isWGSL) {\r\n                        await Promise.all([import(\"../../ShadersWGSL/greasedLine.vertex\"), import(\"../../ShadersWGSL/greasedLine.fragment\")]);\r\n                    } else {\r\n                        await Promise.all([import(\"../../Shaders/greasedLine.vertex\"), import(\"../../Shaders/greasedLine.fragment\")]);\r\n                    }\r\n                },\r\n                shaderLanguage: isWGSL ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n            }\r\n        );\r\n\r\n        options = options || {\r\n            color: GreasedLineMaterialDefaults.DEFAULT_COLOR,\r\n        };\r\n\r\n        this.visibility = options.visibility ?? 1;\r\n        this.useDash = options.useDash ?? false;\r\n        this.dashRatio = options.dashRatio ?? 0.5;\r\n        this.dashOffset = options.dashOffset ?? 0;\r\n        this.dashCount = options.dashCount ?? 1; // calculate the _dashArray value, call the setter\r\n        this.width = options.width\r\n            ? options.width\r\n            : options.sizeAttenuation && options.cameraFacing\r\n              ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED\r\n              : GreasedLineMaterialDefaults.DEFAULT_WIDTH;\r\n        this.sizeAttenuation = options.sizeAttenuation ?? false;\r\n        this.color = options.color ?? Color3.White();\r\n        this.useColors = options.useColors ?? false;\r\n        this.colorsDistributionType = options.colorDistributionType ?? GreasedLineMeshColorDistributionType.COLOR_DISTRIBUTION_TYPE_SEGMENT;\r\n        this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;\r\n        this.colorMode = options.colorMode ?? GreasedLineMeshColorMode.COLOR_MODE_SET;\r\n        this._colors = options.colors ?? null;\r\n        this._cameraFacing = options.cameraFacing ?? true;\r\n        this.resolution = options.resolution ?? new Vector2(engine.getRenderWidth(), engine.getRenderHeight()); // calculate aspect call the setter\r\n\r\n        if (options.colorsTexture) {\r\n            this.colorsTexture = options.colorsTexture;\r\n        } else {\r\n            if (this._colors) {\r\n                this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, this._colors, this.colorsSampling, scene);\r\n            } else {\r\n                this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n                this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n            }\r\n        }\r\n\r\n        if (isWGSL) {\r\n            const sampler = new TextureSampler();\r\n            sampler.setParameters(); // use the default values\r\n            sampler.samplingMode = this.colorsSampling;\r\n            this.setTextureSampler(\"grlColorsSampler\", sampler);\r\n        }\r\n\r\n        engine.onDisposeObservable.add(() => {\r\n            GreasedLineTools.DisposeEmptyColorsTexture();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Disposes the plugin material.\r\n     */\r\n    public override dispose(): void {\r\n        this._colorsTexture?.dispose();\r\n        super.dispose();\r\n    }\r\n\r\n    private _setColorModeAndColorDistributionType() {\r\n        this.setVector2(\"grl_colorModeAndColorDistributionType\", new Vector2(this._colorMode, this._colorsDistributionType));\r\n    }\r\n\r\n    /**\r\n     * Updates the material. Use when material created in lazy mode.\r\n     */\r\n    public updateLazy() {\r\n        if (this._colors) {\r\n            this.setColors(this._colors, false, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the colors used to colorize the line\r\n     */\r\n    get colors() {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Sets the colors used to colorize the line\r\n     */\r\n    set colors(value: Nullable<Color3[]>) {\r\n        this.setColors(value);\r\n    }\r\n\r\n    /**\r\n     * Creates or updates the colors texture\r\n     * @param colors color table RGBA\r\n     * @param lazy if lazy, the colors are not updated\r\n     * @param forceNewTexture force creation of a new texture\r\n     */\r\n    public setColors(colors: Nullable<Color3[]>, lazy = false, forceNewTexture = false): void {\r\n        const origColorsCount = this._colors?.length ?? 0;\r\n\r\n        this._colors = colors;\r\n\r\n        if (colors === null || colors.length === 0) {\r\n            this._colorsTexture?.dispose();\r\n            return;\r\n        }\r\n\r\n        if (lazy && !forceNewTexture) {\r\n            return;\r\n        }\r\n\r\n        if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {\r\n            const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);\r\n            this._colorsTexture.update(colorArray);\r\n        } else {\r\n            this._colorsTexture?.dispose();\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the colors texture\r\n     */\r\n    get colorsTexture() {\r\n        return (this._colorsTexture as RawTexture) ?? null;\r\n    }\r\n\r\n    /**\r\n     * Sets the colorsTexture\r\n     */\r\n    set colorsTexture(value: RawTexture) {\r\n        this._colorsTexture = value;\r\n        this.setFloat(\"grlColorsWidth\", this._colorsTexture.getSize().width);\r\n        this.setTexture(\"grlColors\", this._colorsTexture);\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    get width() {\r\n        return this._width;\r\n    }\r\n\r\n    /**\r\n     * Line base width. At each point the line width is calculated by widths[pointIndex] * width\r\n     */\r\n    set width(value: number) {\r\n        this._width = value;\r\n        this.setFloat(\"grlWidth\", value);\r\n    }\r\n\r\n    /**\r\n     * Whether to use the colors option to colorize the line\r\n     */\r\n    get useColors() {\r\n        return this._useColors;\r\n    }\r\n\r\n    set useColors(value: boolean) {\r\n        this._useColors = value;\r\n        this.setFloat(\"grlUseColors\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    get colorsSampling() {\r\n        return this._colorsSampling;\r\n    }\r\n\r\n    /**\r\n     * The type of sampling of the colors texture. The values are the same when using with textures.\r\n     */\r\n    set colorsSampling(value: number) {\r\n        this._colorsSampling = value;\r\n    }\r\n\r\n    /**\r\n     * Normalized value of how much of the line will be visible\r\n     * 0 - 0% of the line will be visible\r\n     * 1 - 100% of the line will be visible\r\n     */\r\n    get visibility() {\r\n        return this._visibility;\r\n    }\r\n\r\n    set visibility(value: number) {\r\n        this._visibility = value;\r\n        this.setFloat(\"grlVisibility\", value);\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    get useDash() {\r\n        return this._useDash;\r\n    }\r\n\r\n    /**\r\n     * Turns on/off dash mode\r\n     */\r\n    set useDash(value: boolean) {\r\n        this._useDash = value;\r\n        this.setFloat(\"grlUseDash\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the dash offset\r\n     */\r\n    get dashOffset() {\r\n        return this._dashOffset;\r\n    }\r\n\r\n    /**\r\n     * Sets the dash offset\r\n     */\r\n    set dashOffset(value: number) {\r\n        this._dashOffset = value;\r\n        this.setFloat(\"grlDashOffset\", value);\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    get dashRatio() {\r\n        return this._dashRatio;\r\n    }\r\n\r\n    /**\r\n     * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.\r\n     */\r\n    set dashRatio(value: number) {\r\n        this._dashRatio = value;\r\n        this.setFloat(\"grlDashRatio\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the number of dashes in the line\r\n     */\r\n    get dashCount() {\r\n        return this._dashCount;\r\n    }\r\n    /**\r\n     * Sets the number of dashes in the line\r\n     * @param value dash\r\n     */\r\n    set dashCount(value: number) {\r\n        this._dashCount = value;\r\n        this._dashArray = 1 / value;\r\n        this.setFloat(\"grlDashArray\", this._dashArray);\r\n    }\r\n\r\n    /**\r\n     * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    get sizeAttenuation() {\r\n        return this._sizeAttenuation;\r\n    }\r\n\r\n    /**\r\n     * Turn on/off attenuation of the width option and widths array.\r\n     * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines\r\n     */\r\n    set sizeAttenuation(value: boolean) {\r\n        this._sizeAttenuation = value;\r\n        this.setFloat(\"grlSizeAttenuation\", GreasedLineTools.BooleanToNumber(value));\r\n    }\r\n\r\n    /**\r\n     * Gets the color of the line\r\n     */\r\n    get color() {\r\n        return this._color;\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line\r\n     * @param value Color3\r\n     */\r\n    set color(value: Color3) {\r\n        this.setColor(value);\r\n    }\r\n\r\n    /**\r\n     * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.\r\n     * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).\r\n     * @param value color\r\n     */\r\n    public setColor(value: Nullable<Color3>) {\r\n        value = value ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;\r\n        this._color = value;\r\n        this.setColor3(\"grlColor\", value);\r\n    }\r\n\r\n    /**\r\n     * Gets the color distributiopn type\r\n     */\r\n    get colorsDistributionType() {\r\n        return this._colorsDistributionType;\r\n    }\r\n\r\n    /**\r\n     * Sets the color distribution type\r\n     * @see GreasedLineMeshColorDistributionType\r\n     * @param value color distribution type\r\n     */\r\n    set colorsDistributionType(value: GreasedLineMeshColorDistributionType) {\r\n        this._colorsDistributionType = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    get colorMode() {\r\n        return this._colorMode;\r\n    }\r\n\r\n    /**\r\n     * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.\r\n     * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.\r\n     * @see GreasedLineMeshColorMode\r\n     */\r\n    set colorMode(value: GreasedLineMeshColorMode) {\r\n        this._colorMode = value;\r\n        this._setColorModeAndColorDistributionType();\r\n    }\r\n\r\n    /**\r\n     * Gets the resolution\r\n     */\r\n    get resolution() {\r\n        return this._resolution;\r\n    }\r\n\r\n    /**\r\n     * Sets the resolution\r\n     * @param value resolution of the screen for GreasedLine\r\n     */\r\n    set resolution(value: Vector2) {\r\n        this._resolution = value;\r\n        this.setVector2(\"grlResolution\", value);\r\n        this.setFloat(\"grlAspect\", value.x / value.y);\r\n    }\r\n\r\n    /**\r\n     * Serializes this plugin material\r\n     * @returns serializationObjec\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n\r\n        const greasedLineMaterialOptions: GreasedLineMaterialOptions = {\r\n            colorDistributionType: this._colorsDistributionType,\r\n            colorsSampling: this._colorsSampling,\r\n            colorMode: this._colorMode,\r\n            color: this._color,\r\n            dashCount: this._dashCount,\r\n            dashOffset: this._dashOffset,\r\n            dashRatio: this._dashRatio,\r\n            resolution: this._resolution,\r\n            sizeAttenuation: this._sizeAttenuation,\r\n            useColors: this._useColors,\r\n            useDash: this._useDash,\r\n            visibility: this._visibility,\r\n            width: this._width,\r\n            cameraFacing: this._cameraFacing,\r\n        };\r\n\r\n        if (this._colors) {\r\n            greasedLineMaterialOptions.colors = this._colors;\r\n        }\r\n\r\n        serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized objects\r\n     * @param source serialized object\r\n     * @param scene scene\r\n     * @param _rootUrl root url for textures\r\n     */\r\n    public parse(source: any, scene: Scene, _rootUrl: string): void {\r\n        const greasedLineMaterialOptions = <GreasedLineMaterialOptions>source.greasedLineMaterialOptions;\r\n\r\n        this._colorsTexture?.dispose();\r\n\r\n        if (greasedLineMaterialOptions.color) {\r\n            this.color = greasedLineMaterialOptions.color;\r\n        }\r\n        if (greasedLineMaterialOptions.colorDistributionType) {\r\n            this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;\r\n        }\r\n        if (greasedLineMaterialOptions.colorsSampling) {\r\n            this.colorsSampling = greasedLineMaterialOptions.colorsSampling;\r\n        }\r\n        if (greasedLineMaterialOptions.colorMode) {\r\n            this.colorMode = greasedLineMaterialOptions.colorMode;\r\n        }\r\n        if (greasedLineMaterialOptions.useColors) {\r\n            this.useColors = greasedLineMaterialOptions.useColors;\r\n        }\r\n        if (greasedLineMaterialOptions.visibility) {\r\n            this.visibility = greasedLineMaterialOptions.visibility;\r\n        }\r\n        if (greasedLineMaterialOptions.useDash) {\r\n            this.useDash = greasedLineMaterialOptions.useDash;\r\n        }\r\n        if (greasedLineMaterialOptions.dashCount) {\r\n            this.dashCount = greasedLineMaterialOptions.dashCount;\r\n        }\r\n        if (greasedLineMaterialOptions.dashRatio) {\r\n            this.dashRatio = greasedLineMaterialOptions.dashRatio;\r\n        }\r\n        if (greasedLineMaterialOptions.dashOffset) {\r\n            this.dashOffset = greasedLineMaterialOptions.dashOffset;\r\n        }\r\n        if (greasedLineMaterialOptions.width) {\r\n            this.width = greasedLineMaterialOptions.width;\r\n        }\r\n        if (greasedLineMaterialOptions.sizeAttenuation) {\r\n            this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;\r\n        }\r\n        if (greasedLineMaterialOptions.resolution) {\r\n            this.resolution = greasedLineMaterialOptions.resolution;\r\n        }\r\n        if (greasedLineMaterialOptions.colors) {\r\n            this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());\r\n        } else {\r\n            this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);\r\n        }\r\n\r\n        this._cameraFacing = greasedLineMaterialOptions.cameraFacing ?? true;\r\n        this.setDefine(\"GREASED_LINE_CAMERA_FACING\", this._cameraFacing);\r\n    }\r\n}\r\n", "import { _IsConfigurationAvailable, DracoCodec, type IDracoCodecConfiguration } from \"./dracoCodec\";\r\nimport type { EncoderMessage, IDracoAttributeData, IDracoEncodedMeshData, IDracoEncoderOptions, DracoAttributeName } from \"./dracoEncoder.types\";\r\nimport { EncodeMesh, EncoderWorkerFunction } from \"./dracoCompressionWorker\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport { VertexBuffer } from \"../buffer\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Mesh } from \"../mesh\";\r\nimport type { Geometry } from \"../geometry\";\r\nimport { Logger } from \"../../Misc/logger\";\r\nimport { deepMerge } from \"../../Misc/deepMerger\";\r\nimport type { EncoderModule } from \"draco3d\";\r\nimport { AreIndices32Bits, GetTypedArrayData } from \"core/Buffers/bufferUtils\";\r\n\r\n// Missing type from types/draco3d. Do not use in public scope; UMD tests will fail because of EncoderModule.\r\ntype DracoEncoderModule = (props: { wasmBinary?: ArrayBuffer }) => Promise<EncoderModule>;\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoEncoderModule: DracoEncoderModule;\r\n\r\n/**\r\n * Map the Babylon.js attribute kind to the Draco attribute kind, defined by the `GeometryAttributeType` enum.\r\n * @internal\r\n */\r\nfunction GetDracoAttributeName(kind: string): DracoAttributeName {\r\n    if (kind === VertexBuffer.PositionKind) {\r\n        return \"POSITION\";\r\n    } else if (kind === VertexBuffer.NormalKind) {\r\n        return \"NORMAL\";\r\n    } else if (kind === VertexBuffer.ColorKind) {\r\n        return \"COLOR\";\r\n    } else if (kind.startsWith(VertexBuffer.UVKind)) {\r\n        return \"TEX_COORD\";\r\n    }\r\n    return \"GENERIC\";\r\n}\r\n\r\n/**\r\n * Get the indices for the geometry, if present. Eventually used as\r\n * `AddFacesToMesh(mesh: Mesh, numFaces: number, faces: Uint16Array | Uint32Array)`;\r\n * where `numFaces = indices.length / 3` and `faces = indices`.\r\n * @internal\r\n */\r\nfunction PrepareIndicesForDraco(input: Mesh | Geometry): Nullable<Uint32Array | Uint16Array> {\r\n    let indices = input.getIndices(undefined, true);\r\n\r\n    // Convert number[] and Int32Array types, if needed\r\n    if (indices && !(indices instanceof Uint32Array) && !(indices instanceof Uint16Array)) {\r\n        indices = (AreIndices32Bits(indices, indices.length) ? Uint32Array : Uint16Array).from(indices);\r\n    }\r\n\r\n    return indices;\r\n}\r\n\r\n/**\r\n * Get relevant information about the geometry's vertex attributes for Draco encoding. Eventually used for each attribute as\r\n * `AddFloatAttribute(mesh: Mesh, attribute: number, count: number, itemSize: number, array: TypedArray)`\r\n * where `attribute = EncoderModule[<dracoAttribute>]`, `itemSize = <size>`, `array = <data>`, and count is the number of position vertices.\r\n * @internal\r\n */\r\nfunction PrepareAttributesForDraco(input: Mesh | Geometry, excludedAttributes?: string[]): Array<IDracoAttributeData> {\r\n    const attributes: Array<IDracoAttributeData> = [];\r\n\r\n    for (const kind of input.getVerticesDataKinds()) {\r\n        if (excludedAttributes?.includes(kind)) {\r\n            if (kind === VertexBuffer.PositionKind) {\r\n                throw new Error(\"Cannot exclude position attribute from Draco encoding.\");\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // Convert number[] to typed array, if needed.\r\n        const vertexBuffer = input.getVertexBuffer(kind)!;\r\n        const size = vertexBuffer.getSize();\r\n        const data = GetTypedArrayData(vertexBuffer.getData()!, size, vertexBuffer.type, vertexBuffer.byteOffset, vertexBuffer.byteStride, input.getTotalVertices(), true);\r\n        attributes.push({ kind: kind, dracoName: GetDracoAttributeName(kind), size: size, data: data });\r\n    }\r\n\r\n    return attributes;\r\n}\r\n\r\nconst DefaultEncoderOptions: IDracoEncoderOptions = {\r\n    decodeSpeed: 5,\r\n    encodeSpeed: 5,\r\n    method: \"MESH_EDGEBREAKER_ENCODING\",\r\n    quantizationBits: {\r\n        POSITION: 14,\r\n        NORMAL: 10,\r\n        COLOR: 8,\r\n        TEX_COORD: 12,\r\n        GENERIC: 12,\r\n    },\r\n};\r\n\r\n/**\r\n * @experimental This class is subject to change.\r\n *\r\n * Draco Encoder (https://google.github.io/draco/)\r\n *\r\n * This class wraps the Draco encoder module.\r\n *\r\n * By default, the configuration points to a copy of the Draco encoder files from the Babylon.js cdn https://cdn.babylonjs.com/draco_encoder_wasm_wrapper.js.\r\n *\r\n * To update the configuration, use the following code:\r\n * ```javascript\r\n *     DracoEncoder.DefaultConfiguration = {\r\n *          wasmUrl: \"<url to the WebAssembly library>\",\r\n *          wasmBinaryUrl: \"<url to the WebAssembly binary>\",\r\n *          fallbackUrl: \"<url to the fallback JavaScript library>\",\r\n *     };\r\n * ```\r\n *\r\n * Draco has two versions, one for WebAssembly and one for JavaScript. The encoder configuration can be set to only support WebAssembly or only support the JavaScript version.\r\n * Decoding will automatically fallback to the JavaScript version if WebAssembly version is not configured or if WebAssembly is not supported by the browser.\r\n * Use `DracoEncoder.DefaultAvailable` to determine if the encoder configuration is available for the current context.\r\n *\r\n * To encode Draco compressed data, get the default DracoEncoder object and call encodeMeshAsync:\r\n * ```javascript\r\n *     var dracoData = await DracoEncoder.Default.encodeMeshAsync(mesh);\r\n * ```\r\n *\r\n * Currently, DracoEncoder only encodes to meshes. Encoding to point clouds is not yet supported.\r\n *\r\n * Only position, normal, color, and UV attributes are supported natively by the encoder. All other attributes are treated as generic. This means that,\r\n * when decoding these generic attributes later, additional information about their original Babylon types will be needed to interpret the data correctly.\r\n * You can use the return value of `encodeMeshAsync` to source this information, specifically the `attributes` field. E.g.,\r\n * ```javascript\r\n *    var dracoData = await DracoEncoder.Default.encodeMeshAsync(mesh);\r\n *    var meshData = await DracoDecoder.Default.decodeMeshToMeshDataAsync(dracoData.data, dracoData.attributes);\r\n * ```\r\n *\r\n * By default, DracoEncoder will encode all available attributes of the mesh. To exclude specific attributes, use the following code:\r\n * ```javascript\r\n *    var options = { excludedAttributes: [VertexBuffer.MatricesIndicesKind, VertexBuffer.MatricesWeightsKind] };\r\n *    var dracoData = await DracoDecoder.Default.encodeMeshAsync(mesh, options);\r\n * ```\r\n */\r\nexport class DracoEncoder extends DracoCodec {\r\n    /**\r\n     * Default configuration for the DracoEncoder. Defaults to the following:\r\n     * - numWorkers: 50% of the available logical processors, capped to 4. If no logical processors are available, defaults to 1.\r\n     * - wasmUrl: `\"https://cdn.babylonjs.com/draco_encoder_wasm_wrapper.js\"`\r\n     * - wasmBinaryUrl: `\"https://cdn.babylonjs.com/draco_encoder.wasm\"`\r\n     * - fallbackUrl: `\"https://cdn.babylonjs.com/draco_encoder.js\"`\r\n     */\r\n    public static DefaultConfiguration: IDracoCodecConfiguration = {\r\n        wasmUrl: `${Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,\r\n        wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_encoder.wasm`,\r\n        fallbackUrl: `${Tools._DefaultCdnUrl}/draco_encoder.js`,\r\n    };\r\n\r\n    /**\r\n     * Returns true if the encoder's `DefaultConfiguration` is available.\r\n     */\r\n    public static get DefaultAvailable(): boolean {\r\n        return _IsConfigurationAvailable(DracoEncoder.DefaultConfiguration);\r\n    }\r\n\r\n    protected static _Default: Nullable<DracoEncoder> = null;\r\n    /**\r\n     * Default instance for the DracoEncoder.\r\n     */\r\n    public static get Default(): DracoEncoder {\r\n        DracoEncoder._Default ??= new DracoEncoder();\r\n        return DracoEncoder._Default;\r\n    }\r\n\r\n    /**\r\n     * Reset the default DracoEncoder object to null and disposing the removed default instance.\r\n     * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,\r\n     * unless the static worker pool is no longer needed.\r\n     * @param skipDispose set to true to not dispose the removed default instance\r\n     */\r\n    public static ResetDefault(skipDispose?: boolean): void {\r\n        if (DracoEncoder._Default) {\r\n            if (!skipDispose) {\r\n                DracoEncoder._Default.dispose();\r\n            }\r\n            DracoEncoder._Default = null;\r\n        }\r\n    }\r\n\r\n    protected override _isModuleAvailable(): boolean {\r\n        return typeof DracoEncoderModule !== \"undefined\";\r\n    }\r\n\r\n    protected override async _createModuleAsync(wasmBinary?: ArrayBuffer, jsModule?: unknown /** DracoEncoderModule */): Promise<{ module: unknown /** EncoderModule */ }> {\r\n        const module = await ((jsModule as DracoEncoderModule) || DracoEncoderModule)({ wasmBinary });\r\n        return { module };\r\n    }\r\n\r\n    protected override _getWorkerContent(): string {\r\n        return `${EncodeMesh}(${EncoderWorkerFunction})()`;\r\n    }\r\n\r\n    /**\r\n     * Creates a new Draco encoder.\r\n     * @param configuration Optional override of the configuration for the DracoEncoder. If not provided, defaults to {@link DracoEncoder.DefaultConfiguration}.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration = DracoEncoder.DefaultConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async _encodeAsync(\r\n        attributes: Array<IDracoAttributeData>,\r\n        indices: Nullable<Uint16Array | Uint32Array>,\r\n        options?: IDracoEncoderOptions\r\n    ): Promise<Nullable<IDracoEncodedMeshData>> {\r\n        const mergedOptions = options ? deepMerge(DefaultEncoderOptions, options) : DefaultEncoderOptions;\r\n\r\n        if (this._workerPoolPromise) {\r\n            const workerPool = await this._workerPoolPromise;\r\n            return await new Promise<Nullable<IDracoEncodedMeshData>>((resolve, reject) => {\r\n                workerPool.push((worker, onComplete) => {\r\n                    const onError = (error: ErrorEvent) => {\r\n                        worker.removeEventListener(\"error\", onError);\r\n                        worker.removeEventListener(\"message\", onMessage);\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(error);\r\n                        onComplete();\r\n                    };\r\n\r\n                    const onMessage = (message: MessageEvent<EncoderMessage>) => {\r\n                        if (message.data.id === \"encodeMeshDone\") {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(message.data.encodedMeshData);\r\n                            onComplete();\r\n                        }\r\n                    };\r\n\r\n                    worker.addEventListener(\"error\", onError);\r\n                    worker.addEventListener(\"message\", onMessage);\r\n\r\n                    // Build the transfer list. No need to copy, as the data was copied in previous steps.\r\n                    const transferList = [];\r\n                    for (const attribute of attributes) {\r\n                        transferList.push(attribute.data.buffer);\r\n                    }\r\n                    if (indices) {\r\n                        transferList.push(indices.buffer);\r\n                    }\r\n\r\n                    worker.postMessage({ id: \"encodeMesh\", attributes: attributes, indices: indices, options: mergedOptions }, transferList);\r\n                });\r\n            });\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            const encoder = await this._modulePromise;\r\n            return EncodeMesh(encoder.module, attributes, indices, mergedOptions);\r\n        }\r\n\r\n        throw new Error(\"Draco encoder module is not available\");\r\n    }\r\n\r\n    /**\r\n     * Encodes a mesh or geometry into a Draco-encoded mesh data.\r\n     * @param input the mesh or geometry to encode\r\n     * @param options options for the encoding\r\n     * @returns a promise that resolves to the newly-encoded data\r\n     */\r\n    public async encodeMeshAsync(input: Mesh | Geometry, options?: IDracoEncoderOptions): Promise<Nullable<IDracoEncodedMeshData>> {\r\n        const verticesCount = input.getTotalVertices();\r\n        if (verticesCount == 0) {\r\n            throw new Error(\"Cannot compress geometry with Draco. There are no vertices.\");\r\n        }\r\n\r\n        // Prepare parameters for encoding\r\n        if (input instanceof Mesh && input.morphTargetManager && options?.method === \"MESH_EDGEBREAKER_ENCODING\") {\r\n            Logger.Warn(\"Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method.\");\r\n            options.method = \"MESH_SEQUENTIAL_ENCODING\";\r\n        }\r\n\r\n        const indices = PrepareIndicesForDraco(input);\r\n        const attributes = PrepareAttributesForDraco(input, options?.excludedAttributes);\r\n\r\n        return await this._encodeAsync(attributes, indices, options);\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport type { IGreasedLineMaterial } from \"../../Materials/GreasedLine/greasedLineMaterialInterfaces\";\r\nimport { GreasedLinePluginMaterial } from \"../../Materials/GreasedLine/greasedLinePluginMaterial\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { Buffer } from \"../../Buffers/buffer\";\r\nimport type { Vector3 } from \"../../Maths/math.vector\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { DeepCopier } from \"../../Misc/deepCopier\";\r\nimport { GreasedLineSimpleMaterial, GreasedLineUseOffsetsSimpleMaterialDefine } from \"../../Materials/GreasedLine/greasedLineSimpleMaterial\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { FloatArray, IndicesArray } from \"../../types\";\r\nimport { GreasedLineTools } from \"../../Misc/greasedLineTools\";\r\n\r\n/**\r\n * In POINTS_MODE_POINTS every array of points will become the center (backbone) of the ribbon. The ribbon will be expanded by `width / 2` to `+direction` and `-direction` as well.\r\n * In POINTS_MODE_PATHS every array of points specifies an edge. These will be used to build one ribbon.\r\n */\r\nexport const enum GreasedLineRibbonPointsMode {\r\n    POINTS_MODE_POINTS = 0,\r\n    POINTS_MODE_PATHS = 1,\r\n}\r\n\r\n/**\r\n * FACES_MODE_SINGLE_SIDED single sided with back face culling. Default value.\r\n * FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING single sided without back face culling. Sets backFaceCulling = false on the material so it affects all line ribbons added to the line ribbon instance.\r\n * FACES_MODE_DOUBLE_SIDED extra back faces are created. This doubles the amount of faces of the mesh.\r\n */\r\nexport const enum GreasedLineRibbonFacesMode {\r\n    FACES_MODE_SINGLE_SIDED = 0,\r\n    FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = 1,\r\n    FACES_MODE_DOUBLE_SIDED = 2,\r\n}\r\n\r\n/**\r\n * Only with POINTS_MODE_PATHS.\r\n * AUTO_DIRECTIONS_FROM_FIRST_SEGMENT sets the direction (slope) of the ribbon from the direction of the first line segment. Recommended.\r\n * AUTO_DIRECTIONS_FROM_ALL_SEGMENTS in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments. Slow method.\r\n * AUTO_DIRECTIONS_ENHANCED in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments using a more sophisitcaed algorithm. Slowest method.\r\n * AUTO_DIRECTIONS_FACE_TO in this mode the direction (slope) will be calculated for each line segment according to the direction vector between each point of the line segments and a direction (face-to) vector specified in direction. The resulting line will face to the direction of this face-to vector.\r\n * AUTO_DIRECTIONS_NONE you have to set the direction (slope) manually. Recommended.\r\n */\r\nexport const enum GreasedLineRibbonAutoDirectionMode {\r\n    AUTO_DIRECTIONS_FROM_FIRST_SEGMENT = 0,\r\n    AUTO_DIRECTIONS_FROM_ALL_SEGMENTS = 1,\r\n    AUTO_DIRECTIONS_ENHANCED = 2,\r\n    AUTO_DIRECTIONS_FACE_TO = 3,\r\n    AUTO_DIRECTIONS_NONE = 99,\r\n}\r\n\r\nexport type GreasedLineRibbonOptions = {\r\n    /**\r\n     * Defines how the points are processed.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_POINTS every array of points will become the center of the ribbon. The ribbon will be expanded by width/2 to +direction and -direction as well.\r\n     * In GreasedLineRibbonPointsMode.POINTS_MODE_PATHS every array of points is one path. These will be used to buuid one ribbon.\r\n     */\r\n    pointsMode?: GreasedLineRibbonPointsMode;\r\n    /**\r\n     * Normalized directions of the slopes of the non camera facing lines.\r\n     */\r\n    directions?: Vector3[] | Vector3;\r\n    /**\r\n     * Defines the calculation mode of the directions which the line will be thickened to.\r\n     */\r\n    directionsAutoMode?: GreasedLineRibbonAutoDirectionMode;\r\n    /**\r\n     * Width of the ribbon.\r\n     */\r\n    width?: number;\r\n    /**\r\n     * Controls how the faces are created.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED = single sided with back face culling. Default value.\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING = single sided without back face culling\r\n     * GreasedLineRibbonFacesMode.FACES_MODE_DOUBLE_SIDED = extra back faces are created. This doubles the amount of faces of the mesh.\r\n     */\r\n    facesMode?: GreasedLineRibbonFacesMode;\r\n    /**\r\n     * If true, the path will be closed.\r\n     */\r\n    closePath?: boolean;\r\n    /**\r\n     * If true, normals will be computed when creating the vertex buffers.\r\n     * This results to smooth shading of the mesh.\r\n     */\r\n    smoothShading?: boolean;\r\n};\r\n\r\nexport type GreasedLinePoints = Vector3[] | Vector3[][] | Float32Array | Float32Array[] | number[][] | number[];\r\n\r\n/**\r\n * Options for converting the points to the internal number[][] format used by GreasedLine\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GreasedLinePointsOptions {\r\n    /**\r\n     * If defined and a Float32Array is used for the points parameter,\r\n     * it will create multiple disconnected lines.\r\n     * This parameter defines how many entries from the array to use for one line.\r\n     * One entry = 3 float values.\r\n     */\r\n    floatArrayStride?: number;\r\n}\r\n\r\n/**\r\n * Options for creating a GreasedLineMesh\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface GreasedLineMeshOptions {\r\n    /**\r\n     * Points of the line.\r\n     */\r\n    points: GreasedLinePoints;\r\n    /**\r\n     * Each line segment (from point to point) can have it's width multiplier. Final width = widths[segmentIdx] * width.\r\n     * Defaults to empty array.\r\n     */\r\n    widths?: number[];\r\n    /**\r\n     * If instance is specified, lines are added to the specified instance.\r\n     * Defaults to undefined.\r\n     */\r\n    instance?: GreasedLineBaseMesh;\r\n    /**\r\n     * You can manually set the color pointers so you can control which segment/part\r\n     * will use which color from the colors material option\r\n     */\r\n    colorPointers?: number[];\r\n    /**\r\n     * UVs for the mesh\r\n     */\r\n    uvs?: FloatArray;\r\n    /**\r\n     * If true, offsets and widths are updatable.\r\n     * Defaults to false.\r\n     */\r\n    updatable?: boolean;\r\n    /**\r\n     * Use when @see instance is specified.\r\n     * If true, the line will be rendered only after calling instance.updateLazy(). If false, line will be rerendered after every call to @see CreateGreasedLine\r\n     * Defaults to false.\r\n     */\r\n    lazy?: boolean;\r\n    /**\r\n     * The options for the ribbon which will be used as a line.\r\n     * If this option is set the line switches automatically to a non camera facing mode.\r\n     */\r\n    ribbonOptions?: GreasedLineRibbonOptions;\r\n    /**\r\n     * Options for converting the points.\r\n     */\r\n    pointsOptions?: GreasedLinePointsOptions;\r\n}\r\n\r\n/**\r\n * GreasedLineBaseMesh\r\n */\r\nexport abstract class GreasedLineBaseMesh extends Mesh {\r\n    protected _vertexPositions: FloatArray;\r\n    protected _indices: IndicesArray;\r\n    protected _uvs: FloatArray;\r\n    protected _points: number[][];\r\n    protected _offsets: number[];\r\n    protected _colorPointers: number[];\r\n    protected _widths: number[];\r\n\r\n    protected _offsetsBuffer?: Buffer;\r\n    protected _widthsBuffer?: Buffer;\r\n    protected _colorPointersBuffer?: Buffer;\r\n\r\n    protected _lazy = false;\r\n    protected _updatable = false;\r\n\r\n    protected _engine: AbstractEngine;\r\n\r\n    constructor(\r\n        public override readonly name: string,\r\n        scene: Scene,\r\n        protected _options: GreasedLineMeshOptions\r\n    ) {\r\n        super(name, scene, null, null, false, false);\r\n\r\n        this._engine = scene.getEngine();\r\n\r\n        this._lazy = _options.lazy ?? false;\r\n        this._updatable = _options.updatable ?? false;\r\n\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n        this._points = [];\r\n        this._colorPointers = _options.colorPointers ?? [];\r\n        this._widths = _options.widths ?? new Array(_options.points.length).fill(1);\r\n    }\r\n\r\n    /**\r\n     * \"GreasedLineMesh\"\r\n     * @returns \"GreasedLineMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GreasedLineMesh\";\r\n    }\r\n\r\n    protected abstract _setPoints(points: number[][], options?: GreasedLineMeshOptions): void;\r\n    protected abstract _updateColorPointers(): void;\r\n    protected abstract _updateWidths(): void;\r\n\r\n    protected _updateWidthsWithValue(defaulValue: number) {\r\n        let pointCount = 0;\r\n        for (const points of this._points) {\r\n            pointCount += points.length;\r\n        }\r\n        const countDiff = (pointCount / 3) * 2 - this._widths.length;\r\n        for (let i = 0; i < countDiff; i++) {\r\n            this._widths.push(defaulValue);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updated a lazy line. Rerenders the line and updates boundinfo as well.\r\n     */\r\n    public updateLazy() {\r\n        this._setPoints(this._points);\r\n        if (!this._options.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);\r\n        !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();\r\n\r\n        this.greasedLineMaterial?.updateLazy();\r\n    }\r\n\r\n    /**\r\n     * Adds new points to the line. It doesn't rerenders the line if in lazy mode.\r\n     * @param points points table\r\n     * @param options optional options\r\n     */\r\n    public addPoints(points: number[][], options?: GreasedLineMeshOptions) {\r\n        for (const p of points) {\r\n            this._points.push(p);\r\n        }\r\n\r\n        if (!this._lazy) {\r\n            this.setPoints(this._points, options);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose the line and it's resources\r\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\r\n     * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)\r\n     */\r\n    public override dispose(doNotRecurse?: boolean, disposeMaterialAndTextures = false) {\r\n        super.dispose(doNotRecurse, disposeMaterialAndTextures);\r\n    }\r\n\r\n    /**\r\n     * @returns true if the mesh was created in lazy mode\r\n     */\r\n    public isLazy(): boolean {\r\n        return this._lazy;\r\n    }\r\n\r\n    /**\r\n     * Returns the UVs\r\n     */\r\n    get uvs() {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Sets the UVs\r\n     * @param uvs the UVs\r\n     */\r\n    set uvs(uvs: FloatArray) {\r\n        this._uvs = uvs instanceof Float32Array ? uvs : new Float32Array(uvs);\r\n        this._createVertexBuffers();\r\n    }\r\n\r\n    /**\r\n     * Returns the points offsets\r\n     * Return the points offsets\r\n     */\r\n    get offsets() {\r\n        return this._offsets;\r\n    }\r\n\r\n    /**\r\n     * Sets point offests\r\n     * @param offsets offset table [x,y,z, x,y,z, ....]\r\n     */\r\n    set offsets(offsets: number[]) {\r\n        if (this.material instanceof GreasedLineSimpleMaterial) {\r\n            this.material.setDefine(GreasedLineUseOffsetsSimpleMaterialDefine, offsets?.length > 0);\r\n        }\r\n        this._offsets = offsets;\r\n        if (!this._offsetsBuffer) {\r\n            this._createOffsetsBuffer(offsets);\r\n        } else {\r\n            this._offsetsBuffer.update(offsets);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]\r\n     */\r\n    get widths() {\r\n        return this._widths;\r\n    }\r\n\r\n    /**\r\n     * Sets widths at each line point\r\n     * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]\r\n     */\r\n    set widths(widths: number[]) {\r\n        this._widths = widths;\r\n        if (!this._lazy) {\r\n            this._widthsBuffer && this._widthsBuffer.update(widths);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors\r\n     */\r\n    get colorPointers() {\r\n        return this._colorPointers;\r\n    }\r\n\r\n    /**\r\n     * Sets the color pointer\r\n     * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.\r\n     */\r\n    set colorPointers(colorPointers: number[]) {\r\n        this._colorPointers = colorPointers;\r\n        if (!this._lazy) {\r\n            this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the pluginMaterial associated with line\r\n     */\r\n    get greasedLineMaterial(): IGreasedLineMaterial | undefined {\r\n        if (this.material && this.material instanceof GreasedLineSimpleMaterial) {\r\n            return this.material;\r\n        }\r\n        const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);\r\n        if (materialPlugin) {\r\n            return <GreasedLinePluginMaterial>materialPlugin;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * Return copy the points.\r\n     */\r\n    get points() {\r\n        const pointsCopy: number[][] = [];\r\n        DeepCopier.DeepCopy(this._points, pointsCopy);\r\n        return pointsCopy;\r\n    }\r\n\r\n    /**\r\n     * Sets line points and rerenders the line.\r\n     * @param points points table\r\n     * @param options optional options\r\n     */\r\n    public setPoints(points: GreasedLinePoints, options?: GreasedLineMeshOptions) {\r\n        this._points = GreasedLineTools.ConvertPoints(points, options?.pointsOptions ?? this._options.pointsOptions);\r\n        this._updateWidths();\r\n        if (!options?.colorPointers) {\r\n            this._updateColorPointers();\r\n        }\r\n        this._setPoints(this._points, options);\r\n    }\r\n\r\n    protected _initGreasedLine() {\r\n        this._vertexPositions = [];\r\n        this._indices = [];\r\n        this._uvs = [];\r\n    }\r\n\r\n    protected _createLineOptions() {\r\n        const lineOptions: GreasedLineMeshOptions = {\r\n            points: this._points,\r\n            colorPointers: this._colorPointers,\r\n            lazy: this._lazy,\r\n            updatable: this._updatable,\r\n            uvs: this._uvs,\r\n            widths: this._widths,\r\n            ribbonOptions: this._options.ribbonOptions,\r\n        };\r\n        return lineOptions;\r\n    }\r\n\r\n    /**\r\n     * Serializes this GreasedLineMesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.type = this.getClassName();\r\n\r\n        serializationObject.lineOptions = this._createLineOptions();\r\n    }\r\n\r\n    protected _createVertexBuffers(computeNormals = false) {\r\n        const vertexData = new VertexData();\r\n        vertexData.positions = this._vertexPositions;\r\n        vertexData.indices = this._indices;\r\n        vertexData.uvs = this._uvs;\r\n        if (computeNormals) {\r\n            vertexData.normals = [];\r\n            VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);\r\n        }\r\n        vertexData.applyToMesh(this, this._options.updatable);\r\n        return vertexData;\r\n    }\r\n\r\n    protected _createOffsetsBuffer(offsets: number[]) {\r\n        const engine = this._scene.getEngine();\r\n\r\n        const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);\r\n        this.setVerticesBuffer(offsetBuffer.createVertexBuffer(\"grl_offsets\", 0, 3));\r\n        this._offsetsBuffer = offsetBuffer;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["material", "idx", "points", "array", "inputArray", "GetCustomCode", "GetCustomCode", "GreasedLineRibbonPointsMode", "GreasedLineRibbonFacesMode", "GreasedLineRibbonAutoDirectionMode"]
}
