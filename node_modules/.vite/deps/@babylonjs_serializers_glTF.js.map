{
  "version": 3,
  "sources": ["../../../dev/serializers/src/glTF/glTFFileExporter.ts", "../../../dev/serializers/src/glTF/2.0/glTFData.ts", "../../../dev/serializers/src/glTF/2.0/glTFMaterialExporter.ts", "../../../dev/serializers/src/exportUtils.ts", "../../../dev/serializers/src/glTF/2.0/glTFUtilities.ts", "../../../dev/serializers/src/glTF/2.0/dataWriter.ts", "../../../dev/serializers/src/glTF/2.0/bufferManager.ts", "../../../dev/serializers/src/glTF/2.0/glTFAnimation.ts", "../../../dev/serializers/src/glTF/2.0/glTFMorphTargetsUtilities.ts", "../../../dev/serializers/src/glTF/2.0/glTFExporter.ts", "../../../dev/serializers/src/glTF/2.0/glTFSerializer.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat_darkening.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat_ior.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat_color.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat_anisotropy.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_ior.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_specular.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_transmission.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_unlit.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_volume.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_diffuse_roughness.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_basisu.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/EXT_texture_webp.ts", "../../../dev/serializers/src/glTF/2.0/Extensions/EXT_texture_avif.ts"],
  "sourcesContent": ["/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @internal\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}\r\n", "import { GetMimeType } from \"core/Misc/fileTools\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    public readonly files: { [fileName: string]: string | Blob } = {};\r\n\r\n    /**\r\n     * @deprecated Use files instead\r\n     */\r\n    public get glTFFiles() {\r\n        return this.files;\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        for (const key in this.files) {\r\n            const value = this.files[key];\r\n            const blob = new Blob([value], { type: GetMimeType(key) });\r\n            Tools.Download(blob, key);\r\n        }\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable github/no-then */\r\n/* eslint-disable babylonjs/available */\r\n\r\nimport type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IImage } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { DeepImmutable, Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { GetTextureDataAsync, TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { GLTFExporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { SpecularPowerToRoughness } from \"core/Helpers/materialConversionHelper\";\r\nimport { InternalTextureSource } from \"core/Materials/Textures/internalTexture\";\r\nimport { GetMimeType } from \"core/Misc/fileTools\";\r\nimport type { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nconst Epsilon = 1e-6;\r\nconst DielectricSpecular = new Color3(0.04, 0.04, 0.04) as DeepImmutable<Color3>;\r\nconst MaxSpecularPower = 1024;\r\nconst White = Color3.White() as DeepImmutable<Color3>;\r\nconst Black = Color3.BlackReadOnly;\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\ninterface IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    specularColor: Color3;\r\n    glossiness: number;\r\n}\r\n\r\ninterface IPBRMetallicRoughness {\r\n    baseColor: Color3;\r\n    metallic: Nullable<number>;\r\n    roughness: Nullable<number>;\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction GetFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n        case ImageMimeType.AVIF:\r\n            return \".avif\";\r\n        case ImageMimeType.KTX2:\r\n            return \".ktx2\";\r\n    }\r\n}\r\n\r\n/**\r\n * Gets cached image from a texture, if available.\r\n * @param babylonTexture texture to check for cached image\r\n * @returns image data if found and directly usable; null otherwise\r\n */\r\nasync function GetCachedImageAsync(babylonTexture: BaseTexture): Promise<Nullable<{ data: ArrayBuffer; mimeType: string }>> {\r\n    const internalTexture = babylonTexture.getInternalTexture();\r\n    if (!internalTexture || internalTexture.source !== InternalTextureSource.Url) {\r\n        return null;\r\n    }\r\n    if (internalTexture.invertY) {\r\n        return null;\r\n    }\r\n\r\n    const buffer = internalTexture._buffer;\r\n\r\n    let data;\r\n    let mimeType = (babylonTexture as Texture).mimeType;\r\n\r\n    if (!buffer) {\r\n        data = await Tools.LoadFileAsync(internalTexture.url);\r\n        mimeType = GetMimeType(internalTexture.url) || mimeType;\r\n    } else if (ArrayBuffer.isView(buffer)) {\r\n        data = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength) as ArrayBuffer;\r\n    } else if (buffer instanceof ArrayBuffer) {\r\n        data = buffer;\r\n    } else if (buffer instanceof Blob) {\r\n        data = await buffer.arrayBuffer();\r\n        mimeType = buffer.type || mimeType;\r\n    } else if (typeof buffer === \"string\") {\r\n        data = await Tools.LoadFileAsync(buffer);\r\n        mimeType = GetMimeType(buffer) || mimeType;\r\n    } else if (typeof HTMLImageElement !== \"undefined\" && buffer instanceof HTMLImageElement) {\r\n        data = await Tools.LoadFileAsync(buffer.src);\r\n        mimeType = GetMimeType(buffer.src) || mimeType;\r\n    }\r\n\r\n    if (data && mimeType) {\r\n        return { data, mimeType };\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Computes the metallic factor from specular glossiness values.\r\n * @param diffuse diffused value\r\n * @param specular specular value\r\n * @param oneMinusSpecularStrength one minus the specular strength\r\n * @returns metallic value\r\n * @internal\r\n */\r\nexport function _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n    if (specular < DielectricSpecular.r) {\r\n        return 0;\r\n    }\r\n\r\n    const a = DielectricSpecular.r;\r\n    const b = (diffuse * oneMinusSpecularStrength) / (1.0 - DielectricSpecular.r) + specular - 2.0 * DielectricSpecular.r;\r\n    const c = DielectricSpecular.r - specular;\r\n    const d = b * b - 4.0 * a * c;\r\n    return Scalar.Clamp((-b + Math.sqrt(d)) / (2.0 * a), 0, 1);\r\n}\r\n\r\n/**\r\n * Computes the metallic/roughness factors from a Standard Material.\r\n * @internal\r\n */\r\nexport function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n    const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n    const opacity = babylonStandardMaterial.alpha;\r\n    const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);\r\n\r\n    const roughness = SpecularPowerToRoughness(specularPower);\r\n\r\n    const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n        baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n        metallicFactor: 0,\r\n        roughnessFactor: roughness,\r\n    };\r\n\r\n    return glTFPbrMetallicRoughness;\r\n}\r\n\r\n/**\r\n * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n * @param glTFMaterial glTF material\r\n * @param babylonMaterial Babylon material\r\n */\r\nfunction SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff?: number }): void {\r\n    if (babylonMaterial.needAlphaBlending()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n    } else if (babylonMaterial.needAlphaTesting()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n        glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n    }\r\n}\r\n\r\nfunction CreateWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n    const data = new Uint8Array(width * height * 4);\r\n\r\n    for (let i = 0; i < data.length; i = i + 4) {\r\n        data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n    }\r\n\r\n    const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n    return rawTexture;\r\n}\r\n\r\nfunction ConvertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n    if (pixels instanceof Uint8Array) {\r\n        const length = pixels.length;\r\n        const buffer = new Float32Array(pixels.length);\r\n        for (let i = 0; i < length; ++i) {\r\n            buffer[i] = pixels[i] / 255;\r\n        }\r\n        return buffer;\r\n    } else if (pixels instanceof Float32Array) {\r\n        return pixels;\r\n    } else {\r\n        throw new Error(\"Unsupported pixel format!\");\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.\r\n * @internal\r\n */\r\nexport class GLTFMaterialExporter {\r\n    // Mapping to store textures\r\n    private _textureMap = new Map<BaseTexture, ITextureInfo>();\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    constructor(private readonly _exporter: GLTFExporter) {}\r\n\r\n    public getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        return babylonTexture ? (this._textureMap.get(babylonTexture) ?? null) : null;\r\n    }\r\n\r\n    public async exportStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, hasUVs: boolean): Promise<number> {\r\n        const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const diffuseTexture = babylonStandardMaterial.diffuseTexture;\r\n            if (diffuseTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(diffuseTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonStandardMaterial.emissiveTexture;\r\n            if (emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonStandardMaterial.ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        await this._finishMaterialAsync(material, babylonStandardMaterial);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(material);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _finishMaterialAsync(glTFMaterial: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const textures = await this._exporter._extensionsPostExportMaterialAdditionalTexturesAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n\r\n        const promises: Array<Promise<Nullable<ITextureInfo>>> = [];\r\n\r\n        for (const texture of textures) {\r\n            promises.push(this.exportTextureAsync(texture));\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        await this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n    }\r\n\r\n    private async _getImageDataAsync(buffer: Uint8Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        return await DumpTools.DumpDataAsync(width, height, buffer, mimeType, undefined, false, true);\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return await Promise.reject(\"diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = new Color3(0, 0, 0);\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return await Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return await Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: IPBRSpecularGlossiness): IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - DielectricSpecular.r) / Math.max(1 - metallic, Epsilon));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, Epsilon));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        return Math.max(color.r, Math.max(color.g, color.b));\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param baseColor Base color of the material\r\n     * @param metallic Metallic factor of the material\r\n     * @param roughness Roughness factor of the material\r\n     * @param albedoTexture Albedo texture of the material\r\n     * @param metallicTexture Metallic texture of the material\r\n     * @param roughnessTexture Roughness texture of the material\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        baseColor: Color3,\r\n        metallic: Nullable<number>,\r\n        roughness: Nullable<number>,\r\n        albedoTexture: Nullable<BaseTexture>,\r\n        metallicTexture: Nullable<BaseTexture>,\r\n        roughnessTexture: Nullable<BaseTexture>,\r\n        babylonPBRMaterial: PBRBaseMaterial | OpenPBRMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises: Promise<void>[] = [];\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: roughness,\r\n        };\r\n\r\n        if (hasUVs) {\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(albedoTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            // OpenPBRMaterial can have separate metallic and roughness textures so something\r\n            // should be done here to merge them for glTF in that case.\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(metallicTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (promises.length > 0) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n            await Promise.all(promises);\r\n        }\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const mimeType = ImageMimeType.PNG;\r\n        const specGloss: IPBRSpecularGlossiness = {\r\n            diffuseColor: babylonPBRMaterial._albedoColor,\r\n            specularColor: babylonPBRMaterial._reflectivityColor,\r\n            glossiness: babylonPBRMaterial._microSurface,\r\n        };\r\n\r\n        const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n        const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n        const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n        if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n            return await Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n        }\r\n\r\n        if ((albedoTexture || reflectivityTexture) && hasUVs) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n\r\n            const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n            const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType);\r\n\r\n            const textures = this._exporter._textures;\r\n\r\n            if (metallicRoughnessFactors.baseColorTextureData) {\r\n                const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n            }\r\n\r\n            if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n            }\r\n\r\n            return metallicRoughnessFactors;\r\n        } else {\r\n            return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n        }\r\n    }\r\n\r\n    public async exportPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, hasUVs: boolean): Promise<number> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n        }\r\n\r\n        const metallicRoughness = useMetallicRoughness\r\n            ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n                  babylonPBRMaterial._albedoColor,\r\n                  babylonPBRMaterial._metallic,\r\n                  babylonPBRMaterial._roughness,\r\n                  babylonPBRMaterial._albedoTexture,\r\n                  babylonPBRMaterial._metallicTexture,\r\n                  babylonPBRMaterial._metallicTexture,\r\n                  babylonPBRMaterial,\r\n                  glTFPbrMetallicRoughness,\r\n                  hasUVs\r\n              )\r\n            : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs);\r\n\r\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);\r\n        await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(glTFMaterial);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _setMetallicRoughnessPbrMaterialAsync(\r\n        metallicRoughness: IPBRMetallicRoughness,\r\n        babylonPBRMaterial: PBRBaseMaterial | OpenPBRMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<void> {\r\n        SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n\r\n        if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon)) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n        }\r\n\r\n        if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n        }\r\n        if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n        }\r\n\r\n        if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n            if (!babylonPBRMaterial._twoSidedLighting) {\r\n                Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const bumpTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._bumpTexture : babylonPBRMaterial.geometryNormalTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._ambientTexture : babylonPBRMaterial.ambientOcclusionTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            if (babylonPBRMaterial instanceof PBRBaseMaterial) {\r\n                                occlusionTexture.strength = babylonPBRMaterial._ambientTextureStrength;\r\n                            } else {\r\n                                occlusionTexture.strength = babylonPBRMaterial.ambientOcclusionTexture!.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveTexture : babylonPBRMaterial.emissionColorTexture;\r\n            if (emissiveTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        const emissiveColor = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveColor : babylonPBRMaterial.emissionColor;\r\n        if (!emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    public async exportOpenPBRMaterialAsync(babylonOpenPBRMaterial: OpenPBRMaterial, hasUVs: boolean): Promise<number> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonOpenPBRMaterial.name,\r\n        };\r\n\r\n        const albedoColor = babylonOpenPBRMaterial.baseColor;\r\n        const alpha = babylonOpenPBRMaterial.geometryOpacity;\r\n        if (albedoColor) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n        }\r\n\r\n        const metallicRoughness = await this._convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n            babylonOpenPBRMaterial.baseColor,\r\n            babylonOpenPBRMaterial.baseMetalness,\r\n            babylonOpenPBRMaterial.specularRoughness,\r\n            babylonOpenPBRMaterial.baseColorTexture,\r\n            babylonOpenPBRMaterial.baseMetalnessTexture,\r\n            babylonOpenPBRMaterial.specularRoughnessTexture,\r\n            babylonOpenPBRMaterial,\r\n            glTFPbrMetallicRoughness,\r\n            hasUVs\r\n        );\r\n\r\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonOpenPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);\r\n        await this._finishMaterialAsync(glTFMaterial, babylonOpenPBRMaterial);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(glTFMaterial);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    public async exportTextureAsync(babylonTexture: BaseTexture): Promise<Nullable<ITextureInfo>> {\r\n        let textureInfo = this._textureMap.get(babylonTexture);\r\n        if (textureInfo) {\r\n            return textureInfo;\r\n        }\r\n\r\n        const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n        const imageIndex = await this._exportTextureImageAsync(babylonTexture);\r\n\r\n        textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, babylonTexture.coordinatesIndex);\r\n        this._textureMap.set(babylonTexture, textureInfo);\r\n\r\n        this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, babylonTexture);\r\n        return textureInfo;\r\n    }\r\n\r\n    private async _exportTextureImageAsync(babylonTexture: BaseTexture): Promise<number> {\r\n        const requestedMimeType = (babylonTexture as Texture).mimeType ?? \"none\";\r\n        // TODO: Add an official way for users to export using a different mime type\r\n        // than the one they loaded with (which is denoted by Texture.mimeType)\r\n\r\n        const internalTextureToImage = this._internalTextureToImage;\r\n        const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n        internalTextureToImage[internalTextureUniqueId] = internalTextureToImage[internalTextureUniqueId] || {};\r\n        let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][requestedMimeType];\r\n\r\n        if (imageIndexPromise === undefined) {\r\n            imageIndexPromise = (async () => {\r\n                // Try to get the image from memory first, if applicable\r\n                const cache = await GetCachedImageAsync(babylonTexture);\r\n                if (cache && (requestedMimeType === \"none\" || cache.mimeType === requestedMimeType)) {\r\n                    return this._exportImage(babylonTexture.name, cache.mimeType as ImageMimeType, cache.data);\r\n                }\r\n\r\n                // Preserve texture mime type if defined\r\n                let mimeType = ImageMimeType.PNG;\r\n                if (requestedMimeType !== \"none\") {\r\n                    switch (requestedMimeType) {\r\n                        case ImageMimeType.JPEG:\r\n                        case ImageMimeType.PNG:\r\n                        case ImageMimeType.WEBP:\r\n                            mimeType = requestedMimeType;\r\n                            break;\r\n                        default:\r\n                            Tools.Warn(`Unsupported media type: ${requestedMimeType}. Exporting texture as PNG.`);\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                const size = babylonTexture.getSize();\r\n                const pixels = await GetTextureDataAsync(babylonTexture);\r\n                const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n\r\n                return this._exportImage(babylonTexture.name, mimeType, data);\r\n            })();\r\n\r\n            internalTextureToImage[internalTextureUniqueId][requestedMimeType] = imageIndexPromise;\r\n        }\r\n\r\n        return await imageIndexPromise;\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const images = this._exporter._images;\r\n\r\n        let image: IImage;\r\n        if (this._exporter._shouldUseGlb) {\r\n            image = {\r\n                name: name,\r\n                mimeType: mimeType,\r\n                bufferView: undefined, // Will be updated later by BufferManager\r\n            };\r\n            const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));\r\n            this._exporter._bufferManager.setBufferView(image, bufferView);\r\n        } else {\r\n            // Build a unique URI\r\n            const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n            const extension = GetFileExtensionFromMimeType(mimeType);\r\n            let fileName = baseName + extension;\r\n            if (images.some((image) => image.uri === fileName)) {\r\n                fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n            }\r\n\r\n            image = {\r\n                name: name,\r\n                uri: fileName,\r\n            };\r\n            this._exporter._imageData[fileName] = { data: data, mimeType: mimeType }; // Save image data to be written to file later\r\n        }\r\n\r\n        images.push(image);\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n", "import { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Node } from \"core/node\";\r\n\r\n/**\r\n * Matrix that converts handedness on the X-axis. Used to convert from LH to RH and vice versa.\r\n * @internal\r\n */\r\nexport const ConvertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());\r\n\r\n/**\r\n * Checks if a node is a \"noop\" transform node, usually inserted by the glTF loader to correct handedness.\r\n * @internal\r\n */\r\nexport function IsNoopNode(node: Node, useRightHandedSystem: boolean): boolean {\r\n    if (!(node instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Transform\r\n    if (useRightHandedSystem) {\r\n        const matrix = node.getWorldMatrix();\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    } else {\r\n        const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, TmpVectors.Matrix[0]);\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Geometry\r\n    if (node instanceof AbstractMesh && node.geometry) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n", "/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { INode } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, DataArray, IndicesArray, DeepImmutable } from \"core/types\";\r\nimport type { Vector4 } from \"core/Maths/math.vector\";\r\nimport { Quaternion, TmpVectors, Matrix, Vector3 } from \"core/Maths/math.vector\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { EnumerateFloatValues } from \"core/Buffers/bufferUtils\";\r\nimport type { Node } from \"core/node\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport type { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { ConvertHandednessMatrix } from \"../../exportUtils\";\r\n\r\n// Default values for comparison.\r\nexport const DefaultTranslation = Vector3.ZeroReadOnly;\r\nexport const DefaultRotation = Quaternion.Identity() as DeepImmutable<Quaternion>;\r\nexport const DefaultScale = Vector3.OneReadOnly;\r\nconst DefaultLoaderCameraParentScaleLh = new Vector3(-1, 1, 1) as DeepImmutable<Vector3>;\r\n\r\n/**\r\n * Get the information necessary for enumerating a vertex buffer.\r\n * @param vertexBuffer the vertex buffer to enumerate\r\n * @param meshes the meshes that use the vertex buffer\r\n * @returns the information necessary to enumerate the vertex buffer\r\n */\r\nexport function GetVertexBufferInfo(vertexBuffer: VertexBuffer, meshes: AbstractMesh[]) {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const componentCount = vertexBuffer.getSize();\r\n    const totalVertices = meshes.reduce((max, current) => {\r\n        return current.getTotalVertices() > max ? current.getTotalVertices() : max;\r\n    }, -Number.MAX_VALUE); // Get the max total vertices count, to ensure we capture the full range of vertex data used by the meshes.\r\n    const count = totalVertices * componentCount;\r\n    const kind = vertexBuffer.getKind();\r\n\r\n    return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };\r\n}\r\n\r\nexport function GetAccessorElementCount(accessorType: AccessorType): number {\r\n    switch (accessorType) {\r\n        case AccessorType.MAT2:\r\n            return 4;\r\n        case AccessorType.MAT3:\r\n            return 9;\r\n        case AccessorType.MAT4:\r\n            return 16;\r\n        case AccessorType.SCALAR:\r\n            return 1;\r\n        case AccessorType.VEC2:\r\n            return 2;\r\n        case AccessorType.VEC3:\r\n            return 3;\r\n        case AccessorType.VEC4:\r\n            return 4;\r\n    }\r\n}\r\n\r\nexport function FloatsNeed16BitInteger(floatArray: FloatArray): boolean {\r\n    return floatArray.some((value) => value >= 256);\r\n}\r\n\r\nexport function IsStandardVertexAttribute(type: string): boolean {\r\n    switch (type) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.ColorKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function GetAccessorType(kind: string, hasVertexColorAlpha: boolean): AccessorType {\r\n    if (kind == VertexBuffer.ColorKind) {\r\n        return hasVertexColorAlpha ? AccessorType.VEC4 : AccessorType.VEC3;\r\n    }\r\n\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n            return AccessorType.VEC3;\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return AccessorType.VEC4;\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return AccessorType.VEC2;\r\n    }\r\n\r\n    throw new Error(`Unknown kind ${kind}`);\r\n}\r\n\r\nexport function GetAttributeType(kind: string): string {\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n            return \"POSITION\";\r\n        case VertexBuffer.NormalKind:\r\n            return \"NORMAL\";\r\n        case VertexBuffer.TangentKind:\r\n            return \"TANGENT\";\r\n        case VertexBuffer.ColorKind:\r\n            return \"COLOR_0\";\r\n        case VertexBuffer.UVKind:\r\n            return \"TEXCOORD_0\";\r\n        case VertexBuffer.UV2Kind:\r\n            return \"TEXCOORD_1\";\r\n        case VertexBuffer.UV3Kind:\r\n            return \"TEXCOORD_2\";\r\n        case VertexBuffer.UV4Kind:\r\n            return \"TEXCOORD_3\";\r\n        case VertexBuffer.UV5Kind:\r\n            return \"TEXCOORD_4\";\r\n        case VertexBuffer.UV6Kind:\r\n            return \"TEXCOORD_5\";\r\n        case VertexBuffer.MatricesIndicesKind:\r\n            return \"JOINTS_0\";\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n            return \"JOINTS_1\";\r\n        case VertexBuffer.MatricesWeightsKind:\r\n            return \"WEIGHTS_0\";\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return \"WEIGHTS_1\";\r\n    }\r\n\r\n    throw new Error(`Unknown kind: ${kind}`);\r\n}\r\n\r\nexport function GetPrimitiveMode(fillMode: number): MeshPrimitiveMode {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n            return MeshPrimitiveMode.TRIANGLES;\r\n        case Material.TriangleStripDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_STRIP;\r\n        case Material.TriangleFanDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_FAN;\r\n        case Material.PointListDrawMode:\r\n        case Material.PointFillMode:\r\n            return MeshPrimitiveMode.POINTS;\r\n        case Material.LineLoopDrawMode:\r\n            return MeshPrimitiveMode.LINE_LOOP;\r\n        case Material.LineListDrawMode:\r\n            return MeshPrimitiveMode.LINES;\r\n        case Material.LineStripDrawMode:\r\n            return MeshPrimitiveMode.LINE_STRIP;\r\n    }\r\n\r\n    throw new Error(`Unknown fill mode: ${fillMode}`);\r\n}\r\n\r\nexport function IsTriangleFillMode(fillMode: number): boolean {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n        case Material.TriangleStripDrawMode:\r\n        case Material.TriangleFanDrawMode:\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function NormalizeTangent(tangent: Vector4 | Vector3) {\r\n    const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n    if (length > 0) {\r\n        tangent.x /= length;\r\n        tangent.y /= length;\r\n        tangent.z /= length;\r\n    }\r\n}\r\n\r\nexport function ConvertToRightHandedPosition(value: Vector3): Vector3 {\r\n    value.x *= -1;\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport function ConvertToRightHandedTransformMatrix(matrix: Matrix): Matrix {\r\n    ConvertHandednessMatrix.invertToRef(TmpVectors.Matrix[0]).multiplyToRef(matrix, matrix).multiplyToRef(ConvertHandednessMatrix, matrix);\r\n    return matrix;\r\n}\r\n\r\n/**\r\n * Converts, in-place, a left-handed quaternion to a right-handed quaternion via a change of basis.\r\n * @param value the unit quaternion to convert\r\n * @returns the converted quaternion\r\n */\r\nexport function ConvertToRightHandedRotation(value: Quaternion): Quaternion {\r\n    /**\r\n     * This is the simplified version of the following equation:\r\n     *    q' = to_quaternion(M * to_matrix(q) * M^-1)\r\n     * where M is the conversion matrix `convertHandednessMatrix`,\r\n     * q is the input quaternion, and q' is the converted quaternion.\r\n     * Reference: https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2015/01/matrix-to-quat.pdf\r\n     */\r\n    if (value.x * value.x + value.y * value.y > 0.5) {\r\n        const absX = Math.abs(value.x);\r\n        const absY = Math.abs(value.y);\r\n        if (absX > absY) {\r\n            const sign = Math.sign(value.x);\r\n            value.x = absX;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w *= sign;\r\n        } else {\r\n            const sign = Math.sign(value.y);\r\n            value.x *= -sign;\r\n            value.y = absY;\r\n            value.z *= sign;\r\n            value.w *= -sign;\r\n        }\r\n    } else {\r\n        const absZ = Math.abs(value.z);\r\n        const absW = Math.abs(value.w);\r\n        if (absZ > absW) {\r\n            const sign = Math.sign(value.z);\r\n            value.x *= -sign;\r\n            value.y *= sign;\r\n            value.z = absZ;\r\n            value.w *= -sign;\r\n        } else {\r\n            const sign = Math.sign(value.w);\r\n            value.x *= sign;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w = absW;\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Pre-multiplies a 180-degree Y rotation to the quaternion, in order to match glTF's flipped forward direction for cameras.\r\n * @param rotation Target camera rotation.\r\n */\r\nexport function Rotate180Y(rotation: Quaternion): void {\r\n    // Simplified from: rotation * (0, 1, 0, 0).\r\n    rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);\r\n}\r\n\r\n/**\r\n * Collapses GLTF parent and node into a single node, ignoring scaling.\r\n * This is useful for removing nodes that were added by the GLTF importer.\r\n * @param node Original GLTF node (Light or Camera).\r\n * @param parentNode Target parent node.\r\n */\r\nexport function CollapseChildIntoParent(node: INode, parentNode: INode): void {\r\n    const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n    const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n    const parentMatrix = Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);\r\n\r\n    const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);\r\n    const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);\r\n    const matrix = Matrix.ComposeToRef(DefaultScale, rotation, translation, TmpVectors.Matrix[1]);\r\n\r\n    parentMatrix.multiplyToRef(matrix, matrix);\r\n    matrix.decompose(undefined, parentRotation, parentTranslation);\r\n\r\n    if (parentTranslation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n        delete parentNode.translation;\r\n    } else {\r\n        parentNode.translation = parentTranslation.asArray();\r\n    }\r\n\r\n    if (parentRotation.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n        delete parentNode.rotation;\r\n    } else {\r\n        parentNode.rotation = parentRotation.asArray();\r\n    }\r\n\r\n    if (parentNode.scale) {\r\n        delete parentNode.scale;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether a camera or light node is candidate for collapsing with its parent node.\r\n * This is useful for roundtrips, as the glTF Importer parents a new node to\r\n * lights and cameras to store their original transformation information.\r\n * @param babylonNode Babylon light or camera node.\r\n * @param parentBabylonNode Target Babylon parent node.\r\n * @returns True if the two nodes can be merged, false otherwise.\r\n */\r\nexport function IsChildCollapsible(babylonNode: ShadowLight | TargetCamera, parentBabylonNode: Node): boolean {\r\n    if (!(parentBabylonNode instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Verify child is the only descendant\r\n    const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;\r\n    if (!isOnlyDescendant) {\r\n        return false;\r\n    }\r\n\r\n    // Verify parent has the expected scaling, determined by the node type and scene's coordinate system.\r\n    const scene = babylonNode.getScene();\r\n    const expectedScale = babylonNode instanceof TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;\r\n\r\n    if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, Epsilon)) {\r\n        Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Converts an IndicesArray into either a Uint32Array or Uint16Array.\r\n * If the `start` and `count` parameters specify a subset of the array, a new view is created.\r\n * If the input is a number[], the data is copied into a new buffer.\r\n * @param indices input array to be converted\r\n * @param start starting index\r\n * @param count number of indices\r\n * @param is32Bits whether the output should be Uint32Array (true) or Uint16Array (false) when indices is an `Array`\r\n * @returns a Uint32Array or Uint16Array\r\n * @internal\r\n */\r\nexport function IndicesArrayToTypedSubarray(indices: IndicesArray, start: number, count: number, is32Bits: boolean): Uint32Array | Uint16Array {\r\n    let processedIndices = indices;\r\n    if (start !== 0 || count !== indices.length) {\r\n        processedIndices = Array.isArray(indices) ? indices.slice(start, start + count) : indices.subarray(start, start + count);\r\n    }\r\n\r\n    // If Int32Array, cast the indices (which should all be positive) to Uint32Array\r\n    if (processedIndices instanceof Int32Array) {\r\n        return new Uint32Array(processedIndices.buffer, processedIndices.byteOffset, processedIndices.length);\r\n    }\r\n\r\n    if (Array.isArray(processedIndices)) {\r\n        return is32Bits ? new Uint32Array(processedIndices) : new Uint16Array(processedIndices);\r\n    }\r\n\r\n    return processedIndices;\r\n}\r\n\r\nexport function DataArrayToUint8Array(data: DataArray): Uint8Array {\r\n    if (data instanceof Array) {\r\n        const floatData = new Float32Array(data);\r\n        return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);\r\n}\r\n\r\nexport function GetMinMax(data: DataArray, vertexBuffer: VertexBuffer, start: number, count: number): { min: number[]; max: number[] } {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const size = vertexBuffer.getSize();\r\n    const min = new Array<number>(size).fill(Infinity);\r\n    const max = new Array<number>(size).fill(-Infinity);\r\n    EnumerateFloatValues(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {\r\n        for (let i = 0; i < size; i++) {\r\n            min[i] = Math.min(min[i], values[i]);\r\n            max[i] = Math.max(max[i], values[i]);\r\n        }\r\n    });\r\n\r\n    return { min, max };\r\n}\r\n\r\n/**\r\n * Removes, in-place, object properties which have the same value as the default value.\r\n * Useful for avoiding unnecessary properties in the glTF JSON.\r\n * @param object the object to omit default values from\r\n * @param defaultValues a partial object with default values\r\n * @returns object with default values omitted\r\n */\r\nexport function OmitDefaultValues<T extends object>(object: T, defaultValues: Partial<T>): T {\r\n    for (const [key, value] of Object.entries(object)) {\r\n        const defaultValue = defaultValues[key as keyof T];\r\n        if ((Array.isArray(value) && Array.isArray(defaultValue) && AreArraysEqual(value, defaultValue)) || value === defaultValue) {\r\n            delete object[key as keyof T];\r\n        }\r\n    }\r\n    return object;\r\n}\r\n\r\nfunction AreArraysEqual(array1: unknown[], array2: unknown[]): boolean {\r\n    return array1.length === array2.length && array1.every((val, i) => val === array2[i]);\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\nimport type { TypedArray } from \"core/types\";\r\n\r\nconst TypedArrayToWriteMethod = new Map<Function, (dataView: DataView, byteOffset: number, value: number) => void>([\r\n    [Int8Array, (d, b, v) => d.setInt8(b, v)],\r\n    [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],\r\n    [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],\r\n    [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],\r\n    [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],\r\n    [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],\r\n    [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)],\r\n]);\r\n\r\n/** @internal */\r\nexport class DataWriter {\r\n    private _data: Uint8Array;\r\n    private _dataView: DataView;\r\n    private _byteOffset: number;\r\n\r\n    public writeTypedArray(value: Exclude<TypedArray, BigInt64Array | BigUint64Array>): void {\r\n        this._checkGrowBuffer(value.byteLength);\r\n        const setMethod = TypedArrayToWriteMethod.get(value.constructor)!;\r\n        for (let i = 0; i < value.length; i++) {\r\n            setMethod(this._dataView, this._byteOffset, value[i]);\r\n            this._byteOffset += value.BYTES_PER_ELEMENT;\r\n        }\r\n    }\r\n\r\n    public constructor(byteLength: number) {\r\n        this._data = new Uint8Array(byteLength);\r\n        this._dataView = new DataView(this._data.buffer);\r\n        this._byteOffset = 0;\r\n    }\r\n\r\n    public get byteOffset(): number {\r\n        return this._byteOffset;\r\n    }\r\n\r\n    public getOutputData(): Uint8Array {\r\n        return new Uint8Array(this._data.buffer, 0, this._byteOffset);\r\n    }\r\n\r\n    public writeUInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setUint8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setInt8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt16(entry: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setInt16(this._byteOffset, entry, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeUInt16(value: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setUint16(this._byteOffset, value, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeInt32(entry: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setInt32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeUInt32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setUint32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setFloat32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat64(value: number): void {\r\n        this._checkGrowBuffer(8);\r\n        this._dataView.setFloat64(this._byteOffset, value, true);\r\n        this._byteOffset += 8;\r\n    }\r\n\r\n    private _checkGrowBuffer(byteLength: number): void {\r\n        const newByteLength = this.byteOffset + byteLength;\r\n        if (newByteLength > this._data.byteLength) {\r\n            const newData = new Uint8Array(newByteLength * 2);\r\n            newData.set(this._data);\r\n            this._data = newData;\r\n            this._dataView = new DataView(this._data.buffer);\r\n        }\r\n    }\r\n}\r\n", "import type { TypedArray } from \"core/types\";\nimport type { AccessorComponentType, AccessorType, IAccessor, IBufferView } from \"babylonjs-gltf2interface\";\nimport { DataWriter } from \"./dataWriter\";\n\ntype TypedArrayForglTF = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\n\ninterface IPropertyWithBufferView {\n    bufferView?: number;\n}\n\nfunction GetHighestByteAlignment(byteLength: number): number {\n    if (byteLength % 4 === 0) {\n        return 4;\n    }\n    if (byteLength % 2 === 0) {\n        return 2;\n    }\n    return 1;\n}\n\n/**\n * Utility class to centralize the management of binary data, bufferViews, and the objects that reference them.\n * @internal\n */\nexport class BufferManager {\n    /**\n     * Maps a bufferView to its data\n     */\n    private _bufferViewToData: Map<IBufferView, TypedArrayForglTF> = new Map<IBufferView, TypedArrayForglTF>();\n\n    /**\n     * Maps a bufferView to glTF objects that reference it via a \"bufferView\" property (e.g. accessors, images)\n     */\n    private _bufferViewToProperties: Map<IBufferView, IPropertyWithBufferView[]> = new Map<IBufferView, IPropertyWithBufferView[]>();\n\n    /**\n     * Maps an accessor to its bufferView\n     */\n    private _accessorToBufferView: Map<IAccessor, IBufferView> = new Map<IAccessor, IBufferView>();\n\n    /**\n     * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.\n     * @param bufferViews The list of bufferViews to be populated while writing the binary\n     * @returns The binary buffer\n     */\n    public generateBinary(bufferViews: IBufferView[]): Uint8Array {\n        // Construct a DataWriter with the total byte length to prevent resizing\n        let totalByteLength = 0;\n        this._bufferViewToData.forEach((data) => {\n            totalByteLength += data.byteLength;\n        });\n        const dataWriter = new DataWriter(totalByteLength);\n\n        // Order the bufferViews in descending order of their alignment requirements\n        const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));\n\n        // Fill in the bufferViews list and missing bufferView index references while writing the binary\n        for (const bufferView of orderedBufferViews) {\n            bufferView.byteOffset = dataWriter.byteOffset;\n            bufferViews.push(bufferView);\n\n            const bufferViewIndex = bufferViews.length - 1;\n            const properties = this.getPropertiesWithBufferView(bufferView);\n            for (const object of properties) {\n                object.bufferView = bufferViewIndex;\n            }\n\n            dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView)!);\n\n            this._bufferViewToData.delete(bufferView); // Try to free up memory ASAP\n        }\n\n        return dataWriter.getOutputData();\n    }\n\n    /**\n     * Creates a buffer view based on the supplied arguments\n     * @param data a TypedArray to create the bufferView for\n     * @param byteStride byte distance between consecutive elements\n     * @returns bufferView for glTF\n     */\n    public createBufferView(data: TypedArrayForglTF, byteStride?: number): IBufferView {\n        const bufferView: IBufferView = {\n            buffer: 0,\n            byteOffset: undefined, // byteOffset will be set later, when we write the binary and decide bufferView ordering\n            byteLength: data.byteLength,\n            byteStride: byteStride,\n        };\n        this._bufferViewToData.set(bufferView, data);\n        return bufferView;\n    }\n\n    /**\n     * Creates an accessor based on the supplied arguments and assigns it to the bufferView\n     * @param bufferView The glTF bufferView referenced by this accessor\n     * @param type The type of the accessor\n     * @param componentType The datatype of components in the attribute\n     * @param count The number of attributes referenced by this accessor\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\n     * @param minMax Minimum and maximum value of each component in this attribute\n     * @param normalized Specifies whether integer data values are normalized before usage\n     * @returns accessor for glTF\n     */\n    public createAccessor(\n        bufferView: IBufferView,\n        type: AccessorType,\n        componentType: AccessorComponentType,\n        count: number,\n        byteOffset?: number,\n        minMax?: { min: number[]; max: number[] },\n        normalized?: boolean\n    ): IAccessor {\n        this._verifyBufferView(bufferView);\n        const accessor: IAccessor = {\n            bufferView: undefined, // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering\n            componentType: componentType,\n            count: count,\n            type: type,\n            min: minMax?.min,\n            max: minMax?.max,\n            normalized: normalized,\n            byteOffset: byteOffset,\n        };\n        this.setBufferView(accessor, bufferView);\n        this._accessorToBufferView.set(accessor, bufferView);\n        return accessor;\n    }\n\n    /**\n     * Assigns a bufferView to a glTF object that references it\n     * @param object The glTF object\n     * @param bufferView The bufferView to assign\n     */\n    public setBufferView(object: IPropertyWithBufferView, bufferView: IBufferView) {\n        this._verifyBufferView(bufferView);\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        properties.push(object);\n    }\n\n    /**\n     * Removes buffer view from the binary data, as well as from all its known references\n     * @param bufferView the bufferView to remove\n     */\n    public removeBufferView(bufferView: IBufferView): void {\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        for (const object of properties) {\n            if (object.bufferView !== undefined) {\n                delete object.bufferView;\n            }\n        }\n\n        this._bufferViewToData.delete(bufferView);\n        this._bufferViewToProperties.delete(bufferView);\n        this._accessorToBufferView.forEach((bv, accessor) => {\n            if (bv === bufferView) {\n                // Additionally, remove byteOffset from accessor referencing this bufferView\n                if (accessor.byteOffset !== undefined) {\n                    delete accessor.byteOffset;\n                }\n                this._accessorToBufferView.delete(accessor);\n            }\n        });\n    }\n\n    public getBufferView(accessor: IAccessor): IBufferView {\n        const bufferView = this._accessorToBufferView.get(accessor);\n        this._verifyBufferView(bufferView);\n        return bufferView!;\n    }\n\n    public getPropertiesWithBufferView(bufferView: IBufferView): IPropertyWithBufferView[] {\n        this._verifyBufferView(bufferView);\n        this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);\n        return this._bufferViewToProperties.get(bufferView)!;\n    }\n\n    public getData(bufferView: IBufferView): TypedArrayForglTF {\n        this._verifyBufferView(bufferView);\n        return this._bufferViewToData.get(bufferView)!;\n    }\n\n    private _verifyBufferView(bufferView?: IBufferView): void {\n        if (bufferView === undefined || !this._bufferViewToData.has(bufferView)) {\n            throw new Error(`BufferView ${bufferView} not found in BufferManager.`);\n        }\n    }\n}\n", "import type { IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel } from \"babylonjs-gltf2interface\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\n\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\nimport { GetAccessorElementCount, ConvertToRightHandedPosition, Rotate180Y, ConvertToRightHandedRotation } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @internal\r\n * Interface to store animation data.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4 | AccessorType.SCALAR;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum for handling in tangent and out tangent.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT,\r\n}\r\n\r\n/**\r\n * @internal\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * Determine if a node is transformable - ie has properties it should be part of animation of transformation.\r\n     * @param babylonNode the node to test\r\n     * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.\r\n     */\r\n    private static _IsTransformable(babylonNode: Node): boolean {\r\n        return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number\r\n    ): Nullable<_IAnimationData> {\r\n        if (this._IsTransformable(babylonTransformNode)) {\r\n            const inputs: number[] = [];\r\n            const outputs: number[][] = [];\r\n            const keyFrames = animation.getKeys();\r\n            const minMaxKeyFrames = _GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);\r\n            const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n\r\n            const interpolation = interpolationOrBake.interpolationType;\r\n            const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n            if (shouldBakeAnimation) {\r\n                _GLTFAnimation._CreateBakedAnimation(\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    minMaxKeyFrames.min,\r\n                    minMaxKeyFrames.max,\r\n                    animation.framePerSecond,\r\n                    animationSampleRate,\r\n                    inputs,\r\n                    outputs,\r\n                    minMaxKeyFrames,\r\n                    useQuaternion\r\n                );\r\n            } else {\r\n                if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                    _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                    _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else {\r\n                    _GLTFAnimation._CreateBakedAnimation(\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationChannelTargetPath,\r\n                        minMaxKeyFrames.min,\r\n                        minMaxKeyFrames.max,\r\n                        animation.framePerSecond,\r\n                        animationSampleRate,\r\n                        inputs,\r\n                        outputs,\r\n                        minMaxKeyFrames,\r\n                        useQuaternion\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (inputs.length && outputs.length) {\r\n                const result: _IAnimationData = {\r\n                    inputs: inputs,\r\n                    outputs: outputs,\r\n                    samplerInterpolation: interpolation,\r\n                    inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                    inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond),\r\n                };\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        const property = animation.targetProperty.split(\".\");\r\n        switch (property[0]) {\r\n            case \"scaling\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case \"position\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case \"rotation\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"rotationQuaternion\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"influence\": {\r\n                dataAccessorType = AccessorType.SCALAR;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.WEIGHTS;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        } else {\r\n            Tools.Error(\"animation channel target path and data accessor type could be deduced\");\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (_GLTFAnimation._IsTransformable(babylonNode)) {\r\n            if (babylonNode.animations) {\r\n                for (const animation of babylonNode.animations) {\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: [],\r\n                        };\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            useRightHanded\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create individual morph animations from the mesh's morph target animation tracks\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof Mesh) {\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n            if (morphTargetManager) {\r\n                for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                    const morphTarget = morphTargetManager.getTarget(i);\r\n                    for (const animation of morphTarget.animations) {\r\n                        if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                            continue;\r\n                        }\r\n                        const combinedAnimation = new Animation(\r\n                            `${animation.name}`,\r\n                            \"influence\",\r\n                            animation.framePerSecond,\r\n                            animation.dataType,\r\n                            animation.loopMode,\r\n                            animation.enableBlending\r\n                        );\r\n                        const combinedAnimationKeys: IAnimationKey[] = [];\r\n                        const animationKeys = animation.getKeys();\r\n\r\n                        for (let j = 0; j < animationKeys.length; ++j) {\r\n                            const animationKey = animationKeys[j];\r\n                            for (let k = 0; k < morphTargetManager.numTargets; ++k) {\r\n                                if (k == i) {\r\n                                    combinedAnimationKeys.push(animationKey);\r\n                                } else {\r\n                                    combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });\r\n                                }\r\n                            }\r\n                        }\r\n                        combinedAnimation.setKeys(combinedAnimationKeys);\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimation);\r\n                        if (animationInfo) {\r\n                            glTFAnimation = {\r\n                                name: combinedAnimation.name,\r\n                                samplers: [],\r\n                                channels: [],\r\n                            };\r\n                            _GLTFAnimation._AddAnimation(\r\n                                animation.name,\r\n                                animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                                babylonNode,\r\n                                combinedAnimation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                bufferManager,\r\n                                bufferViews,\r\n                                accessors,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate,\r\n                                useRightHanded,\r\n                                morphTargetManager.numTargets\r\n                            );\r\n                            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                                idleGLTFAnimations.push(glTFAnimation);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Create node and morph animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAndMorphAnimationFromAnimationGroups(\r\n        babylonScene: Scene,\r\n        glTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        leftHandedNodes: Set<Node>,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            const animationGroups = babylonScene.animationGroups;\r\n            for (const animationGroup of animationGroups) {\r\n                const morphAnimations: Map<Mesh, Map<MorphTarget, Animation>> = new Map();\r\n                const sampleAnimations: Map<Mesh, Animation> = new Map();\r\n                const morphAnimationMeshes: Set<Mesh> = new Set();\r\n                const animationGroupFrameDiff = animationGroup.to - animationGroup.from;\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: [],\r\n                };\r\n                for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {\r\n                    const targetAnimation = animationGroup.targetedAnimations[i];\r\n                    const target = targetAnimation.target;\r\n                    const animation = targetAnimation.animation;\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n\r\n                    const convertToRightHanded = leftHandedNodes.has(target);\r\n\r\n                    if (this._IsTransformable(target) || (target.length === 1 && this._IsTransformable(target[0]))) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;\r\n                            if (babylonTransformNode) {\r\n                                _GLTFAnimation._AddAnimation(\r\n                                    `${animation.name}`,\r\n                                    glTFAnimation,\r\n                                    babylonTransformNode,\r\n                                    animation,\r\n                                    animationInfo.dataAccessorType,\r\n                                    animationInfo.animationChannelTargetPath,\r\n                                    nodeMap,\r\n                                    bufferManager,\r\n                                    bufferViews,\r\n                                    accessors,\r\n                                    animationInfo.useQuaternion,\r\n                                    animationSampleRate,\r\n                                    convertToRightHanded\r\n                                );\r\n                            }\r\n                        }\r\n                    } else if (target instanceof MorphTarget || (target.length === 1 && target[0] instanceof MorphTarget)) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonMorphTarget = target instanceof MorphTarget ? target : (target[0] as MorphTarget);\r\n                            if (babylonMorphTarget) {\r\n                                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {\r\n                                    for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                                        if (morphTargetManager.getTarget(j) === babylonMorphTarget) {\r\n                                            return true;\r\n                                        }\r\n                                    }\r\n                                    return false;\r\n                                });\r\n                                if (babylonMorphTargetManager) {\r\n                                    const babylonMesh = babylonScene.meshes.find((mesh) => {\r\n                                        return (mesh as Mesh).morphTargetManager === babylonMorphTargetManager;\r\n                                    }) as Mesh;\r\n                                    if (babylonMesh) {\r\n                                        if (!morphAnimations.has(babylonMesh)) {\r\n                                            morphAnimations.set(babylonMesh, new Map());\r\n                                        }\r\n                                        morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);\r\n                                        morphAnimationMeshes.add(babylonMesh);\r\n                                        sampleAnimations.set(babylonMesh, animation);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // this is the place for the KHR_animation_pointer.\r\n                    }\r\n                }\r\n                morphAnimationMeshes.forEach((mesh) => {\r\n                    const morphTargetManager = mesh.morphTargetManager!;\r\n                    let combinedAnimationGroup: Nullable<Animation> = null;\r\n                    const animationKeys: IAnimationKey[] = [];\r\n                    const sampleAnimation = sampleAnimations.get(mesh)!;\r\n                    const sampleAnimationKeys = sampleAnimation.getKeys();\r\n                    const numAnimationKeys = sampleAnimationKeys.length;\r\n                    /*\r\n                        Due to how glTF expects morph target animation data to be formatted, we need to rearrange the individual morph target animation tracks,\r\n                        such that we have a single animation, where a given keyframe input value has successive output values for each morph target belonging to the manager.\r\n                        See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\r\n                        We do this via constructing a new Animation track, and interleaving the frames of each morph target animation track in the current Animation Group\r\n                        We reuse the Babylon Animation data structure for ease of handling export of cubic spline animation keys, and to reuse the\r\n                        existing _GLTFAnimation.AddAnimation codepath with minimal modification, however the constructed Babylon Animation is NOT intended for use in-engine.\r\n                    */\r\n                    for (let i = 0; i < numAnimationKeys; ++i) {\r\n                        for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                            const morphTarget = morphTargetManager.getTarget(j);\r\n                            const animationsByMorphTarget = morphAnimations.get(mesh);\r\n                            if (animationsByMorphTarget) {\r\n                                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);\r\n                                if (morphTargetAnimation) {\r\n                                    if (!combinedAnimationGroup) {\r\n                                        combinedAnimationGroup = new Animation(\r\n                                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                                            \"influence\",\r\n                                            morphTargetAnimation.framePerSecond,\r\n                                            Animation.ANIMATIONTYPE_FLOAT,\r\n                                            morphTargetAnimation.loopMode,\r\n                                            morphTargetAnimation.enableBlending\r\n                                        );\r\n                                    }\r\n                                    animationKeys.push(morphTargetAnimation.getKeys()[i]);\r\n                                } else {\r\n                                    animationKeys.push({\r\n                                        frame: animationGroup.from + (animationGroupFrameDiff / numAnimationKeys) * i,\r\n                                        value: morphTarget.influence,\r\n                                        inTangent: sampleAnimationKeys[0].inTangent ? 0 : undefined,\r\n                                        outTangent: sampleAnimationKeys[0].outTangent ? 0 : undefined,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    combinedAnimationGroup!.setKeys(animationKeys);\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup!);\r\n                    if (animationInfo) {\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                            glTFAnimation,\r\n                            mesh,\r\n                            combinedAnimationGroup!,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            false,\r\n                            morphTargetManager?.numTargets\r\n                        );\r\n                    }\r\n                });\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _AddAnimation(\r\n        name: string,\r\n        glTFAnimation: IAnimation,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        dataAccessorType: AccessorType,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number,\r\n        convertToRightHanded: boolean,\r\n        morphAnimationChannels?: number\r\n    ) {\r\n        const animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            /*\r\n             * Now that we have the glTF converted morph target animation data,\r\n             * we can remove redundant input data so that we have n input frames,\r\n             * and morphAnimationChannels * n output frames\r\n             */\r\n            if (morphAnimationChannels) {\r\n                let index = 0;\r\n                let currentInput: number = 0;\r\n                const newInputs: number[] = [];\r\n                while (animationData.inputs.length > 0) {\r\n                    currentInput = animationData.inputs.shift()!;\r\n                    if (index % morphAnimationChannels == 0) {\r\n                        newInputs.push(currentInput);\r\n                    }\r\n                    index++;\r\n                }\r\n                animationData.inputs = newInputs;\r\n            }\r\n\r\n            const nodeIndex = nodeMap.get(babylonTransformNode);\r\n\r\n            // Create buffer view and accessor for key frames.\r\n            const inputData = new Float32Array(animationData.inputs);\r\n            bufferView = bufferManager.createBufferView(inputData);\r\n            accessor = bufferManager.createAccessor(bufferView, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, undefined, {\r\n                min: [animationData.inputsMin],\r\n                max: [animationData.inputsMax],\r\n            });\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // Perform conversions on keyed values while also building their buffer.\r\n            const rotationQuaternion = new Quaternion();\r\n            const eulerVec3 = new Vector3();\r\n            const position = new Vector3();\r\n            const isCamera = babylonTransformNode instanceof Camera;\r\n\r\n            const elementCount = GetAccessorElementCount(dataAccessorType);\r\n            const outputData = new Float32Array(animationData.outputs.length * elementCount);\r\n            animationData.outputs.forEach(function (output: number[], index: number) {\r\n                let outputToWrite: number[] = output;\r\n                switch (animationChannelTargetPath) {\r\n                    case AnimationChannelTargetPath.TRANSLATION:\r\n                        if (convertToRightHanded) {\r\n                            Vector3.FromArrayToRef(output, 0, position);\r\n                            ConvertToRightHandedPosition(position);\r\n                            position.toArray(outputToWrite);\r\n                        }\r\n                        break;\r\n                    case AnimationChannelTargetPath.ROTATION:\r\n                        if (output.length === 4) {\r\n                            Quaternion.FromArrayToRef(output, 0, rotationQuaternion);\r\n                        } else {\r\n                            outputToWrite = new Array(4); // Will need 4, not 3, for a quaternion\r\n                            Vector3.FromArrayToRef(output, 0, eulerVec3);\r\n                            Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);\r\n                        }\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedRotation(rotationQuaternion);\r\n                            if (isCamera) {\r\n                                Rotate180Y(rotationQuaternion);\r\n                            }\r\n                        }\r\n\r\n                        rotationQuaternion.toArray(outputToWrite);\r\n                        break;\r\n                }\r\n                outputData.set(outputToWrite, index * elementCount);\r\n            });\r\n\r\n            // Create buffer view and accessor for keyed values.\r\n            bufferView = bufferManager.createBufferView(outputData);\r\n            accessor = bufferManager.createAccessor(bufferView, dataAccessorType, AccessorComponentType.FLOAT, animationData.outputs.length);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex,\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath,\r\n                },\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param sampleRate\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param minMaxFrames\r\n     * @param minMaxFrames.min\r\n     * @param minMaxFrames.max\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        minFrame: number,\r\n        maxFrame: number,\r\n        fps: number,\r\n        sampleRate: number,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        minMaxFrames: { min: number; max: number },\r\n        useQuaternion: boolean\r\n    ) {\r\n        let value: number | Vector3 | Quaternion;\r\n        const quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        const keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value)) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) {\r\n                        // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            } else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value)) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                } else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    const state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode,\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(\r\n        factor: number,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): Vector3 | Quaternion {\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);\r\n        // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n        const property = animation.targetProperty.split(\".\");\r\n        const componentName = property ? property[1] : \"\"; // x, y, z, or w component\r\n        const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n        switch (componentName) {\r\n            case \"x\":\r\n            case \"y\":\r\n            case \"z\": {\r\n                value[componentName] = factor;\r\n                break;\r\n            }\r\n            case \"w\": {\r\n                (value as Quaternion).w = factor;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`glTFAnimation: Unsupported component name \"${componentName}\"!`);\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(\r\n        babylonTransformNode: Node,\r\n        value: number | Vector3 | Quaternion,\r\n        time: number,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        quaternionCache: Quaternion,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        let cacheValue: Vector3 | Quaternion | number;\r\n        inputs.push(time);\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n            outputs.push([value as number]);\r\n            return;\r\n        }\r\n\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\r\n        }\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                quaternionCache = value as Quaternion;\r\n            } else {\r\n                cacheValue = value as Vector3;\r\n                Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n            }\r\n            outputs.push(quaternionCache.asArray());\r\n        } else {\r\n            // scaling and position animation\r\n            cacheValue = value as Vector3;\r\n            outputs.push(cacheValue.asArray());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        for (const keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        animation.getKeys().forEach(function (keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: Node, animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                const q = (babylonTransformNode as TransformNode).rotationQuaternion;\r\n                basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();\r\n            } else {\r\n                const r: Vector3 = (babylonTransformNode as TransformNode).rotation;\r\n                basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();\r\n            }\r\n        } else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            const p: Vector3 = (babylonTransformNode as TransformNode).position;\r\n            basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();\r\n        } else {\r\n            // scale\r\n            const s: Vector3 = (babylonTransformNode as TransformNode).scaling;\r\n            basePositionRotationOrScale = (s ?? Vector3.One()).asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param babylonTransformNode\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(\r\n        keyFrame: IAnimationKey,\r\n        animation: Animation,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        babylonTransformNode: Node,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion | number>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            let value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n        } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                outputs.push([keyFrame.value]);\r\n            } else {\r\n                // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n                newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(\r\n                    keyFrame.value as number,\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    useQuaternion\r\n                );\r\n                if (newPositionRotationOrScale) {\r\n                    if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                        const posRotScale = useQuaternion\r\n                            ? (newPositionRotationOrScale as Quaternion)\r\n                            : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                        outputs.push(posRotScale.asArray());\r\n                    }\r\n                    outputs.push(newPositionRotationOrScale.asArray());\r\n                }\r\n            }\r\n        } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            outputs.push((keyFrame.value as Quaternion).normalize().asArray());\r\n        } else {\r\n            Tools.Error(\"glTFAnimation: Unsupported key frame values for animation!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(\r\n        keyFrames: IAnimationKey[],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): { interpolationType: AnimationSamplerInterpolation; shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            } else {\r\n                if (interpolationType) {\r\n                    if (\r\n                        interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP && interpolationType !== AnimationSamplerInterpolation.STEP)\r\n                    ) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    } else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     */\r\n    private static _AddSplineTangent(\r\n        tangentType: _TangentType,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        interpolation: AnimationSamplerInterpolation,\r\n        keyFrame: IAnimationKey,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let tangent: number[];\r\n        const tangentValue: Vector3 | Quaternion | number = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).asArray();\r\n                    } else {\r\n                        const array = tangentValue as Vector3;\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n                } else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            } else if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                if (tangentValue) {\r\n                    tangent = [tangentValue as number];\r\n                } else {\r\n                    tangent = [0];\r\n                }\r\n            } else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).asArray();\r\n                } else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static _CalculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number; max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function (keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n    }\r\n}\r\n", "import type { IBufferView, IAccessor } from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType } from \"babylonjs-gltf2interface\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\n\r\nimport { NormalizeTangent } from \"./glTFUtilities\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Interface to store morph target information.\r\n * @internal\r\n */\r\nexport interface IMorphTargetData {\r\n    attributes: Record<string, number>;\r\n    influence: number;\r\n    name: string;\r\n}\r\n\r\nexport function BuildMorphTargetBuffers(\r\n    morphTarget: MorphTarget,\r\n    mesh: AbstractMesh,\r\n    bufferManager: BufferManager,\r\n    bufferViews: IBufferView[],\r\n    accessors: IAccessor[],\r\n    convertToRightHanded: boolean\r\n): IMorphTargetData {\r\n    const result: IMorphTargetData = {\r\n        attributes: {},\r\n        influence: morphTarget.influence,\r\n        name: morphTarget.name,\r\n    };\r\n\r\n    const geometry = mesh.geometry;\r\n    if (!geometry) {\r\n        Tools.Warn(\"Attempted to export morph target data from a mesh without geometry. This should not happen.\");\r\n        return result;\r\n    }\r\n\r\n    const flipX = convertToRightHanded ? -1 : 1;\r\n    const floatSize = 4;\r\n    const difference = Vector3.Zero();\r\n    let vertexStart = 0;\r\n    let vertexCount = 0;\r\n\r\n    if (morphTarget.hasPositions) {\r\n        const morphPositions = morphTarget.getPositions()!;\r\n        const originalPositions = geometry.getVerticesData(VertexBuffer.PositionKind); // Bypasses any instance data of mesh\r\n\r\n        if (originalPositions) {\r\n            const positionData = new Float32Array(originalPositions.length);\r\n            const min = [Infinity, Infinity, Infinity];\r\n            const max = [-Infinity, -Infinity, -Infinity];\r\n            vertexCount = originalPositions.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalPosition = Vector3.FromArray(originalPositions, i * 3);\r\n                const morphPosition = Vector3.FromArray(morphPositions, i * 3);\r\n                morphPosition.subtractToRef(originalPosition, difference);\r\n                difference.x *= flipX;\r\n\r\n                min[0] = Math.min(min[0], difference.x);\r\n                max[0] = Math.max(max[0], difference.x);\r\n\r\n                min[1] = Math.min(min[1], difference.y);\r\n                max[1] = Math.max(max[1], difference.y);\r\n\r\n                min[2] = Math.min(min[2], difference.z);\r\n                max[2] = Math.max(max[2], difference.z);\r\n\r\n                positionData[i * 3] = difference.x;\r\n                positionData[i * 3 + 1] = difference.y;\r\n                positionData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphPositions.length / 3, 0, { min, max });\r\n            accessors.push(accessor);\r\n            result.attributes[\"POSITION\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasNormals) {\r\n        const morphNormals = morphTarget.getNormals()!;\r\n        const originalNormals = geometry.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n        if (originalNormals) {\r\n            const normalData = new Float32Array(originalNormals.length);\r\n            vertexCount = originalNormals.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();\r\n                const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();\r\n                morphNormal.subtractToRef(originalNormal, difference);\r\n\r\n                normalData[i * 3] = difference.x * flipX;\r\n                normalData[i * 3 + 1] = difference.y;\r\n                normalData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphNormals.length / 3, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"NORMAL\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasTangents) {\r\n        const morphTangents = morphTarget.getTangents()!;\r\n        const originalTangents = geometry.getVerticesData(VertexBuffer.TangentKind);\r\n\r\n        if (originalTangents) {\r\n            vertexCount = originalTangents.length / 4;\r\n            const tangentData = new Float32Array(vertexCount * 3);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                // Only read the x, y, z components and ignore w\r\n                const originalTangent = Vector3.FromArray(originalTangents, i * 4);\r\n                NormalizeTangent(originalTangent);\r\n\r\n                // Morph target tangents omit the w component so it won't be present in the data\r\n                const morphTangent = Vector3.FromArray(morphTangents, i * 3);\r\n                NormalizeTangent(morphTangent);\r\n\r\n                morphTangent.subtractToRef(originalTangent, difference);\r\n                tangentData[i * 3] = difference.x * flipX;\r\n                tangentData[i * 3 + 1] = difference.y;\r\n                tangentData[i * 3 + 2] = difference.z;\r\n            }\r\n            const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"TANGENT\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasColors) {\r\n        const morphColors = morphTarget.getColors()!;\r\n        const originalColors = geometry.getVerticesData(VertexBuffer.ColorKind);\r\n        const buffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);\r\n\r\n        if (originalColors && buffer) {\r\n            const componentSize = buffer.getSize();\r\n\r\n            vertexCount = originalColors.length / componentSize;\r\n            const colorData = new Float32Array(vertexCount * componentSize);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                if (componentSize === 3) {\r\n                    const originalColor = Vector3.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector3.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference);\r\n                    colorData[i * 3] = difference.x;\r\n                    colorData[i * 3 + 1] = difference.y;\r\n                    colorData[i * 3 + 2] = difference.z;\r\n                } else if (componentSize === 4) {\r\n                    const difference4 = new Vector4();\r\n                    const originalColor = Vector4.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector4.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference4);\r\n                    colorData[i * 4] = difference4.x;\r\n                    colorData[i * 4 + 1] = difference4.y;\r\n                    colorData[i * 4 + 2] = difference4.z;\r\n                    colorData[i * 4 + 3] = difference4.w;\r\n                } else {\r\n                    Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);\r\n                }\r\n            }\r\n            const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);\r\n            const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? AccessorType.VEC3 : AccessorType.VEC4, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"COLOR_0\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n", "import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n    ImageMimeType,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType, CameraType } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport { TmpVectors, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Buffer } from \"core/Buffers/buffer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport {\r\n    ConvertToRightHandedPosition,\r\n    ConvertToRightHandedRotation,\r\n    DataArrayToUint8Array,\r\n    GetAccessorType,\r\n    GetAttributeType,\r\n    GetMinMax,\r\n    GetPrimitiveMode,\r\n    IsTriangleFillMode,\r\n    IsChildCollapsible,\r\n    FloatsNeed16BitInteger,\r\n    IsStandardVertexAttribute,\r\n    IndicesArrayToTypedSubarray,\r\n    GetVertexBufferInfo,\r\n    CollapseChildIntoParent,\r\n    Rotate180Y,\r\n    DefaultTranslation,\r\n    DefaultScale,\r\n    DefaultRotation,\r\n    ConvertToRightHandedTransformMatrix,\r\n} from \"./glTFUtilities\";\r\nimport { IsNoopNode } from \"../../exportUtils\";\r\nimport { BufferManager } from \"./bufferManager\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { EnumerateFloatValues, AreIndices32Bits } from \"core/Buffers/bufferUtils\";\r\nimport type { Bone, Skeleton } from \"core/Bones\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport type { MorphTarget } from \"core/Morph\";\r\nimport { BuildMorphTargetBuffers } from \"./glTFMorphTargetsUtilities\";\r\nimport type { IMorphTargetData } from \"./glTFMorphTargetsUtilities\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { GreasedLineBaseMesh } from \"core/Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { DataWriter } from \"./dataWriter\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nclass ExporterState {\r\n    // Babylon indices array, start, count, offset, flip -> glTF accessor index\r\n    private _indicesAccessorMap = new Map<Nullable<IndicesArray>, Map<number, Map<number, Map<number, Map<boolean, number>>>>>();\r\n\r\n    // Babylon buffer -> glTF buffer view\r\n    private _vertexBufferViewMap = new Map<Buffer, IBufferView>();\r\n\r\n    // Babylon vertex buffer, start, count -> glTF accessor index\r\n    private _vertexAccessorMap = new Map<VertexBuffer, Map<number, Map<number, number>>>();\r\n\r\n    private _remappedBufferView = new Map<Buffer, Map<VertexBuffer, IBufferView>>();\r\n\r\n    private _meshMorphTargetMap = new Map<AbstractMesh, IMorphTargetData[]>();\r\n\r\n    private _vertexMapColorAlpha = new Map<VertexBuffer, boolean>();\r\n\r\n    private _exportedNodes = new Set<Node>();\r\n\r\n    // Babylon mesh -> glTF mesh index\r\n    private _meshMap = new Map<AbstractMesh, number>();\r\n\r\n    public constructor(convertToRightHanded: boolean, wasAddedByNoopNode: boolean) {\r\n        this.convertToRightHanded = convertToRightHanded;\r\n        this.wasAddedByNoopNode = wasAddedByNoopNode;\r\n    }\r\n\r\n    public readonly convertToRightHanded: boolean;\r\n\r\n    public readonly wasAddedByNoopNode: boolean;\r\n\r\n    // Only used when convertToRightHanded is true.\r\n    public readonly convertedToRightHandedBuffers = new Map<Buffer, Uint8Array>();\r\n\r\n    public getIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean): number | undefined {\r\n        return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);\r\n    }\r\n\r\n    public setIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean, accessorIndex: number): void {\r\n        let map1 = this._indicesAccessorMap.get(indices);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, Map<number, Map<boolean, number>>>>();\r\n            this._indicesAccessorMap.set(indices, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, Map<number, Map<boolean, number>>>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        let map3 = map2.get(count);\r\n        if (!map3) {\r\n            map3 = new Map<number, Map<boolean, number>>();\r\n            map2.set(count, map3);\r\n        }\r\n\r\n        let map4 = map3.get(offset);\r\n        if (!map4) {\r\n            map4 = new Map<boolean, number>();\r\n            map3.set(offset, map4);\r\n        }\r\n\r\n        map4.set(flip, accessorIndex);\r\n    }\r\n\r\n    public pushExportedNode(node: Node) {\r\n        if (!this._exportedNodes.has(node)) {\r\n            this._exportedNodes.add(node);\r\n        }\r\n    }\r\n\r\n    public getNodesSet(): Set<Node> {\r\n        return this._exportedNodes;\r\n    }\r\n\r\n    public getVertexBufferView(buffer: Buffer): IBufferView | undefined {\r\n        return this._vertexBufferViewMap.get(buffer);\r\n    }\r\n\r\n    public setVertexBufferView(buffer: Buffer, bufferView: IBufferView): void {\r\n        this._vertexBufferViewMap.set(buffer, bufferView);\r\n    }\r\n\r\n    public setRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer, bufferView: IBufferView) {\r\n        this._remappedBufferView.set(buffer, new Map<VertexBuffer, IBufferView>());\r\n        this._remappedBufferView.get(buffer)!.set(vertexBuffer, bufferView);\r\n    }\r\n\r\n    public getRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer): IBufferView | undefined {\r\n        return this._remappedBufferView.get(buffer)?.get(vertexBuffer);\r\n    }\r\n\r\n    public getVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number): number | undefined {\r\n        return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);\r\n    }\r\n\r\n    public setVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number, accessorIndex: number): void {\r\n        let map1 = this._vertexAccessorMap.get(vertexBuffer);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, number>>();\r\n            this._vertexAccessorMap.set(vertexBuffer, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, number>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        map2.set(count, accessorIndex);\r\n    }\r\n\r\n    public hasVertexColorAlpha(vertexBuffer: VertexBuffer): boolean {\r\n        return this._vertexMapColorAlpha.get(vertexBuffer) || false;\r\n    }\r\n\r\n    public setHasVertexColorAlpha(vertexBuffer: VertexBuffer, hasAlpha: boolean) {\r\n        return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);\r\n    }\r\n\r\n    public getMesh(mesh: AbstractMesh): number | undefined {\r\n        return this._meshMap.get(mesh);\r\n    }\r\n\r\n    public setMesh(mesh: AbstractMesh, meshIndex: number): void {\r\n        this._meshMap.set(mesh, meshIndex);\r\n    }\r\n\r\n    public bindMorphDataToMesh(mesh: AbstractMesh, morphData: IMorphTargetData) {\r\n        const morphTargets = this._meshMorphTargetMap.get(mesh) || [];\r\n        this._meshMorphTargetMap.set(mesh, morphTargets);\r\n        if (morphTargets.indexOf(morphData) === -1) {\r\n            morphTargets.push(morphData);\r\n        }\r\n    }\r\n\r\n    public getMorphTargetsFromMesh(mesh: AbstractMesh): IMorphTargetData[] | undefined {\r\n        return this._meshMorphTargetMap.get(mesh);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class GLTFExporter {\r\n    public readonly _glTF: IGLTF = {\r\n        asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n    };\r\n\r\n    public readonly _animations: IAnimation[] = [];\r\n    public readonly _accessors: IAccessor[] = [];\r\n    public readonly _bufferViews: IBufferView[] = [];\r\n    public readonly _cameras: ICamera[] = [];\r\n    public readonly _images: IImage[] = [];\r\n    public readonly _materials: IMaterial[] = [];\r\n    public readonly _meshes: IMesh[] = [];\r\n    public readonly _nodes: INode[] = [];\r\n    public readonly _samplers: ISampler[] = [];\r\n    public readonly _scenes: IScene[] = [];\r\n    public readonly _skins: ISkin[] = [];\r\n    public readonly _textures: ITexture[] = [];\r\n\r\n    public readonly _babylonScene: Scene;\r\n    public readonly _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } } = {};\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private readonly _options: Required<IExportOptions>;\r\n\r\n    public _shouldUseGlb: boolean = false;\r\n\r\n    public readonly _materialExporter = new GLTFMaterialExporter(this);\r\n\r\n    private readonly _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    public readonly _bufferManager = new BufferManager();\r\n\r\n    private readonly _shouldExportNodeMap = new Map<Node, boolean>();\r\n\r\n    // Babylon node -> glTF node index\r\n    private readonly _nodeMap = new Map<Node, number>();\r\n\r\n    // Babylon material -> glTF material index\r\n    public readonly _materialMap = new Map<Material, number>();\r\n    private readonly _camerasMap = new Map<Camera, ICamera>();\r\n    private readonly _nodesCameraMap = new Map<ICamera, INode[]>();\r\n    private readonly _skinMap = new Map<Skeleton, ISkin>();\r\n    private readonly _nodesSkinMap = new Map<ISkin, INode[]>();\r\n\r\n    // A material in this set requires UVs\r\n    public readonly _materialNeedsUVsSet = new Set<Material>();\r\n\r\n    private static readonly _ExtensionNames = new Array<string>();\r\n    private static readonly _ExtensionFactories: { [name: string]: (exporter: GLTFExporter) => IGLTFExporterExtensionV2 } = {};\r\n    private static readonly _ExtensionOrders: { [name: string]: number } = {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtension<T>(\r\n        node: T,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._ApplyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return currentPromise.then(async (newNode) => (newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null));\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtensions<T>(node: T, actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._ApplyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return this._ApplyExtensions(\r\n            node,\r\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n            (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportMaterialAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n        return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    /**\r\n     * Get additional textures for a material\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material\r\n     * @param babylonMaterial The Babylon.js material\r\n     * @returns List of additional textures\r\n     */\r\n    public async _extensionsPostExportMaterialAdditionalTexturesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const output: BaseTexture[] = [];\r\n\r\n        await Promise.all(\r\n            GLTFExporter._ExtensionNames.map(async (name) => {\r\n                const extension = this._extensions[name];\r\n\r\n                if (extension.postExportMaterialAdditionalTexturesAsync) {\r\n                    const textures = await extension.postExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial);\r\n                    output.push(...textures);\r\n                }\r\n            })\r\n        );\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitive(primitive: IMeshPrimitive): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMeshPrimitive) {\r\n                extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async _extensionsPreGenerateBinaryAsync(): Promise<void> {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.preGenerateBinaryAsync) {\r\n                // eslint-disable-next-line no-await-in-loop\r\n                await extension.preGenerateBinaryAsync(this._bufferManager);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                this._glTF.extensionsUsed ||= [];\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    this._glTF.extensionsRequired ||= [];\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                this._glTF.extensions ||= {};\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = GLTFExporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    public constructor(babylonScene: Nullable<Scene> = EngineStore.LastCreatedScene, options?: IExportOptions) {\r\n        if (!babylonScene) {\r\n            throw new Error(\"No scene available to export\");\r\n        }\r\n\r\n        this._babylonScene = babylonScene;\r\n\r\n        this._options = {\r\n            shouldExportNode: () => true,\r\n            shouldExportAnimation: () => true,\r\n            metadataSelector: (metadata) => metadata?.gltf?.extras,\r\n            animationSampleRate: 1 / 60,\r\n            exportWithoutWaitingForScene: false,\r\n            exportUnusedUVs: false,\r\n            removeNoopRootNodes: true,\r\n            includeCoordinateSystemConversionNodes: false,\r\n            meshCompressionMethod: \"None\",\r\n            ...options,\r\n        };\r\n\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const key in this._extensions) {\r\n            const extension = this._extensions[key];\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public static RegisterExtension(name: string, factory: (exporter: GLTFExporter) => IGLTFExporterExtensionV2, order: number = 100): void {\r\n        if (GLTFExporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        GLTFExporter._ExtensionFactories[name] = factory;\r\n        const extensionOrder = order ?? 0; // Use provided order or default to 0\r\n        GLTFExporter._ExtensionOrders[name] = extensionOrder;\r\n\r\n        // Find the correct position to insert the extension based on order\r\n        let insertIndex = GLTFExporter._ExtensionNames.length;\r\n        for (let i = 0; i < GLTFExporter._ExtensionNames.length; i++) {\r\n            const existingName = GLTFExporter._ExtensionNames[i];\r\n            const existingOrder = GLTFExporter._ExtensionOrders[existingName];\r\n\r\n            // If the order is less, insert before.\r\n            if (extensionOrder < existingOrder) {\r\n                insertIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        GLTFExporter._ExtensionNames.splice(insertIndex, 0, name);\r\n    }\r\n\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFExporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete GLTFExporter._ExtensionFactories[name];\r\n        delete GLTFExporter._ExtensionOrders[name];\r\n\r\n        const index = GLTFExporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFExporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _generateJSON(bufferByteLength: number, fileName?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: bufferByteLength };\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            this._glTF.images = this._images;\r\n        }\r\n\r\n        if (!this._shouldUseGlb) {\r\n            buffer.uri = fileName + \".bin\";\r\n        }\r\n\r\n        return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n    }\r\n\r\n    public async generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);\r\n\r\n        const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n        const glTFFileName = glTFPrefix + \".gltf\";\r\n        const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n        const container = new GLTFData();\r\n\r\n        container.files[glTFFileName] = jsonText;\r\n        container.files[glTFBinFile] = bin;\r\n\r\n        if (this._imageData) {\r\n            for (const image in this._imageData) {\r\n                container.files[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n            }\r\n        }\r\n\r\n        return container;\r\n    }\r\n\r\n    private async _generateBinaryAsync(): Promise<Uint8Array> {\r\n        await this._exportSceneAsync();\r\n        await this._extensionsPreGenerateBinaryAsync();\r\n        return this._bufferManager.generateBinary(this._bufferViews);\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    public async generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        this._shouldUseGlb = true;\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength);\r\n\r\n        const glbFileName = glTFPrefix + \".glb\";\r\n        const headerLength = 12;\r\n        const chunkLengthPrefix = 8;\r\n        let jsonLength = jsonText.length;\r\n        let encodedJsonText;\r\n        // Make use of TextEncoder when available\r\n        if (typeof TextEncoder !== \"undefined\") {\r\n            const encoder = new TextEncoder();\r\n            encodedJsonText = encoder.encode(jsonText);\r\n            jsonLength = encodedJsonText.length;\r\n        }\r\n        const jsonPadding = this._getPadding(jsonLength);\r\n        const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n\r\n        const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;\r\n\r\n        const dataWriter = new DataWriter(byteLength);\r\n\r\n        // Header\r\n        dataWriter.writeUInt32(0x46546c67); // \"glTF\"\r\n        dataWriter.writeUInt32(2); // Version\r\n        dataWriter.writeUInt32(byteLength); // Total bytes in file\r\n\r\n        // JSON chunk length prefix\r\n        dataWriter.writeUInt32(jsonLength + jsonPadding);\r\n        dataWriter.writeUInt32(0x4e4f534a); // \"JSON\"\r\n\r\n        // JSON chunk bytes\r\n        if (encodedJsonText) {\r\n            // If TextEncoder was available, we can simply copy the encoded array\r\n            dataWriter.writeTypedArray(encodedJsonText);\r\n        } else {\r\n            const blankCharCode = \"_\".charCodeAt(0);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                const charCode = jsonText.charCodeAt(i);\r\n                // If the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                if (charCode != jsonText.codePointAt(i)) {\r\n                    dataWriter.writeUInt8(blankCharCode);\r\n                } else {\r\n                    dataWriter.writeUInt8(charCode);\r\n                }\r\n            }\r\n        }\r\n\r\n        // JSON padding\r\n        for (let i = 0; i < jsonPadding; ++i) {\r\n            dataWriter.writeUInt8(0x20);\r\n        }\r\n\r\n        // Binary chunk length prefix\r\n        dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);\r\n        dataWriter.writeUInt32(0x004e4942); // \"BIN\"\r\n\r\n        // Binary chunk bytes\r\n        dataWriter.writeTypedArray(binaryBuffer);\r\n\r\n        // Binary padding\r\n        for (let i = 0; i < binPadding; ++i) {\r\n            dataWriter.writeUInt8(0);\r\n        }\r\n\r\n        const container = new GLTFData();\r\n        container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: \"application/octet-stream\" });\r\n\r\n        return container;\r\n    }\r\n\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHanded: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n\r\n        if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion =\r\n            babylonTransformNode.rotationQuaternion?.clone() ||\r\n            Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedRotation(rotationQuaternion);\r\n            }\r\n\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: TargetCamera, convertToRightHanded: boolean): void {\r\n        // Camera types store rotation differently (e.g., ArcRotateCamera uses alpha/beta, others use rotationQuaternion).\r\n        // Extract the transform from the world matrix instead of handling each case separately.\r\n        const translation = TmpVectors.Vector3[0];\r\n        const rotationQuaternion = TmpVectors.Quaternion[0];\r\n        const cameraWorldMatrix = babylonCamera.getWorldMatrix();\r\n\r\n        if (babylonCamera.parent) {\r\n            // Camera.getWorldMatrix returns global coordinates. GLTF node must use local coordinates. If camera has parent we need to use local translation/rotation.\r\n            const parentInvWorldMatrix = babylonCamera.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            const cameraLocal = cameraWorldMatrix.multiplyToRef(parentInvWorldMatrix, TmpVectors.Matrix[1]);\r\n            cameraLocal.decompose(undefined, rotationQuaternion, translation);\r\n        } else {\r\n            cameraWorldMatrix.decompose(undefined, rotationQuaternion, translation);\r\n        }\r\n\r\n        if (!translation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (convertToRightHanded) {\r\n            ConvertToRightHandedRotation(rotationQuaternion);\r\n        }\r\n\r\n        // Left-handed scenes have cameras that always face Z+ (opposite of glTF's Z-).\r\n        // Use scene coordinate system rather than convertToRightHanded, since some\r\n        // cameras may not need convertToRightHanded but still need correction to face Z-.\r\n        if (!this._babylonScene.useRightHandedSystem) {\r\n            Rotate180Y(rotationQuaternion);\r\n        }\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            node.rotation = rotationQuaternion.asArray();\r\n        }\r\n    }\r\n\r\n    // Export babylon cameras to glTF cameras\r\n    private _listAvailableCameras(): void {\r\n        for (const camera of this._babylonScene.cameras) {\r\n            const glTFCamera: ICamera = {\r\n                type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n            };\r\n\r\n            if (camera.name) {\r\n                glTFCamera.name = camera.name;\r\n            }\r\n\r\n            if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                glTFCamera.perspective = {\r\n                    aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                    yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                glTFCamera.orthographic = {\r\n                    xmag: halfWidth,\r\n                    ymag: halfHeight,\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            }\r\n            this._camerasMap.set(camera, glTFCamera);\r\n        }\r\n    }\r\n\r\n    // Cleanup unused cameras and assign index to nodes.\r\n    private _exportAndAssignCameras(): void {\r\n        const gltfCameras = Array.from(this._camerasMap.values());\r\n        for (const gltfCamera of gltfCameras) {\r\n            const usedNodes = this._nodesCameraMap.get(gltfCamera);\r\n            if (usedNodes !== undefined) {\r\n                this._cameras.push(gltfCamera);\r\n                for (const node of usedNodes) {\r\n                    node.camera = this._cameras.length - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Collects all skins in a skins map so nodes can reference it during node parsing.\r\n    private _listAvailableSkeletons(): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin: ISkin = { joints: [] };\r\n            this._skinMap.set(skeleton, skin);\r\n        }\r\n    }\r\n\r\n    private _exportAndAssignSkeletons(leftHandNodes: Set<Node>): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin = this._skinMap.get(skeleton);\r\n            if (skin == undefined) {\r\n                continue;\r\n            }\r\n\r\n            // The bones (joints) of a skeleton (skin) must be exported in the same order as they appear in vertex attributes,\r\n            // which is indicated by getIndex and may not match a bone's index in skeleton.bones\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set joints indices to scene nodes.\r\n            const inverseBindMatrices: Matrix[] = [];\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex]; // Assumes no gaps in bone indices\r\n                const transformNode = bone.getTransformNode();\r\n                const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : undefined;\r\n                if (nodeIndex === undefined) {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported.\");\r\n                    continue; // The indices may be out-of-sync after this and break the skinning.\r\n                }\r\n                skin.joints.push(nodeIndex);\r\n\r\n                const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();\r\n                if (leftHandNodes.has(transformNode!)) {\r\n                    ConvertToRightHandedTransformMatrix(boneMatrix);\r\n                }\r\n                inverseBindMatrices.push(boneMatrix);\r\n            }\r\n\r\n            // Nodes that use this skin.\r\n            const skinnedNodes = this._nodesSkinMap.get(skin);\r\n\r\n            // Only export the skin if it has at least one joint and is used by a mesh.\r\n            if (skin.joints.length > 0 && skinnedNodes !== undefined) {\r\n                const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16); // Always a 4 x 4 matrix of 32 bit float\r\n                inverseBindMatrices.forEach((mat: Matrix, index: number) => {\r\n                    inverseBindMatricesData.set(mat.m, index * 16);\r\n                });\r\n\r\n                const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.MAT4, AccessorComponentType.FLOAT, inverseBindMatrices.length));\r\n                skin.inverseBindMatrices = this._accessors.length - 1;\r\n\r\n                this._skins.push(skin);\r\n                const skinIndex = this._skins.length - 1;\r\n                for (const skinnedNode of skinnedNodes) {\r\n                    skinnedNode.skin = skinIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _exportSceneAsync(): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n\r\n        // Scene metadata\r\n        if (this._babylonScene.metadata) {\r\n            const extras = this._options.metadataSelector(this._babylonScene.metadata);\r\n            if (extras) {\r\n                scene.extras = extras;\r\n            }\r\n        }\r\n\r\n        //  TODO:\r\n        //  deal with this from the loader:\r\n        //  babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n        //  babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n\r\n        const rootNodesRH = new Array<Node>();\r\n        const rootNodesLH = new Array<Node>();\r\n        const rootNoopNodesRH = new Array<Node>();\r\n\r\n        for (const rootNode of this._babylonScene.rootNodes) {\r\n            if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {\r\n                rootNoopNodesRH.push(...rootNode.getChildren());\r\n            } else if (this._babylonScene.useRightHandedSystem) {\r\n                rootNodesRH.push(rootNode);\r\n            } else {\r\n                rootNodesLH.push(rootNode);\r\n            }\r\n        }\r\n\r\n        this._listAvailableCameras();\r\n        this._listAvailableSkeletons();\r\n\r\n        const stateLH = new ExporterState(true, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesLH, stateLH)));\r\n        const stateRH = new ExporterState(false, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesRH, stateRH)));\r\n        const noopRH = new ExporterState(false, true);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNoopNodesRH, noopRH)));\r\n\r\n        if (scene.nodes.length) {\r\n            this._scenes.push(scene);\r\n        }\r\n\r\n        this._exportAndAssignCameras();\r\n        this._exportAndAssignSkeletons(stateLH.getNodesSet());\r\n\r\n        if (this._babylonScene.animationGroups.length) {\r\n            _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                this._babylonScene,\r\n                this._animations,\r\n                this._nodeMap,\r\n                this._bufferManager,\r\n                this._bufferViews,\r\n                this._accessors,\r\n                this._animationSampleRate,\r\n                stateLH.getNodesSet(),\r\n                this._options.shouldExportAnimation\r\n            );\r\n        }\r\n    }\r\n\r\n    private _shouldExportNode(babylonNode: Node): boolean {\r\n        let result = this._shouldExportNodeMap.get(babylonNode);\r\n\r\n        if (result === undefined) {\r\n            result = this._options.shouldExportNode(babylonNode);\r\n            this._shouldExportNodeMap.set(babylonNode, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private async _exportNodesAsync(babylonRootNodes: Node[], state: ExporterState): Promise<number[]> {\r\n        const nodes = new Array<number>();\r\n\r\n        this._exportBuffers(babylonRootNodes, state);\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonNode, nodes, state);\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    private _collectBuffers(\r\n        babylonNode: Node,\r\n        bufferToVertexBuffersMap: Map<Buffer, VertexBuffer[]>,\r\n        vertexBufferToMeshesMap: Map<VertexBuffer, AbstractMesh[]>,\r\n        morphTargetsToMeshesMap: Map<MorphTarget, AbstractMesh[]>,\r\n        state: ExporterState\r\n    ): void {\r\n        if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {\r\n            const vertexBuffers = babylonNode.geometry.getVertexBuffers();\r\n            if (vertexBuffers) {\r\n                for (const kind in vertexBuffers) {\r\n                    if (!IsStandardVertexAttribute(kind)) {\r\n                        continue;\r\n                    }\r\n                    const vertexBuffer = vertexBuffers[kind];\r\n                    state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);\r\n                    const buffer = vertexBuffer._buffer;\r\n                    const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];\r\n                    bufferToVertexBuffersMap.set(buffer, vertexBufferArray);\r\n                    if (vertexBufferArray.indexOf(vertexBuffer) === -1) {\r\n                        vertexBufferArray.push(vertexBuffer);\r\n                    }\r\n\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];\r\n                    vertexBufferToMeshesMap.set(vertexBuffer, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n\r\n            if (morphTargetManager) {\r\n                for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {\r\n                    const morphTarget = morphTargetManager.getTarget(morphIndex);\r\n\r\n                    const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];\r\n                    morphTargetsToMeshesMap.set(morphTarget, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);\r\n        }\r\n    }\r\n\r\n    private _exportBuffers(babylonRootNodes: Node[], state: ExporterState): void {\r\n        const bufferToVertexBuffersMap = new Map<Buffer, VertexBuffer[]>();\r\n        const vertexBufferToMeshesMap = new Map<VertexBuffer, AbstractMesh[]>();\r\n        const morphTargetsMeshesMap = new Map<MorphTarget, AbstractMesh[]>();\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);\r\n        }\r\n\r\n        const buffers = Array.from(bufferToVertexBuffersMap.keys());\r\n\r\n        for (const buffer of buffers) {\r\n            const data = buffer.getData();\r\n            if (!data) {\r\n                throw new Error(\"Buffer data is not available\");\r\n            }\r\n\r\n            const vertexBuffers = bufferToVertexBuffersMap.get(buffer);\r\n\r\n            if (!vertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const byteStride = vertexBuffers[0].byteStride;\r\n            if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {\r\n                throw new Error(\"Vertex buffers pointing to the same buffer must have the same byte stride\");\r\n            }\r\n\r\n            const bytes = DataArrayToUint8Array(data).slice();\r\n\r\n            // Apply normalizations and color corrections to buffer data in-place.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                switch (kind) {\r\n                    // Normalize normals and tangents.\r\n                    case VertexBuffer.NormalKind:\r\n                    case VertexBuffer.TangentKind: {\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);\r\n                            if (length > 0) {\r\n                                const invLength = 1 / length;\r\n                                values[0] *= invLength;\r\n                                values[1] *= invLength;\r\n                                values[2] *= invLength;\r\n                            }\r\n                        });\r\n                        break;\r\n                    }\r\n                    // Convert StandardMaterial vertex colors from gamma to linear space.\r\n                    case VertexBuffer.ColorKind: {\r\n                        const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;\r\n                        if (stdMaterialCount == 0) {\r\n                            break; // Buffer not used by StandardMaterials, so no conversion needed.\r\n                        }\r\n                        // TODO: Implement this case.\r\n                        if (stdMaterialCount != meshes.length) {\r\n                            Logger.Warn(\"Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.\");\r\n                            break;\r\n                        }\r\n                        if (type == VertexBuffer.UNSIGNED_BYTE) {\r\n                            Logger.Warn(\"Converting uint8 vertex colors to linear space. Results may look incorrect.\");\r\n                        }\r\n\r\n                        const vertexData3 = new Color3();\r\n                        const vertexData4 = new Color4();\r\n                        const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            // Using separate Color3 and Color4 objects to ensure the right functions are called.\r\n                            if (values.length === 3) {\r\n                                vertexData3.fromArray(values, 0);\r\n                                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);\r\n                                vertexData3.toArray(values, 0);\r\n                            } else {\r\n                                vertexData4.fromArray(values, 0);\r\n                                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);\r\n                                vertexData4.toArray(values, 0);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Perform coordinate conversions, if needed, to buffer data in-place (only for positions, normals and tangents).\r\n            if (state.convertToRightHanded) {\r\n                for (const vertexBuffer of vertexBuffers) {\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                    const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                    switch (kind) {\r\n                        case VertexBuffer.PositionKind:\r\n                        case VertexBuffer.NormalKind:\r\n                        case VertexBuffer.TangentKind: {\r\n                            EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                                values[0] = -values[0];\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Save converted bytes for min/max computation.\r\n                state.convertedToRightHandedBuffers.set(buffer, bytes);\r\n            }\r\n\r\n            // Create buffer view, but defer accessor creation for later. Instead, track it via ExporterState.\r\n            const bufferView = this._bufferManager.createBufferView(bytes, byteStride);\r\n            state.setVertexBufferView(buffer, bufferView);\r\n\r\n            const floatMatricesIndices = new Map<VertexBuffer, FloatArray>();\r\n\r\n            // If buffers are of type MatricesIndicesKind and have float values, we need to create a new buffer instead.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n                switch (kind) {\r\n                    case VertexBuffer.MatricesIndicesKind:\r\n                    case VertexBuffer.MatricesIndicesExtraKind: {\r\n                        if (vertexBuffer.type == VertexBuffer.FLOAT) {\r\n                            const floatData = vertexBuffer.getFloatData(totalVertices);\r\n                            if (floatData !== null) {\r\n                                floatMatricesIndices.set(vertexBuffer, floatData);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (floatMatricesIndices.size !== 0) {\r\n                Logger.Warn(\r\n                    `Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`\r\n                );\r\n            }\r\n\r\n            const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());\r\n\r\n            for (const vertexBuffer of floatArrayVertexBuffers) {\r\n                const array = floatMatricesIndices.get(vertexBuffer);\r\n\r\n                if (!array) {\r\n                    continue;\r\n                }\r\n\r\n                const is16Bit = FloatsNeed16BitInteger(array);\r\n                const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);\r\n                for (let index = 0; index < array.length; index++) {\r\n                    newArray[index] = array[index];\r\n                }\r\n                const bufferView = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));\r\n                state.setRemappedBufferView(buffer, vertexBuffer, bufferView);\r\n            }\r\n        }\r\n\r\n        // Build morph targets buffers\r\n        const morphTargets = Array.from(morphTargetsMeshesMap.keys());\r\n\r\n        for (const morphTarget of morphTargets) {\r\n            const meshes = morphTargetsMeshesMap.get(morphTarget);\r\n\r\n            if (!meshes) {\r\n                continue;\r\n            }\r\n\r\n            const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);\r\n\r\n            for (const mesh of meshes) {\r\n                state.bindMorphDataToMesh(mesh, glTFMorphTarget);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a node to be exported to the glTF file\r\n     * @returns A promise that resolves once the node has been exported\r\n     * @internal\r\n     */\r\n    private async _exportNodeAsync(babylonNode: Node, parentNodeChildren: Array<number>, state: ExporterState): Promise<void> {\r\n        let nodeIndex = this._nodeMap.get(babylonNode);\r\n        if (nodeIndex !== undefined) {\r\n            if (!parentNodeChildren.includes(nodeIndex)) {\r\n                parentNodeChildren.push(nodeIndex);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const node = await this._createNodeAsync(babylonNode, state);\r\n\r\n        if (node) {\r\n            nodeIndex = this._nodes.length;\r\n            this._nodes.push(node);\r\n            this._nodeMap.set(babylonNode, nodeIndex);\r\n            state.pushExportedNode(babylonNode);\r\n            parentNodeChildren.push(nodeIndex);\r\n\r\n            // Process node's animations once the node has been added to nodeMap (TODO: This should be refactored)\r\n            const runtimeGLTFAnimation: IAnimation = {\r\n                name: \"runtime animations\",\r\n                channels: [],\r\n                samplers: [],\r\n            };\r\n            const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n            if (!this._babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                    babylonNode,\r\n                    runtimeGLTFAnimation,\r\n                    idleGLTFAnimations,\r\n                    this._nodeMap,\r\n                    this._nodes,\r\n                    this._bufferManager,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._animationSampleRate,\r\n                    state.convertToRightHanded,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n                if (babylonNode.animations.length) {\r\n                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                        babylonNode,\r\n                        runtimeGLTFAnimation,\r\n                        idleGLTFAnimations,\r\n                        this._nodeMap,\r\n                        this._nodes,\r\n                        this._bufferManager,\r\n                        this._bufferViews,\r\n                        this._accessors,\r\n                        this._animationSampleRate,\r\n                        state.convertToRightHanded,\r\n                        this._options.shouldExportAnimation\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Begin processing child nodes once parent has been added to the node list\r\n        const children = node ? [] : parentNodeChildren;\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonChildNode, children, state);\r\n        }\r\n\r\n        if (node && children.length) {\r\n            node.children = children;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon.js node. If skipped, returns null.\r\n     * @internal\r\n     */\r\n    private async _createNodeAsync(babylonNode: Node, state: ExporterState): Promise<Nullable<INode>> {\r\n        if (!this._shouldExportNode(babylonNode)) {\r\n            return null;\r\n        }\r\n\r\n        const node: INode = {};\r\n\r\n        if (babylonNode.name) {\r\n            node.name = babylonNode.name;\r\n        }\r\n\r\n        // Node metadata\r\n        if (babylonNode.metadata) {\r\n            const extras = this._options.metadataSelector(babylonNode.metadata);\r\n            if (extras) {\r\n                node.extras = extras;\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TransformNode) {\r\n            this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n            if (babylonNode instanceof AbstractMesh) {\r\n                const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : (babylonNode as Mesh);\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    node.mesh = await this._exportMeshAsync(babylonMesh, state);\r\n                }\r\n\r\n                if (babylonNode.skeleton) {\r\n                    const skin = this._skinMap.get(babylonNode.skeleton);\r\n\r\n                    if (skin !== undefined) {\r\n                        if (this._nodesSkinMap.get(skin) === undefined) {\r\n                            this._nodesSkinMap.set(skin, []);\r\n                        }\r\n\r\n                        this._nodesSkinMap.get(skin)?.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TargetCamera) {\r\n            const gltfCamera = this._camerasMap.get(babylonNode);\r\n\r\n            if (gltfCamera) {\r\n                if (this._nodesCameraMap.get(gltfCamera) === undefined) {\r\n                    this._nodesCameraMap.set(gltfCamera, []);\r\n                }\r\n\r\n                this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n                // If a parent node exists and can be collapsed, merge their transformations and mark the parent as the camera-containing node.\r\n                const parentBabylonNode = babylonNode.parent;\r\n                if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                    const parentNodeIndex = this._nodeMap.get(parentBabylonNode);\r\n                    if (parentNodeIndex !== undefined) {\r\n                        const parentNode = this._nodes[parentNodeIndex];\r\n                        CollapseChildIntoParent(node, parentNode);\r\n                        this._nodesCameraMap.get(gltfCamera)?.push(parentNode);\r\n                        return null; // Skip exporting the original child node\r\n                    }\r\n                }\r\n\r\n                this._nodesCameraMap.get(gltfCamera)?.push(node);\r\n            }\r\n        }\r\n\r\n        // Apply extensions to the node. If this resolves to null, it means we should skip exporting this node\r\n        const processedNode = await this._extensionsPostExportNodeAsync(\"exportNodeAsync\", node, babylonNode, this._nodeMap, state.convertToRightHanded);\r\n        if (!processedNode) {\r\n            Logger.Warn(`Not exporting node ${babylonNode.name}`);\r\n            return null;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private _exportIndices(\r\n        indices: Nullable<IndicesArray>,\r\n        is32Bits: boolean,\r\n        start: number,\r\n        count: number,\r\n        offset: number,\r\n        fillMode: number,\r\n        sideOrientation: number,\r\n        state: ExporterState,\r\n        primitive: IMeshPrimitive\r\n    ): void {\r\n        let indicesToExport = indices;\r\n\r\n        primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n        // Flip indices if triangle winding order is not CCW, as glTF is always CCW.\r\n        const flip = sideOrientation !== Material.CounterClockWiseSideOrientation && IsTriangleFillMode(fillMode);\r\n        if (flip) {\r\n            if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {\r\n                throw new Error(\"Triangle strip/fan fill mode is not implemented\");\r\n            }\r\n\r\n            primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n\r\n            if (indices) {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = indices[start + i] + offset;\r\n                    newIndices[i + 1] = indices[start + i + 2] + offset;\r\n                    newIndices[i + 2] = indices[start + i + 1] + offset;\r\n                }\r\n            } else {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = i;\r\n                    newIndices[i + 1] = i + 2;\r\n                    newIndices[i + 2] = i + 1;\r\n                }\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        } else if (indices && offset !== 0) {\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n            for (let i = 0; i < count; i++) {\r\n                newIndices[i] = indices[start + i] + offset;\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        }\r\n\r\n        if (indicesToExport) {\r\n            let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);\r\n            if (accessorIndex === undefined) {\r\n                const bytes = IndicesArrayToTypedSubarray(indicesToExport, start, count, is32Bits);\r\n                const bufferView = this._bufferManager.createBufferView(bytes);\r\n\r\n                const componentType = is32Bits ? AccessorComponentType.UNSIGNED_INT : AccessorComponentType.UNSIGNED_SHORT;\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.SCALAR, componentType, count, 0));\r\n                accessorIndex = this._accessors.length - 1;\r\n                state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);\r\n            }\r\n\r\n            primitive.indices = accessorIndex;\r\n        }\r\n    }\r\n\r\n    private _exportVertexBuffer(vertexBuffer: VertexBuffer, babylonMaterial: Material, start: number, count: number, state: ExporterState, primitive: IMeshPrimitive): void {\r\n        const kind = vertexBuffer.getKind();\r\n\r\n        if (!IsStandardVertexAttribute(kind)) {\r\n            return;\r\n        }\r\n\r\n        if (kind.startsWith(\"uv\") && !this._options.exportUnusedUVs) {\r\n            if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);\r\n\r\n        if (accessorIndex === undefined) {\r\n            // Get min/max from converted or original data.\r\n            const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData()!;\r\n            const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : undefined;\r\n\r\n            // For the remapped buffer views we created for float matrices indices, make sure to use their updated information.\r\n            const isFloatMatricesIndices =\r\n                (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;\r\n\r\n            const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;\r\n            const vertexBufferNormalized = isFloatMatricesIndices ? undefined : vertexBuffer.normalized;\r\n            const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer)! : state.getVertexBufferView(vertexBuffer._buffer)!;\r\n\r\n            const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;\r\n            this._accessors.push(\r\n                this._bufferManager.createAccessor(\r\n                    bufferView,\r\n                    GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),\r\n                    vertexBufferType,\r\n                    count,\r\n                    byteOffset,\r\n                    minMax,\r\n                    vertexBufferNormalized // TODO: Find other places where this is needed.\r\n                )\r\n            );\r\n            accessorIndex = this._accessors.length - 1;\r\n            state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);\r\n        }\r\n\r\n        primitive.attributes[GetAttributeType(kind)] = accessorIndex;\r\n    }\r\n\r\n    private async _exportMaterialAsync(babylonMaterial: Material, vertexBuffers: { [kind: string]: VertexBuffer }, subMesh: SubMesh, primitive: IMeshPrimitive): Promise<void> {\r\n        let materialIndex = this._materialMap.get(babylonMaterial);\r\n        if (materialIndex === undefined) {\r\n            const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith(\"uv\"));\r\n            babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex]! : babylonMaterial;\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                materialIndex = await this._materialExporter.exportOpenPBRMaterialAsync(babylonMaterial, hasUVs);\r\n            } else {\r\n                Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);\r\n                return;\r\n            }\r\n\r\n            this._materialMap.set(babylonMaterial, materialIndex);\r\n        }\r\n\r\n        primitive.material = materialIndex;\r\n    }\r\n\r\n    private async _exportMeshAsync(babylonMesh: Mesh, state: ExporterState): Promise<number> {\r\n        let meshIndex = state.getMesh(babylonMesh);\r\n        if (meshIndex !== undefined) {\r\n            return meshIndex;\r\n        }\r\n\r\n        const mesh: IMesh = { primitives: [] };\r\n        meshIndex = this._meshes.length;\r\n        this._meshes.push(mesh);\r\n        state.setMesh(babylonMesh, meshIndex);\r\n\r\n        const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();\r\n        const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();\r\n        const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);\r\n\r\n        const isLinesMesh = babylonMesh instanceof LinesMesh;\r\n        const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;\r\n\r\n        const subMeshes = babylonMesh.subMeshes;\r\n        if (vertexBuffers && subMeshes && subMeshes.length > 0) {\r\n            for (const subMesh of subMeshes) {\r\n                const primitive: IMeshPrimitive = { attributes: {} };\r\n\r\n                const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;\r\n\r\n                if (isGreasedLineMesh) {\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    const colorWhite = Color3.White();\r\n                    const alpha = babylonLinesMesh.material?.alpha ?? 1;\r\n                    const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;\r\n                    if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...color.asArray(), alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else if (isLinesMesh) {\r\n                    // Special case for LinesMesh\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else {\r\n                    // Material\r\n                    // eslint-disable-next-line no-await-in-loop\r\n                    await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);\r\n                }\r\n\r\n                // Index buffer\r\n                const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : (babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode);\r\n\r\n                let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);\r\n                if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {\r\n                    // To properly remove a conversion node, we must also cancel out the implicit flip in its children's side orientations.\r\n                    sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n                }\r\n\r\n                this._exportIndices(\r\n                    indices,\r\n                    indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535,\r\n                    indices ? subMesh.indexStart : subMesh.verticesStart,\r\n                    indices ? subMesh.indexCount : subMesh.verticesCount,\r\n                    -subMesh.verticesStart,\r\n                    fillMode,\r\n                    sideOrientation,\r\n                    state,\r\n                    primitive\r\n                );\r\n\r\n                // Vertex buffers\r\n                for (const vertexBuffer of Object.values(vertexBuffers)) {\r\n                    this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);\r\n                }\r\n\r\n                if (morphTargets) {\r\n                    primitive.targets = [];\r\n                    for (const gltfMorphTarget of morphTargets) {\r\n                        primitive.targets.push(gltfMorphTarget.attributes);\r\n                    }\r\n                }\r\n\r\n                mesh.primitives.push(primitive);\r\n                this._extensionsPostExportMeshPrimitive(primitive);\r\n            }\r\n        }\r\n\r\n        if (morphTargets) {\r\n            mesh.weights = [];\r\n\r\n            if (!mesh.extras) {\r\n                mesh.extras = {};\r\n            }\r\n            mesh.extras.targetNames = [];\r\n\r\n            for (const gltfMorphTarget of morphTargets) {\r\n                mesh.weights.push(gltfMorphTarget.influence);\r\n                mesh.extras.targetNames.push(gltfMorphTarget.name);\r\n            }\r\n        }\r\n\r\n        return meshIndex;\r\n    }\r\n}\r\n", "import type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { GLTFData } from \"./glTFData\";\r\nimport { GLTFExporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Mesh compression methods.\r\n */\r\nexport type MeshCompressionMethod = \"None\" | \"Draco\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function which indicates whether an animation on the scene should be exported or not\r\n     * @param animation source animation\r\n     * @returns boolean, which indicates whether the animation should be exported (true) or not (false)\r\n     */\r\n    shouldExportAnimation?(animation: Animation): boolean;\r\n\r\n    /**\r\n     * Function to extract the part of the scene or node's `metadata` that will populate the corresponding\r\n     * glTF object's `extras` field. If not defined, `node.metadata.gltf.extras` will be used.\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store into the glTF extras field\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves. Defaults to 1 / 60.\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready. Defaults to false.\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if unused vertex uv attributes should be included in export. Defaults to false.\r\n     */\r\n    exportUnusedUVs?: boolean;\r\n\r\n    /**\r\n     * Remove no-op root nodes when possible. Defaults to true.\r\n     */\r\n    removeNoopRootNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export. Defaults to false.\r\n     * @deprecated Please use removeNoopRootNodes instead\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates what compression method to apply to mesh data.\r\n     */\r\n    meshCompressionMethod?: MeshCompressionMethod;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the scene to .gltf file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .gltf file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLTFAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLTFAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Exports the scene to .glb file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .glb file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLBAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLBAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n}\r\n", "import type { INode, IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport type { BufferManager } from \"../bufferManager\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport { TmpVectors, Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport { ConvertToRightHandedPosition, ConvertToRightHandedRotation } from \"../glTFUtilities\";\r\n\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\nfunction ColorBufferToRGBAToRGB(colorBuffer: Float32Array, instanceCount: number) {\r\n    const colorBufferRgb = new Float32Array(instanceCount * 3);\r\n\r\n    for (let i = 0; i < instanceCount; i++) {\r\n        colorBufferRgb[i * 3 + 0] = colorBuffer[i * 4 + 0];\r\n        colorBufferRgb[i * 3 + 1] = colorBuffer[i * 4 + 1];\r\n        colorBufferRgb[i * 3 + 2] = colorBuffer[i * 4 + 2];\r\n    }\r\n    return colorBufferRgb;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /**\r\n     * Internal state to emit warning about instance color alpha once\r\n     */\r\n    private _instanceColorWarned = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After node is exported\r\n     * @param context the GLTF context when loading the asset\r\n     * @param node the node exported\r\n     * @param babylonNode the corresponding babylon node\r\n     * @param nodeMap map from babylon node id to node index\r\n     * @param convertToRightHanded true if we need to convert data from left hand to right hand system.\r\n     * @param bufferManager buffer manager\r\n     * @returns nullable promise, resolves with the node\r\n     */\r\n    public async postExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: Map<Node, number>,\r\n        convertToRightHanded: boolean,\r\n        bufferManager: BufferManager\r\n    ): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (node && babylonNode instanceof Mesh) {\r\n                if (babylonNode.hasThinInstances && this._exporter) {\r\n                    this._wasUsed = true;\r\n\r\n                    const noTranslation = Vector3.Zero();\r\n                    const noRotation = Quaternion.Identity();\r\n                    const noScale = Vector3.One();\r\n\r\n                    // retrieve all the instance world matrix\r\n                    const matrix = babylonNode.thinInstanceGetWorldMatrices();\r\n\r\n                    const iwt = TmpVectors.Vector3[2];\r\n                    const iwr = TmpVectors.Quaternion[1];\r\n                    const iws = TmpVectors.Vector3[3];\r\n\r\n                    let hasAnyInstanceWorldTranslation = false;\r\n                    let hasAnyInstanceWorldRotation = false;\r\n                    let hasAnyInstanceWorldScale = false;\r\n\r\n                    // prepare temp buffers\r\n                    const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n                    const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);\r\n                    const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n\r\n                    let i = 0;\r\n                    for (const m of matrix) {\r\n                        m.decompose(iws, iwr, iwt);\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedPosition(iwt);\r\n                            ConvertToRightHandedRotation(iwr);\r\n                        }\r\n\r\n                        // fill the temp buffer\r\n                        translationBuffer.set(iwt.asArray(), i * 3);\r\n                        rotationBuffer.set(iwr.normalize().asArray(), i * 4); // ensure the quaternion is normalized\r\n                        scaleBuffer.set(iws.asArray(), i * 3);\r\n\r\n                        // this is where we decide if there is any transformation\r\n                        hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);\r\n                        hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);\r\n                        hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);\r\n\r\n                        i++;\r\n                    }\r\n\r\n                    const extension: IEXTMeshGpuInstancing = {\r\n                        attributes: {},\r\n                    };\r\n\r\n                    // do we need to write TRANSLATION ?\r\n                    if (hasAnyInstanceWorldTranslation) {\r\n                        extension.attributes[\"TRANSLATION\"] = this._buildAccessor(translationBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write ROTATION ?\r\n                    if (hasAnyInstanceWorldRotation) {\r\n                        // we decided to stay on FLOAT for now see https://github.com/BabylonJS/Babylon.js/pull/12495\r\n                        extension.attributes[\"ROTATION\"] = this._buildAccessor(rotationBuffer, AccessorType.VEC4, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write SCALE ?\r\n                    if (hasAnyInstanceWorldScale) {\r\n                        extension.attributes[\"SCALE\"] = this._buildAccessor(scaleBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    let colorBuffer = babylonNode._userThinInstanceBuffersStorage?.data?.instanceColor;\r\n                    if (colorBuffer) {\r\n                        const instanceCount = babylonNode.thinInstanceCount;\r\n                        const accessorType = AccessorType.VEC3;\r\n                        if (babylonNode.hasVertexAlpha && colorBuffer.length === instanceCount * 4) {\r\n                            if (!this._instanceColorWarned) {\r\n                                Logger.Warn(\"EXT_mesh_gpu_instancing: Exporting instance colors as RGB, alpha channel of instance color is not exported\");\r\n                                this._instanceColorWarned = true;\r\n                            }\r\n                            colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);\r\n                        } else if (colorBuffer.length === instanceCount * 4) {\r\n                            colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);\r\n                        }\r\n                        if (colorBuffer.length === instanceCount * 3) {\r\n                            extension.attributes[\"_COLOR_0\"] = this._buildAccessor(colorBuffer, accessorType, instanceCount, bufferManager);\r\n                        }\r\n                    }\r\n\r\n                    /* eslint-enable @typescript-eslint/naming-convention*/\r\n                    node.extensions = node.extensions || {};\r\n                    node.extensions[NAME] = extension;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n\r\n    private _buildAccessor(buffer: Float32Array, type: AccessorType, count: number, bufferManager: BufferManager): number {\r\n        // build the buffer view\r\n        const bv = bufferManager.createBufferView(buffer);\r\n\r\n        // finally build the accessor\r\n        const accessor = bufferManager.createAccessor(bv, type, AccessorComponentType.FLOAT, count);\r\n        this._exporter._accessors.push(accessor);\r\n        return this._exporter._accessors.length - 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));\r\n", "import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\nimport type { IAccessor, IBufferView, IKHRDracoMeshCompression, IMeshPrimitive } from \"babylonjs-gltf2interface\";\nimport type { BufferManager } from \"../bufferManager\";\nimport { DracoEncoder } from \"core/Meshes/Compression/dracoEncoder\";\nimport { GetTypedArrayData, GetTypeByteLength } from \"core/Buffers/bufferUtils\";\nimport { GetAccessorElementCount } from \"../glTFUtilities\";\nimport type { DracoAttributeName, IDracoAttributeData, IDracoEncoderOptions } from \"core/Meshes/Compression/dracoEncoder.types\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { Nullable } from \"core/types\";\n\nconst NAME = \"KHR_draco_mesh_compression\";\n\nfunction GetDracoAttributeName(glTFName: string): DracoAttributeName {\n    if (glTFName === \"POSITION\") {\n        return \"POSITION\";\n    } else if (glTFName === \"NORMAL\") {\n        return \"NORMAL\";\n    } else if (glTFName.startsWith(\"COLOR\")) {\n        return \"COLOR\";\n    } else if (glTFName.startsWith(\"TEXCOORD\")) {\n        return \"TEX_COORD\";\n    }\n    return \"GENERIC\";\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression implements IGLTFExporterExtensionV2 {\n    /** Name of this extension */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled */\n    public enabled;\n\n    /** KHR_draco_mesh_compression is required, as uncompressed fallback data is not yet implemented. */\n    public required = true;\n\n    /** BufferViews used for Draco data, which may be eligible for removal after Draco encoding */\n    private _bufferViewsUsed: Set<IBufferView> = new Set();\n\n    /** Accessors that were replaced with Draco data, which may be eligible for removal after Draco encoding */\n    private _accessorsUsed: Set<IAccessor> = new Set();\n\n    /** Promise pool for Draco encoding work */\n    private _encodePromises: Promise<void>[] = [];\n\n    private _wasUsed = false;\n\n    /** @internal */\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    /** @internal */\n    constructor(exporter: GLTFExporter) {\n        this.enabled = exporter.options.meshCompressionMethod === \"Draco\" && DracoEncoder.DefaultAvailable;\n    }\n\n    /** @internal */\n    public dispose() {}\n\n    /** @internal */\n    public postExportMeshPrimitive(primitive: IMeshPrimitive, bufferManager: BufferManager, accessors: IAccessor[]): void {\n        if (!this.enabled) {\n            return;\n        }\n\n        if (primitive.mode !== MeshPrimitiveMode.TRIANGLES && primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP) {\n            Logger.Warn(\"Cannot compress primitive with mode \" + primitive.mode + \".\");\n            return;\n        }\n\n        // Collect bufferViews and accessors used by this primitive\n        const primitiveBufferViews: IBufferView[] = [];\n        const primitiveAccessors: IAccessor[] = [];\n\n        // Prepare indices for Draco encoding\n        let indices: Nullable<Uint32Array | Uint16Array> = null;\n        if (primitive.indices !== undefined) {\n            const accessor = accessors[primitive.indices];\n            const bufferView = bufferManager.getBufferView(accessor);\n            // Per exportIndices, indices must be either Uint16Array or Uint32Array\n            indices = bufferManager.getData(bufferView).slice() as Uint32Array | Uint16Array;\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Prepare attributes for Draco encoding\n        const attributes: IDracoAttributeData[] = [];\n        for (const [name, accessorIndex] of Object.entries(primitive.attributes)) {\n            const accessor = accessors[accessorIndex];\n            const bufferView = bufferManager.getBufferView(accessor);\n\n            const size = GetAccessorElementCount(accessor.type);\n            const data = GetTypedArrayData(\n                bufferManager.getData(bufferView),\n                size,\n                accessor.componentType,\n                accessor.byteOffset || 0,\n                bufferView.byteStride || GetTypeByteLength(accessor.componentType) * size,\n                accessor.count,\n                true\n            );\n\n            attributes.push({ kind: name, dracoName: GetDracoAttributeName(name), size: GetAccessorElementCount(accessor.type), data: data });\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Use sequential encoding to preserve vertex order for cases like morph targets\n        const options: IDracoEncoderOptions = {\n            method: primitive.targets ? \"MESH_SEQUENTIAL_ENCODING\" : \"MESH_EDGEBREAKER_ENCODING\",\n        };\n\n        const promise = DracoEncoder.Default._encodeAsync(attributes, indices, options)\n            // eslint-disable-next-line github/no-then\n            .then((encodedData) => {\n                if (!encodedData) {\n                    Logger.Error(\"Draco encoding failed for primitive.\");\n                    return;\n                }\n\n                const dracoInfo: IKHRDracoMeshCompression = {\n                    bufferView: -1, // bufferView will be set to a real index later, when we write the binary and decide bufferView ordering\n                    attributes: encodedData.attributeIds,\n                };\n                const bufferView = bufferManager.createBufferView(encodedData.data);\n                bufferManager.setBufferView(dracoInfo, bufferView);\n\n                for (const bufferView of primitiveBufferViews) {\n                    this._bufferViewsUsed.add(bufferView);\n                }\n                for (const accessor of primitiveAccessors) {\n                    this._accessorsUsed.add(accessor);\n                }\n\n                primitive.extensions ||= {};\n                primitive.extensions[NAME] = dracoInfo;\n            })\n            // eslint-disable-next-line github/no-then\n            .catch((error) => {\n                Logger.Error(\"Draco encoding failed for primitive: \" + error);\n            });\n\n        this._encodePromises.push(promise);\n\n        this._wasUsed = true;\n    }\n\n    /** @internal */\n    public async preGenerateBinaryAsync(bufferManager: BufferManager): Promise<void> {\n        if (!this.enabled) {\n            return;\n        }\n\n        await Promise.all(this._encodePromises);\n\n        // Cull obsolete bufferViews that were replaced with Draco data\n        this._bufferViewsUsed.forEach((bufferView) => {\n            const references = bufferManager.getPropertiesWithBufferView(bufferView);\n            const onlyUsedByEncodedPrimitives = references.every((object) => {\n                return this._accessorsUsed.has(object as IAccessor); // has() can handle any object, but TS doesn't know that\n            });\n            if (onlyUsedByEncodedPrimitives) {\n                bufferManager.removeBufferView(bufferView);\n            }\n        });\n\n        this._bufferViewsUsed.clear();\n        this._accessorsUsed.clear();\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_draco_mesh_compression(exporter));\n", "import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ConvertToRightHandedPosition, OmitDefaultValues, CollapseChildIntoParent, IsChildCollapsible } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\nconst DEFAULTS: Omit<IKHRLightsPunctual_Light, \"type\"> = {\r\n    name: \"\",\r\n    color: [1, 1, 1],\r\n    intensity: 1,\r\n    range: Number.MAX_VALUE,\r\n};\r\nconst SPOTDEFAULTS: NonNullable<IKHRLightsPunctual_Light[\"spot\"]> = {\r\n    innerConeAngle: 0,\r\n    outerConeAngle: Math.PI / 4.0,\r\n};\r\nconst LIGHTDIRECTION = Vector3.Backward();\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of babylon node to glTF node index\r\n     * @param convertToRightHanded Flag to convert the values to right-handed\r\n     * @returns nullable INode promise\r\n     */\r\n    public async postExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonNode instanceof Light)) {\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            const lightType =\r\n                babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                    ? KHRLightsPunctual_LightType.POINT\r\n                    : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                      ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                      : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                        ? KHRLightsPunctual_LightType.SPOT\r\n                        : null;\r\n            if (!lightType || !(babylonNode instanceof ShadowLight)) {\r\n                Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n            }\r\n\r\n            // Set the node's translation and rotation here, since lights are not handled in exportNodeAsync\r\n            if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                const translation = TmpVectors.Vector3[0].copyFrom(babylonNode.position);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(translation);\r\n                }\r\n                node.translation = translation.asArray();\r\n            }\r\n\r\n            // Represent the Babylon light's direction as a quaternion\r\n            // relative to glTF lights' forward direction, (0, 0, -1).\r\n            if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                const direction = babylonNode.direction.normalizeToRef(TmpVectors.Vector3[0]);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(direction);\r\n                }\r\n\r\n                const lightRotationQuaternion = Quaternion.FromUnitVectorsToRef(LIGHTDIRECTION, direction, TmpVectors.Quaternion[0]);\r\n                if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                    node.rotation = lightRotationQuaternion.asArray();\r\n                }\r\n            }\r\n\r\n            const light: IKHRLightsPunctual_Light = {\r\n                type: lightType,\r\n                name: babylonNode.name,\r\n                color: babylonNode.diffuse.asArray(),\r\n                intensity: babylonNode.intensity,\r\n                range: babylonNode.range,\r\n            };\r\n            OmitDefaultValues(light, DEFAULTS);\r\n\r\n            // Separately handle the required 'spot' field for spot lights\r\n            if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                const babylonSpotLight = babylonNode as SpotLight;\r\n                light.spot = {\r\n                    innerConeAngle: babylonSpotLight.innerAngle / 2.0,\r\n                    outerConeAngle: babylonSpotLight.angle / 2.0,\r\n                };\r\n                OmitDefaultValues(light.spot, SPOTDEFAULTS);\r\n            }\r\n\r\n            this._lights ||= {\r\n                lights: [],\r\n            };\r\n            this._lights.lights.push(light);\r\n\r\n            const lightReference: IKHRLightsPunctual_LightReference = {\r\n                light: this._lights.lights.length - 1,\r\n            };\r\n\r\n            // Assign the light to its parent node, if possible, to condense the glTF\r\n            // Why and when: the glTF loader generates a new parent TransformNode for each light node, which we should undo on export\r\n            const parentBabylonNode = babylonNode.parent;\r\n\r\n            if (parentBabylonNode && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                const parentNodeIndex = nodeMap.get(parentBabylonNode);\r\n                if (parentNodeIndex) {\r\n                    // Combine the light's transformation with the parent's\r\n                    const parentNode = this._exporter._nodes[parentNodeIndex];\r\n                    CollapseChildIntoParent(node, parentNode);\r\n                    parentNode.extensions ||= {};\r\n                    parentNode.extensions[NAME] = lightReference;\r\n\r\n                    // Do not export the original node\r\n                    resolve(null);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = lightReference;\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n", "import type { IMaterial, IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\n// Convert OpenPBR anisotropy values to glTF-compatible values\r\nfunction OpenpbrAnisotropyStrengthToGltf(baseRoughness: number, anisotropy: number) {\r\n    const baseAlpha = baseRoughness * baseRoughness;\r\n    const roughnessT = baseAlpha * Math.sqrt(2.0 / (1.0 + (1 - anisotropy) * (1 - anisotropy)));\r\n    const roughnessB = (1 - anisotropy) * roughnessT;\r\n    const newBaseRoughness = Math.sqrt(roughnessB);\r\n    const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1.0 - baseAlpha, 0.0001)), 1.0);\r\n\r\n    return { newBaseRoughness, newAnisotropyStrength };\r\n}\r\n\r\nfunction CopyTextureTransform(source: Texture, destination: Texture) {\r\n    destination.uOffset = source.uOffset;\r\n    destination.vOffset = source.vOffset;\r\n    destination.uScale = source.uScale;\r\n    destination.vScale = source.vScale;\r\n    destination.uAng = source.uAng;\r\n    destination.vAng = source.vAng;\r\n    destination.wAng = source.wAng;\r\n    destination.uRotationCenter = source.uRotationCenter;\r\n    destination.vRotationCenter = source.vRotationCenter;\r\n}\r\n\r\n// Custom shader for merging anisotropy into tangent texture\r\nconst AnisotropyMergeFragment = `\r\n    precision highp float;\r\n#ifdef HAS_TANGENT_TEXTURE\r\n    uniform sampler2D tangentTexture;\r\n#endif\r\n#ifdef HAS_ANISOTROPY_TEXTURE\r\n    uniform sampler2D anisotropyTexture;\r\n#endif\r\n    uniform int useRoughnessFromMetallicGreen;\r\n    uniform int useAnisotropyFromTangentBlue;\r\n\r\n    varying vec2 vUV;\r\n\r\n    void main() {\r\n        vec2 tangent = vec2(1.0, 0.0);\r\n        float anisotropy = 1.0;\r\n        #ifdef HAS_TANGENT_TEXTURE\r\n            // Tangent texture is present\r\n            vec4 tangentSample = texture2D(tangentTexture, vUV);\r\n            tangent = tangentSample.rg;\r\n\r\n            if (useAnisotropyFromTangentBlue > 0) {\r\n                anisotropy = tangentSample.b;\r\n            }\r\n        #endif\r\n        #ifdef HAS_ANISOTROPY_TEXTURE\r\n            // Anisotropy texture is present\r\n            vec4 anisotropySample = texture2D(anisotropyTexture, vUV);\r\n            anisotropy = anisotropySample.r;\r\n        #endif\r\n        \r\n        // Output: RG = tangent XY, B = anisotropy strength\r\n        vec4 anisotropyData = vec4(tangent.x, tangent.y, anisotropy, 1.0);\r\n        gl_FragColor = anisotropyData;\r\n    }\r\n`;\r\n\r\n// In your postExportMaterialAsync method:\r\nasync function CreateMergedAnisotropyTexture(babylonMaterial: OpenPBRMaterial): Promise<Nullable<ProceduralTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n\r\n    // Register the custom shader if not already done\r\n    if (!Effect.ShadersStore[\"anisotropyMergeFragmentShader\"]) {\r\n        Effect.ShadersStore[\"anisotropyMergeFragmentShader\"] = AnisotropyMergeFragment;\r\n    }\r\n\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.specularRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryTangentTexture;\r\n\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(anisoStrengthTexture || tangentTexture)) {\r\n        return null;\r\n    }\r\n\r\n    const width = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().width : 1, tangentTexture ? tangentTexture.getSize().width : 1);\r\n    const height = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().height : 1, tangentTexture ? tangentTexture.getSize().height : 1);\r\n    const textureOptions: IProceduralTextureCreationOptions = {\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer: false,\r\n        generateStencilBuffer: false,\r\n        generateMipMaps: false,\r\n    };\r\n    const rtTexture = new ProceduralTexture(\r\n        babylonMaterial.name + \"_anisotropy\",\r\n        {\r\n            width,\r\n            height,\r\n        },\r\n        \"anisotropyMerge\",\r\n        scene,\r\n        textureOptions\r\n    );\r\n    rtTexture.refreshRate = -1;\r\n\r\n    // Set uniforms and defines\r\n    let defines = \"\";\r\n    if (tangentTexture) {\r\n        defines += \"#define HAS_TANGENT_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"tangentTexture\", tangentTexture);\r\n        CopyTextureTransform(tangentTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setVector2(\"tangentVector\", babylonMaterial.geometryTangent);\r\n    if (anisoStrengthTexture) {\r\n        defines += \"#define HAS_ANISOTROPY_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"anisotropyTexture\", anisoStrengthTexture);\r\n        CopyTextureTransform(anisoStrengthTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setInt(\"useAnisotropyFromTangentBlue\", babylonMaterial._useSpecularRoughnessAnisotropyFromTangentTexture ? 1 : 0);\r\n    rtTexture.defines = defines;\r\n\r\n    return await new Promise<ProceduralTexture>((resolve, reject) => {\r\n        // Compile and render\r\n        rtTexture.executeWhenReady(() => {\r\n            try {\r\n                rtTexture.render();\r\n                resolve(rtTexture);\r\n            } catch (error) {\r\n                reject(error instanceof Error ? error : new Error(String(error)));\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _anisoTexturesMap: Record<string, ProceduralTexture> = {};\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {\r\n                if (babylonMaterial.anisotropy.texture) {\r\n                    additionalTextures.push(babylonMaterial.anisotropy.texture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.specularRoughnessAnisotropy > 0) {\r\n                const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);\r\n                if (anisoTexture) {\r\n                    additionalTextures.push(anisoTexture);\r\n                    this._anisoTexturesMap[babylonMaterial.id] = anisoTexture;\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const anisotropyTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.anisotropy.texture);\r\n\r\n                const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                    anisotropyStrength: babylonMaterial.anisotropy.intensity,\r\n                    anisotropyRotation: babylonMaterial.anisotropy.angle,\r\n                    anisotropyTexture: anisotropyTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (anisotropyInfo.anisotropyTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = anisotropyInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.specularRoughnessAnisotropy > 0) {\r\n                    this._wasUsed = true;\r\n\r\n                    node.extensions = node.extensions || {};\r\n\r\n                    // Check if we can convert from OpenPBR anisotropy to glTF anisotropy\r\n                    // Conversion involves both specular roughness and anisotropic roughness changes so,\r\n                    // if there are textures for either, we can't reliably convert due to there potentially\r\n                    // being different mappings between the textures.\r\n                    let roughnessTexture: Nullable<BaseTexture> = babylonMaterial.specularRoughnessTexture;\r\n                    if (babylonMaterial._useRoughnessFromMetallicTextureGreen) {\r\n                        roughnessTexture = babylonMaterial.baseMetalnessTexture;\r\n                    }\r\n                    const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];\r\n\r\n                    // If no textures are being used, we'll always output glTF-style anisotropy.\r\n                    // If using OpenPBR anisotropy, convert the constants. Otherwise, just export what we have.\r\n                    if (!roughnessTexture && !mergedAnisoTexture) {\r\n                        // Convert constants\r\n                        let newBaseRoughness = babylonMaterial.specularRoughness;\r\n                        let newAnisotropyStrength = babylonMaterial.specularRoughnessAnisotropy;\r\n                        if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                            const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.specularRoughness, babylonMaterial.specularRoughnessAnisotropy);\r\n                            newBaseRoughness = newParams.newBaseRoughness;\r\n                            newAnisotropyStrength = newParams.newAnisotropyStrength;\r\n                        }\r\n                        if (node.pbrMetallicRoughness) {\r\n                            node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;\r\n                        }\r\n                        const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                            anisotropyStrength: newAnisotropyStrength,\r\n                            anisotropyRotation: babylonMaterial.geometryTangentAngle + Math.PI * 0.5,\r\n                            anisotropyTexture: undefined,\r\n                        };\r\n                        node.extensions[NAME] = anisotropyInfo;\r\n                        return resolve(node);\r\n                    }\r\n\r\n                    const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;\r\n\r\n                    const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                        anisotropyStrength: babylonMaterial.specularRoughnessAnisotropy,\r\n                        anisotropyRotation: babylonMaterial.geometryTangentAngle,\r\n                        anisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : undefined,\r\n                        extensions: {},\r\n                    };\r\n\r\n                    if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                        anisotropyInfo.extensions![\"EXT_materials_anisotropy_openpbr\"] = {\r\n                            openPbrAnisotropyEnabled: true,\r\n                        };\r\n                        this._exporter._glTF.extensionsUsed ||= [];\r\n                        if (this._exporter._glTF.extensionsUsed.indexOf(\"EXT_materials_anisotropy_openpbr\") === -1) {\r\n                            this._exporter._glTF.extensionsUsed.push(\"EXT_materials_anisotropy_openpbr\");\r\n                        }\r\n                    }\r\n\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n\r\n                    node.extensions[NAME] = anisotropyInfo;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_anisotropy(exporter));\r\n", "import type { IMaterial, IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatWeight > 0) {\r\n                if (babylonMaterial.coatWeightTexture) {\r\n                    additionalTextures.push(babylonMaterial.coatWeightTexture);\r\n                }\r\n                if (babylonMaterial.geometryCoatNormalTexture) {\r\n                    additionalTextures.push(babylonMaterial.geometryCoatNormalTexture);\r\n                }\r\n                if (babylonMaterial.coatRoughnessTexture) {\r\n                    additionalTextures.push(babylonMaterial.coatRoughnessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {\r\n                    Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.clearCoat.intensity,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatWeight == 0.0) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.useCoatRoughnessFromWeightTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatRoughnessTexture);\r\n                }\r\n\r\n                if (babylonMaterial.coatColorTexture) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.geometryCoatNormalTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.coatWeight,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.coatRoughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat(exporter));\r\n", "import type { IMaterial, IKHRMaterialsClearcoatDarkening } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat_darkening\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat_darkening implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatDarkening) {\r\n                if (babylonMaterial.coatDarkeningTexture) {\r\n                    additionalTextures.push(babylonMaterial.coatDarkeningTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let coatDarkeningFactor: Nullable<number> = null;\r\n            let coatDarkeningTexture: Nullable<BaseTexture> = null;\r\n            if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                coatDarkeningFactor = babylonMaterial.coatDarkening;\r\n                coatDarkeningTexture = babylonMaterial.coatDarkeningTexture;\r\n            }\r\n            if (coatDarkeningFactor === null || (coatDarkeningFactor === 1.0 && coatDarkeningTexture === null)) {\r\n                return resolve(node);\r\n            }\r\n\r\n            // This material must have the clearcoat extension already before\r\n            // we can add the clearcoat darkening sub-extension\r\n            const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n            if (!parentExt) {\r\n                return resolve(node);\r\n            }\r\n\r\n            this._wasUsed = true;\r\n\r\n            const coatDarkeningTextureInfo = this._exporter._materialExporter.getTextureInfo(coatDarkeningTexture);\r\n\r\n            const coatDarkeningInfo: IKHRMaterialsClearcoatDarkening = {\r\n                clearcoatDarkeningFactor: coatDarkeningFactor,\r\n                clearcoatDarkeningTexture: coatDarkeningTextureInfo ?? undefined,\r\n            };\r\n\r\n            if (coatDarkeningInfo.clearcoatDarkeningTexture !== null) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n            }\r\n\r\n            parentExt.extensions = parentExt.extensions || {};\r\n            parentExt.extensions[NAME] = coatDarkeningInfo;\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat_darkening(exporter), 105);\r\n", "import type { IMaterial, IKHRMaterialsClearcoatIor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat_ior\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat_ior implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /**\r\n     * @param exporter The glTF exporter\r\n     */\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let coatIor: Nullable<number> = null;\r\n            if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                coatIor = babylonMaterial.coatIor;\r\n            } else if (babylonMaterial instanceof PBRMaterial) {\r\n                coatIor = babylonMaterial.clearCoat.indexOfRefraction;\r\n            }\r\n            if (coatIor === null || coatIor === 1.5) {\r\n                return resolve(node);\r\n            }\r\n\r\n            // This material must have the clearcoat extension already before\r\n            // we can add the clearcoat IOR sub-extension\r\n            const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n            if (!parentExt) {\r\n                return resolve(node);\r\n            }\r\n\r\n            this._wasUsed = true;\r\n\r\n            const coatIorInfo: IKHRMaterialsClearcoatIor = {\r\n                clearcoatIor: coatIor,\r\n            };\r\n\r\n            this._exporter;\r\n\r\n            parentExt.extensions = parentExt.extensions || {};\r\n            parentExt.extensions[NAME] = coatIorInfo;\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat_ior(exporter), 105);\r\n", "import type { IMaterial, IKHRMaterialsClearcoatColor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat_color\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat_color implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.tintTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.tintTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatWeight > 0) {\r\n                if (babylonMaterial.coatColorTexture) {\r\n                    additionalTextures.push(babylonMaterial.coatColorTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                // This material must have the clearcoat extension already before\r\n                // we can add the clearcoat color sub-extension\r\n                const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n                if (!parentExt) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                const coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.tintTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoatColor = {\r\n                    clearcoatColorFactor: babylonMaterial.clearCoat.tintColor.asArray(),\r\n                    clearcoatColorTexture: coatColorTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatColorTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                parentExt.extensions = parentExt.extensions || {};\r\n                parentExt.extensions[NAME] = clearCoatInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatWeight == 0.0) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                // This material must have the clearcoat extension already before\r\n                // we can add the clearcoat color sub-extension\r\n                const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n                if (!parentExt) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                const coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);\r\n                const clearCoatInfo: IKHRMaterialsClearcoatColor = {\r\n                    clearcoatColorFactor: babylonMaterial.coatColor.asArray(),\r\n                    clearcoatColorTexture: coatColorTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatColorTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n                parentExt.extensions = parentExt.extensions || {};\r\n                parentExt.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat_color(exporter), 105);\r\n", "import type { IMaterial, IKHRMaterialsClearcoatAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat_anisotropy\";\r\n\r\n// Convert OpenPBR anisotropy values to glTF-compatible values\r\nfunction OpenpbrAnisotropyStrengthToGltf(baseRoughness: number, anisotropy: number) {\r\n    const baseAlpha = baseRoughness * baseRoughness;\r\n    const roughnessT = baseAlpha * Math.sqrt(2.0 / (1.0 + (1 - anisotropy) * (1 - anisotropy)));\r\n    const roughnessB = (1 - anisotropy) * roughnessT;\r\n    const newBaseRoughness = Math.sqrt(roughnessB);\r\n    const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1.0 - baseAlpha, 0.0001)), 1.0);\r\n\r\n    return { newBaseRoughness, newAnisotropyStrength };\r\n}\r\n\r\nfunction CopyTextureTransform(source: Texture, destination: Texture) {\r\n    destination.uOffset = source.uOffset;\r\n    destination.vOffset = source.vOffset;\r\n    destination.uScale = source.uScale;\r\n    destination.vScale = source.vScale;\r\n    destination.uAng = source.uAng;\r\n    destination.vAng = source.vAng;\r\n    destination.wAng = source.wAng;\r\n    destination.uRotationCenter = source.uRotationCenter;\r\n    destination.vRotationCenter = source.vRotationCenter;\r\n}\r\n\r\n// Custom shader for merging anisotropy into tangent texture\r\nconst AnisotropyMergeFragment = `\r\n    precision highp float;\r\n#ifdef HAS_TANGENT_TEXTURE\r\n    uniform sampler2D tangentTexture;\r\n#endif\r\n#ifdef HAS_ANISOTROPY_TEXTURE\r\n    uniform sampler2D anisotropyTexture;\r\n#endif\r\n    uniform int useRoughnessFromMetallicGreen;\r\n    uniform int useAnisotropyFromTangentBlue;\r\n\r\n    varying vec2 vUV;\r\n\r\n    void main() {\r\n        vec2 tangent = vec2(1.0, 0.0);\r\n        float anisotropy = 1.0;\r\n        #ifdef HAS_TANGENT_TEXTURE\r\n            // Tangent texture is present\r\n            vec4 tangentSample = texture2D(tangentTexture, vUV);\r\n            tangent = tangentSample.rg;\r\n\r\n            if (useAnisotropyFromTangentBlue > 0) {\r\n                anisotropy = tangentSample.b;\r\n            }\r\n        #endif\r\n        #ifdef HAS_ANISOTROPY_TEXTURE\r\n            // Anisotropy texture is present\r\n            vec4 anisotropySample = texture2D(anisotropyTexture, vUV);\r\n            anisotropy = anisotropySample.r;\r\n        #endif\r\n        \r\n        // Output: RG = tangent XY, B = anisotropy strength\r\n        vec4 anisotropyData = vec4(tangent.x, tangent.y, anisotropy, 1.0);\r\n        gl_FragColor = anisotropyData;\r\n    }\r\n`;\r\n\r\n// In your postExportMaterialAsync method:\r\nasync function CreateMergedAnisotropyTexture(babylonMaterial: OpenPBRMaterial): Promise<Nullable<ProceduralTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n\r\n    // Register the custom shader if not already done\r\n    if (!Effect.ShadersStore[\"anisotropyMergeFragmentShader\"]) {\r\n        Effect.ShadersStore[\"anisotropyMergeFragmentShader\"] = AnisotropyMergeFragment;\r\n    }\r\n\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryCoatTangentTexture;\r\n\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(anisoStrengthTexture || tangentTexture)) {\r\n        return null;\r\n    }\r\n\r\n    const width = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().width : 1, tangentTexture ? tangentTexture.getSize().width : 1);\r\n    const height = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().height : 1, tangentTexture ? tangentTexture.getSize().height : 1);\r\n    const textureOptions: IProceduralTextureCreationOptions = {\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer: false,\r\n        generateStencilBuffer: false,\r\n        generateMipMaps: false,\r\n    };\r\n    const rtTexture = new ProceduralTexture(\r\n        babylonMaterial.name + \"_anisotropy\",\r\n        {\r\n            width,\r\n            height,\r\n        },\r\n        \"anisotropyMerge\",\r\n        scene,\r\n        textureOptions\r\n    );\r\n    rtTexture.refreshRate = -1;\r\n\r\n    // Set uniforms and defines\r\n    let defines = \"\";\r\n    if (tangentTexture) {\r\n        defines += \"#define HAS_TANGENT_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"tangentTexture\", tangentTexture);\r\n        CopyTextureTransform(tangentTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setVector2(\"tangentVector\", babylonMaterial.geometryTangent);\r\n    if (anisoStrengthTexture) {\r\n        defines += \"#define HAS_ANISOTROPY_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"anisotropyTexture\", anisoStrengthTexture);\r\n        CopyTextureTransform(anisoStrengthTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setInt(\"useAnisotropyFromTangentBlue\", babylonMaterial._useCoatRoughnessAnisotropyFromTangentTexture ? 1 : 0);\r\n    rtTexture.defines = defines;\r\n\r\n    return await new Promise<ProceduralTexture>((resolve, reject) => {\r\n        // Compile and render\r\n        rtTexture.executeWhenReady(() => {\r\n            try {\r\n                rtTexture.render();\r\n                resolve(rtTexture);\r\n            } catch (error) {\r\n                reject(error instanceof Error ? error : new Error(String(error)));\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _anisoTexturesMap: Record<string, ProceduralTexture> = {};\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatRoughnessAnisotropy > 0) {\r\n                const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);\r\n                if (anisoTexture) {\r\n                    additionalTextures.push(anisoTexture);\r\n                    this._anisoTexturesMap[babylonMaterial.id] = anisoTexture;\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatRoughnessAnisotropy > 0) {\r\n                    // This material must have the clearcoat extension already before\r\n                    // we can add the clearcoat anisotropy sub-extension\r\n                    node.extensions = node.extensions || {};\r\n                    const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n                    if (!parentExt) {\r\n                        return resolve(node);\r\n                    }\r\n                    this._wasUsed = true;\r\n\r\n                    // Check if we can convert from OpenPBR anisotropy to glTF anisotropy\r\n                    // Conversion involves both specular roughness and anisotropic roughness changes so,\r\n                    // if there are textures for either, we can't reliably convert due to there potentially\r\n                    // being different mappings between the textures.\r\n                    const roughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n                    const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];\r\n\r\n                    // If no textures are being used, we'll always output glTF-style anisotropy.\r\n                    // If using OpenPBR anisotropy, convert the constants. Otherwise, just export what we have.\r\n                    if (!roughnessTexture && !mergedAnisoTexture) {\r\n                        // Convert constants\r\n                        let newBaseRoughness = babylonMaterial.coatRoughness;\r\n                        let newAnisotropyStrength = babylonMaterial.coatRoughnessAnisotropy;\r\n                        if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                            const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.coatRoughness, babylonMaterial.coatRoughnessAnisotropy);\r\n                            newBaseRoughness = newParams.newBaseRoughness;\r\n                            newAnisotropyStrength = newParams.newAnisotropyStrength;\r\n                        }\r\n                        if (node.pbrMetallicRoughness) {\r\n                            node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;\r\n                        }\r\n                        const anisotropyInfo: IKHRMaterialsClearcoatAnisotropy = {\r\n                            clearcoatAnisotropyStrength: newAnisotropyStrength,\r\n                            clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle + Math.PI * 0.5,\r\n                            clearcoatAnisotropyTexture: undefined,\r\n                        };\r\n                        parentExt.extensions = parentExt.extensions || {};\r\n                        parentExt.extensions[NAME] = anisotropyInfo;\r\n                        return resolve(node);\r\n                    }\r\n\r\n                    const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;\r\n\r\n                    const anisotropyInfo: IKHRMaterialsClearcoatAnisotropy = {\r\n                        clearcoatAnisotropyStrength: babylonMaterial.coatRoughnessAnisotropy,\r\n                        clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle,\r\n                        clearcoatAnisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : undefined,\r\n                        extensions: {},\r\n                    };\r\n\r\n                    if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                        anisotropyInfo.extensions![\"EXT_materials_anisotropy_openpbr\"] = {\r\n                            openPbrAnisotropyEnabled: true,\r\n                        };\r\n                        this._exporter._glTF.extensionsUsed ||= [];\r\n                        if (this._exporter._glTF.extensionsUsed.indexOf(\"EXT_materials_anisotropy_openpbr\") === -1) {\r\n                            this._exporter._glTF.extensionsUsed.push(\"EXT_materials_anisotropy_openpbr\");\r\n                        }\r\n                    }\r\n\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n\r\n                    parentExt.extensions = parentExt.extensions || {};\r\n                    parentExt.extensions[NAME] = anisotropyInfo;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat_anisotropy(exporter), 105);\r\n", "import type { IMaterial, IKHRMaterialsDiffuseTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_transmission\";\r\n\r\n/**\r\n * Get the appropriate translucency intensity texture for the material.\r\n * @internal\r\n */\r\nfunction GetTranslucencyIntensityTexture(context: string, babylonMaterial: PBRMaterial): Nullable<BaseTexture> {\r\n    const subs = babylonMaterial.subSurface;\r\n    let texture = null;\r\n\r\n    // Check if translucency intensity texture is available or can be derived from thickness texture\r\n    if (subs.translucencyIntensityTexture) {\r\n        texture = subs.translucencyIntensityTexture;\r\n    } else if (subs.thicknessTexture && subs.useMaskFromThicknessTexture) {\r\n        texture = subs.thicknessTexture;\r\n    }\r\n\r\n    if (texture && !subs.useGltfStyleTextures) {\r\n        Logger.Warn(`${context}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${babylonMaterial.name}`, 1);\r\n        return null;\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n            if (translucencyIntensityTexture) {\r\n                additionalTextures.push(translucencyIntensityTexture);\r\n            }\r\n            if (babylonMaterial.subSurface.translucencyColorTexture) {\r\n                additionalTextures.push(babylonMaterial.subSurface.translucencyColorTexture);\r\n            }\r\n            return additionalTextures;\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        if (!subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            !mat.unlit &&\r\n            !subs.useAlbedoToTintTranslucency &&\r\n            subs.useGltfStyleTextures &&\r\n            subs.volumeIndexOfRefraction === 1 &&\r\n            subs.minimumThickness === 0 &&\r\n            subs.maximumThickness === 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n\r\n                const diffuseTransmissionFactor = subs.translucencyIntensity == 0 ? undefined : subs.translucencyIntensity;\r\n                const diffuseTransmissionTexture = this._exporter._materialExporter.getTextureInfo(translucencyIntensityTexture) ?? undefined;\r\n                const diffuseTransmissionColorFactor = !subs.translucencyColor || subs.translucencyColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.translucencyColor.asArray();\r\n                const diffuseTransmissionColorTexture = this._exporter._materialExporter.getTextureInfo(subs.translucencyColorTexture) ?? undefined;\r\n\r\n                const diffuseTransmissionInfo: IKHRMaterialsDiffuseTransmission = {\r\n                    diffuseTransmissionFactor,\r\n                    diffuseTransmissionTexture,\r\n                    diffuseTransmissionColorFactor,\r\n                    diffuseTransmissionColorTexture,\r\n                };\r\n\r\n                if (diffuseTransmissionTexture || diffuseTransmissionColorTexture) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = diffuseTransmissionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_diffuse_transmission(exporter));\r\n", "import type { IMaterial, IKHRMaterialsDispersion } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_dispersion\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_dispersion implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Constructor */\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires refraction to be enabled.\r\n        if (!subs.isRefractionEnabled && !subs.isDispersionEnabled) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const dispersion = subs.dispersion;\r\n\r\n                const dispersionInfo: IKHRMaterialsDispersion = {\r\n                    dispersion: dispersion,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = dispersionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_dispersion());\r\n", "import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { IMaterial, IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                return resolve(node);\r\n            }\r\n\r\n            const emissiveColor = babylonMaterial.emissiveColor.scale(babylonMaterial.emissiveIntensity);\r\n            const tempEmissiveStrength = Math.max(...emissiveColor.asArray());\r\n\r\n            if (tempEmissiveStrength > 1) {\r\n                // If the strength is greater than 1, normalize the color and store the strength\r\n                node.emissiveFactor = emissiveColor.scale(1 / tempEmissiveStrength).asArray();\r\n\r\n                this._wasUsed = true;\r\n                const emissiveStrengthInfo: IKHRMaterialsEmissiveStrength = {\r\n                    emissiveStrength: tempEmissiveStrength,\r\n                };\r\n                node.extensions ||= {};\r\n                node.extensions[NAME] = emissiveStrengthInfo;\r\n            } else {\r\n                // Otherwise, just store the adjusted emissive color in emissiveFactor\r\n                node.emissiveFactor = emissiveColor.asArray();\r\n            }\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_emissive_strength());\r\n", "import type { IMaterial, IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return mat.indexOfRefraction != undefined && mat.indexOfRefraction != 1.5; // 1.5 is normative default value.\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const iorInfo: IKHRMaterialsIor = {\r\n                    ior: babylonMaterial.indexOfRefraction,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = iorInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_ior());\r\n", "import type { IMaterial, IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.iridescence.isEnabled) {\r\n                if (babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.texture);\r\n                }\r\n                if (babylonMaterial.iridescence.thicknessTexture && babylonMaterial.iridescence.thicknessTexture !== babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.thinFilmWeight > 0) {\r\n                if (babylonMaterial.thinFilmWeightTexture) {\r\n                    additionalTextures.push(babylonMaterial.thinFilmWeightTexture);\r\n                }\r\n                if (babylonMaterial.thinFilmThicknessTexture && babylonMaterial.thinFilmThicknessTexture !== babylonMaterial.thinFilmWeightTexture) {\r\n                    additionalTextures.push(babylonMaterial.thinFilmThicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.iridescence.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const iridescenceTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.texture);\r\n                const iridescenceThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.thicknessTexture);\r\n\r\n                const iridescenceInfo: IKHRMaterialsIridescence = {\r\n                    iridescenceFactor: babylonMaterial.iridescence.intensity,\r\n                    iridescenceIor: babylonMaterial.iridescence.indexOfRefraction,\r\n                    iridescenceThicknessMinimum: babylonMaterial.iridescence.minimumThickness,\r\n                    iridescenceThicknessMaximum: babylonMaterial.iridescence.maximumThickness,\r\n\r\n                    iridescenceTexture: iridescenceTextureInfo ?? undefined,\r\n                    iridescenceThicknessTexture: iridescenceThicknessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = iridescenceInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.thinFilmWeight <= 0) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const thinFilmWeightTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.thinFilmWeightTexture);\r\n                const thinFilmThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.thinFilmThicknessTexture);\r\n\r\n                const iridescenceInfo: IKHRMaterialsIridescence = {\r\n                    iridescenceFactor: babylonMaterial.thinFilmWeight,\r\n                    iridescenceIor: babylonMaterial.thinFilmIor,\r\n                    iridescenceThicknessMinimum: babylonMaterial.thinFilmThicknessMin * 1000, // Convert to nanometers for glTF\r\n                    iridescenceThicknessMaximum: babylonMaterial.thinFilmThickness * 1000, // Convert to nanometers for glTF\r\n\r\n                    iridescenceTexture: thinFilmWeightTextureInfo ?? undefined,\r\n                    iridescenceThicknessTexture: thinFilmThicknessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = iridescenceInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_iridescence(exporter));\r\n", "import type { IMaterial, IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHRMaterialsSheen = {\r\n                    sheenColorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    sheenRoughnessFactor: babylonMaterial.sheen.roughness ?? 0,\r\n                };\r\n\r\n                if (sheenInfo.sheenColorTexture !== null || sheenInfo.sheenRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    sheenInfo.sheenColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                if (babylonMaterial.sheen.textureRoughness && !babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.textureRoughness) ?? undefined;\r\n                } else if (babylonMaterial.sheen.texture && babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));\r\n", "import type { IMaterial, IKHRMaterialsSpecular, IEXTMaterialsSpecularEdgeColor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.metallicReflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.metallicReflectanceTexture);\r\n                }\r\n                if (babylonMaterial.reflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.reflectanceTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return (\r\n            (mat.metallicF0Factor != undefined && mat.metallicF0Factor != 1.0) ||\r\n            (mat.metallicReflectanceColor != undefined && !mat.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.metallicReflectanceTexture != null || mat.reflectanceTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const metallicReflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.metallicReflectanceTexture) ?? undefined;\r\n                const reflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.reflectanceTexture) ?? undefined;\r\n                const metallicF0Factor = babylonMaterial.metallicF0Factor == 1.0 ? undefined : babylonMaterial.metallicF0Factor;\r\n                const metallicReflectanceColor = babylonMaterial.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)\r\n                    ? undefined\r\n                    : babylonMaterial.metallicReflectanceColor.asArray();\r\n\r\n                const specularInfo: IKHRMaterialsSpecular = {\r\n                    specularFactor: metallicF0Factor,\r\n                    specularTexture: metallicReflectanceTexture,\r\n                    specularColorFactor: metallicReflectanceColor,\r\n                    specularColorTexture: reflectanceTexture,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = specularInfo;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                node.extensions = node.extensions || {};\r\n\r\n                const specularWeightTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.specularWeightTexture) ?? undefined;\r\n                const specularColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.specularColorTexture) ?? undefined;\r\n                const specularWeight = babylonMaterial.specularWeight == 1.0 ? undefined : babylonMaterial.specularWeight;\r\n                const specularColor = babylonMaterial.specularColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : babylonMaterial.specularColor.asArray();\r\n\r\n                if (!specularColorTexture && !specularWeightTexture && specularWeight === undefined && specularColor === undefined) {\r\n                    return resolve(node);\r\n                }\r\n                this._wasUsed = true;\r\n\r\n                const specularEdgeColorInfo: IEXTMaterialsSpecularEdgeColor = {\r\n                    specularEdgeColorEnabled: true,\r\n                };\r\n\r\n                const specularInfo: IKHRMaterialsSpecular = {\r\n                    specularFactor: specularWeight,\r\n                    specularTexture: specularWeightTexture,\r\n                    specularColorFactor: specularColor,\r\n                    specularColorTexture: specularColorTexture,\r\n                    extensions: {},\r\n                };\r\n\r\n                specularInfo.extensions![\"EXT_materials_specular_edge_color\"] = specularEdgeColorInfo;\r\n                this._exporter._glTF.extensionsUsed ||= [];\r\n                if (this._exporter._glTF.extensionsUsed.indexOf(\"EXT_materials_specular_edge_color\") === -1) {\r\n                    this._exporter._glTF.extensionsUsed.push(\"EXT_materials_specular_edge_color\");\r\n                }\r\n\r\n                if (specularWeightTexture || specularColorTexture) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = specularInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_specular(exporter));\r\n", "import type { IMaterial, IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        return (subs.isRefractionEnabled && subs.refractionIntensity != undefined && subs.refractionIntensity != 0) || this._hasTexturesExtension(mat);\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.refractionIntensityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns true if successful\r\n     */\r\n    public async postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            this._wasUsed = true;\r\n\r\n            const subSurface = babylonMaterial.subSurface;\r\n            const transmissionFactor = subSurface.refractionIntensity === 0 ? undefined : subSurface.refractionIntensity;\r\n\r\n            const volumeInfo: IKHRMaterialsTransmission = {\r\n                transmissionFactor: transmissionFactor,\r\n            };\r\n\r\n            if (this._hasTexturesExtension(babylonMaterial)) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n            }\r\n\r\n            if (subSurface.refractionIntensityTexture) {\r\n                if (subSurface.useGltfStyleTextures) {\r\n                    const transmissionTexture = await this._exporter._materialExporter.exportTextureAsync(subSurface.refractionIntensityTexture);\r\n                    if (transmissionTexture) {\r\n                        volumeInfo.transmissionTexture = transmissionTexture;\r\n                    }\r\n                } else {\r\n                    Logger.Warn(`${context}: Exporting a subsurface refraction intensity texture without \\`useGltfStyleTextures\\` is not supported`);\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = volumeInfo;\r\n        }\r\n\r\n        return node;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_transmission(exporter));\r\n", "import type { IMaterial } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let unlitMaterial = false;\r\n\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                unlitMaterial = babylonMaterial.unlit;\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                unlitMaterial = babylonMaterial.disableLighting;\r\n            }\r\n\r\n            if (unlitMaterial) {\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n\r\n                node.extensions[NAME] = {};\r\n            }\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_unlit());\r\n", "import type { IMaterial, IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if (!subs.isRefractionEnabled && !subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n        return (\r\n            (subs.maximumThickness != undefined && subs.maximumThickness != 0) ||\r\n            (subs.tintColorAtDistance != undefined && subs.tintColorAtDistance != Number.POSITIVE_INFINITY) ||\r\n            (subs.tintColor != undefined && subs.tintColor != Color3.White()) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.thicknessTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const thicknessFactor = subs.maximumThickness == 0 ? undefined : subs.maximumThickness;\r\n                const thicknessTexture = this._exporter._materialExporter.getTextureInfo(subs.thicknessTexture) ?? undefined;\r\n                const attenuationDistance = subs.tintColorAtDistance == Number.POSITIVE_INFINITY ? undefined : subs.tintColorAtDistance;\r\n                const attenuationColor = subs.tintColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.tintColor.asArray();\r\n\r\n                const volumeInfo: IKHRMaterialsVolume = {\r\n                    thicknessFactor: thicknessFactor,\r\n                    thicknessTexture: thicknessTexture,\r\n                    attenuationDistance: attenuationDistance,\r\n                    attenuationColor: attenuationColor,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = volumeInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_volume(exporter));\r\n", "import type { IMaterial, IKHRMaterialsDiffuseRoughness } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_roughness\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_roughness implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial._baseDiffuseRoughness) {\r\n                if (babylonMaterial._baseDiffuseRoughnessTexture) {\r\n                    additionalTextures.push(babylonMaterial._baseDiffuseRoughnessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.baseDiffuseRoughness) {\r\n                if (babylonMaterial.baseDiffuseRoughnessTexture) {\r\n                    additionalTextures.push(babylonMaterial.baseDiffuseRoughnessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let diffuseRoughnessFactor: Nullable<number> = null;\r\n            let diffuseRoughnessTexture: Nullable<BaseTexture> = null;\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                diffuseRoughnessFactor = babylonMaterial._baseDiffuseRoughness;\r\n                diffuseRoughnessTexture = babylonMaterial._baseDiffuseRoughnessTexture;\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                diffuseRoughnessFactor = babylonMaterial.baseDiffuseRoughness;\r\n                diffuseRoughnessTexture = babylonMaterial.baseDiffuseRoughnessTexture;\r\n            }\r\n            if (!diffuseRoughnessFactor) {\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            this._wasUsed = true;\r\n\r\n            node.extensions = node.extensions || {};\r\n\r\n            const diffuseRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(diffuseRoughnessTexture);\r\n\r\n            const diffuseRoughnessInfo: IKHRMaterialsDiffuseRoughness = {\r\n                diffuseRoughnessFactor: diffuseRoughnessFactor,\r\n                diffuseRoughnessTexture: diffuseRoughnessTextureInfo ?? undefined,\r\n            };\r\n\r\n            if (diffuseRoughnessInfo.diffuseRoughnessTexture !== null) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n            }\r\n\r\n            node.extensions[NAME] = diffuseRoughnessInfo;\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_diffuse_roughness(exporter));\r\n", "import type { ITextureInfo, IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * Computes the adjusted offset for a rotation centered about the origin.\r\n * @internal\r\n */\r\nfunction AdjustOffsetForRotationCenter(babylonTexture: Texture): [number, number] {\r\n    const { uOffset, vOffset, uRotationCenter, vRotationCenter, uScale, vScale, wAng } = babylonTexture;\r\n    const cosAngle = Math.cos(wAng);\r\n    const sinAngle = Math.sin(wAng);\r\n    const scaledURotationCenter = uRotationCenter * uScale;\r\n    const scaledVRotationCenter = vRotationCenter * vScale;\r\n    const deltaU = scaledURotationCenter * (1 - cosAngle) + scaledVRotationCenter * sinAngle;\r\n    const deltaV = scaledVRotationCenter * (1 - cosAngle) - scaledURotationCenter * sinAngle;\r\n    return [uOffset + deltaU, vOffset + deltaV];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const scene = babylonTexture.getScene();\r\n        if (!scene) {\r\n            Tools.Warn(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n        }\r\n\r\n        /*\r\n         * The KHR_texture_transform schema only supports w rotation around the origin.\r\n         * See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates.\r\n         */\r\n        if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {\r\n            Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);\r\n            // Usually, we'd always early return here if the texture uses an unsupported combination of transform properties,\r\n            // but we're making an exception here to maintain backwards compatibility.\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const textureTransform: IKHRTextureTransform = {};\r\n        let transformIsRequired = false;\r\n\r\n        if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n            textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n            textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.wAng !== 0) {\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                // See https://github.com/mrdoob/three.js/issues/15831 for more details.\r\n                if (babylonTexture.homogeneousRotationInUVTransform && babylonTexture.uScale !== babylonTexture.vScale) {\r\n                    Tools.Warn(\r\n                        `${context}: Texture ${babylonTexture.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${NAME}.`\r\n                    );\r\n                    return;\r\n                }\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with non-origin rotation center will be exported using an adjusted offset with ${NAME}.`);\r\n                textureTransform.offset = AdjustOffsetForRotationCenter(babylonTexture);\r\n            }\r\n            textureTransform.rotation = -babylonTexture.wAng;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.coordinatesIndex !== 0) {\r\n            textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (!transformIsRequired) {\r\n            return;\r\n        }\r\n\r\n        this._wasUsed = true;\r\n        if (!textureInfo.extensions) {\r\n            textureInfo.extensions = {};\r\n        }\r\n        textureInfo.extensions[NAME] = textureTransform;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_texture_transform());\r\n", "/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"KHR_texture_basisu\";\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_texture_basisu implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.KTX2) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_texture_basisu(exporter));\n", "/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"EXT_texture_webp\";\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_texture_webp implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.WEBP) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_texture_webp(exporter));\n", "/* eslint-disable jsdoc/require-jsdoc */\n/* eslint-disable babylonjs/available */\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { GetMimeType } from \"core/Misc/fileTools\";\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\n\nconst NAME = \"EXT_texture_avif\";\n\n/**\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/blob/5cb7518cf9a1bfb8268320026961b21caf5a4aac/extensions/2.0/Vendor/EXT_texture_avif/README.md)\n * @experimental\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_texture_avif implements IGLTFExporterExtensionV2 {\n    public readonly name = NAME;\n\n    public enabled = true;\n\n    public required = true;\n\n    private _wasUsed = false;\n\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    private _exporter: GLTFExporter;\n\n    constructor(exporter: GLTFExporter) {\n        this._exporter = exporter;\n    }\n\n    public dispose() {}\n\n    public postExportTexture(_: string, textureInfo: BABYLON.GLTF2.ITextureInfo): void {\n        const texture = this._exporter._textures[textureInfo.index];\n        const imageIndex = texture.source;\n        if (imageIndex === undefined) {\n            return;\n        }\n\n        const image = this._exporter._images[imageIndex];\n        const sourceMimeType = image.mimeType || GetMimeType(image.uri!);\n        if (sourceMimeType !== ImageMimeType.AVIF) {\n            return;\n        }\n\n        texture.source = undefined;\n        texture.extensions ||= {};\n        texture.extensions[NAME] = {\n            source: imageIndex,\n        };\n\n        this._wasUsed = true;\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_texture_avif(exporter));\n"],
  "mappings": "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",
  "names": ["Epsilon", "image", "_TangentType", "node", "byteStride", "bufferView", "NAME", "bufferView", "NAME", "NAME", "anisotropyInfo", "NAME", "NAME", "NAME", "NAME", "NAME", "OpenpbrAnisotropyStrengthToGltf", "CopyTextureTransform", "AnisotropyMergeFragment", "CreateMergedAnisotropyTexture", "anisotropyInfo", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME", "NAME"]
}
