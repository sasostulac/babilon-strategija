import {
  ApplyPostProcess
} from "./chunk-CBV5AKY2.js";
import {
  PostProcess
} from "./chunk-X4TNHLCS.js";

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools = class {
  /**
   * Expand the RGBD Texture from RGBD to Half Float if possible.
   * @param texture the texture to expand.
   */
  static ExpandRGBDTexture(texture) {
    const internalTexture = texture._texture;
    if (!internalTexture || !texture.isRGBD) {
      return;
    }
    const engine = internalTexture.getEngine();
    const caps = engine.getCaps();
    const isReady = internalTexture.isReady;
    let expandTexture = false;
    if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 2;
    } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
      expandTexture = true;
      internalTexture.type = 1;
    }
    if (expandTexture) {
      internalTexture.isReady = false;
      internalTexture._isRGBD = false;
      internalTexture.invertY = false;
    }
    const expandRgbdTextureAsync = async () => {
      const isWebGpu = engine.isWebGPU;
      const shaderLanguage = isWebGpu ? 1 : 0;
      internalTexture.isReady = false;
      if (isWebGpu) {
        await import("./rgbdDecode.fragment-YNB3EJMU.js");
      } else {
        await import("./rgbdDecode.fragment-HIQLP2G3.js");
      }
      const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false, void 0, shaderLanguage);
      rgbdPostProcess.externalTextureSamplerBinding = true;
      const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
        generateDepthBuffer: false,
        generateMipMaps: false,
        generateStencilBuffer: false,
        samplingMode: internalTexture.samplingMode,
        type: internalTexture.type,
        format: 5
      });
      rgbdPostProcess.onEffectCreatedObservable.addOnce((e) => {
        e.executeWhenCompiled(() => {
          rgbdPostProcess.onApply = (effect) => {
            effect._bindTexture("textureSampler", internalTexture);
            effect.setFloat2("scale", 1, 1);
          };
          texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
          engine.restoreDefaultFramebuffer();
          engine._releaseTexture(internalTexture);
          if (rgbdPostProcess) {
            rgbdPostProcess.dispose();
          }
          expandedTexture._swapAndDie(internalTexture);
          internalTexture.isReady = true;
        });
      });
    };
    if (expandTexture) {
      if (isReady) {
        expandRgbdTextureAsync();
      } else {
        texture.onLoadObservable.addOnce(expandRgbdTextureAsync);
      }
    }
  }
  /**
   * Encode the texture to RGBD if possible.
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param outputTextureType type of the texture in which the encoding is performed
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  // Should have "Async" in the name but this is a breaking change.
  // eslint-disable-next-line no-restricted-syntax
  static async EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
    if (!scene.getEngine().isWebGPU) {
      await import("./rgbdEncode.fragment-EF5XJXMW.js");
    } else {
      await import("./rgbdEncode.fragment-XQ6EU2YS.js");
    }
    return await ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
  }
};

export {
  RGBDTextureTools
};
//# sourceMappingURL=chunk-BKFBU7UZ.js.map
