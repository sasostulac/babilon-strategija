import {
  AbstractNamedAudioNode,
  _WebAudioParameterComponent
} from "./chunk-GA37H3AK.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/abstractAudioAnalyzer.js
var _AudioAnalyzerDefaults = {
  fftSize: 2048,
  minDecibels: -100,
  maxDecibels: -30,
  smoothing: 0.8
};
function _HasAudioAnalyzerOptions(options) {
  return options.analyzerEnabled || options.analyzerFFTSize !== void 0 || options.analyzerMinDecibels !== void 0 || options.analyzerMaxDecibels !== void 0 || options.analyzerSmoothing !== void 0;
}
var AbstractAudioAnalyzer = class {
  /**
   * The number of data values that will be returned when calling getByteFrequencyData() or getFloatFrequencyData(). This is always half the `fftSize`.
   */
  get frequencyBinCount() {
    return this.fftSize / 2;
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubNode.js
var _AbstractAudioSubNode = class extends AbstractNamedAudioNode {
  /** @internal */
  constructor(name, engine) {
    super(
      name,
      engine,
      3
      /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */
    );
  }
  /** @internal */
  connect(node) {
    if (!this._connect(node)) {
      throw new Error("Connect failed");
    }
  }
  /** @internal */
  disconnect(node) {
    if (!this._disconnect(node)) {
      throw new Error("Disconnect failed");
    }
  }
  /** @internal */
  disconnectAll() {
    if (!this._downstreamNodes) {
      throw new Error("Disconnect failed");
    }
    const it = this._downstreamNodes.values();
    for (let next = it.next(); !next.done; next = it.next()) {
      if (!this._disconnect(next.value)) {
        throw new Error("Disconnect failed");
      }
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/volumeAudioSubNode.js
var _VolumeAudioDefaults = {
  volume: 1
};
var _VolumeAudioSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Volume", engine);
  }
  /** @internal */
  setOptions(options) {
    this.volume = options.volume ?? _VolumeAudioDefaults.volume;
  }
};
function _GetVolumeAudioSubNode(subGraph) {
  return subGraph.getSubNode(
    "Volume"
    /* AudioSubNode.VOLUME */
  );
}
function _GetVolumeAudioProperty(subGraph, property) {
  return _GetVolumeAudioSubNode(subGraph)?.[property] ?? _VolumeAudioDefaults[property];
}

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/audioAnalyzerSubNode.js
var _AudioAnalyzerSubNode = class extends _AbstractAudioSubNode {
  constructor(engine) {
    super("Analyzer", engine);
  }
  /** @internal */
  setOptions(options) {
    this.fftSize = options.analyzerFFTSize ?? _AudioAnalyzerDefaults.fftSize;
    this.minDecibels = options.analyzerMinDecibels ?? _AudioAnalyzerDefaults.minDecibels;
    this.maxDecibels = options.analyzerMaxDecibels ?? _AudioAnalyzerDefaults.maxDecibels;
    this.smoothing = options.analyzerSmoothing ?? _AudioAnalyzerDefaults.smoothing;
  }
};
function _GetAudioAnalyzerSubNode(subGraph) {
  return subGraph.getSubNode(
    "Analyzer"
    /* AudioSubNode.ANALYZER */
  );
}
function _SetAudioAnalyzerProperty(subGraph, property, value) {
  subGraph.callOnSubNode("Analyzer", (node) => {
    node[property] = value;
  });
}

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subProperties/audioAnalyzer.js
var EmptyByteFrequencyData = null;
var EmptyFloatFrequencyData = null;
function _GetEmptyByteFrequencyData() {
  if (!EmptyByteFrequencyData) {
    EmptyByteFrequencyData = new Uint8Array();
  }
  return EmptyByteFrequencyData;
}
function _GetEmptyFloatFrequencyData() {
  if (!EmptyFloatFrequencyData) {
    EmptyFloatFrequencyData = new Float32Array();
  }
  return EmptyFloatFrequencyData;
}
var _AudioAnalyzer = class extends AbstractAudioAnalyzer {
  /** @internal */
  constructor(subGraph) {
    super();
    this._fftSize = _AudioAnalyzerDefaults.fftSize;
    this._maxDecibels = _AudioAnalyzerDefaults.maxDecibels;
    this._minDecibels = _AudioAnalyzerDefaults.minDecibels;
    this._smoothing = _AudioAnalyzerDefaults.smoothing;
    this._subGraph = subGraph;
  }
  /** @internal */
  get fftSize() {
    return this._fftSize;
  }
  set fftSize(value) {
    this._fftSize = value;
    _SetAudioAnalyzerProperty(this._subGraph, "fftSize", value);
  }
  /** @internal */
  get isEnabled() {
    return _GetAudioAnalyzerSubNode(this._subGraph) !== null;
  }
  /** @internal */
  get minDecibels() {
    return this._minDecibels;
  }
  set minDecibels(value) {
    this._minDecibels = value;
    _SetAudioAnalyzerProperty(this._subGraph, "minDecibels", value);
  }
  /** @internal */
  get maxDecibels() {
    return this._maxDecibels;
  }
  set maxDecibels(value) {
    this._maxDecibels = value;
    _SetAudioAnalyzerProperty(this._subGraph, "maxDecibels", value);
  }
  /** @internal */
  get smoothing() {
    return this._smoothing;
  }
  set smoothing(value) {
    this._smoothing = value;
    _SetAudioAnalyzerProperty(this._subGraph, "smoothing", value);
  }
  /** @internal */
  dispose() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (subNode) {
      this._subGraph.removeSubNodeAsync(subNode);
      subNode.dispose();
    }
  }
  /** @internal */
  async enableAsync() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      await this._subGraph.createAndAddSubNodeAsync(
        "Analyzer"
        /* AudioSubNode.ANALYZER */
      );
    }
  }
  /** @internal */
  getByteFrequencyData() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      Logger.Warn("AudioAnalyzer not enabled");
      this.enableAsync();
      return _GetEmptyByteFrequencyData();
    }
    return subNode.getByteFrequencyData();
  }
  /** @internal */
  getFloatFrequencyData() {
    const subNode = _GetAudioAnalyzerSubNode(this._subGraph);
    if (!subNode) {
      Logger.Warn("AudioAnalyzer not enabled");
      this.enableAsync();
      return _GetEmptyFloatFrequencyData();
    }
    return subNode.getFloatFrequencyData();
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractAudioOutNode.js
var AbstractAudioOutNode = class extends AbstractNamedAudioNode {
  constructor(name, engine, nodeType) {
    super(name, engine, nodeType);
    this._analyzer = null;
  }
  /**
   * The analyzer features of the bus.
   */
  get analyzer() {
    return this._analyzer ?? (this._analyzer = new _AudioAnalyzer(this._subGraph));
  }
  /**
   * The audio output volume.
   */
  get volume() {
    return _GetVolumeAudioProperty(this._subGraph, "volume");
  }
  set volume(value) {
    const node = _GetVolumeAudioSubNode(this._subGraph);
    if (!node) {
      throw new Error("No volume subnode");
    }
    node.volume = value;
  }
  /**
   * Releases associated resources.
   */
  dispose() {
    super.dispose();
    this._analyzer?.dispose();
    this._analyzer = null;
    this._subGraph.dispose();
  }
  /**
   * Sets the audio output volume with optional ramping.
   * If the duration is 0 then the volume is set immediately, otherwise it is ramped to the new value over the given duration using the given shape.
   * If a ramp is already in progress then the volume is not set and an error is thrown.
   * @param value The value to set the volume to.
   * @param options The options to use for ramping the volume change.
   */
  setVolume(value, options = null) {
    const node = _GetVolumeAudioSubNode(this._subGraph);
    if (!node) {
      throw new Error("No volume subnode");
    }
    node.setVolume(value, options);
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/subNodes/abstractAudioSubGraph.js
var _AbstractAudioSubGraph = class {
  constructor() {
    this._createSubNodePromises = {};
    this._isDisposed = false;
    this._subNodes = {};
    this._onSubNodeDisposed = (node) => {
      const subNode = node;
      delete this._subNodes[subNode.name];
      this._onSubNodesChanged();
    };
  }
  /**
   * Executes the given callback with the named sub node, creating the sub node if needed.
   *
   * @param name The name of the sub node
   * @param callback The function to call with the named sub node
   *
   * @internal
   */
  callOnSubNode(name, callback) {
    const node = this.getSubNode(name);
    if (node) {
      callback(node);
      return;
    }
    this._createSubNodePromisesResolvedAsync().then(() => {
      const node2 = this.getSubNode(name);
      if (node2) {
        callback(node2);
        return;
      }
      this.createAndAddSubNodeAsync(name).then((node3) => {
        callback(node3);
      });
    });
  }
  /**
   * Creates the named subnode and adds it to the sub graph.
   *
   * @param name The name of the sub node.
   * @returns A promise that resolves to the created sub node.
   *
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  createAndAddSubNodeAsync(name) {
    var _a;
    (_a = this._createSubNodePromises)[name] || (_a[name] = this._createSubNode(name).then((node) => {
      this._addSubNode(node);
      return node;
    }));
    return this._createSubNodePromises[name];
  }
  /**
   * Releases associated resources.
   *
   * @internal
   */
  dispose() {
    this._isDisposed = true;
    const subNodes = Object.values(this._subNodes);
    for (const subNode of subNodes) {
      subNode.dispose();
    }
    this._subNodes = {};
    this._createSubNodePromises = {};
  }
  /**
   * Gets a previously created sub node.
   *
   * @param name - The name of the sub node
   * @returns The named sub node, or `null` if it has not been created, yet
   *
   * @internal
   * */
  getSubNode(name) {
    return this._subNodes[name] ?? null;
  }
  /**
   * Removes a sub node from the sub graph.
   *
   * @param subNode - The sub node to remove
   * @returns A promise that resolves when the sub node is removed
   *
   * @internal
   */
  async removeSubNodeAsync(subNode) {
    await this._createSubNodePromisesResolvedAsync();
    const name = subNode.name;
    if (this._subNodes[name]) {
      delete this._subNodes[name];
    }
    delete this._createSubNodePromises[name];
    this._onSubNodesChanged();
  }
  async _createSubNodePromisesResolvedAsync() {
    return await Promise.all(Object.values(this._createSubNodePromises));
  }
  _addSubNode(node) {
    if (this._isDisposed) {
      node.dispose();
      return;
    }
    this._subNodes[node.name] = node;
    node.onDisposeObservable.addOnce(this._onSubNodeDisposed);
    this._onSubNodesChanged();
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/volumeWebAudioSubNode.js
async function _CreateVolumeAudioSubNodeAsync(engine) {
  return new _VolumeWebAudioSubNode(engine);
}
var _VolumeWebAudioSubNode = class extends _VolumeAudioSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    const gainNode = this.node = new GainNode(engine._audioContext);
    this._volume = new _WebAudioParameterComponent(engine, gainNode.gain);
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._volume.dispose();
  }
  /** @internal */
  get volume() {
    return this._volume.value;
  }
  /** @internal */
  set volume(value) {
    this.setVolume(value);
  }
  /** @internal */
  get _inNode() {
    return this.node;
  }
  /** @internal */
  get _outNode() {
    return this.node;
  }
  /** @internal */
  setVolume(value, options = null) {
    this._volume.setTargetValue(value, options);
  }
  _connect(node) {
    const connected = super._connect(node);
    if (!connected) {
      return false;
    }
    if (node._inNode) {
      this.node.connect(node._inNode);
    }
    return true;
  }
  _disconnect(node) {
    const disconnected = super._disconnect(node);
    if (!disconnected) {
      return false;
    }
    if (node._inNode) {
      this.node.disconnect(node._inNode);
    }
    return true;
  }
  /** @internal */
  getClassName() {
    return "_VolumeWebAudioSubNode";
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioAnalyzerSubNode.js
async function _CreateAudioAnalyzerSubNodeAsync(engine) {
  return new _WebAudioAnalyzerSubNode(engine);
}
var _WebAudioAnalyzerSubNode = class extends _AudioAnalyzerSubNode {
  /** @internal */
  constructor(engine) {
    super(engine);
    this._byteFrequencyData = null;
    this._floatFrequencyData = null;
    this._analyzerNode = new AnalyserNode(engine._audioContext);
  }
  /** @internal */
  get fftSize() {
    return this._analyzerNode.fftSize;
  }
  set fftSize(value) {
    if (value === this._analyzerNode.fftSize) {
      return;
    }
    this._analyzerNode.fftSize = value;
    this._clearArrays();
  }
  /** @internal */
  get _inNode() {
    return this._analyzerNode;
  }
  /** @internal */
  get minDecibels() {
    return this._analyzerNode.minDecibels;
  }
  set minDecibels(value) {
    this._analyzerNode.minDecibels = value;
  }
  /** @internal */
  get maxDecibels() {
    return this._analyzerNode.maxDecibels;
  }
  set maxDecibels(value) {
    this._analyzerNode.maxDecibels = value;
  }
  /** @internal */
  get smoothing() {
    return this._analyzerNode.smoothingTimeConstant;
  }
  set smoothing(value) {
    this._analyzerNode.smoothingTimeConstant = value;
  }
  /** @internal */
  dispose() {
    super.dispose();
    this._clearArrays();
    this._byteFrequencyData = null;
    this._floatFrequencyData = null;
    this._analyzerNode.disconnect();
  }
  /** @internal */
  getClassName() {
    return "_WebAudioAnalyzerSubNode";
  }
  /** @internal */
  getByteFrequencyData() {
    if (!this._byteFrequencyData || this._byteFrequencyData.length === 0) {
      this._byteFrequencyData = new Uint8Array(this._analyzerNode.frequencyBinCount);
    }
    this._analyzerNode.getByteFrequencyData(this._byteFrequencyData);
    return this._byteFrequencyData;
  }
  /** @internal */
  getFloatFrequencyData() {
    if (!this._floatFrequencyData || this._floatFrequencyData.length === 0) {
      this._floatFrequencyData = new Float32Array(this._analyzerNode.frequencyBinCount);
    }
    this._analyzerNode.getFloatFrequencyData(this._floatFrequencyData);
    return this._floatFrequencyData;
  }
  _clearArrays() {
    this._byteFrequencyData?.set(_GetEmptyByteFrequencyData());
    this._floatFrequencyData?.set(_GetEmptyFloatFrequencyData());
  }
};

// node_modules/@babylonjs/core/AudioV2/webAudio/subNodes/webAudioBaseSubGraph.js
var _WebAudioBaseSubGraph = class extends _AbstractAudioSubGraph {
  /** @internal */
  constructor(owner) {
    super();
    this._outputNode = null;
    this._owner = owner;
  }
  /** @internal */
  async initAsync(options) {
    const hasAnalyzerOptions = _HasAudioAnalyzerOptions(options);
    if (hasAnalyzerOptions) {
      await this.createAndAddSubNodeAsync(
        "Analyzer"
        /* AudioSubNode.ANALYZER */
      );
    }
    await this.createAndAddSubNodeAsync(
      "Volume"
      /* AudioSubNode.VOLUME */
    );
    await this._createSubNodePromisesResolvedAsync();
    if (hasAnalyzerOptions) {
      const analyzerNode = _GetAudioAnalyzerSubNode(this);
      if (!analyzerNode) {
        throw new Error("No analyzer subnode.");
      }
      analyzerNode.setOptions(options);
    }
    const volumeNode = _GetVolumeAudioSubNode(this);
    if (!volumeNode) {
      throw new Error("No volume subnode.");
    }
    volumeNode.setOptions(options);
    if (volumeNode.getClassName() !== "_VolumeWebAudioSubNode") {
      throw new Error("Not a WebAudio subnode.");
    }
    this._outputNode = volumeNode.node;
    if (this._outputNode && this._downstreamNodes) {
      const it = this._downstreamNodes.values();
      for (let next = it.next(); !next.done; next = it.next()) {
        const inNode = next.value._inNode;
        if (inNode) {
          this._outputNode.connect(inNode);
        }
      }
    }
  }
  /** @internal */
  get _inNode() {
    return this._outputNode;
  }
  /** @internal */
  get _outNode() {
    return this._outputNode;
  }
  // Function is async, but throws synchronously. Avoiding breaking changes.
  // eslint-disable-next-line @typescript-eslint/promise-function-async
  _createSubNode(name) {
    switch (name) {
      case "Analyzer":
        return _CreateAudioAnalyzerSubNodeAsync(this._owner.engine);
      case "Volume":
        return _CreateVolumeAudioSubNodeAsync(this._owner.engine);
      default:
        throw new Error(`Unknown subnode name: ${name}`);
    }
  }
  _onSubNodesChanged() {
    const analyzerNode = _GetAudioAnalyzerSubNode(this);
    const volumeNode = _GetVolumeAudioSubNode(this);
    if (analyzerNode && volumeNode) {
      volumeNode.connect(analyzerNode);
    }
  }
};

export {
  _AbstractAudioSubNode,
  _GetVolumeAudioSubNode,
  _AudioAnalyzerDefaults,
  _HasAudioAnalyzerOptions,
  AbstractAudioAnalyzer,
  AbstractAudioOutNode,
  _WebAudioBaseSubGraph
};
//# sourceMappingURL=chunk-RO2Q2ME2.js.map
