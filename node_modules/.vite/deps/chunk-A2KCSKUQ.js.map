{
  "version": 3,
  "sources": ["../../../dev/core/src/Engines/Extensions/engine.dynamicTexture.ts", "../../../dev/core/src/Materials/Textures/dynamicTexture.ts", "../../../dev/core/src/Meshes/groundMesh.ts", "../../../dev/core/src/Meshes/Builders/groundBuilder.ts", "../../../dev/core/src/Meshes/Builders/boxBuilder.ts", "../../../dev/core/src/Misc/codeStringParsingTools.ts", "../../../dev/core/src/Engines/Processors/shaderCodeInliner.ts", "../../../dev/core/src/Rendering/boundingBoxRenderer.ts", "../../../dev/core/src/Shaders/ShadersInclude/sceneFragmentDeclaration.ts"],
  "sourcesContent": ["import { GetExponentOfTwo } from \"core/Misc/tools.functions\";\r\nimport { ThinEngine } from \"../../Engines/thinEngine\";\r\nimport { InternalTexture, InternalTextureSource } from \"../../Materials/Textures/internalTexture\";\r\nimport type { ImageSource, Nullable } from \"../../types\";\r\nimport type { ICanvas } from \"../ICanvas\";\r\n\r\ndeclare module \"../../Engines/abstractEngine\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractEngine {\r\n        /**\r\n         * Creates a dynamic texture\r\n         * @param width defines the width of the texture\r\n         * @param height defines the height of the texture\r\n         * @param generateMipMaps defines if the engine should generate the mip levels\r\n         * @param samplingMode defines the required sampling mode (Texture.NEAREST_SAMPLINGMODE by default)\r\n         * @returns the dynamic texture inside an InternalTexture\r\n         */\r\n        createDynamicTexture(width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture;\r\n\r\n        /**\r\n         * Update the content of a dynamic texture\r\n         * @param texture defines the texture to update\r\n         * @param source defines the source containing the data\r\n         * @param invertY defines if data must be stored with Y axis inverted\r\n         * @param premulAlpha defines if alpha is stored as premultiplied\r\n         * @param format defines the format of the data\r\n         * @param forceBindTexture if the texture should be forced to be bound eg. after a graphics context loss (Default: false)\r\n         * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n         */\r\n        updateDynamicTexture(\r\n            texture: Nullable<InternalTexture>,\r\n            source: ImageSource | ICanvas,\r\n            invertY?: boolean,\r\n            premulAlpha?: boolean,\r\n            format?: number,\r\n            forceBindTexture?: boolean,\r\n            allowGPUOptimization?: boolean\r\n        ): void;\r\n    }\r\n}\r\n\r\nThinEngine.prototype.createDynamicTexture = function (width: number, height: number, generateMipMaps: boolean, samplingMode: number): InternalTexture {\r\n    const texture = new InternalTexture(this, InternalTextureSource.Dynamic);\r\n    texture.baseWidth = width;\r\n    texture.baseHeight = height;\r\n\r\n    if (generateMipMaps) {\r\n        width = this.needPOTTextures ? GetExponentOfTwo(width, this._caps.maxTextureSize) : width;\r\n        height = this.needPOTTextures ? GetExponentOfTwo(height, this._caps.maxTextureSize) : height;\r\n    }\r\n\r\n    //  this.resetTextureCache();\r\n    texture.width = width;\r\n    texture.height = height;\r\n    texture.isReady = false;\r\n    texture.generateMipMaps = generateMipMaps;\r\n    texture.samplingMode = samplingMode;\r\n\r\n    this.updateTextureSamplingMode(samplingMode, texture);\r\n\r\n    this._internalTexturesCache.push(texture);\r\n\r\n    return texture;\r\n};\r\n\r\nThinEngine.prototype.updateDynamicTexture = function (\r\n    texture: Nullable<InternalTexture>,\r\n    source: ImageSource,\r\n    invertY?: boolean,\r\n    premulAlpha: boolean = false,\r\n    format?: number,\r\n    forceBindTexture: boolean = false,\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    allowGPUOptimization: boolean = false\r\n): void {\r\n    if (!texture) {\r\n        return;\r\n    }\r\n\r\n    const gl = this._gl;\r\n    const target = gl.TEXTURE_2D;\r\n\r\n    const wasPreviouslyBound = this._bindTextureDirectly(target, texture, true, forceBindTexture);\r\n\r\n    this._unpackFlipY(invertY === undefined ? texture.invertY : invertY);\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);\r\n    }\r\n\r\n    const textureType = this._getWebGLTextureType(texture.type);\r\n    const glformat = this._getInternalFormat(format ? format : texture.format);\r\n    const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, glformat);\r\n\r\n    gl.texImage2D(target, 0, internalFormat, glformat, textureType, source as TexImageSource);\r\n\r\n    if (texture.generateMipMaps) {\r\n        gl.generateMipmap(target);\r\n    }\r\n\r\n    if (!wasPreviouslyBound) {\r\n        this._bindTextureDirectly(target, null);\r\n    }\r\n\r\n    if (premulAlpha) {\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);\r\n    }\r\n\r\n    if (format) {\r\n        texture.format = format;\r\n    }\r\n\r\n    texture._dynamicTextureSource = source;\r\n    texture._premulAlpha = premulAlpha;\r\n    texture.invertY = invertY || false;\r\n    texture.isReady = true;\r\n};\r\n", "import { Logger } from \"../../Misc/logger\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { ISize } from \"../../Maths/math.size\";\r\nimport type { ITextureCreationOptions } from \"../../Materials/Textures/texture\";\r\nimport { Texture } from \"../../Materials/Textures/texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { ICanvas, ICanvasRenderingContext } from \"../../Engines/ICanvas\";\r\n\r\nimport \"../../Engines/Extensions/engine.dynamicTexture\";\r\n\r\n/**\r\n * Interface defining options used to create a dynamic texture\r\n */\r\nexport interface IDynamicTextureOptions extends ITextureCreationOptions {\r\n    /** defines the width of the texture (default: 0) */\r\n    width?: number;\r\n    /** defines the height of the texture (default: 0) */\r\n    height?: number;\r\n    /** defines the hosting scene (default: null) */\r\n    scene?: Nullable<Scene>;\r\n}\r\n\r\n/**\r\n * A class extending Texture allowing drawing on a texture\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/dynamicTexture\r\n */\r\nexport class DynamicTexture extends Texture {\r\n    private _generateMipMaps: boolean;\r\n    private _canvas: ICanvas;\r\n    private _ownCanvas: boolean;\r\n    private _context: ICanvasRenderingContext;\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param canvasOrSize provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param options The options to be used when constructing the dynamic texture\r\n     */\r\n    constructor(name: string, canvasOrSize: ICanvas | { width: number; height: number } | number, options?: IDynamicTextureOptions);\r\n\r\n    /**\r\n     * Creates a DynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height\r\n     * @param scene defines the scene where you want the texture\r\n     * @param generateMipMaps defines the use of MinMaps or not (default is false)\r\n     * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)\r\n     * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: ICanvas | { width: number; height: number } | number,\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps?: boolean,\r\n        samplingMode?: number,\r\n        format?: number,\r\n        invertY?: boolean\r\n    );\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        canvasOrSize: ICanvas | { width: number; height: number } | number,\r\n        sceneOrOptions?: Nullable<Scene> | IDynamicTextureOptions,\r\n        generateMipMaps: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        format: number = Constants.TEXTUREFORMAT_RGBA,\r\n        invertY?: boolean\r\n    ) {\r\n        const isScene = !sceneOrOptions || (sceneOrOptions as Scene)._isScene;\r\n        const scene = isScene ? (sceneOrOptions as Scene) : (sceneOrOptions as IDynamicTextureOptions)?.scene;\r\n        const noMipmap = isScene ? !generateMipMaps : (sceneOrOptions as IDynamicTextureOptions);\r\n\r\n        super(null, scene, noMipmap, invertY, samplingMode, undefined, undefined, undefined, undefined, format);\r\n\r\n        this.name = name;\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n        this._generateMipMaps = generateMipMaps;\r\n\r\n        const engine = this._getEngine();\r\n        if (!engine) {\r\n            return;\r\n        }\r\n\r\n        if ((canvasOrSize as ICanvas).getContext) {\r\n            this._canvas = canvasOrSize as ICanvas;\r\n            this._ownCanvas = false;\r\n            this._texture = engine.createDynamicTexture(this._canvas.width, this._canvas.height, generateMipMaps, samplingMode);\r\n        } else {\r\n            this._canvas = engine.createCanvas(1, 1);\r\n            this._ownCanvas = true;\r\n\r\n            const optionsAsSize = canvasOrSize as ISize;\r\n            if (optionsAsSize.width || optionsAsSize.width === 0) {\r\n                this._texture = engine.createDynamicTexture(optionsAsSize.width, optionsAsSize.height, generateMipMaps, samplingMode);\r\n            } else {\r\n                this._texture = engine.createDynamicTexture(canvasOrSize as number, canvasOrSize as number, generateMipMaps, samplingMode);\r\n            }\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n\r\n        if (this._canvas.width !== textureSize.width) {\r\n            this._canvas.width = textureSize.width;\r\n        }\r\n        if (this._canvas.height !== textureSize.height) {\r\n            this._canvas.height = textureSize.height;\r\n        }\r\n        this._context = this._canvas.getContext(\"2d\");\r\n    }\r\n\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"DynamicTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"DynamicTexture\";\r\n    }\r\n\r\n    /**\r\n     * Gets the current state of canRescale\r\n     */\r\n    public override get canRescale(): boolean {\r\n        return true;\r\n    }\r\n\r\n    private _recreate(textureSize: ISize): void {\r\n        this._canvas.width = textureSize.width;\r\n        this._canvas.height = textureSize.height;\r\n\r\n        this.releaseInternalTexture();\r\n\r\n        this._texture = this._getEngine()!.createDynamicTexture(textureSize.width, textureSize.height, this._generateMipMaps, this.samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public override scale(ratio: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width *= ratio;\r\n        textureSize.height *= ratio;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public scaleTo(width: number, height: number): void {\r\n        const textureSize = this.getSize();\r\n\r\n        textureSize.width = width;\r\n        textureSize.height = height;\r\n\r\n        this._recreate(textureSize);\r\n    }\r\n\r\n    /**\r\n     * Gets the context of the canvas used by the texture\r\n     * @returns the canvas context of the dynamic texture\r\n     */\r\n    public getContext(): ICanvasRenderingContext {\r\n        return this._context;\r\n    }\r\n\r\n    /**\r\n     * Clears the texture\r\n     * @param clearColor Defines the clear color to use\r\n     */\r\n    public clear(clearColor?: string): void {\r\n        const size = this.getSize();\r\n        if (clearColor) {\r\n            this._context.fillStyle = clearColor;\r\n        }\r\n        this._context.clearRect(0, 0, size.width, size.height);\r\n    }\r\n\r\n    /**\r\n     * Updates the texture\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param premulAlpha defines if alpha is stored as premultiplied (default is false)\r\n     * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature \"allowGPUOptimizationsForGUI\" being true)\r\n     */\r\n    public update(invertY?: boolean, premulAlpha = false, allowGPUOptimization = false): void {\r\n        // When disposed, this._texture will be null.\r\n        if (!this._texture) {\r\n            return;\r\n        }\r\n\r\n        this._getEngine()!.updateDynamicTexture(\r\n            this._texture,\r\n            this._canvas,\r\n            invertY === undefined ? true : invertY,\r\n            premulAlpha,\r\n            this._format || undefined,\r\n            undefined,\r\n            allowGPUOptimization\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draws text onto the texture\r\n     * @param text defines the text to be drawn\r\n     * @param x defines the placement of the text from the left\r\n     * @param y defines the placement of the text from the top when invertY is true and from the bottom when false\r\n     * @param font defines the font to be used with font-style, font-size, font-name\r\n     * @param color defines the color used for the text\r\n     * @param fillColor defines the color for the canvas, use null to not overwrite canvas (this bleands with the background to replace, use the clear function)\r\n     * @param invertY defines the direction for the Y axis (default is true - y increases downwards)\r\n     * @param update defines whether texture is immediately update (default is true)\r\n     */\r\n    public drawText(\r\n        text: string,\r\n        x: number | null | undefined,\r\n        y: number | null | undefined,\r\n        font: string,\r\n        color: string | null,\r\n        fillColor: string | null,\r\n        invertY?: boolean,\r\n        update = true\r\n    ) {\r\n        const size = this.getSize();\r\n        if (fillColor) {\r\n            this._context.fillStyle = fillColor;\r\n            this._context.fillRect(0, 0, size.width, size.height);\r\n        }\r\n\r\n        this._context.font = font;\r\n        if (x === null || x === undefined) {\r\n            const textSize = this._context.measureText(text);\r\n            x = (size.width - textSize.width) / 2;\r\n        }\r\n        if (y === null || y === undefined) {\r\n            const fontSize = parseInt(font.replace(/\\D/g, \"\"));\r\n            y = size.height / 2 + fontSize / 3.65;\r\n        }\r\n\r\n        this._context.fillStyle = color || \"\";\r\n        this._context.fillText(text, x, y);\r\n\r\n        if (update) {\r\n            this.update(invertY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the dynamic texture.\r\n     */\r\n    public override dispose(): void {\r\n        super.dispose();\r\n\r\n        if (this._ownCanvas) {\r\n            this._canvas?.remove?.();\r\n        }\r\n        (this._canvas as any) = null;\r\n        (this._context as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture\r\n     * @returns the clone of the texture.\r\n     */\r\n    public override clone(): DynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n\r\n        const textureSize = this.getSize();\r\n        const newTexture = new DynamicTexture(this.name, textureSize, scene, this._generateMipMaps);\r\n\r\n        // Base texture\r\n        newTexture.hasAlpha = this.hasAlpha;\r\n        newTexture.level = this.level;\r\n\r\n        // Dynamic Texture\r\n        newTexture.wrapU = this.wrapU;\r\n        newTexture.wrapV = this.wrapV;\r\n\r\n        return newTexture;\r\n    }\r\n\r\n    /**\r\n     * Serializes the dynamic texture.  The scene should be ready before the dynamic texture is serialized\r\n     * @returns a serialized dynamic texture object\r\n     */\r\n    public override serialize(): any {\r\n        const scene = this.getScene();\r\n        if (scene && !scene.isReady()) {\r\n            Logger.Warn(\"The scene must be ready before serializing the dynamic texture\");\r\n        }\r\n\r\n        const serializationObject = super.serialize();\r\n        if (DynamicTexture._IsCanvasElement(this._canvas)) {\r\n            serializationObject.base64String = this._canvas.toDataURL();\r\n        }\r\n\r\n        serializationObject.invertY = this._invertY;\r\n        serializationObject.samplingMode = this.samplingMode;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _IsCanvasElement(canvas: HTMLCanvasElement | OffscreenCanvas | ICanvas): canvas is HTMLCanvasElement {\r\n        return (canvas as HTMLCanvasElement).toDataURL !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _rebuild(): void {\r\n        this.update();\r\n    }\r\n}\r\n", "import type { Scene } from \"../scene\";\r\nimport { Vector3, Vector2, TmpVectors, Vector4 } from \"../Maths/math.vector\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\n\r\nMesh._GroundMeshParser = (parsedMesh: any, scene: Scene): Mesh => {\r\n    return GroundMesh.Parse(parsedMesh, scene);\r\n};\r\n\r\n/**\r\n * Mesh representing the ground\r\n */\r\nexport class GroundMesh extends Mesh {\r\n    /** If octree should be generated */\r\n    public generateOctree = false;\r\n\r\n    private _heightQuads: { slope: Vector2; facet1: Vector4; facet2: Vector4 }[];\r\n\r\n    /** @internal */\r\n    public _subdivisionsX: number;\r\n    /** @internal */\r\n    public _subdivisionsY: number;\r\n    /** @internal */\r\n    public _width: number;\r\n    /** @internal */\r\n    public _height: number;\r\n    /** @internal */\r\n    public _minX: number;\r\n    /** @internal */\r\n    public _maxX: number;\r\n    /** @internal */\r\n    public _minZ: number;\r\n    /** @internal */\r\n    public _maxZ: number;\r\n\r\n    constructor(name: string, scene?: Scene) {\r\n        super(name, scene);\r\n    }\r\n\r\n    /**\r\n     * \"GroundMesh\"\r\n     * @returns \"GroundMesh\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GroundMesh\";\r\n    }\r\n\r\n    /**\r\n     * The minimum of x and y subdivisions\r\n     */\r\n    public get subdivisions(): number {\r\n        return Math.min(this._subdivisionsX, this._subdivisionsY);\r\n    }\r\n\r\n    /**\r\n     * X subdivisions\r\n     */\r\n    public get subdivisionsX(): number {\r\n        return this._subdivisionsX;\r\n    }\r\n\r\n    /**\r\n     * Y subdivisions\r\n     */\r\n    public get subdivisionsY(): number {\r\n        return this._subdivisionsY;\r\n    }\r\n\r\n    /**\r\n     * This function will divide the mesh into submeshes and update an octree to help to select the right submeshes\r\n     * for rendering, picking and collision computations. Please note that you must have a decent number of submeshes\r\n     * to get performance improvements when using an octree.\r\n     * @param chunksCount the number of submeshes the mesh will be divided into\r\n     * @param octreeBlocksSize the maximum size of the octree blocks (Default: 32)\r\n     */\r\n    public optimize(chunksCount: number, octreeBlocksSize = 32): void {\r\n        this._subdivisionsX = chunksCount;\r\n        this._subdivisionsY = chunksCount;\r\n        this.subdivide(chunksCount);\r\n\r\n        // Call the octree system optimization if it is defined.\r\n        const thisAsAny = this as any;\r\n        if (thisAsAny.createOrUpdateSubmeshesOctree) {\r\n            thisAsAny.createOrUpdateSubmeshesOctree(octreeBlocksSize);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a height (y) value in the World system :\r\n     * the ground altitude at the coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns the ground y position if (x, z) are outside the ground surface.\r\n     */\r\n    public getHeightAtCoordinates(x: number, z: number): number {\r\n        const world = this.getWorldMatrix();\r\n        const invMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(invMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, invMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x >= this._maxX || z <= this._minZ || z > this._maxZ) {\r\n            return this.position.y;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        const y = -(facet.x * x + facet.z * z + facet.w) / facet.y;\r\n        // return y in the World system\r\n        Vector3.TransformCoordinatesFromFloatsToRef(0.0, y, 0.0, world, tmpVect);\r\n        return tmpVect.y;\r\n    }\r\n\r\n    /**\r\n     * Returns a normalized vector (Vector3) orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.\r\n     */\r\n    public getNormalAtCoordinates(x: number, z: number): Vector3 {\r\n        const normal = new Vector3(0.0, 1.0, 0.0);\r\n        this.getNormalAtCoordinatesToRef(x, z, normal);\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground\r\n     * at the ground coordinates (x, z) expressed in the World system.\r\n     * Doesn't update the reference Vector3 if (x, z) are outside the ground surface.\r\n     * @param x x coordinate\r\n     * @param z z coordinate\r\n     * @param ref vector to store the result\r\n     * @returns the GroundMesh.\r\n     */\r\n    public getNormalAtCoordinatesToRef(x: number, z: number, ref: Vector3): GroundMesh {\r\n        const world = this.getWorldMatrix();\r\n        const tmpMat = TmpVectors.Matrix[5];\r\n        world.invertToRef(tmpMat);\r\n        const tmpVect = TmpVectors.Vector3[8];\r\n        Vector3.TransformCoordinatesFromFloatsToRef(x, 0.0, z, tmpMat, tmpVect); // transform x,z in the mesh local space\r\n        x = tmpVect.x;\r\n        z = tmpVect.z;\r\n        if (x < this._minX || x > this._maxX || z < this._minZ || z > this._maxZ) {\r\n            return this;\r\n        }\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n            this._computeHeightQuads();\r\n        }\r\n        const facet = this._getFacetAt(x, z);\r\n        Vector3.TransformNormalFromFloatsToRef(facet.x, facet.y, facet.z, world, ref);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()\r\n     * if the ground has been updated.\r\n     * This can be used in the render loop.\r\n     * @returns the GroundMesh.\r\n     */\r\n    public updateCoordinateHeights(): GroundMesh {\r\n        if (!this._heightQuads || this._heightQuads.length == 0) {\r\n            this._initHeightQuads();\r\n        }\r\n        this._computeHeightQuads();\r\n        return this;\r\n    }\r\n\r\n    // Returns the element \"facet\" from the heightQuads array relative to (x, z) local coordinates\r\n    private _getFacetAt(x: number, z: number): Vector4 {\r\n        // retrieve col and row from x, z coordinates in the ground local system\r\n        const col = Math.floor(((x + this._maxX) * this._subdivisionsX) / this._width);\r\n        const row = Math.floor((-(z + this._maxZ) * this._subdivisionsY) / this._height + this._subdivisionsY);\r\n        const quad = this._heightQuads[row * this._subdivisionsX + col];\r\n        let facet;\r\n        if (z < quad.slope.x * x + quad.slope.y) {\r\n            facet = quad.facet1;\r\n        } else {\r\n            facet = quad.facet2;\r\n        }\r\n        return facet;\r\n    }\r\n\r\n    //  Creates and populates the heightMap array with \"facet\" elements :\r\n    // a quad is two triangular facets separated by a slope, so a \"facet\" element is 1 slope + 2 facets\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _initHeightQuads(): GroundMesh {\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n        this._heightQuads = [];\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                const quad = { slope: Vector2.Zero(), facet1: new Vector4(0.0, 0.0, 0.0, 0.0), facet2: new Vector4(0.0, 0.0, 0.0, 0.0) };\r\n                this._heightQuads[row * subdivisionsX + col] = quad;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    // Compute each quad element values and update the heightMap array :\r\n    // slope : Vector2(c, h) = 2D diagonal line equation setting apart two triangular facets in a quad : z = cx + h\r\n    // facet1 : Vector4(a, b, c, d) = first facet 3D plane equation : ax + by + cz + d = 0\r\n    // facet2 :  Vector4(a, b, c, d) = second facet 3D plane equation : ax + by + cz + d = 0\r\n    // Returns the GroundMesh.\r\n    private _computeHeightQuads(): GroundMesh {\r\n        const positions = this.getVerticesData(VertexBuffer.PositionKind);\r\n\r\n        if (!positions) {\r\n            return this;\r\n        }\r\n\r\n        const v1 = TmpVectors.Vector3[3];\r\n        const v2 = TmpVectors.Vector3[2];\r\n        const v3 = TmpVectors.Vector3[1];\r\n        const v4 = TmpVectors.Vector3[0];\r\n        const v1v2 = TmpVectors.Vector3[4];\r\n        const v1v3 = TmpVectors.Vector3[5];\r\n        const v1v4 = TmpVectors.Vector3[6];\r\n        const norm1 = TmpVectors.Vector3[7];\r\n        const norm2 = TmpVectors.Vector3[8];\r\n        let i = 0;\r\n        let j = 0;\r\n        let k = 0;\r\n        let cd = 0; // 2D slope coefficient : z = cd * x + h\r\n        let h = 0;\r\n        let d1 = 0; // facet plane equation : ax + by + cz + d = 0\r\n        let d2 = 0;\r\n\r\n        const subdivisionsX = this._subdivisionsX;\r\n        const subdivisionsY = this._subdivisionsY;\r\n\r\n        for (let row = 0; row < subdivisionsY; row++) {\r\n            for (let col = 0; col < subdivisionsX; col++) {\r\n                i = col * 3;\r\n                j = row * (subdivisionsX + 1) * 3;\r\n                k = (row + 1) * (subdivisionsX + 1) * 3;\r\n                v1.x = positions[j + i];\r\n                v1.y = positions[j + i + 1];\r\n                v1.z = positions[j + i + 2];\r\n                v2.x = positions[j + i + 3];\r\n                v2.y = positions[j + i + 4];\r\n                v2.z = positions[j + i + 5];\r\n                v3.x = positions[k + i];\r\n                v3.y = positions[k + i + 1];\r\n                v3.z = positions[k + i + 2];\r\n                v4.x = positions[k + i + 3];\r\n                v4.y = positions[k + i + 4];\r\n                v4.z = positions[k + i + 5];\r\n\r\n                // 2D slope V1V4\r\n                cd = (v4.z - v1.z) / (v4.x - v1.x);\r\n                h = v1.z - cd * v1.x; // v1 belongs to the slope\r\n\r\n                // facet equations :\r\n                // we compute each facet normal vector\r\n                // the equation of the facet plane is : norm.x * x + norm.y * y + norm.z * z + d = 0\r\n                // we compute the value d by applying the equation to v1 which belongs to the plane\r\n                // then we store the facet equation in a Vector4\r\n                v2.subtractToRef(v1, v1v2);\r\n                v3.subtractToRef(v1, v1v3);\r\n                v4.subtractToRef(v1, v1v4);\r\n                Vector3.CrossToRef(v1v4, v1v3, norm1); // caution : CrossToRef uses the Tmp class\r\n                Vector3.CrossToRef(v1v2, v1v4, norm2);\r\n                norm1.normalize();\r\n                norm2.normalize();\r\n                d1 = -(norm1.x * v1.x + norm1.y * v1.y + norm1.z * v1.z);\r\n                d2 = -(norm2.x * v2.x + norm2.y * v2.y + norm2.z * v2.z);\r\n\r\n                const quad = this._heightQuads[row * subdivisionsX + col];\r\n                quad.slope.copyFromFloats(cd, h);\r\n                quad.facet1.copyFromFloats(norm1.x, norm1.y, norm1.z, d1);\r\n                quad.facet2.copyFromFloats(norm2.x, norm2.y, norm2.z, d2);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Serializes this ground mesh\r\n     * @param serializationObject object to write serialization to\r\n     */\r\n    public override serialize(serializationObject: any): void {\r\n        super.serialize(serializationObject);\r\n        serializationObject.subdivisionsX = this._subdivisionsX;\r\n        serializationObject.subdivisionsY = this._subdivisionsY;\r\n\r\n        serializationObject.minX = this._minX;\r\n        serializationObject.maxX = this._maxX;\r\n\r\n        serializationObject.minZ = this._minZ;\r\n        serializationObject.maxZ = this._maxZ;\r\n\r\n        serializationObject.width = this._width;\r\n        serializationObject.height = this._height;\r\n    }\r\n\r\n    /**\r\n     * Parses a serialized ground mesh\r\n     * @param parsedMesh the serialized mesh\r\n     * @param scene the scene to create the ground mesh in\r\n     * @returns the created ground mesh\r\n     */\r\n    public static override Parse(parsedMesh: any, scene: Scene): GroundMesh {\r\n        const result = new GroundMesh(parsedMesh.name, scene);\r\n\r\n        result._subdivisionsX = parsedMesh.subdivisionsX || 1;\r\n        result._subdivisionsY = parsedMesh.subdivisionsY || 1;\r\n\r\n        result._minX = parsedMesh.minX;\r\n        result._maxX = parsedMesh.maxX;\r\n\r\n        result._minZ = parsedMesh.minZ;\r\n        result._maxZ = parsedMesh.maxZ;\r\n\r\n        result._width = parsedMesh.width;\r\n        result._height = parsedMesh.height;\r\n\r\n        return result;\r\n    }\r\n}\r\n", "import type { Scene } from \"../../scene\";\r\nimport { Vector3 } from \"../../Maths/math.vector\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { GroundMesh } from \"../groundMesh\";\r\nimport { Tools } from \"../../Misc/tools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { EngineStore } from \"../../Engines/engineStore\";\r\nimport { Epsilon } from \"../../Maths/math.constants\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\n\r\n/**\r\n * Creates the VertexData for a Ground\r\n * @param options an object used to set the following optional parameters for the Ground, required but can be empty\r\n * @param options.width the width (x direction) of the ground, optional, default 1\r\n * @param options.height the height (z direction) of the ground, optional, default 1\r\n * @param options.subdivisions the number of subdivisions per side, optional, default 1\r\n * @param options.subdivisionsX the number of subdivisions in the x direction, overrides options.subdivisions, optional, default undefined\r\n * @param options.subdivisionsY the number of subdivisions in the y direction, overrides options.subdivisions, optional, default undefined\r\n * @returns the VertexData of the Ground\r\n */\r\nexport function CreateGroundVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    subdivisions?: number;\r\n    subdivisionsX?: number;\r\n    subdivisionsY?: number;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row: number, col: number;\r\n\r\n    const width: number = options.width || options.size || 1;\r\n    const height: number = options.height || options.size || 1;\r\n    const subdivisionsX: number = (options.subdivisionsX || options.subdivisions || 1) | 0;\r\n    const subdivisionsY: number = (options.subdivisionsY || options.subdivisions || 1) | 0;\r\n\r\n    for (row = 0; row <= subdivisionsY; row++) {\r\n        for (col = 0; col <= subdivisionsX; col++) {\r\n            const position = new Vector3((col * width) / subdivisionsX - width / 2.0, 0, ((subdivisionsY - row) * height) / subdivisionsY - height / 2.0);\r\n            const normal = new Vector3(0, 1.0, 0);\r\n\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(normal.x, normal.y, normal.z);\r\n            uvs.push(col / subdivisionsX, useOpenGLOrientationForUV ? row / subdivisionsY : 1.0 - row / subdivisionsY);\r\n        }\r\n    }\r\n\r\n    for (row = 0; row < subdivisionsY; row++) {\r\n        for (col = 0; col < subdivisionsX; col++) {\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + row * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n\r\n            indices.push(col + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + 1 + (row + 1) * (subdivisionsX + 1));\r\n            indices.push(col + row * (subdivisionsX + 1));\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a TiledGround by subdividing the ground into tiles\r\n * @param options an object used to set the following optional parameters for the Ground\r\n * @param options.xmin ground minimum X coordinate, default -1\r\n * @param options.zmin ground minimum Z coordinate, default -1\r\n * @param options.xmax ground maximum X coordinate, default 1\r\n * @param options.zmax ground maximum Z coordinate, default 1\r\n * @param options.subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @returns the VertexData of the TiledGround\r\n */\r\nexport function CreateTiledGroundVertexData(options: {\r\n    xmin: number;\r\n    zmin: number;\r\n    xmax: number;\r\n    zmax: number;\r\n    subdivisions?: { w: number; h: number };\r\n    precision?: { w: number; h: number };\r\n}): VertexData {\r\n    const xmin = options.xmin !== undefined && options.xmin !== null ? options.xmin : -1.0;\r\n    const zmin = options.zmin !== undefined && options.zmin !== null ? options.zmin : -1.0;\r\n    const xmax = options.xmax !== undefined && options.xmax !== null ? options.xmax : 1.0;\r\n    const zmax = options.zmax !== undefined && options.zmax !== null ? options.zmax : 1.0;\r\n    const subdivisions = options.subdivisions || { w: 1, h: 1 };\r\n    const precision = options.precision || { w: 1, h: 1 };\r\n\r\n    const indices: number[] = [];\r\n    const positions: number[] = [];\r\n    const normals: number[] = [];\r\n    const uvs: number[] = [];\r\n    let row: number, col: number, tileRow: number, tileCol: number;\r\n\r\n    subdivisions.h = subdivisions.h < 1 ? 1 : subdivisions.h;\r\n    subdivisions.w = subdivisions.w < 1 ? 1 : subdivisions.w;\r\n    precision.w = precision.w < 1 ? 1 : precision.w;\r\n    precision.h = precision.h < 1 ? 1 : precision.h;\r\n\r\n    const tileSize = {\r\n        w: (xmax - xmin) / subdivisions.w,\r\n        h: (zmax - zmin) / subdivisions.h,\r\n    };\r\n\r\n    function applyTile(xTileMin: number, zTileMin: number, xTileMax: number, zTileMax: number) {\r\n        // Indices\r\n        const base = positions.length / 3;\r\n        const rowLength = precision.w + 1;\r\n        for (row = 0; row < precision.h; row++) {\r\n            for (col = 0; col < precision.w; col++) {\r\n                const square = [base + col + row * rowLength, base + (col + 1) + row * rowLength, base + (col + 1) + (row + 1) * rowLength, base + col + (row + 1) * rowLength];\r\n\r\n                indices.push(square[1]);\r\n                indices.push(square[2]);\r\n                indices.push(square[3]);\r\n                indices.push(square[0]);\r\n                indices.push(square[1]);\r\n                indices.push(square[3]);\r\n            }\r\n        }\r\n\r\n        // Position, normals and uvs\r\n        const position = Vector3.Zero();\r\n        const normal = new Vector3(0, 1.0, 0);\r\n        for (row = 0; row <= precision.h; row++) {\r\n            position.z = (row * (zTileMax - zTileMin)) / precision.h + zTileMin;\r\n            for (col = 0; col <= precision.w; col++) {\r\n                position.x = (col * (xTileMax - xTileMin)) / precision.w + xTileMin;\r\n                position.y = 0;\r\n\r\n                positions.push(position.x, position.y, position.z);\r\n                normals.push(normal.x, normal.y, normal.z);\r\n                uvs.push(col / precision.w, row / precision.h);\r\n            }\r\n        }\r\n    }\r\n\r\n    for (tileRow = 0; tileRow < subdivisions.h; tileRow++) {\r\n        for (tileCol = 0; tileCol < subdivisions.w; tileCol++) {\r\n            applyTile(xmin + tileCol * tileSize.w, zmin + tileRow * tileSize.h, xmin + (tileCol + 1) * tileSize.w, zmin + (tileRow + 1) * tileSize.h);\r\n        }\r\n    }\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData of the Ground designed from a heightmap\r\n * @param options an object used to set the following parameters for the Ground, required and provided by CreateGroundFromHeightMap\r\n * @param options.width the width (x direction) of the ground\r\n * @param options.height the height (z direction) of the ground\r\n * @param options.subdivisions the number of subdivisions per side\r\n * @param options.minHeight the minimum altitude on the ground, optional, default 0\r\n * @param options.maxHeight the maximum altitude on the ground, optional default 1\r\n * @param options.colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)\r\n * @param options.buffer the array holding the image color data\r\n * @param options.bufferWidth the width of image\r\n * @param options.bufferHeight the height of image\r\n * @param options.alphaFilter Remove any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.heightBuffer a array of floats where the height data can be saved, if its length is greater than zero.\r\n * @returns the VertexData of the Ground designed from a heightmap\r\n */\r\nexport function CreateGroundFromHeightMapVertexData(options: {\r\n    width: number;\r\n    height: number;\r\n    subdivisions: number;\r\n    minHeight: number;\r\n    maxHeight: number;\r\n    colorFilter: Color3;\r\n    buffer: Uint8Array;\r\n    bufferWidth: number;\r\n    bufferHeight: number;\r\n    alphaFilter: number;\r\n    heightBuffer?: Float32Array;\r\n}): VertexData {\r\n    const indices = [];\r\n    const positions = [];\r\n    const normals = [];\r\n    const uvs = [];\r\n    let row, col;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    let invert = false;\r\n\r\n    if (options.minHeight > options.maxHeight) {\r\n        invert = true;\r\n        const temp = options.maxHeight;\r\n        options.maxHeight = options.minHeight;\r\n        options.minHeight = temp;\r\n    }\r\n\r\n    // Vertices\r\n    for (row = 0; row <= options.subdivisions; row++) {\r\n        for (col = 0; col <= options.subdivisions; col++) {\r\n            const position = new Vector3(\r\n                (col * options.width) / options.subdivisions - options.width / 2.0,\r\n                0,\r\n                ((options.subdivisions - row) * options.height) / options.subdivisions - options.height / 2.0\r\n            );\r\n\r\n            // Compute height\r\n            const heightMapX = (((position.x + options.width / 2) / options.width) * (options.bufferWidth - 1)) | 0;\r\n            const heightMapY = ((1.0 - (position.z + options.height / 2) / options.height) * (options.bufferHeight - 1)) | 0;\r\n            const pos = (heightMapX + heightMapY * options.bufferWidth) * 4;\r\n            let r = options.buffer[pos] / 255.0;\r\n            let g = options.buffer[pos + 1] / 255.0;\r\n            let b = options.buffer[pos + 2] / 255.0;\r\n            const a = options.buffer[pos + 3] / 255.0;\r\n\r\n            if (invert) {\r\n                r = 1.0 - r;\r\n                g = 1.0 - g;\r\n                b = 1.0 - b;\r\n            }\r\n\r\n            const gradient = r * filter.r + g * filter.g + b * filter.b;\r\n\r\n            // If our alpha channel is not within our filter then we will assign a 'special' height\r\n            // Then when building the indices, we will ignore any vertex that is using the special height\r\n            if (a >= alphaFilter) {\r\n                position.y = options.minHeight + (options.maxHeight - options.minHeight) * gradient;\r\n            } else {\r\n                position.y = options.minHeight - Epsilon; // We can't have a height below minHeight, normally.\r\n            }\r\n            if (options.heightBuffer) {\r\n                // set the height buffer information in row major order.\r\n                options.heightBuffer[row * (options.subdivisions + 1) + col] = position.y;\r\n            }\r\n\r\n            // Add  vertex\r\n            positions.push(position.x, position.y, position.z);\r\n            normals.push(0, 0, 0);\r\n            uvs.push(col / options.subdivisions, 1.0 - row / options.subdivisions);\r\n        }\r\n    }\r\n\r\n    // Indices\r\n    for (row = 0; row < options.subdivisions; row++) {\r\n        for (col = 0; col < options.subdivisions; col++) {\r\n            // Calculate Indices\r\n            const idx1 = col + 1 + (row + 1) * (options.subdivisions + 1);\r\n            const idx2 = col + 1 + row * (options.subdivisions + 1);\r\n            const idx3 = col + row * (options.subdivisions + 1);\r\n            const idx4 = col + (row + 1) * (options.subdivisions + 1);\r\n\r\n            // Check that all indices are visible (based on our special height)\r\n            // Only display the vertex if all Indices are visible\r\n            // Positions are stored x,y,z for each vertex, hence the * 3 and + 1 for height\r\n            const isVisibleIdx1 = positions[idx1 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx2 = positions[idx2 * 3 + 1] >= options.minHeight;\r\n            const isVisibleIdx3 = positions[idx3 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx1 && isVisibleIdx2 && isVisibleIdx3) {\r\n                indices.push(idx1);\r\n                indices.push(idx2);\r\n                indices.push(idx3);\r\n            }\r\n\r\n            const isVisibleIdx4 = positions[idx4 * 3 + 1] >= options.minHeight;\r\n            if (isVisibleIdx4 && isVisibleIdx1 && isVisibleIdx3) {\r\n                indices.push(idx4);\r\n                indices.push(idx1);\r\n                indices.push(idx3);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Normals\r\n    VertexData.ComputeNormals(positions, indices, normals);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.width set the width size (float, default 1)\r\n * @param options.height set the height size (float, default 1)\r\n * @param options.subdivisions sets the number of subdivision per side (default 1)\r\n * @param options.subdivisionsX sets the number of subdivision on the X axis (overrides subdivisions)\r\n * @param options.subdivisionsY sets the number of subdivision on the Y axis (overrides subdivisions)\r\n * @param options.updatable defines if the mesh must be flagged as updatable (default false)\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground\r\n */\r\nexport function CreateGround(\r\n    name: string,\r\n    options: { width?: number; height?: number; subdivisions?: number; subdivisionsX?: number; subdivisionsY?: number; updatable?: boolean } = {},\r\n    scene?: Scene\r\n): GroundMesh {\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._setReady(false);\r\n    ground._subdivisionsX = options.subdivisionsX || options.subdivisions || 1;\r\n    ground._subdivisionsY = options.subdivisionsY || options.subdivisions || 1;\r\n    ground._width = options.width || 1;\r\n    ground._height = options.height || 1;\r\n    ground._maxX = ground._width / 2;\r\n    ground._maxZ = ground._height / 2;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    const vertexData = CreateGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(ground, options.updatable);\r\n\r\n    ground._setReady(true);\r\n\r\n    return ground;\r\n}\r\n\r\n/**\r\n * Creates a tiled ground mesh\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param options.xmin ground minimum X coordinate (float, default -1)\r\n * @param options.zmin ground minimum Z coordinate (float, default -1)\r\n * @param options.xmax ground maximum X coordinate (float, default 1)\r\n * @param options.zmax ground maximum Z coordinate (float, default 1)\r\n * @param options.subdivisions a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile\r\n * @param options.subdivisions.w positive integer, default 6\r\n * @param options.subdivisions.h positive integer, default 6\r\n * @param options.precision a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile\r\n * @param options.precision.w positive integer, default 2\r\n * @param options.precision.h positive integer, default 2\r\n * @param options.updatable boolean, default false, true if the mesh must be flagged as updatable\r\n * @param scene defines the hosting scene\r\n * @returns the tiled ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#tiled-ground\r\n */\r\nexport function CreateTiledGround(\r\n    name: string,\r\n    options: { xmin: number; zmin: number; xmax: number; zmax: number; subdivisions?: { w: number; h: number }; precision?: { w: number; h: number }; updatable?: boolean },\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const tiledGround = new Mesh(name, scene);\r\n\r\n    const vertexData = CreateTiledGroundVertexData(options);\r\n\r\n    vertexData.applyToMesh(tiledGround, options.updatable);\r\n\r\n    return tiledGround;\r\n}\r\n\r\n/**\r\n * Creates a ground mesh from a height map. The height map download can take some frames,\r\n * so the mesh is not immediately ready. To wait for the mesh to be completely built,\r\n * you should use the `onReady` callback option.\r\n * @param name defines the name of the mesh\r\n * @param url sets the URL of the height map image resource.\r\n * @param options defines the options used to create the mesh\r\n * @param options.width sets the ground width size (positive float, default 10)\r\n * @param options.height sets the ground height size (positive float, default 10)\r\n * @param options.subdivisions sets the number of subdivision per side (positive integer, default 1)\r\n * @param options.minHeight is the minimum altitude on the ground (float, default 0)\r\n * @param options.maxHeight is the maximum altitude on the ground (float, default 1)\r\n * @param options.colorFilter is the filter to apply to the image pixel colors to compute the height (optional Color3, default (0.3, 0.59, 0.11) )\r\n * @param options.alphaFilter will filter any data where the alpha channel is below this value, defaults 0 (all data visible)\r\n * @param options.updatable defines if the mesh must be flagged as updatable\r\n * @param options.onReady is a javascript callback function that will be called once the mesh is just built (the height map download can last some time)\r\n * @param options.onError is a javascript callback function that will be called if there is an error\r\n * @param options.passHeightBufferInCallback a boolean that indicates if the calculated height data will be passed in the onReady callback. Useful if you need the height data for physics, for example.\r\n * @param scene defines the hosting scene\r\n * @returns the ground mesh\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set/height_map\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#ground-from-a-height-map\r\n */\r\nexport function CreateGroundFromHeightMap(\r\n    name: string,\r\n    url: string | { data: Uint8Array; width: number; height: number },\r\n    options: {\r\n        width?: number;\r\n        height?: number;\r\n        subdivisions?: number;\r\n        minHeight?: number;\r\n        maxHeight?: number;\r\n        colorFilter?: Color3;\r\n        alphaFilter?: number;\r\n        updatable?: boolean;\r\n        onReady?: (mesh: GroundMesh, heightBuffer?: Float32Array) => void;\r\n        onError?: (message?: string, exception?: any) => void;\r\n        passHeightBufferInCallback?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): GroundMesh {\r\n    const width = options.width || 10.0;\r\n    const height = options.height || 10.0;\r\n    const subdivisions = options.subdivisions || 1 | 0;\r\n    const minHeight = options.minHeight || 0.0;\r\n    const maxHeight = options.maxHeight || 1.0;\r\n    const filter = options.colorFilter || new Color3(0.3, 0.59, 0.11);\r\n    const alphaFilter = options.alphaFilter || 0.0;\r\n    const updatable = options.updatable;\r\n    const onReady = options.onReady;\r\n\r\n    scene = scene || EngineStore.LastCreatedScene!;\r\n\r\n    const ground = new GroundMesh(name, scene);\r\n    ground._subdivisionsX = subdivisions;\r\n    ground._subdivisionsY = subdivisions;\r\n    ground._width = width;\r\n    ground._height = height;\r\n    ground._maxX = ground._width / 2.0;\r\n    ground._maxZ = ground._height / 2.0;\r\n    ground._minX = -ground._maxX;\r\n    ground._minZ = -ground._maxZ;\r\n\r\n    ground._setReady(false);\r\n\r\n    let heightBuffer: Float32Array;\r\n    if (options.passHeightBufferInCallback) {\r\n        heightBuffer = new Float32Array((subdivisions + 1) * (subdivisions + 1));\r\n    }\r\n\r\n    const onBufferLoaded = (buffer: Uint8Array, bufferWidth: number, bufferHeight: number) => {\r\n        const vertexData = CreateGroundFromHeightMapVertexData({\r\n            width: width,\r\n            height: height,\r\n            subdivisions: subdivisions,\r\n            minHeight: minHeight,\r\n            maxHeight: maxHeight,\r\n            colorFilter: filter,\r\n            buffer: buffer,\r\n            bufferWidth: bufferWidth,\r\n            bufferHeight: bufferHeight,\r\n            alphaFilter: alphaFilter,\r\n            heightBuffer,\r\n        });\r\n\r\n        vertexData.applyToMesh(ground, updatable);\r\n\r\n        //execute ready callback, if set\r\n        if (onReady) {\r\n            onReady(ground, heightBuffer);\r\n        }\r\n\r\n        ground._setReady(true);\r\n    };\r\n\r\n    if (typeof url === \"string\") {\r\n        const onload = (img: HTMLImageElement | ImageBitmap) => {\r\n            const bufferWidth = img.width;\r\n            const bufferHeight = img.height;\r\n\r\n            if (scene.isDisposed) {\r\n                return;\r\n            }\r\n\r\n            const buffer = scene?.getEngine().resizeImageBitmap(img, bufferWidth, bufferHeight);\r\n\r\n            onBufferLoaded(buffer, bufferWidth, bufferHeight);\r\n        };\r\n\r\n        Tools.LoadImage(url, onload, options.onError ? options.onError : () => {}, scene.offlineProvider);\r\n    } else {\r\n        onBufferLoaded(url.data, url.width, url.height);\r\n    }\r\n\r\n    return ground;\r\n}\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated use the functions directly from the module\r\n */\r\nexport const GroundBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGround,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateGroundFromHeightMap,\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateTiledGround,\r\n};\r\n\r\nVertexData.CreateGround = CreateGroundVertexData;\r\nVertexData.CreateTiledGround = CreateTiledGroundVertexData;\r\nVertexData.CreateGroundFromHeightMap = CreateGroundFromHeightMapVertexData;\r\n\r\nMesh.CreateGround = (name: string, width: number, height: number, subdivisions: number, scene?: Scene, updatable?: boolean): Mesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        updatable,\r\n    };\r\n\r\n    return CreateGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateTiledGround = (\r\n    name: string,\r\n    xmin: number,\r\n    zmin: number,\r\n    xmax: number,\r\n    zmax: number,\r\n    subdivisions: { w: number; h: number },\r\n    precision: { w: number; h: number },\r\n    scene: Scene,\r\n    updatable?: boolean\r\n): Mesh => {\r\n    const options = {\r\n        xmin,\r\n        zmin,\r\n        xmax,\r\n        zmax,\r\n        subdivisions,\r\n        precision,\r\n        updatable,\r\n    };\r\n\r\n    return CreateTiledGround(name, options, scene);\r\n};\r\n\r\nMesh.CreateGroundFromHeightMap = (\r\n    name: string,\r\n    url: string,\r\n    width: number,\r\n    height: number,\r\n    subdivisions: number,\r\n    minHeight: number,\r\n    maxHeight: number,\r\n    scene: Scene,\r\n    updatable?: boolean,\r\n    onReady?: (mesh: GroundMesh) => void,\r\n    alphaFilter?: number\r\n): GroundMesh => {\r\n    const options = {\r\n        width,\r\n        height,\r\n        subdivisions,\r\n        minHeight,\r\n        maxHeight,\r\n        updatable,\r\n        onReady,\r\n        alphaFilter,\r\n    };\r\n\r\n    return CreateGroundFromHeightMap(name, url, options, scene);\r\n};\r\n", "import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\r\nimport { Color4 } from \"../../Maths/math.color\";\r\nimport { Mesh } from \"../mesh\";\r\nimport { VertexData } from \"../mesh.vertexData\";\r\nimport { useOpenGLOrientationForUV } from \"../../Compat/compatibilityOptions\";\r\nimport { CreateGroundVertexData } from \"./groundBuilder\";\r\n\r\n/**\r\n * Creates the VertexData for a box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * faceUV an array of 6 Vector4 elements used to set different images to each box side\r\n * * faceColors an array of 6 Color3 elements used to set different colors to each box side\r\n * * sideOrientation optional and takes the values : Mesh.FRONTSIDE (default), Mesh.BACKSIDE or Mesh.DOUBLESIDE\r\n * * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)\r\n * * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    faceUV?: Vector4[];\r\n    faceColors?: Color4[];\r\n    sideOrientation?: number;\r\n    frontUVs?: Vector4;\r\n    backUVs?: Vector4;\r\n    wrap?: boolean;\r\n    topBaseAt?: number;\r\n    bottomBaseAt?: number;\r\n}): VertexData {\r\n    const nbFaces = 6;\r\n    let indices = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];\r\n    const normals = [\r\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0,\r\n        1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0,\r\n    ];\r\n    const uvs = [];\r\n    let positions = [];\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const wrap = options.wrap || false;\r\n    let topBaseAt = options.topBaseAt === void 0 ? 1 : options.topBaseAt;\r\n    let bottomBaseAt = options.bottomBaseAt === void 0 ? 0 : options.bottomBaseAt;\r\n    topBaseAt = (topBaseAt + 4) % 4; // places values as 0 to 3\r\n    bottomBaseAt = (bottomBaseAt + 4) % 4; // places values as 0 to 3\r\n    const topOrder = [2, 0, 3, 1];\r\n    const bottomOrder = [2, 0, 1, 3];\r\n    let topIndex = topOrder[topBaseAt];\r\n    let bottomIndex = bottomOrder[bottomBaseAt];\r\n    let basePositions = [\r\n        1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1,\r\n        1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, -1, -1, -1, 1,\r\n    ];\r\n    if (wrap) {\r\n        indices = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14];\r\n        basePositions = [\r\n            -1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1,\r\n        ];\r\n        let topFaceBase: any = [\r\n            [1, 1, 1],\r\n            [-1, 1, 1],\r\n            [-1, 1, -1],\r\n            [1, 1, -1],\r\n        ];\r\n        let bottomFaceBase: any = [\r\n            [-1, -1, 1],\r\n            [1, -1, 1],\r\n            [1, -1, -1],\r\n            [-1, -1, -1],\r\n        ];\r\n        const topFaceOrder: any = [17, 18, 19, 16];\r\n        const bottomFaceOrder: any = [22, 23, 20, 21];\r\n        while (topIndex > 0) {\r\n            topFaceBase.unshift(topFaceBase.pop());\r\n            topFaceOrder.unshift(topFaceOrder.pop());\r\n            topIndex--;\r\n        }\r\n        while (bottomIndex > 0) {\r\n            bottomFaceBase.unshift(bottomFaceBase.pop());\r\n            bottomFaceOrder.unshift(bottomFaceOrder.pop());\r\n            bottomIndex--;\r\n        }\r\n        topFaceBase = topFaceBase.flat();\r\n        bottomFaceBase = bottomFaceBase.flat();\r\n        basePositions = basePositions.concat(topFaceBase).concat(bottomFaceBase);\r\n        indices.push(topFaceOrder[0], topFaceOrder[2], topFaceOrder[3], topFaceOrder[0], topFaceOrder[1], topFaceOrder[2]);\r\n        indices.push(bottomFaceOrder[0], bottomFaceOrder[2], bottomFaceOrder[3], bottomFaceOrder[0], bottomFaceOrder[1], bottomFaceOrder[2]);\r\n    }\r\n    const scaleArray = [width / 2, height / 2, depth / 2];\r\n    positions = basePositions.reduce((accumulator: Array<number>, currentValue, currentIndex) => accumulator.concat(currentValue * scaleArray[currentIndex % 3]), []);\r\n\r\n    const sideOrientation = options.sideOrientation === 0 ? 0 : options.sideOrientation || VertexData.DEFAULTSIDE;\r\n\r\n    const faceUV: Vector4[] = options.faceUV || new Array<Vector4>(6);\r\n    const faceColors = options.faceColors;\r\n    const colors = [];\r\n\r\n    // default face colors and UV if undefined\r\n    for (let f = 0; f < 6; f++) {\r\n        if (faceUV[f] === undefined) {\r\n            faceUV[f] = new Vector4(0, 0, 1, 1);\r\n        }\r\n        if (faceColors && faceColors[f] === undefined) {\r\n            faceColors[f] = new Color4(1, 1, 1, 1);\r\n        }\r\n    }\r\n\r\n    // Create each face in turn.\r\n    for (let index = 0; index < nbFaces; index++) {\r\n        uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1.0 - faceUV[index].w : faceUV[index].w);\r\n        uvs.push(faceUV[index].x, useOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        uvs.push(faceUV[index].z, useOpenGLOrientationForUV ? 1.0 - faceUV[index].y : faceUV[index].y);\r\n        if (faceColors) {\r\n            for (let c = 0; c < 4; c++) {\r\n                colors.push(faceColors[index].r, faceColors[index].g, faceColors[index].b, faceColors[index].a);\r\n            }\r\n        }\r\n    }\r\n\r\n    // sides\r\n    VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, options.frontUVs, options.backUVs);\r\n\r\n    // Result\r\n    const vertexData = new VertexData();\r\n\r\n    vertexData.indices = indices;\r\n    vertexData.positions = positions;\r\n    vertexData.normals = normals;\r\n    vertexData.uvs = uvs;\r\n\r\n    if (faceColors) {\r\n        const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;\r\n        vertexData.colors = totalColors;\r\n    }\r\n\r\n    return vertexData;\r\n}\r\n\r\n/**\r\n * Creates the VertexData for a segmented box\r\n * @param options an object used to set the following optional parameters for the box, required but can be empty\r\n * * size sets the width, height and depth of the box to the value of size, optional default 1\r\n * * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size\r\n * * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size\r\n * * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size\r\n * * segments sets the number of segments on the all axis (1 by default)\r\n * * widthSegments sets the number of segments on the x axis (1 by default)\r\n * * heightSegments sets the number of segments on the y axis (1 by default)\r\n * * depthSegments sets the number of segments on the z axis (1 by default)\r\n * @returns the VertexData of the box\r\n */\r\nexport function CreateSegmentedBoxVertexData(options: {\r\n    size?: number;\r\n    width?: number;\r\n    height?: number;\r\n    depth?: number;\r\n    segments?: number;\r\n    widthSegments?: number;\r\n    heightSegments?: number;\r\n    depthSegments?: number;\r\n}): VertexData {\r\n    const width = options.width || options.size || 1;\r\n    const height = options.height || options.size || 1;\r\n    const depth = options.depth || options.size || 1;\r\n    const widthSegments = (options.widthSegments || options.segments || 1) | 0;\r\n    const heightSegments = (options.heightSegments || options.segments || 1) | 0;\r\n    const depthSegments = (options.depthSegments || options.segments || 1) | 0;\r\n    const rotationMatrix = new Matrix();\r\n    const translationMatrix = new Matrix();\r\n    const transformMatrix = new Matrix();\r\n\r\n    const bottomPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, -height / 2, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    bottomPlane.transform(transformMatrix);\r\n\r\n    const topPlane = CreateGroundVertexData({ width: width, height: depth, subdivisionsX: widthSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(0, height / 2, 0, transformMatrix);\r\n    topPlane.transform(transformMatrix);\r\n\r\n    const negXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(-width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negXPlane.transform(transformMatrix);\r\n\r\n    const posXPlane = CreateGroundVertexData({ width: height, height: depth, subdivisionsX: heightSegments, subdivisionsY: depthSegments });\r\n    Matrix.TranslationToRef(width / 2, 0, 0, translationMatrix);\r\n    Matrix.RotationZToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posXPlane.transform(transformMatrix);\r\n\r\n    const negZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, -depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(-Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    negZPlane.transform(transformMatrix);\r\n\r\n    const posZPlane = CreateGroundVertexData({ width: width, height: height, subdivisionsX: widthSegments, subdivisionsY: heightSegments });\r\n    Matrix.TranslationToRef(0, 0, depth / 2, translationMatrix);\r\n    Matrix.RotationXToRef(Math.PI / 2, rotationMatrix);\r\n    rotationMatrix.multiplyToRef(translationMatrix, transformMatrix);\r\n    posZPlane.transform(transformMatrix);\r\n\r\n    // Result\r\n    bottomPlane.merge([topPlane, posXPlane, negXPlane, negZPlane, posZPlane], true);\r\n\r\n    return bottomPlane;\r\n}\r\n\r\n/**\r\n * Creates a box mesh\r\n * * The parameter `size` sets the size (float) of each box side (default 1)\r\n * * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value of `size`)\r\n * * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)\r\n * * Please read this tutorial : https://doc.babylonjs.com/features/featuresDeepDive/materials/using/texturePerBoxFace\r\n * * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE\r\n * * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#side-orientation\r\n * * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/creation/set#box\r\n * @param name defines the name of the mesh\r\n * @param options defines the options used to create the mesh\r\n * @param scene defines the hosting scene\r\n * @returns the box mesh\r\n */\r\nexport function CreateBox(\r\n    name: string,\r\n    options: {\r\n        size?: number;\r\n        width?: number;\r\n        height?: number;\r\n        depth?: number;\r\n        faceUV?: Vector4[];\r\n        faceColors?: Color4[];\r\n        sideOrientation?: number;\r\n        frontUVs?: Vector4;\r\n        backUVs?: Vector4;\r\n        wrap?: boolean;\r\n        topBaseAt?: number;\r\n        bottomBaseAt?: number;\r\n        updatable?: boolean;\r\n    } = {},\r\n    scene: Nullable<Scene> = null\r\n): Mesh {\r\n    const box = new Mesh(name, scene);\r\n\r\n    options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);\r\n    box._originalBuilderSideOrientation = options.sideOrientation;\r\n\r\n    const vertexData = CreateBoxVertexData(options);\r\n\r\n    vertexData.applyToMesh(box, options.updatable);\r\n\r\n    return box;\r\n}\r\n\r\n/**\r\n * Class containing static functions to help procedurally build meshes\r\n * @deprecated please use CreateBox directly\r\n */\r\nexport const BoxBuilder = {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    CreateBox,\r\n};\r\n\r\n// Side effects\r\nVertexData.CreateBox = CreateBoxVertexData;\r\n\r\nMesh.CreateBox = (name: string, size: number, scene: Nullable<Scene> = null, updatable?: boolean, sideOrientation?: number): Mesh => {\r\n    const options = {\r\n        size,\r\n        sideOrientation,\r\n        updatable,\r\n    };\r\n\r\n    return CreateBox(name, options, scene);\r\n};\r\n", "/**\r\n * Extracts the characters between two markers (for eg, between \"(\" and \")\"). The function handles nested markers as well as markers inside strings (delimited by \", ' or `) and comments\r\n * @param markerOpen opening marker\r\n * @param markerClose closing marker\r\n * @param block code block to parse\r\n * @param startIndex starting index in block where the extraction must start. The character at block[startIndex] should be the markerOpen character!\r\n * @returns index of the last character for the extraction (or -1 if the string is invalid - no matching closing marker found). The string to extract (without the markers) is the string between startIndex + 1 and the returned value (exclusive)\r\n */\r\nexport function ExtractBetweenMarkers(markerOpen: string, markerClose: string, block: string, startIndex: number): number {\r\n    let currPos = startIndex,\r\n        openMarkers = 0,\r\n        waitForChar = \"\";\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case markerOpen:\r\n                    openMarkers++;\r\n                    break;\r\n                case markerClose:\r\n                    openMarkers--;\r\n                    break;\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                } else {\r\n                    waitForChar = \"\";\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    currPos++;\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n        if (openMarkers === 0) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return openMarkers === 0 ? currPos - 1 : -1;\r\n}\r\n\r\n/**\r\n * Parses a string and skip whitespaces\r\n * @param s string to parse\r\n * @param index index where to start parsing\r\n * @returns the index after all whitespaces have been skipped\r\n */\r\nexport function SkipWhitespaces(s: string, index: number): number {\r\n    while (index < s.length) {\r\n        const c = s[index];\r\n        if (c !== \" \" && c !== \"\\n\" && c !== \"\\r\" && c !== \"\\t\" && c !== \"\\u000a\" && c !== \"\\u00a0\") {\r\n            break;\r\n        }\r\n        index++;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Checks if a character is an identifier character (meaning, if it is 0-9, A-Z, a-z or _)\r\n * @param c character to check\r\n * @returns true if the character is an identifier character\r\n */\r\nexport function IsIdentifierChar(c: string): boolean {\r\n    const v = c.charCodeAt(0);\r\n    return (\r\n        (v >= 48 && v <= 57) || // 0-9\r\n        (v >= 65 && v <= 90) || // A-Z\r\n        (v >= 97 && v <= 122) || // a-z\r\n        v == 95\r\n    ); // _\r\n}\r\n\r\n/**\r\n * Removes the comments of a code block\r\n * @param block code block to parse\r\n * @returns block with the comments removed\r\n */\r\nexport function RemoveComments(block: string): string {\r\n    let currPos = 0,\r\n        waitForChar = \"\",\r\n        inComments = false;\r\n    const s = [];\r\n\r\n    while (currPos < block.length) {\r\n        const currChar = block.charAt(currPos);\r\n\r\n        if (!waitForChar) {\r\n            switch (currChar) {\r\n                case '\"':\r\n                case \"'\":\r\n                case \"`\":\r\n                    waitForChar = currChar;\r\n                    break;\r\n                case \"/\":\r\n                    if (currPos + 1 < block.length) {\r\n                        const nextChar = block.charAt(currPos + 1);\r\n                        if (nextChar === \"/\") {\r\n                            waitForChar = \"\\n\";\r\n                            inComments = true;\r\n                        } else if (nextChar === \"*\") {\r\n                            waitForChar = \"*/\";\r\n                            inComments = true;\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            if (!inComments) {\r\n                s.push(currChar);\r\n            }\r\n        } else {\r\n            if (currChar === waitForChar) {\r\n                if (waitForChar === '\"' || waitForChar === \"'\") {\r\n                    block.charAt(currPos - 1) !== \"\\\\\" && (waitForChar = \"\");\r\n                    s.push(currChar);\r\n                } else {\r\n                    waitForChar = \"\";\r\n                    inComments = false;\r\n                }\r\n            } else if (waitForChar === \"*/\" && currChar === \"*\" && currPos + 1 < block.length) {\r\n                block.charAt(currPos + 1) === \"/\" && (waitForChar = \"\");\r\n                if (waitForChar === \"\") {\r\n                    inComments = false;\r\n                    currPos++;\r\n                }\r\n            } else {\r\n                if (!inComments) {\r\n                    s.push(currChar);\r\n                }\r\n            }\r\n        }\r\n\r\n        currPos++;\r\n    }\r\n\r\n    return s.join(\"\");\r\n}\r\n\r\n/**\r\n * Finds the first occurrence of a character in a string going backward\r\n * @param s the string to parse\r\n * @param index starting index in the string\r\n * @param c the character to find\r\n * @param c2 an optional second character to find\r\n * @returns the index of the character if found, else -1\r\n */\r\nexport function FindBackward(s: string, index: number, c: string, c2?: string): number {\r\n    while (index >= 0 && s.charAt(index) !== c && (!c2 || s.charAt(index) !== c2)) {\r\n        index--;\r\n    }\r\n\r\n    return index;\r\n}\r\n\r\n/**\r\n * Escapes a string so that it is usable as a regular expression\r\n * @param s string to escape\r\n * @returns escaped string\r\n */\r\nexport function EscapeRegExp(s: string): string {\r\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\n\r\n/**\r\n * Injects code at the beginning and/or end of a function.\r\n * The function is identified by \"mainFuncDecl\". The starting code is injected just after the first \"\\{\" found after the mainFuncDecl.\r\n * The ending code is injected just before the last \"\\}\" of the whole block of code (so, it is assumed that the function is the last of the block of code).\r\n * @param code code to inject into\r\n * @param mainFuncDecl Function declaration to find in the code (for eg: \"void main\")\r\n * @param startingCode The code to inject at the beginning of the function\r\n * @param endingCode The code to inject at the end of the function\r\n * @returns The code with the injected code\r\n */\r\nexport function InjectStartingAndEndingCode(code: string, mainFuncDecl: string, startingCode?: string, endingCode?: string): string {\r\n    let idx = code.indexOf(mainFuncDecl);\r\n    if (idx < 0) {\r\n        return code;\r\n    }\r\n    if (startingCode) {\r\n        // eslint-disable-next-line no-empty\r\n        while (idx++ < code.length && code.charAt(idx) != \"{\") {}\r\n        if (idx < code.length) {\r\n            const part1 = code.substring(0, idx + 1);\r\n            const part2 = code.substring(idx + 1);\r\n            code = part1 + startingCode + part2;\r\n        }\r\n    }\r\n\r\n    if (endingCode) {\r\n        const lastClosingCurly = code.lastIndexOf(\"}\");\r\n        code = code.substring(0, lastClosingCurly);\r\n        code += endingCode + \"\\n}\";\r\n    }\r\n\r\n    return code;\r\n}\r\n", "import { Logger } from \"core/Misc/logger\";\r\nimport { EscapeRegExp, ExtractBetweenMarkers, FindBackward, IsIdentifierChar, RemoveComments, SkipWhitespaces } from \"../../Misc/codeStringParsingTools\";\r\n\r\ninterface IInlineFunctionDescr {\r\n    name: string;\r\n    type: string;\r\n    parameters: string[];\r\n    body: string;\r\n    callIndex: number;\r\n}\r\n\r\n/**\r\n * Class used to inline functions in shader code\r\n */\r\nexport class ShaderCodeInliner {\r\n    private static readonly _RegexpFindFunctionNameAndType = /((\\s+?)(\\w+)\\s+(\\w+)\\s*?)$/;\r\n\r\n    private _sourceCode: string;\r\n    private _functionDescr: IInlineFunctionDescr[];\r\n    private _numMaxIterations: number;\r\n\r\n    /** Gets or sets the token used to mark the functions to inline */\r\n    public inlineToken: string;\r\n\r\n    /** Gets or sets the debug mode */\r\n    public debug: boolean = false;\r\n\r\n    /** Gets the code after the inlining process */\r\n    public get code(): string {\r\n        return this._sourceCode;\r\n    }\r\n\r\n    /**\r\n     * Initializes the inliner\r\n     * @param sourceCode shader code source to inline\r\n     * @param numMaxIterations maximum number of iterations (used to detect recursive calls)\r\n     */\r\n    constructor(sourceCode: string, numMaxIterations = 20) {\r\n        this._sourceCode = sourceCode;\r\n        this._numMaxIterations = numMaxIterations;\r\n        this._functionDescr = [];\r\n        this.inlineToken = \"#define inline\";\r\n    }\r\n\r\n    /**\r\n     * Start the processing of the shader code\r\n     */\r\n    public processCode() {\r\n        if (this.debug) {\r\n            Logger.Log(`Start inlining process (code size=${this._sourceCode.length})...`);\r\n        }\r\n        this._collectFunctions();\r\n        this._processInlining(this._numMaxIterations);\r\n        if (this.debug) {\r\n            Logger.Log(\"End of inlining process.\");\r\n        }\r\n    }\r\n\r\n    private _collectFunctions() {\r\n        let startIndex = 0;\r\n\r\n        while (startIndex < this._sourceCode.length) {\r\n            // locate the function to inline and extract its name\r\n            const inlineTokenIndex = this._sourceCode.indexOf(this.inlineToken, startIndex);\r\n            if (inlineTokenIndex < 0) {\r\n                break;\r\n            }\r\n\r\n            const funcParamsStartIndex = this._sourceCode.indexOf(\"(\", inlineTokenIndex + this.inlineToken.length);\r\n            if (funcParamsStartIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not find the opening parenthesis after the token. startIndex=${startIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcNameMatch = ShaderCodeInliner._RegexpFindFunctionNameAndType.exec(\r\n                this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)\r\n            );\r\n            if (!funcNameMatch) {\r\n                if (this.debug) {\r\n                    Logger.Warn(\r\n                        `Could not extract the name/type of the function from: ${this._sourceCode.substring(inlineTokenIndex + this.inlineToken.length, funcParamsStartIndex)}`\r\n                    );\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const [funcType, funcName] = [funcNameMatch[3], funcNameMatch[4]];\r\n\r\n            // extract the parameters of the function as a whole string (without the leading / trailing parenthesis)\r\n            const funcParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, funcParamsStartIndex);\r\n            if (funcParamsEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the parameters the function '${funcName}' (type=${funcType}). funcParamsStartIndex=${funcParamsStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcParams = this._sourceCode.substring(funcParamsStartIndex + 1, funcParamsEndIndex);\r\n\r\n            // extract the body of the function (with the curly brackets)\r\n            const funcBodyStartIndex = SkipWhitespaces(this._sourceCode, funcParamsEndIndex + 1);\r\n            if (funcBodyStartIndex === this._sourceCode.length) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcParamsEndIndex=${funcParamsEndIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n\r\n            const funcBodyEndIndex = ExtractBetweenMarkers(\"{\", \"}\", this._sourceCode, funcBodyStartIndex);\r\n            if (funcBodyEndIndex < 0) {\r\n                if (this.debug) {\r\n                    Logger.Warn(`Could not extract the body of the function '${funcName}' (type=${funcType}). funcBodyStartIndex=${funcBodyStartIndex}`);\r\n                }\r\n                startIndex = inlineTokenIndex + this.inlineToken.length;\r\n                continue;\r\n            }\r\n            const funcBody = this._sourceCode.substring(funcBodyStartIndex, funcBodyEndIndex + 1);\r\n\r\n            // process the parameters: extract each names\r\n            const params = RemoveComments(funcParams).split(\",\");\r\n            const paramNames = [];\r\n\r\n            for (let p = 0; p < params.length; ++p) {\r\n                const param = params[p].trim();\r\n                const idx = param.lastIndexOf(\" \");\r\n\r\n                if (idx >= 0) {\r\n                    paramNames.push(param.substring(idx + 1));\r\n                }\r\n            }\r\n\r\n            if (funcType !== \"void\") {\r\n                // for functions that return a value, we will replace \"return\" by \"tempvarname = \", tempvarname being a unique generated name\r\n                paramNames.push(\"return\");\r\n            }\r\n\r\n            // collect the function\r\n            this._functionDescr.push({\r\n                name: funcName,\r\n                type: funcType,\r\n                parameters: paramNames,\r\n                body: funcBody,\r\n                callIndex: 0,\r\n            });\r\n\r\n            startIndex = funcBodyEndIndex + 1;\r\n\r\n            // remove the function from the source code\r\n            const partBefore = inlineTokenIndex > 0 ? this._sourceCode.substring(0, inlineTokenIndex) : \"\";\r\n            const partAfter = funcBodyEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(funcBodyEndIndex + 1) : \"\";\r\n\r\n            this._sourceCode = partBefore + partAfter;\r\n\r\n            startIndex -= funcBodyEndIndex + 1 - inlineTokenIndex;\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`Collect functions: ${this._functionDescr.length} functions found. functionDescr=${this._functionDescr}`);\r\n        }\r\n    }\r\n\r\n    private _processInlining(numMaxIterations: number = 20): boolean {\r\n        while (numMaxIterations-- >= 0) {\r\n            if (!this._replaceFunctionCallsByCode()) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (this.debug) {\r\n            Logger.Log(`numMaxIterations is ${numMaxIterations} after inlining process`);\r\n        }\r\n\r\n        return numMaxIterations >= 0;\r\n    }\r\n\r\n    private _replaceFunctionCallsByCode(): boolean {\r\n        let doAgain = false;\r\n\r\n        for (const func of this._functionDescr) {\r\n            const { name, type, parameters, body } = func;\r\n\r\n            let startIndex = 0;\r\n\r\n            while (startIndex < this._sourceCode.length) {\r\n                // Look for the function name in the source code\r\n                const functionCallIndex = this._sourceCode.indexOf(name, startIndex);\r\n\r\n                if (functionCallIndex < 0) {\r\n                    break;\r\n                }\r\n\r\n                // Make sure \"name\" is not part of a bigger string\r\n                if (functionCallIndex === 0 || IsIdentifierChar(this._sourceCode.charAt(functionCallIndex - 1))) {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // Find the opening parenthesis\r\n                const callParamsStartIndex = SkipWhitespaces(this._sourceCode, functionCallIndex + name.length);\r\n                if (callParamsStartIndex === this._sourceCode.length || this._sourceCode.charAt(callParamsStartIndex) !== \"(\") {\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                // extract the parameters of the function call as a whole string (without the leading / trailing parenthesis)\r\n                const callParamsEndIndex = ExtractBetweenMarkers(\"(\", \")\", this._sourceCode, callParamsStartIndex);\r\n                if (callParamsEndIndex < 0) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(`Could not extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}`);\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n                const callParams = this._sourceCode.substring(callParamsStartIndex + 1, callParamsEndIndex);\r\n\r\n                // process the parameter call: extract each names\r\n\r\n                // this function split the parameter list used in the function call at ',' boundaries by taking care of potential parenthesis like in:\r\n                //      myfunc(a, vec2(1., 0.), 4.)\r\n                const splitParameterCall = (s: string) => {\r\n                    const parameters = [];\r\n                    let curIdx = 0,\r\n                        startParamIdx = 0;\r\n                    while (curIdx < s.length) {\r\n                        if (s.charAt(curIdx) === \"(\") {\r\n                            const idx2 = ExtractBetweenMarkers(\"(\", \")\", s, curIdx);\r\n                            if (idx2 < 0) {\r\n                                return null;\r\n                            }\r\n                            curIdx = idx2;\r\n                        } else if (s.charAt(curIdx) === \",\") {\r\n                            parameters.push(s.substring(startParamIdx, curIdx));\r\n                            startParamIdx = curIdx + 1;\r\n                        }\r\n                        curIdx++;\r\n                    }\r\n                    if (startParamIdx < curIdx) {\r\n                        parameters.push(s.substring(startParamIdx, curIdx));\r\n                    }\r\n                    return parameters;\r\n                };\r\n\r\n                const params = splitParameterCall(RemoveComments(callParams));\r\n\r\n                if (params === null) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: can't extract the parameters of the function call. Function '${name}' (type=${type}). callParamsStartIndex=${callParamsStartIndex}, callParams=` +\r\n                                callParams\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                const paramNames = [];\r\n\r\n                for (let p = 0; p < params.length; ++p) {\r\n                    const param = params[p].trim();\r\n                    paramNames.push(param);\r\n                }\r\n\r\n                const retParamName = type !== \"void\" ? name + \"_\" + func.callIndex++ : null;\r\n\r\n                if (retParamName) {\r\n                    paramNames.push(retParamName + \" =\");\r\n                }\r\n\r\n                if (paramNames.length !== parameters.length) {\r\n                    if (this.debug) {\r\n                        Logger.Warn(\r\n                            `Invalid function call: not the same number of parameters for the call than the number expected by the function. Function '${name}' (type=${type}). function parameters=${parameters}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                    startIndex = functionCallIndex + name.length;\r\n                    continue;\r\n                }\r\n\r\n                startIndex = callParamsEndIndex + 1;\r\n\r\n                // replace the function call by the body function\r\n                const funcBody = this._replaceNames(body, parameters, paramNames);\r\n\r\n                let partBefore = functionCallIndex > 0 ? this._sourceCode.substring(0, functionCallIndex) : \"\";\r\n                const partAfter = callParamsEndIndex + 1 < this._sourceCode.length - 1 ? this._sourceCode.substring(callParamsEndIndex + 1) : \"\";\r\n\r\n                if (retParamName) {\r\n                    // case where the function returns a value. We generate:\r\n                    // FUNCTYPE retParamName;\r\n                    // {function body}\r\n                    // and replace the function call by retParamName\r\n                    const injectDeclarationIndex = FindBackward(this._sourceCode, functionCallIndex - 1, \"\\n\", \"{\");\r\n\r\n                    partBefore = this._sourceCode.substring(0, injectDeclarationIndex + 1);\r\n                    const partBetween = this._sourceCode.substring(injectDeclarationIndex + 1, functionCallIndex);\r\n\r\n                    this._sourceCode = partBefore + type + \" \" + retParamName + \";\\n\" + funcBody + \"\\n\" + partBetween + retParamName + partAfter;\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(\r\n                            `Replace function call by code. Function '${name}' (type=${type}). injectDeclarationIndex=${injectDeclarationIndex}, call parameters=${paramNames}`\r\n                        );\r\n                    }\r\n                } else {\r\n                    // simple case where the return value of the function is \"void\"\r\n                    this._sourceCode = partBefore + funcBody + partAfter;\r\n\r\n                    startIndex += funcBody.length - (callParamsEndIndex + 1 - functionCallIndex);\r\n\r\n                    if (this.debug) {\r\n                        Logger.Log(`Replace function call by code. Function '${name}' (type=${type}). functionCallIndex=${functionCallIndex}, call parameters=${paramNames}`);\r\n                    }\r\n                }\r\n\r\n                doAgain = true;\r\n            }\r\n        }\r\n\r\n        return doAgain;\r\n    }\r\n\r\n    private _replaceNames(code: string, sources: string[], destinations: string[]): string {\r\n        for (let i = 0; i < sources.length; ++i) {\r\n            const source = new RegExp(EscapeRegExp(sources[i]), \"g\"),\r\n                sourceLen = sources[i].length,\r\n                destination = destinations[i];\r\n\r\n            code = code.replace(source, (match, ...args) => {\r\n                const offset: number = args[0];\r\n                // Make sure \"source\" is not part of a bigger identifier (for eg, if source=view and we matched it with viewDirection)\r\n                if (IsIdentifierChar(code.charAt(offset - 1)) || IsIdentifierChar(code.charAt(offset + sourceLen))) {\r\n                    return sources[i];\r\n                }\r\n                return destination;\r\n            });\r\n        }\r\n\r\n        return code;\r\n    }\r\n}\r\n", "import { Scene } from \"../scene\";\r\nimport { Buffer, VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport type { Nullable, FloatArray, IndicesArray } from \"../types\";\r\nimport type { ISceneComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { BoundingBox } from \"../Culling/boundingBox\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { Material } from \"../Materials/material\";\r\nimport { ShaderMaterial } from \"../Materials/shaderMaterial\";\r\nimport type { DataBuffer } from \"../Buffers/dataBuffer\";\r\nimport { Color3 } from \"../Maths/math.color\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { DrawWrapper } from \"../Materials/drawWrapper\";\r\nimport { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport { CreateBoxVertexData } from \"../Meshes/Builders/boxBuilder\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { _RetryWithInterval } from \"../Misc/timingTools\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /** @internal (Backing field) */\r\n        _boundingBoxRenderer: BoundingBoxRenderer;\r\n\r\n        /** @internal (Backing field) */\r\n        _forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if all bounding boxes must be rendered\r\n         */\r\n        forceShowBoundingBoxes: boolean;\r\n\r\n        /**\r\n         * Gets the bounding box renderer associated with the scene\r\n         * @returns a BoundingBoxRenderer\r\n         */\r\n        getBoundingBoxRenderer(): BoundingBoxRenderer;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"forceShowBoundingBoxes\", {\r\n    get: function (this: Scene) {\r\n        return this._forceShowBoundingBoxes || false;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        this._forceShowBoundingBoxes = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getBoundingBoxRenderer = function (): BoundingBoxRenderer {\r\n    if (!this._boundingBoxRenderer) {\r\n        this._boundingBoxRenderer = new BoundingBoxRenderer(this);\r\n    }\r\n\r\n    return this._boundingBoxRenderer;\r\n};\r\n\r\ndeclare module \"../Meshes/abstractMesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface AbstractMesh {\r\n        /** @internal (Backing field) */\r\n        _showBoundingBox: boolean;\r\n\r\n        /**\r\n         * Gets or sets a boolean indicating if the bounding box must be rendered as well (false by default)\r\n         */\r\n        showBoundingBox: boolean;\r\n    }\r\n}\r\n\r\nObject.defineProperty(AbstractMesh.prototype, \"showBoundingBox\", {\r\n    get: function (this: AbstractMesh) {\r\n        return this._showBoundingBox || false;\r\n    },\r\n    set: function (this: AbstractMesh, value: boolean) {\r\n        this._showBoundingBox = value;\r\n        // Lazyly creates a BB renderer if needed.\r\n        if (value) {\r\n            this.getScene().getBoundingBoxRenderer();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nconst TempMatrix = Matrix.Identity();\r\nconst TempVec1 = new Vector3();\r\nconst TempVec2 = new Vector3();\r\n// `Matrix.asArray` returns its internal array, so it can be directly updated\r\nconst TempMatrixArray = TempMatrix.asArray();\r\n\r\n// BoundingBox copies from it, so it's safe to reuse vectors here\r\nconst DummyBoundingBox = new BoundingBox(TempVec1, TempVec1);\r\n\r\n/**\r\n * Component responsible of rendering the bounding box of the meshes in a scene.\r\n * This is usually used through the mesh.showBoundingBox or the scene.forceShowBoundingBoxes properties\r\n */\r\nexport class BoundingBoxRenderer implements ISceneComponent {\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_BOUNDINGBOXRENDERER;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    /**\r\n     * Color of the bounding box lines placed in front of an object\r\n     */\r\n    public frontColor = new Color3(1, 1, 1);\r\n    /**\r\n     * Color of the bounding box lines placed behind an object\r\n     */\r\n    public backColor = new Color3(0.1, 0.1, 0.1);\r\n    /**\r\n     * Defines if the renderer should show the back lines or not\r\n     */\r\n    public showBackLines = true;\r\n\r\n    /**\r\n     * Observable raised before rendering a bounding box\r\n     * When {@link BoundingBoxRenderer.useInstances} enabled,\r\n     * this would only be triggered once for one rendering, instead of once every bounding box.\r\n     * Events would be triggered with a dummy box to keep backwards compatibility,\r\n     * the passed bounding box has no meaning and should be ignored.\r\n     */\r\n    public onBeforeBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after rendering a bounding box\r\n     * When {@link BoundingBoxRenderer.useInstances} enabled,\r\n     * this would only be triggered once for one rendering, instead of once every bounding box.\r\n     * Events would be triggered with a dummy box to keep backwards compatibility,\r\n     * the passed bounding box has no meaning and should be ignored.\r\n     */\r\n    public onAfterBoxRenderingObservable = new Observable<BoundingBox>();\r\n\r\n    /**\r\n     * Observable raised after resources are created\r\n     */\r\n    public onResourcesReadyObservable = new Observable<BoundingBoxRenderer>();\r\n\r\n    /**\r\n     * When false, no bounding boxes will be rendered\r\n     */\r\n    public enabled = true;\r\n\r\n    /** Shader language used by the renderer */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language used in this renderer.\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public renderList = new SmartArray<BoundingBox>(32);\r\n\r\n    private _colorShader: ShaderMaterial;\r\n    private _colorShaderForOcclusionQuery: ShaderMaterial;\r\n    private _vertexBuffers: { [key: string]: Nullable<VertexBuffer> } = {};\r\n    private _indexBuffer: DataBuffer;\r\n    private _fillIndexBuffer: Nullable<DataBuffer> = null;\r\n    private _fillIndexData: Nullable<IndicesArray> = null;\r\n    private _uniformBufferFront: UniformBuffer;\r\n    private _uniformBufferBack: UniformBuffer;\r\n    private _renderPassIdForOcclusionQuery: number;\r\n    /**\r\n     * Internal buffer for instanced rendering\r\n     */\r\n    private _matrixBuffer: Nullable<Buffer> = null;\r\n    private _matrices: Nullable<Float32Array> = null;\r\n\r\n    /**\r\n     * Internal state of whether instanced rendering enabled\r\n     */\r\n    protected _useInstances = false;\r\n\r\n    /** @internal */\r\n    public _drawWrapperFront: Nullable<DrawWrapper> = null;\r\n    /** @internal */\r\n    public _drawWrapperBack: Nullable<DrawWrapper> = null;\r\n\r\n    /**\r\n     * Instantiates a new bounding box renderer in a scene.\r\n     * @param scene the scene the  renderer renders in\r\n     */\r\n    constructor(scene: Scene) {\r\n        this.scene = scene;\r\n\r\n        const engine = this.scene.getEngine();\r\n        if (engine.isWebGPU) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n        }\r\n\r\n        scene._addComponent(this);\r\n        this._uniformBufferFront = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererFront\", true);\r\n        this._buildUniformLayout(this._uniformBufferFront);\r\n        this._uniformBufferBack = new UniformBuffer(this.scene.getEngine(), undefined, undefined, \"BoundingBoxRendererBack\", true);\r\n        this._buildUniformLayout(this._uniformBufferBack);\r\n    }\r\n\r\n    private _buildUniformLayout(ubo: UniformBuffer): void {\r\n        ubo.addUniform(\"color\", 4);\r\n        ubo.addUniform(\"world\", 16);\r\n        ubo.addUniform(\"viewProjection\", 16);\r\n        ubo.addUniform(\"viewProjectionR\", 16);\r\n        ubo.create();\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._beforeEvaluateActiveMeshStage.registerStep(SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER, this, this.reset);\r\n\r\n        this.scene._preActiveMeshStage.registerStep(SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER, this, this._preActiveMesh);\r\n\r\n        this.scene._evaluateSubMeshStage.registerStep(SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER, this, this._evaluateSubMesh);\r\n\r\n        this.scene._afterRenderingGroupDrawStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER, this, this.render);\r\n    }\r\n\r\n    /**\r\n     * Checks if the renderer is ready asynchronously.\r\n     * @param timeStep Time step in ms between retries (default is 16)\r\n     * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 30000)\r\n     * @returns The promise that resolves when the renderer is ready\r\n     */\r\n    public async whenReadyAsync(timeStep = 16, maxTimeout = 30000): Promise<void> {\r\n        this._prepareResources();\r\n        return await new Promise((resolve) => {\r\n            _RetryWithInterval(\r\n                () => {\r\n                    return this._colorShader.isReady();\r\n                },\r\n                () => {\r\n                    resolve();\r\n                },\r\n                (err, isTimeout) => {\r\n                    if (!isTimeout) {\r\n                        Logger.Error(\"BoundingBoxRenderer: An unexpected error occurred while waiting for the renderer to be ready.\");\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                            if (err.stack) {\r\n                                Logger.Error(err.stack);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        Logger.Error(`BoundingBoxRenderer: Timeout while waiting for the renderer to be ready.`);\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                        }\r\n                    }\r\n                },\r\n                timeStep,\r\n                maxTimeout\r\n            );\r\n        });\r\n    }\r\n\r\n    /** @internal */\r\n    public _evaluateSubMesh(mesh: AbstractMesh, subMesh: SubMesh): void {\r\n        if (mesh.showSubMeshesBoundingBox) {\r\n            const boundingInfo = subMesh.getBoundingInfo();\r\n            if (boundingInfo !== null && boundingInfo !== undefined) {\r\n                boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n                this.renderList.push(boundingInfo.boundingBox);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public _preActiveMesh(mesh: AbstractMesh): void {\r\n        if (mesh.showBoundingBox || this.scene.forceShowBoundingBoxes) {\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            boundingInfo.boundingBox._tag = mesh.renderingGroupId;\r\n            this.renderList.push(boundingInfo.boundingBox);\r\n        }\r\n    }\r\n\r\n    private _prepareResources(): void {\r\n        if (this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this._colorShader = new ShaderMaterial(\r\n            \"colorShader\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind, \"world0\", \"world1\", \"world2\", \"world3\"],\r\n\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n                shaderLanguage: this._shaderLanguage,\r\n                extraInitializationsAsync: async () => {\r\n                    if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                        await Promise.all([import(\"../ShadersWGSL/boundingBoxRenderer.vertex\"), import(\"../ShadersWGSL/boundingBoxRenderer.fragment\")]);\r\n                    } else {\r\n                        await Promise.all([import(\"../Shaders/boundingBoxRenderer.vertex\"), import(\"../Shaders/boundingBoxRenderer.fragment\")]);\r\n                    }\r\n                },\r\n            },\r\n            false\r\n        );\r\n        this._colorShader.setDefine(\"INSTANCES\", this._useInstances);\r\n        this._colorShader.doNotSerialize = true;\r\n\r\n        this._colorShader.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        this._colorShaderForOcclusionQuery = new ShaderMaterial(\r\n            \"colorShaderOccQuery\",\r\n            this.scene,\r\n            \"boundingBoxRenderer\",\r\n            {\r\n                attributes: [VertexBuffer.PositionKind],\r\n                uniforms: [\"world\", \"viewProjection\", \"viewProjectionR\", \"color\"],\r\n                uniformBuffers: [\"BoundingBoxRenderer\"],\r\n                shaderLanguage: this._shaderLanguage,\r\n                extraInitializationsAsync: async () => {\r\n                    if (this._shaderLanguage === ShaderLanguage.WGSL) {\r\n                        await Promise.all([import(\"../ShadersWGSL/boundingBoxRenderer.vertex\"), import(\"../ShadersWGSL/boundingBoxRenderer.fragment\")]);\r\n                    } else {\r\n                        await Promise.all([import(\"../Shaders/boundingBoxRenderer.vertex\"), import(\"../Shaders/boundingBoxRenderer.fragment\")]);\r\n                    }\r\n                },\r\n            },\r\n            true\r\n        );\r\n        this._colorShaderForOcclusionQuery.doNotSerialize = true;\r\n\r\n        this._colorShaderForOcclusionQuery.reservedDataStore = {\r\n            hidden: true,\r\n        };\r\n\r\n        const engine = this.scene.getEngine();\r\n        const boxdata = CreateBoxVertexData({ size: 1.0 });\r\n        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(engine, <FloatArray>boxdata.positions, VertexBuffer.PositionKind, false);\r\n        this._createIndexBuffer();\r\n        this._fillIndexData = boxdata.indices;\r\n        this.onResourcesReadyObservable.notifyObservers(this);\r\n    }\r\n\r\n    private _createIndexBuffer(): void {\r\n        const engine = this.scene.getEngine();\r\n        this._indexBuffer = engine.createIndexBuffer([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 7, 1, 6, 2, 5, 3, 4]);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        const vb = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (vb) {\r\n            vb._rebuild();\r\n        }\r\n        this._createIndexBuffer();\r\n\r\n        if (this._matrixBuffer) {\r\n            this._matrixBuffer._rebuild();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public reset(): void {\r\n        this.renderList.reset();\r\n    }\r\n\r\n    /**\r\n     * Render the bounding boxes of a specific rendering group\r\n     * @param renderingGroupId defines the rendering group to render\r\n     */\r\n    public render(renderingGroupId: number): void {\r\n        if (this.renderList.length === 0 || !this.enabled) {\r\n            return;\r\n        }\r\n\r\n        if (this._useInstances) {\r\n            this._renderInstanced(renderingGroupId);\r\n            return;\r\n        }\r\n\r\n        this._prepareResources();\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const engine = this.scene.getEngine();\r\n        engine.setDepthWrite(false);\r\n\r\n        const transformMatrix = this.scene.getTransformMatrix();\r\n\r\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\r\n            const boundingBox = this.renderList.data[boundingBoxIndex];\r\n            if (boundingBox._tag !== renderingGroupId) {\r\n                continue;\r\n            }\r\n\r\n            this._createWrappersForBoundingBox(boundingBox);\r\n            this.onBeforeBoxRenderingObservable.notifyObservers(boundingBox);\r\n\r\n            const min = boundingBox.minimum;\r\n            const max = boundingBox.maximum;\r\n            const diff = max.subtract(min);\r\n            const median = min.add(diff.scale(0.5));\r\n\r\n            const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z)\r\n                .multiply(Matrix.Translation(median.x, median.y, median.z))\r\n                .multiply(boundingBox.getWorldMatrix());\r\n\r\n            const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n            if (this.showBackLines) {\r\n                const drawWrapperBack = boundingBox._drawWrapperBack ?? this._colorShader._getDrawWrapper();\r\n\r\n                this._colorShader._preBind(drawWrapperBack);\r\n\r\n                engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\r\n\r\n                // Back\r\n                if (useReverseDepthBuffer) {\r\n                    engine.setDepthFunctionToLessOrEqual();\r\n                } else {\r\n                    engine.setDepthFunctionToGreaterOrEqual();\r\n                }\r\n                this._uniformBufferBack.bindToEffect(drawWrapperBack.effect!, \"BoundingBoxRenderer\");\r\n                this._uniformBufferBack.updateColor4(\"color\", this.backColor, 1);\r\n                this._uniformBufferBack.updateMatrix(\"world\", worldMatrix);\r\n                this._uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\r\n                this._uniformBufferBack.update();\r\n\r\n                // Draw order\r\n                engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n            }\r\n\r\n            const drawWrapperFront = boundingBox._drawWrapperFront ?? this._colorShader._getDrawWrapper();\r\n\r\n            this._colorShader._preBind(drawWrapperFront);\r\n\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._colorShader.getEffect());\r\n\r\n            // Front\r\n            if (useReverseDepthBuffer) {\r\n                engine.setDepthFunctionToGreater();\r\n            } else {\r\n                engine.setDepthFunctionToLess();\r\n            }\r\n            this._uniformBufferFront.bindToEffect(drawWrapperFront.effect!, \"BoundingBoxRenderer\");\r\n            this._uniformBufferFront.updateColor4(\"color\", this.frontColor, 1);\r\n            this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n            this._uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\r\n            this._uniformBufferFront.update();\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24);\r\n\r\n            this.onAfterBoxRenderingObservable.notifyObservers(boundingBox);\r\n        }\r\n        this._colorShader.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n    }\r\n\r\n    private _createWrappersForBoundingBox(boundingBox: BoundingBox | BoundingBoxRenderer): void {\r\n        if (!boundingBox._drawWrapperFront) {\r\n            const engine = this.scene.getEngine();\r\n\r\n            boundingBox._drawWrapperFront = new DrawWrapper(engine);\r\n            boundingBox._drawWrapperBack = new DrawWrapper(engine);\r\n\r\n            boundingBox._drawWrapperFront.setEffect(this._colorShader.getEffect());\r\n            boundingBox._drawWrapperBack.setEffect(this._colorShader.getEffect());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In case of occlusion queries, we can render the occlusion bounding box through this method\r\n     * @param mesh Define the mesh to render the occlusion bounding box for\r\n     */\r\n    public renderOcclusionBoundingBox(mesh: AbstractMesh): void {\r\n        const engine = this.scene.getEngine();\r\n\r\n        if (this._renderPassIdForOcclusionQuery === undefined) {\r\n            this._renderPassIdForOcclusionQuery = engine.createRenderPassId(`Render pass for occlusion query`);\r\n        }\r\n\r\n        const currentRenderPassId = engine.currentRenderPassId;\r\n\r\n        engine.currentRenderPassId = this._renderPassIdForOcclusionQuery;\r\n\r\n        this._prepareResources();\r\n\r\n        const subMesh = mesh.subMeshes[0];\r\n\r\n        if (!this._colorShaderForOcclusionQuery.isReady(mesh, undefined, subMesh) || !mesh.hasBoundingInfo) {\r\n            engine.currentRenderPassId = currentRenderPassId;\r\n            return;\r\n        }\r\n\r\n        if (!this._fillIndexBuffer) {\r\n            this._fillIndexBuffer = engine.createIndexBuffer(this._fillIndexData!);\r\n        }\r\n\r\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n\r\n        engine.setDepthWrite(false);\r\n        engine.setColorWrite(false);\r\n\r\n        const boundingBox = mesh.getBoundingInfo().boundingBox;\r\n        const min = boundingBox.minimum;\r\n        const max = boundingBox.maximum;\r\n        const diff = max.subtract(min);\r\n        const median = min.add(diff.scale(0.5));\r\n\r\n        const worldMatrix = Matrix.Scaling(diff.x, diff.y, diff.z)\r\n            .multiply(Matrix.Translation(median.x, median.y, median.z))\r\n            .multiply(boundingBox.getWorldMatrix());\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        this._colorShaderForOcclusionQuery._preBind(drawWrapper);\r\n\r\n        engine.bindBuffers(this._vertexBuffers, this._fillIndexBuffer, <Effect>drawWrapper.effect);\r\n\r\n        if (useReverseDepthBuffer) {\r\n            engine.setDepthFunctionToGreater();\r\n        } else {\r\n            engine.setDepthFunctionToLess();\r\n        }\r\n\r\n        this.scene.resetCachedMaterial();\r\n\r\n        this._uniformBufferFront.bindToEffect(drawWrapper.effect!, \"BoundingBoxRenderer\");\r\n        this._uniformBufferFront.updateMatrix(\"world\", worldMatrix);\r\n        this._uniformBufferFront.updateMatrix(\"viewProjection\", this.scene.getTransformMatrix());\r\n        this._uniformBufferFront.update();\r\n\r\n        engine.drawElementsType(Material.TriangleFillMode, 0, 36);\r\n\r\n        this._colorShaderForOcclusionQuery.unbind();\r\n        engine.setDepthFunctionToLessOrEqual();\r\n        engine.setDepthWrite(true);\r\n        engine.setColorWrite(true);\r\n\r\n        engine.currentRenderPassId = currentRenderPassId;\r\n    }\r\n\r\n    /**\r\n     * Sets whether to use instanced rendering.\r\n     * When not enabled, BoundingBoxRenderer renders in a loop,\r\n     * calling engine.drawElementsType for each bounding box in renderList,\r\n     * making every bounding box 1 or 2 draw call.\r\n     * When enabled, it collects bounding boxes to render,\r\n     * and render all boxes in 1 or 2 draw call.\r\n     * This could make the rendering with many bounding boxes much faster than not enabled,\r\n     * but could result in a difference in rendering result if\r\n     * {@link BoundingBoxRenderer.showBackLines} enabled,\r\n     * because drawing the black/white part of each box one after the other\r\n     * can be different from drawing the black part of all boxes and then the white part.\r\n     * Also, when enabled, events of {@link BoundingBoxRenderer.onBeforeBoxRenderingObservable}\r\n     * and {@link BoundingBoxRenderer.onAfterBoxRenderingObservable} would only be triggered once\r\n     * for one rendering, instead of once every bounding box.\r\n     * Events would be triggered with a dummy box to keep backwards compatibility,\r\n     * the passed bounding box has no meaning and should be ignored.\r\n     * @param val whether to use instanced rendering\r\n     */\r\n    public set useInstances(val: boolean) {\r\n        this._useInstances = val;\r\n        if (this._colorShader) {\r\n            this._colorShader.setDefine(\"INSTANCES\", val);\r\n        }\r\n        if (!val) {\r\n            this._cleanupInstances();\r\n        }\r\n    }\r\n\r\n    public get useInstances(): boolean {\r\n        return this._useInstances;\r\n    }\r\n\r\n    /**\r\n     * Instanced render the bounding boxes of a specific rendering group\r\n     * @param renderingGroupId defines the rendering group to render\r\n     */\r\n    private _renderInstanced(renderingGroupId: number): void {\r\n        if (this.renderList.length === 0 || !this.enabled) {\r\n            return;\r\n        }\r\n        this._prepareResources();\r\n\r\n        if (!this._colorShader.isReady()) {\r\n            return;\r\n        }\r\n\r\n        const colorShader = this._colorShader;\r\n        let matrices = this._matrices;\r\n        const expectedLength = this.renderList.length * 16;\r\n        if (!matrices || matrices.length < expectedLength || matrices.length > expectedLength * 2) {\r\n            matrices = new Float32Array(expectedLength);\r\n            this._matrices = matrices;\r\n        }\r\n\r\n        this.onBeforeBoxRenderingObservable.notifyObservers(DummyBoundingBox);\r\n\r\n        let instancesCount = 0;\r\n        const floatingOriginOffset = this.scene.floatingOriginOffset;\r\n\r\n        for (let boundingBoxIndex = 0; boundingBoxIndex < this.renderList.length; boundingBoxIndex++) {\r\n            const boundingBox = this.renderList.data[boundingBoxIndex];\r\n            if (boundingBox._tag !== renderingGroupId) {\r\n                continue;\r\n            }\r\n\r\n            const min = boundingBox.minimum;\r\n            const max = boundingBox.maximum;\r\n\r\n            const diff = max.subtractToRef(min, TempVec2);\r\n            const median = min.addToRef(diff.scaleToRef(0.5, TempVec1), TempVec1);\r\n\r\n            const m = TempMatrixArray;\r\n\r\n            // Directly update the matrix values in column-major order\r\n            m[0] = diff._x; // Scale X\r\n            m[3] = median._x; // Translate X\r\n\r\n            m[5] = diff._y; // Scale Y\r\n            m[7] = median._y; // Translate Y\r\n\r\n            m[10] = diff._z; // Scale Z\r\n            m[11] = median._z; // Translate Z\r\n\r\n            const offset = instancesCount * 16;\r\n            TempMatrix.multiplyToArray(boundingBox.getWorldMatrix(), matrices, offset);\r\n\r\n            matrices[offset + 12] -= floatingOriginOffset.x;\r\n            matrices[offset + 13] -= floatingOriginOffset.y;\r\n            matrices[offset + 14] -= floatingOriginOffset.z;\r\n            instancesCount++;\r\n        }\r\n\r\n        const engine = this.scene.getEngine();\r\n        // keeps the original depth function and depth write\r\n        const depthFunction = engine.getDepthFunction() ?? Constants.LEQUAL;\r\n        const depthWrite = engine.getDepthWrite();\r\n        engine.setDepthWrite(false);\r\n        const matrixBuffer = this._matrixBuffer;\r\n        if (matrixBuffer?.isUpdatable() && matrixBuffer.getData() === matrices) {\r\n            matrixBuffer.update(matrices);\r\n        } else {\r\n            this._createInstanceBuffer(matrices);\r\n        }\r\n\r\n        this._createWrappersForBoundingBox(this);\r\n\r\n        const useReverseDepthBuffer = engine.useReverseDepthBuffer;\r\n        const transformMatrix = this.scene.getTransformMatrix();\r\n\r\n        if (this.showBackLines) {\r\n            const drawWrapperBack = this._drawWrapperBack ?? colorShader._getDrawWrapper();\r\n\r\n            colorShader._preBind(drawWrapperBack);\r\n\r\n            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, colorShader.getEffect());\r\n\r\n            // Back\r\n            if (useReverseDepthBuffer) {\r\n                engine.setDepthFunctionToLessOrEqual();\r\n            } else {\r\n                engine.setDepthFunctionToGreaterOrEqual();\r\n            }\r\n            const _uniformBufferBack: UniformBuffer = this._uniformBufferBack;\r\n\r\n            _uniformBufferBack.bindToEffect(drawWrapperBack.effect!, \"BoundingBoxRenderer\");\r\n            _uniformBufferBack.updateColor4(\"color\", this.backColor, 1);\r\n            _uniformBufferBack.updateMatrix(\"viewProjection\", transformMatrix);\r\n            _uniformBufferBack.update();\r\n\r\n            // Draw order\r\n            engine.drawElementsType(Material.LineListDrawMode, 0, 24, instancesCount);\r\n        }\r\n\r\n        const drawWrapperFront = colorShader._getDrawWrapper();\r\n\r\n        colorShader._preBind(drawWrapperFront);\r\n\r\n        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, colorShader.getEffect());\r\n\r\n        // Front\r\n        if (useReverseDepthBuffer) {\r\n            engine.setDepthFunctionToGreater();\r\n        } else {\r\n            engine.setDepthFunctionToLess();\r\n        }\r\n        const _uniformBufferFront: UniformBuffer = this._uniformBufferFront;\r\n        _uniformBufferFront.bindToEffect(drawWrapperFront.effect!, \"BoundingBoxRenderer\");\r\n        _uniformBufferFront.updateColor4(\"color\", this.frontColor, 1);\r\n        _uniformBufferFront.updateMatrix(\"viewProjection\", transformMatrix);\r\n        _uniformBufferFront.update();\r\n\r\n        // Draw order\r\n        engine.drawElementsType(Material.LineListDrawMode, 0, 24, instancesCount);\r\n\r\n        this.onAfterBoxRenderingObservable.notifyObservers(DummyBoundingBox);\r\n\r\n        colorShader.unbind();\r\n        engine.setDepthFunction(depthFunction);\r\n        engine.setDepthWrite(depthWrite);\r\n    }\r\n\r\n    /**\r\n     * Creates buffer for instanced rendering\r\n     * @param buffer buffer to set\r\n     */\r\n    private _createInstanceBuffer(buffer: Float32Array): void {\r\n        const vertexBuffers = this._vertexBuffers;\r\n        this._cleanupInstanceBuffer();\r\n        const matrixBuffer = new Buffer(this.scene.getEngine(), buffer, true, 16, false, true);\r\n\r\n        vertexBuffers.world0 = matrixBuffer.createVertexBuffer(\"world0\", 0, 4);\r\n        vertexBuffers.world1 = matrixBuffer.createVertexBuffer(\"world1\", 4, 4);\r\n        vertexBuffers.world2 = matrixBuffer.createVertexBuffer(\"world2\", 8, 4);\r\n        vertexBuffers.world3 = matrixBuffer.createVertexBuffer(\"world3\", 12, 4);\r\n\r\n        this._matrixBuffer = matrixBuffer;\r\n    }\r\n\r\n    /**\r\n     * Clean up buffers for instanced rendering\r\n     */\r\n    private _cleanupInstanceBuffer(): void {\r\n        const vertexBuffers = this._vertexBuffers;\r\n        if (vertexBuffers.world0) {\r\n            vertexBuffers.world0.dispose();\r\n            delete vertexBuffers.world0;\r\n        }\r\n        if (vertexBuffers.world1) {\r\n            vertexBuffers.world1.dispose();\r\n            delete vertexBuffers.world1;\r\n        }\r\n        if (vertexBuffers.world2) {\r\n            vertexBuffers.world2.dispose();\r\n            delete vertexBuffers.world2;\r\n        }\r\n        if (vertexBuffers.world3) {\r\n            vertexBuffers.world3.dispose();\r\n            delete vertexBuffers.world3;\r\n        }\r\n        this._matrices = null;\r\n        if (this._matrixBuffer) {\r\n            this._matrixBuffer.dispose();\r\n            this._matrixBuffer = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clean up resources for instanced rendering\r\n     */\r\n    private _cleanupInstances(): void {\r\n        this._cleanupInstanceBuffer();\r\n        if (this._drawWrapperFront) {\r\n            this._drawWrapperFront.dispose();\r\n            this._drawWrapperFront = null;\r\n        }\r\n        if (this._drawWrapperBack) {\r\n            this._drawWrapperBack.dispose();\r\n            this._drawWrapperBack = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose and release the resources attached to this renderer.\r\n     */\r\n    public dispose(): void {\r\n        if (this._renderPassIdForOcclusionQuery !== undefined) {\r\n            this.scene.getEngine().releaseRenderPassId(this._renderPassIdForOcclusionQuery);\r\n            this._renderPassIdForOcclusionQuery = undefined as any;\r\n        }\r\n\r\n        if (!this._colorShader) {\r\n            return;\r\n        }\r\n\r\n        this.onBeforeBoxRenderingObservable.clear();\r\n        this.onAfterBoxRenderingObservable.clear();\r\n        this.onResourcesReadyObservable.clear();\r\n\r\n        this.renderList.dispose();\r\n\r\n        this._colorShader.dispose();\r\n        this._colorShaderForOcclusionQuery.dispose();\r\n\r\n        this._uniformBufferFront.dispose();\r\n        this._uniformBufferBack.dispose();\r\n\r\n        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];\r\n        if (buffer) {\r\n            buffer.dispose();\r\n            this._vertexBuffers[VertexBuffer.PositionKind] = null;\r\n        }\r\n        this.scene.getEngine()._releaseBuffer(this._indexBuffer);\r\n\r\n        if (this._fillIndexBuffer) {\r\n            this.scene.getEngine()._releaseBuffer(this._fillIndexBuffer);\r\n            this._fillIndexBuffer = null;\r\n        }\r\n        this._cleanupInstances();\r\n    }\r\n}\r\n", "// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\n\nconst name = \"sceneFragmentDeclaration\";\nconst shader = `uniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\nuniform mat4 view;uniform mat4 projection;uniform vec4 vEyePosition;\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const sceneFragmentDeclaration = { name, shader };\n"],
  "mappings": "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",
  "names": ["name", "name", "name", "name", "name", "parameters"]
}
