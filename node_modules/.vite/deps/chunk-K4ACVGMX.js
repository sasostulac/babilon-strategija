import {
  AbstractSoundSource
} from "./chunk-D2DH57YH.js";
import {
  AbstractAudioNode
} from "./chunk-GA37H3AK.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";

// node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSound.js
var AbstractSound = class extends AbstractSoundSource {
  constructor(name, engine) {
    super(
      name,
      engine,
      3
      /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */
    );
    this._newestInstance = null;
    this._privateInstances = /* @__PURE__ */ new Set();
    this._state = 1;
    this._instances = this._privateInstances;
    this.onEndedObservable = new Observable();
    this._onInstanceEnded = (instance) => {
      if (this._newestInstance === instance) {
        this._newestInstance = null;
      }
      this._privateInstances.delete(instance);
      if (this._instances.size === 0) {
        this._state = 1;
        this.onEndedObservable.notifyObservers(this);
      }
    };
  }
  /**
   * Whether the sound should start playing automatically. Defaults to `false`.
   */
  get autoplay() {
    return this._options.autoplay;
  }
  /**
   * The current playback time of the sound, in seconds.
   */
  get currentTime() {
    const instance = this._getNewestInstance();
    return instance ? instance.currentTime : 0;
  }
  set currentTime(value) {
    this.startOffset = value;
    const instance = this._getNewestInstance();
    if (instance) {
      instance.currentTime = value;
    }
  }
  /**
   * Whether the sound should loop. Defaults to `false`.
   */
  get loop() {
    return this._options.loop;
  }
  set loop(value) {
    this._options.loop = value;
  }
  /**
   * The maximum number of instances that can play at the same time. Defaults to `Infinity`.
   */
  get maxInstances() {
    return this._options.maxInstances;
  }
  set maxInstances(value) {
    this._options.maxInstances = value;
  }
  /**
   * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.
   */
  get startOffset() {
    return this._options.startOffset;
  }
  set startOffset(value) {
    this._options.startOffset = value;
  }
  /**
   * The state of the sound.
   */
  get state() {
    return this._state;
  }
  /**
   * Releases associated resources.
   */
  dispose() {
    super.dispose();
    this.stop();
    this._newestInstance = null;
    this._privateInstances.clear();
    this.onEndedObservable.clear();
  }
  /**
   * Pauses the sound.
   */
  pause() {
    const it = this._instances.values();
    for (let next = it.next(); !next.done; next = it.next()) {
      next.value.pause();
    }
    this._state = 5;
  }
  /**
   * Resumes the sound.
   */
  resume() {
    if (this._state !== 5) {
      return;
    }
    const it = this._instances.values();
    for (let next = it.next(); !next.done; next = it.next()) {
      next.value.resume();
    }
    this._state = 3;
  }
  _beforePlay(instance) {
    if (this.state === 5 && this._instances.size > 0) {
      this.resume();
      return;
    }
    instance.onEndedObservable.addOnce(this._onInstanceEnded);
    this._privateInstances.add(instance);
    this._newestInstance = instance;
  }
  _afterPlay(instance) {
    this._state = instance.state;
  }
  _getNewestInstance() {
    if (this._instances.size === 0) {
      return null;
    }
    if (!this._newestInstance) {
      const it = this._instances.values();
      for (let next = it.next(); !next.done; next = it.next()) {
        this._newestInstance = next.value;
      }
    }
    return this._newestInstance;
  }
  _setState(state) {
    this._state = state;
  }
  _stopExcessInstances() {
    if (this.maxInstances < Infinity) {
      const numberOfInstancesToStop = Array.from(this._instances).filter(
        (instance) => instance.state === 3
        /* SoundState.Started */
      ).length - this.maxInstances;
      const it = this._instances.values();
      for (let i = 0; i < numberOfInstancesToStop; i++) {
        const instance = it.next().value;
        instance.stop();
      }
    }
  }
};

// node_modules/@babylonjs/core/AudioV2/abstractAudio/abstractSoundInstance.js
var _AbstractSoundInstance = class extends AbstractAudioNode {
  constructor(sound) {
    super(
      sound.engine,
      2
      /* AudioNodeType.HAS_OUTPUTS */
    );
    this._state = 1;
    this.onEndedObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onStateChangedObservable = new Observable();
    this._sound = sound;
  }
  /** The playback state of the sound instance */
  get state() {
    return this._state;
  }
  /** @internal */
  dispose() {
    super.dispose();
    this.stop();
    this.onEndedObservable.clear();
    this.onStateChangedObservable.clear();
  }
  _setState(value) {
    if (this._state === value) {
      return;
    }
    this._state = value;
    this.onStateChangedObservable.notifyObservers(this);
  }
};

export {
  AbstractSound,
  _AbstractSoundInstance
};
//# sourceMappingURL=chunk-K4ACVGMX.js.map
