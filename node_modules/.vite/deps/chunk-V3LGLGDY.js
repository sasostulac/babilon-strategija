import {
  GetEnvironmentBRDFTexture
} from "./chunk-I3TMUHRM.js";
import {
  DetailMapConfiguration,
  MaterialPluginBase
} from "./chunk-CXGX3PZM.js";
import {
  ImageProcessingDefinesMixin,
  ImageProcessingMixin,
  Material,
  MaterialDefines,
  MaterialHelperGeometryRendering,
  PrePassConfiguration,
  PushMaterial,
  UVDefinesMixin
} from "./chunk-43CLNRDT.js";
import {
  EffectFallbacks,
  ImageProcessingConfiguration,
  Scene
} from "./chunk-VEFBIZWV.js";
import {
  AddClipPlaneUniforms,
  BindBonesParameters,
  BindClipPlane,
  BindFogParameters,
  BindIBLParameters,
  BindIBLSamplers,
  BindLights,
  BindLogDepth,
  BindMorphTargetParameters,
  BindTextureMatrix,
  HandleFallbacksForShadows,
  MaterialFlags,
  PrepareAttributesForBakedVertexAnimation,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  PrepareAttributesForMorphTargets,
  PrepareDefinesForAttributes,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForIBL,
  PrepareDefinesForLights,
  PrepareDefinesForMergedUV,
  PrepareDefinesForMisc,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareUniformLayoutForIBL,
  PrepareUniformsAndSamplersForIBL,
  PrepareUniformsAndSamplersList
} from "./chunk-UCQRX3RS.js";
import {
  SmartArray
} from "./chunk-A4D5JG2T.js";
import {
  SerializationHelper
} from "./chunk-KEOAMMZ7.js";
import {
  __decorate,
  expandToProperty,
  serialize,
  serializeAsColor3,
  serializeAsTexture,
  serializeAsVector2
} from "./chunk-URVCX2UN.js";
import {
  Color3,
  TmpColors
} from "./chunk-5HS37WJT.js";
import {
  TmpVectors,
  Vector2,
  Vector4
} from "./chunk-H4PB4IWT.js";
import {
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.BRDF_V_HEIGHT_CORRELATED = false;
    this.MS_BRDF_ENERGY_CONSERVATION = false;
    this.SPHERICAL_HARMONICS = false;
    this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
    this.MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
    this.LEGACY_SPECULAR_ENERGY_CONSERVATION = false;
    this.BASE_DIFFUSE_MODEL = 0;
    this.DIELECTRIC_SPECULAR_MODEL = 0;
    this.CONDUCTOR_SPECULAR_MODEL = 0;
  }
};
var PBRBRDFConfiguration = class _PBRBRDFConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
    this._useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this.useEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
    this._useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this.useSmithVisibilityHeightCorrelated = _PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
    this._useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this.useSphericalHarmonics = _PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
    this._useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this.useSpecularGlossinessInputEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
    this._mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
    this.mixIblRadianceWithIrradiance = _PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE;
    this._useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
    this.useLegacySpecularEnergyConservation = _PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION;
    this._baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
    this.baseDiffuseModel = _PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL;
    this._dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
    this.dielectricSpecularModel = _PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL;
    this._conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
    this.conductorSpecularModel = _PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL;
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
    this._enable(true);
  }
  prepareDefines(defines) {
    defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
    defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
    defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
    defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
    defines.MIX_IBL_RADIANCE_WITH_IRRADIANCE = this._mixIblRadianceWithIrradiance;
    defines.LEGACY_SPECULAR_ENERGY_CONSERVATION = this._useLegacySpecularEnergyConservation;
    defines.BASE_DIFFUSE_MODEL = this._baseDiffuseModel;
    defines.DIELECTRIC_SPECULAR_MODEL = this._dielectricSpecularModel;
    defines.CONDUCTOR_SPECULAR_MODEL = this._conductorSpecularModel;
  }
  getClassName() {
    return "PBRBRDFConfiguration";
  }
};
PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;
PBRBRDFConfiguration.DEFAULT_USE_LEGACY_SPECULAR_ENERGY_CONSERVATION = true;
PBRBRDFConfiguration.DEFAULT_DIFFUSE_MODEL = 0;
PBRBRDFConfiguration.DEFAULT_DIELECTRIC_SPECULAR_MODEL = 0;
PBRBRDFConfiguration.DEFAULT_CONDUCTOR_SPECULAR_MODEL = 0;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "mixIblRadianceWithIrradiance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "useLegacySpecularEnergyConservation", void 0);
__decorate([
  serialize("baseDiffuseModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "baseDiffuseModel", void 0);
__decorate([
  serialize("dielectricSpecularModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "dielectricSpecularModel", void 0);
__decorate([
  serialize("conductorSpecularModel"),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBRDFConfiguration.prototype, "conductorSpecularModel", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.CLEARCOAT = false;
    this.CLEARCOAT_DEFAULTIOR = false;
    this.CLEARCOAT_TEXTURE = false;
    this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
    this.CLEARCOAT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.CLEARCOAT_BUMP = false;
    this.CLEARCOAT_BUMPDIRECTUV = 0;
    this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
    this.CLEARCOAT_REMAP_F0 = false;
    this.CLEARCOAT_TINT = false;
    this.CLEARCOAT_TINT_TEXTURE = false;
    this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
    this.CLEARCOAT_TINT_GAMMATEXTURE = false;
  }
};
var PBRClearCoatConfiguration = class _PBRClearCoatConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.roughness = 0;
    this._indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this.indexOfRefraction = _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._remapF0OnInterfaceChange = true;
    this.remapF0OnInterfaceChange = true;
    this._bumpTexture = null;
    this.bumpTexture = null;
    this._isTintEnabled = false;
    this.isTintEnabled = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.tintThickness = 1;
    this._tintTexture = null;
    this.tintTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene, engine) {
    if (!this._isEnabled) {
      return true;
    }
    const disableBumpMap = this._material._disableBumpMap;
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
          if (!this._tintTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.CLEARCOAT = true;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
          } else {
            defines.CLEARCOAT_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
          } else {
            defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          }
          if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
            PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
          } else {
            defines.CLEARCOAT_BUMP = false;
          }
          defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === _PBRClearCoatConfiguration._DefaultIndexOfRefraction;
          if (this._isTintEnabled) {
            defines.CLEARCOAT_TINT = true;
            if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
              defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
            } else {
              defines.CLEARCOAT_TINT_TEXTURE = false;
            }
          } else {
            defines.CLEARCOAT_TINT = false;
            defines.CLEARCOAT_TINT_TEXTURE = false;
          }
        }
      }
    } else {
      defines.CLEARCOAT = false;
      defines.CLEARCOAT_TEXTURE = false;
      defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
      defines.CLEARCOAT_BUMP = false;
      defines.CLEARCOAT_TINT = false;
      defines.CLEARCOAT_TINT_TEXTURE = false;
      defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.CLEARCOAT_DEFAULTIOR = false;
      defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
      defines.CLEARCOAT_BUMPDIRECTUV = 0;
      defines.CLEARCOAT_REMAP_F0 = false;
      defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
      defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const disableBumpMap = this._material._disableBumpMap;
    const invertNormalMapX = this._material._invertNormalMapX;
    const invertNormalMapY = this._material._invertNormalMapY;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.updateFloat4("vClearCoatInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
        }
        if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
        }
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
        uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
        BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
        if (scene._mirroredCameraPosition) {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
        } else {
          uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
        }
      }
      if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
        BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
      }
      uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
      const a = 1 - this._indexOfRefraction;
      const b = 1 + this._indexOfRefraction;
      const f0 = Math.pow(-a / b, 2);
      const eta = 1 / this._indexOfRefraction;
      uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
      if (this._isTintEnabled) {
        uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
        uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatSampler", this._texture);
      }
      if (this._textureRoughness && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
        uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
      }
      if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
        uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
      }
      if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
        uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._tintTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._tintTexture) {
      activeTextures.push(this._tintTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      animatables.push(this._bumpTexture);
    }
    if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
      animatables.push(this._tintTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._textureRoughness?.dispose();
      this._bumpTexture?.dispose();
      this._tintTexture?.dispose();
    }
  }
  getClassName() {
    return "PBRClearCoatConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.CLEARCOAT_BUMP) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
    }
    if (defines.CLEARCOAT_TINT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
    }
    if (defines.CLEARCOAT) {
      fallbacks.addFallback(currentRank++, "CLEARCOAT");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vClearCoatParams", size: 2, type: "vec2" },
        { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
        { name: "vClearCoatInfos", size: 4, type: "vec4" },
        { name: "clearCoatMatrix", size: 16, type: "mat4" },
        { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
        { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
        { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
        { name: "vClearCoatTintParams", size: 4, type: "vec4" },
        { name: "clearCoatColorAtDistance", size: 1, type: "float" },
        { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
        { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
__decorate([
  serializeAsColor3()
], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.IRIDESCENCE = false;
    this.IRIDESCENCE_TEXTURE = false;
    this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
    this.IRIDESCENCE_THICKNESS_TEXTURE = false;
    this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
  }
};
var PBRIridescenceConfiguration = class _PBRIridescenceConfiguration extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.minimumThickness = _PBRIridescenceConfiguration._DefaultMinimumThickness;
    this.maximumThickness = _PBRIridescenceConfiguration._DefaultMaximumThickness;
    this.indexOfRefraction = _PBRIridescenceConfiguration._DefaultIndexOfRefraction;
    this._texture = null;
    this.texture = null;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.IRIDESCENCE = true;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
          } else {
            defines.IRIDESCENCE_TEXTURE = false;
          }
          if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
          } else {
            defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          }
        }
      }
    } else {
      defines.IRIDESCENCE = false;
      defines.IRIDESCENCE_TEXTURE = false;
      defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
      defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
      defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.updateFloat4("vIridescenceInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._thicknessTexture?.coordinatesIndex ?? 0, this._thicknessTexture?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
        }
        if (this._thicknessTexture) {
          BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
        }
      }
      uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceSampler", this._texture);
      }
      if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
        uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._thicknessTexture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._thicknessTexture?.dispose();
    }
  }
  getClassName() {
    return "PBRIridescenceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.IRIDESCENCE) {
      fallbacks.addFallback(currentRank++, "IRIDESCENCE");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vIridescenceParams", size: 4, type: "vec4" },
        { name: "vIridescenceInfos", size: 4, type: "vec4" },
        { name: "iridescenceMatrix", size: 16, type: "mat4" },
        { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "intensity", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "texture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.ANISOTROPIC = false;
    this.ANISOTROPIC_TEXTURE = false;
    this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
    this.ANISOTROPIC_LEGACY = false;
    this.MAINUV1 = false;
  }
};
var PBRAnisotropicConfiguration = class extends MaterialPluginBase {
  /**
   * Sets the anisotropy direction as an angle.
   */
  set angle(value) {
    this.direction.x = Math.cos(value);
    this.direction.y = Math.sin(value);
  }
  /**
   * Gets the anisotropy angle value in radians.
   * @returns the anisotropy angle value in radians.
   */
  get angle() {
    return Math.atan2(this.direction.y, this.direction.x);
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markAllSubMeshesAsMiscDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsMiscDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this.intensity = 1;
    this.direction = new Vector2(1, 0);
    this._texture = null;
    this.texture = null;
    this._legacy = false;
    this.legacy = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene, mesh) {
    if (this._isEnabled) {
      defines.ANISOTROPIC = this._isEnabled;
      if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
        defines._needUVs = true;
        defines.MAINUV1 = true;
      }
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
          } else {
            defines.ANISOTROPIC_TEXTURE = false;
          }
        }
      }
      if (defines._areMiscDirty) {
        defines.ANISOTROPIC_LEGACY = this._legacy;
      }
    } else {
      defines.ANISOTROPIC = false;
      defines.ANISOTROPIC_TEXTURE = false;
      defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
      defines.ANISOTROPIC_LEGACY = false;
    }
  }
  bindForSubMesh(uniformBuffer, scene) {
    if (!this._isEnabled) {
      return;
    }
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
        BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
      }
      uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
        uniformBuffer.setTexture("anisotropySampler", this._texture);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._texture) {
        this._texture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRAnisotropicConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.ANISOTROPIC) {
      fallbacks.addFallback(currentRank++, "ANISOTROPIC");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("anisotropySampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vAnisotropy", size: 3, type: "vec3" },
        { name: "vAnisotropyInfos", size: 2, type: "vec2" },
        { name: "anisotropyMatrix", size: 16, type: "mat4" }
      ]
    };
  }
  /**
   * Parses a anisotropy Configuration from a serialized object.
   * @param source - Serialized object.
   * @param scene Defines the scene we are parsing for
   * @param rootUrl Defines the rootUrl to load from
   */
  parse(source, scene, rootUrl) {
    super.parse(source, scene, rootUrl);
    if (source.legacy === void 0) {
      this.legacy = true;
    }
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsVector2()
], PBRAnisotropicConfiguration.prototype, "direction", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRAnisotropicConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRAnisotropicConfiguration.prototype, "legacy", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SHEEN = false;
    this.SHEEN_TEXTURE = false;
    this.SHEEN_GAMMATEXTURE = false;
    this.SHEEN_TEXTURE_ROUGHNESS = false;
    this.SHEEN_TEXTUREDIRECTUV = 0;
    this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    this.SHEEN_LINKWITHALBEDO = false;
    this.SHEEN_ROUGHNESS = false;
    this.SHEEN_ALBEDOSCALING = false;
    this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
  }
};
var PBRSheenConfiguration = class extends MaterialPluginBase {
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
    this._isEnabled = false;
    this.isEnabled = false;
    this._linkSheenWithAlbedo = false;
    this.linkSheenWithAlbedo = false;
    this.intensity = 1;
    this.color = Color3.White();
    this._texture = null;
    this.texture = null;
    this._useRoughnessFromMainTexture = true;
    this.useRoughnessFromMainTexture = true;
    this._roughness = null;
    this.roughness = null;
    this._textureRoughness = null;
    this.textureRoughness = null;
    this._albedoScaling = false;
    this.albedoScaling = false;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._texture && MaterialFlags.SheenTextureEnabled) {
          if (!this._texture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
          if (!this._textureRoughness.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (this._isEnabled) {
      defines.SHEEN = true;
      defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
      defines.SHEEN_ROUGHNESS = this._roughness !== null;
      defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
            defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
          } else {
            defines.SHEEN_TEXTURE = false;
          }
          if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
            PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
          } else {
            defines.SHEEN_TEXTURE_ROUGHNESS = false;
          }
        }
      }
    } else {
      defines.SHEEN = false;
      defines.SHEEN_TEXTURE = false;
      defines.SHEEN_TEXTURE_ROUGHNESS = false;
      defines.SHEEN_LINKWITHALBEDO = false;
      defines.SHEEN_ROUGHNESS = false;
      defines.SHEEN_ALBEDOSCALING = false;
      defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
      defines.SHEEN_GAMMATEXTURE = false;
      defines.SHEEN_TEXTUREDIRECTUV = 0;
      defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.updateFloat4("vSheenInfos", this._texture?.coordinatesIndex ?? 0, this._texture?.level ?? 0, this._textureRoughness?.coordinatesIndex ?? 0, this._textureRoughness?.level ?? 0);
        if (this._texture) {
          BindTextureMatrix(this._texture, uniformBuffer, "sheen");
        }
        if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
          BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
        }
      }
      uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
      if (this._roughness !== null) {
        uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
      }
    }
    if (scene.texturesEnabled) {
      if (this._texture && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenSampler", this._texture);
      }
      if (this._textureRoughness && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
        uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
      }
    }
  }
  hasTexture(texture) {
    if (this._texture === texture) {
      return true;
    }
    if (this._textureRoughness === texture) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._texture) {
      activeTextures.push(this._texture);
    }
    if (this._textureRoughness) {
      activeTextures.push(this._textureRoughness);
    }
  }
  getAnimatables(animatables) {
    if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
      animatables.push(this._texture);
    }
    if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
      animatables.push(this._textureRoughness);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      this._texture?.dispose();
      this._textureRoughness?.dispose();
    }
  }
  getClassName() {
    return "PBRSheenConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SHEEN) {
      fallbacks.addFallback(currentRank++, "SHEEN");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("sheenSampler", "sheenRoughnessSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vSheenColor", size: 4, type: "vec4" },
        { name: "vSheenRoughness", size: 1, type: "float" },
        { name: "vSheenInfos", size: 4, type: "vec4" },
        { name: "sheenMatrix", size: 16, type: "mat4" },
        { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "isEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
__decorate([
  serialize()
], PBRSheenConfiguration.prototype, "intensity", void 0);
__decorate([
  serializeAsColor3()
], PBRSheenConfiguration.prototype, "color", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "texture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "roughness", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSheenConfiguration.prototype, "albedoScaling", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.SUBSURFACE = false;
    this.SS_REFRACTION = false;
    this.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_TRANSLUCENCY = false;
    this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
    this.SS_SCATTERING = false;
    this.SS_DISPERSION = false;
    this.SS_THICKNESSANDMASK_TEXTURE = false;
    this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
    this.SS_HAS_THICKNESS = false;
    this.SS_REFRACTIONINTENSITY_TEXTURE = false;
    this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
    this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
    this.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
    this.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
    this.SS_REFRACTIONMAP_3D = false;
    this.SS_REFRACTIONMAP_OPPOSITEZ = false;
    this.SS_LODINREFRACTIONALPHA = false;
    this.SS_GAMMAREFRACTION = false;
    this.SS_RGBDREFRACTION = false;
    this.SS_LINEARSPECULARREFRACTION = false;
    this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
    this.SS_ALBEDOFORREFRACTIONTINT = false;
    this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
    this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
    this.SS_USE_THICKNESS_AS_DEPTH = false;
    this.SS_USE_GLTF_TEXTURES = false;
    this.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
    this.SS_TRANSLUCENCY_LEGACY = false;
  }
};
var PBRSubSurfaceConfiguration = class _PBRSubSurfaceConfiguration extends MaterialPluginBase {
  /**
   * Diffusion profile for subsurface scattering.
   * Useful for better scattering in the skins or foliages.
   */
  get scatteringDiffusionProfile() {
    if (!this._scene.subSurfaceConfiguration) {
      return null;
    }
    return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
  }
  set scatteringDiffusionProfile(c) {
    if (!this._scene.enableSubSurfaceForPrePass()) {
      return;
    }
    if (c) {
      this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
    }
  }
  /**
   * Index of refraction of the material's volume.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This ONLY impacts refraction. If not provided or given a non-valid value,
   * the volume will use the same IOR as the surface.
   */
  get volumeIndexOfRefraction() {
    if (this._volumeIndexOfRefraction >= 1) {
      return this._volumeIndexOfRefraction;
    }
    return this._indexOfRefraction;
  }
  set volumeIndexOfRefraction(value) {
    if (value >= 1) {
      this._volumeIndexOfRefraction = value;
    } else {
      this._volumeIndexOfRefraction = -1;
    }
  }
  /**
   * Keeping for backward compatibility... Should not be used anymore. It has been replaced by
   * the property with the correct spelling.
   * @see legacyTranslucency
   */
  get legacyTransluceny() {
    return this.legacyTranslucency;
  }
  set legacyTransluceny(value) {
    this.legacyTranslucency = value;
  }
  /** @internal */
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  /** @internal */
  _markScenePrePassDirty() {
    this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
    this._internalMarkAllSubMeshesAsTexturesDirty();
    this._internalMarkScenePrePassDirty();
  }
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language.
   * @returns true if the plugin is compatible with the shader language
   */
  isCompatible() {
    return true;
  }
  constructor(material, addToPluginList = true) {
    super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
    this._isRefractionEnabled = false;
    this.isRefractionEnabled = false;
    this._isTranslucencyEnabled = false;
    this.isTranslucencyEnabled = false;
    this._isDispersionEnabled = false;
    this.isDispersionEnabled = false;
    this._isScatteringEnabled = false;
    this.isScatteringEnabled = false;
    this._scatteringDiffusionProfileIndex = 0;
    this.refractionIntensity = 1;
    this.translucencyIntensity = 1;
    this.useAlbedoToTintRefraction = false;
    this.useAlbedoToTintTranslucency = false;
    this._thicknessTexture = null;
    this.thicknessTexture = null;
    this._refractionTexture = null;
    this.refractionTexture = null;
    this._indexOfRefraction = 1.5;
    this.indexOfRefraction = 1.5;
    this._volumeIndexOfRefraction = -1;
    this._invertRefractionY = false;
    this.invertRefractionY = false;
    this._linkRefractionWithTransparency = false;
    this.linkRefractionWithTransparency = false;
    this.minimumThickness = 0;
    this.maximumThickness = 1;
    this.useThicknessAsDepth = false;
    this.tintColor = Color3.White();
    this.tintColorAtDistance = 1;
    this.dispersion = 0;
    this.diffusionDistance = Color3.White();
    this._useMaskFromThicknessTexture = false;
    this.useMaskFromThicknessTexture = false;
    this._refractionIntensityTexture = null;
    this.refractionIntensityTexture = null;
    this._translucencyIntensityTexture = null;
    this.translucencyIntensityTexture = null;
    this.translucencyColor = null;
    this._translucencyColorTexture = null;
    this.translucencyColorTexture = null;
    this._useGltfStyleTextures = true;
    this.useGltfStyleTextures = true;
    this.applyAlbedoAfterSubSurface = _PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE;
    this.legacyTranslucency = _PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY;
    this._scene = material.getScene();
    this.registerForExtraEvents = true;
    this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
    this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
  }
  isReadyForSubMesh(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return true;
    }
    if (defines._areTexturesDirty) {
      if (scene.texturesEnabled) {
        if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
          if (!this._thicknessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
          if (!this._refractionIntensityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
          if (!this._translucencyColorTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
          if (!this._translucencyIntensityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const refractionTexture = this._getRefractionTexture(scene);
        if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
          if (!refractionTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
      }
    }
    return true;
  }
  prepareDefinesBeforeAttributes(defines, scene) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      defines.SUBSURFACE = false;
      defines.SS_DISPERSION = false;
      defines.SS_TRANSLUCENCY = false;
      defines.SS_SCATTERING = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTUREDIRECTUV = 0;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = false;
      defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = false;
      return;
    }
    if (defines._areTexturesDirty) {
      defines.SUBSURFACE = true;
      defines.SS_DISPERSION = this._isDispersionEnabled;
      defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_TRANSLUCENCY_LEGACY = this.legacyTranslucency;
      defines.SS_SCATTERING = this._isScatteringEnabled;
      defines.SS_THICKNESSANDMASK_TEXTURE = false;
      defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
      defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
      defines.SS_HAS_THICKNESS = false;
      defines.SS_USE_GLTF_TEXTURES = false;
      defines.SS_REFRACTION = false;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = false;
      defines.SS_REFRACTIONMAP_3D = false;
      defines.SS_GAMMAREFRACTION = false;
      defines.SS_RGBDREFRACTION = false;
      defines.SS_LINEARSPECULARREFRACTION = false;
      defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
      defines.SS_LODINREFRACTIONALPHA = false;
      defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
      defines.SS_ALBEDOFORREFRACTIONTINT = false;
      defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
      defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
      defines.SS_USE_THICKNESS_AS_DEPTH = false;
      defines.SS_TRANSLUCENCYCOLOR_TEXTURE = false;
      defines.SS_APPLY_ALBEDO_AFTER_SUBSURFACE = this.applyAlbedoAfterSubSurface;
      if (defines._areTexturesDirty) {
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
          }
          if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled) {
            PrepareDefinesForMergedUV(this._translucencyColorTexture, defines, "SS_TRANSLUCENCYCOLOR_TEXTURE");
            defines.SS_TRANSLUCENCYCOLOR_TEXTURE_GAMMA = this._translucencyColorTexture.gammaSpace;
          }
        }
      }
      defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
      defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
      defines.SS_REFRACTION_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._refractionIntensityTexture;
      defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_THICKNESS = this._useMaskFromThicknessTexture && !this._translucencyIntensityTexture;
      if (this._isRefractionEnabled) {
        if (scene.texturesEnabled) {
          const refractionTexture = this._getRefractionTexture(scene);
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            defines.SS_REFRACTION = true;
            defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
            defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
            defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
            defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
            defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
            defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
            defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
            defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
            defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
            defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
          }
        }
      }
      if (this._isTranslucencyEnabled) {
        defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
      }
    }
  }
  /**
   * Binds the material data (this function is called even if mustRebind() returns false)
   * @param uniformBuffer defines the Uniform buffer to fill in.
   * @param scene defines the scene the material belongs to.
   * @param engine defines the engine the material belongs to.
   * @param subMesh the submesh to bind data for
   */
  hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    if (this.maximumThickness === 0 && this.minimumThickness === 0) {
      uniformBuffer.updateFloat2("vThicknessParam", 0, 0);
    } else {
      subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
      const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
      uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
    }
  }
  bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
    if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
      return;
    }
    const defines = subMesh.materialDefines;
    const isFrozen = this._material.isFrozen;
    const realTimeFiltering = this._material.realTimeFiltering;
    const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
    const refractionTexture = this._getRefractionTexture(scene);
    if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
        BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
        BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyColorInfos", this._translucencyColorTexture.coordinatesIndex, this._translucencyColorTexture.level);
        BindTextureMatrix(this._translucencyColorTexture, uniformBuffer, "translucencyColor");
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
        BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
        let depth = 1;
        if (!refractionTexture.isCube) {
          if (refractionTexture.depth) {
            depth = refractionTexture.depth;
          }
        }
        const width = refractionTexture.getSize().width;
        const refractionIor = this.volumeIndexOfRefraction;
        uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
        uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
        if (realTimeFiltering) {
          uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Math.log2(width));
        }
        if (refractionTexture.boundingBoxSize) {
          const cubeTexture = refractionTexture;
          uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
          uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
        }
      }
      if (this._isScatteringEnabled) {
        uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
      }
      uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
      uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
      uniformBuffer.updateColor4("vTranslucencyColor", this.translucencyColor ?? this.tintColor, 0);
      uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
      uniformBuffer.updateFloat("dispersion", this.dispersion);
    }
    if (scene.texturesEnabled) {
      if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
        uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
      }
      if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
      }
      if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
        uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
      }
      if (this._translucencyColorTexture && MaterialFlags.TranslucencyColorTextureEnabled && defines.SS_TRANSLUCENCYCOLOR_TEXTURE) {
        uniformBuffer.setTexture("translucencyColorSampler", this._translucencyColorTexture);
      }
      if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
        if (lodBasedMicrosurface) {
          uniformBuffer.setTexture("refractionSampler", refractionTexture);
        } else {
          uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
          uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
        }
      }
    }
  }
  /**
   * Returns the texture used for refraction or null if none is used.
   * @param scene defines the scene the material belongs to.
   * @returns - Refraction texture if present.  If no refraction texture and refraction
   * is linked with transparency, returns environment texture.  Otherwise, returns null.
   */
  _getRefractionTexture(scene) {
    if (this._refractionTexture) {
      return this._refractionTexture;
    }
    if (this._isRefractionEnabled) {
      return scene.environmentTexture;
    }
    return null;
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get disableAlphaBlending() {
    return this._isRefractionEnabled && this._linkRefractionWithTransparency;
  }
  /**
   * Fills the list of render target textures.
   * @param renderTargets the list of render targets to update
   */
  fillRenderTargetTextures(renderTargets) {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      renderTargets.push(this._refractionTexture);
    }
  }
  hasTexture(texture) {
    if (this._thicknessTexture === texture) {
      return true;
    }
    if (this._refractionTexture === texture) {
      return true;
    }
    if (this._refractionIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyIntensityTexture === texture) {
      return true;
    }
    if (this._translucencyColorTexture === texture) {
      return true;
    }
    return false;
  }
  hasRenderTargetTextures() {
    if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
      return true;
    }
    return false;
  }
  getActiveTextures(activeTextures) {
    if (this._thicknessTexture) {
      activeTextures.push(this._thicknessTexture);
    }
    if (this._refractionTexture) {
      activeTextures.push(this._refractionTexture);
    }
    if (this._refractionIntensityTexture) {
      activeTextures.push(this._refractionIntensityTexture);
    }
    if (this._translucencyColorTexture) {
      activeTextures.push(this._translucencyColorTexture);
    }
    if (this._translucencyIntensityTexture) {
      activeTextures.push(this._translucencyIntensityTexture);
    }
  }
  getAnimatables(animatables) {
    if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
      animatables.push(this._thicknessTexture);
    }
    if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
      animatables.push(this._refractionTexture);
    }
    if (this._refractionIntensityTexture && this._refractionIntensityTexture.animations && this._refractionIntensityTexture.animations.length > 0) {
      animatables.push(this._refractionIntensityTexture);
    }
    if (this._translucencyColorTexture && this._translucencyColorTexture.animations && this._translucencyColorTexture.animations.length > 0) {
      animatables.push(this._translucencyColorTexture);
    }
    if (this._translucencyIntensityTexture && this._translucencyIntensityTexture.animations && this._translucencyIntensityTexture.animations.length > 0) {
      animatables.push(this._translucencyIntensityTexture);
    }
  }
  dispose(forceDisposeTextures) {
    if (forceDisposeTextures) {
      if (this._thicknessTexture) {
        this._thicknessTexture.dispose();
      }
      if (this._refractionTexture) {
        this._refractionTexture.dispose();
      }
      if (this._refractionIntensityTexture) {
        this._refractionIntensityTexture.dispose();
      }
      if (this._translucencyColorTexture) {
        this._translucencyColorTexture.dispose();
      }
      if (this._translucencyIntensityTexture) {
        this._translucencyIntensityTexture.dispose();
      }
    }
  }
  getClassName() {
    return "PBRSubSurfaceConfiguration";
  }
  addFallbacks(defines, fallbacks, currentRank) {
    if (defines.SS_SCATTERING) {
      fallbacks.addFallback(currentRank++, "SS_SCATTERING");
    }
    if (defines.SS_TRANSLUCENCY) {
      fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
    }
    return currentRank;
  }
  getSamplers(samplers) {
    samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh", "translucencyColorSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
        { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
        { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
        { name: "vRefractionInfos", size: 4, type: "vec4" },
        { name: "refractionMatrix", size: 16, type: "mat4" },
        { name: "vThicknessInfos", size: 2, type: "vec2" },
        { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
        { name: "thicknessMatrix", size: 16, type: "mat4" },
        { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
        { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
        { name: "vThicknessParam", size: 2, type: "vec2" },
        { name: "vDiffusionDistance", size: 3, type: "vec3" },
        { name: "vTintColor", size: 4, type: "vec4" },
        { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
        { name: "vRefractionPosition", size: 3, type: "vec3" },
        { name: "vRefractionSize", size: 3, type: "vec3" },
        { name: "scatteringDiffusionProfile", size: 1, type: "float" },
        { name: "dispersion", size: 1, type: "float" },
        { name: "vTranslucencyColor", size: 4, type: "vec4" },
        { name: "vTranslucencyColorInfos", size: 2, type: "vec2" },
        { name: "translucencyColorMatrix", size: 16, type: "mat4" }
      ]
    };
  }
};
PBRSubSurfaceConfiguration.DEFAULT_APPLY_ALBEDO_AFTERSUBSURFACE = false;
PBRSubSurfaceConfiguration.DEFAULT_LEGACY_TRANSLUCENCY = false;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "isDispersionEnabled", void 0);
__decorate([
  serialize(),
  expandToProperty("_markScenePrePassDirty")
], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "dispersion", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
__decorate([
  serializeAsColor3()
], PBRSubSurfaceConfiguration.prototype, "translucencyColor", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "translucencyColorTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "applyAlbedoAfterSubSurface", void 0);
__decorate([
  serialize()
], PBRSubSurfaceConfiguration.prototype, "legacyTranslucency", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters = { effect: null, subMesh: null };
var PBRMaterialDefinesBase = class extends UVDefinesMixin(MaterialDefines) {
};
var PBRMaterialDefines = class extends ImageProcessingDefinesMixin(PBRMaterialDefinesBase) {
  /**
   * Initializes the PBR Material defines.
   * @param externalProperties The external properties
   */
  constructor(externalProperties) {
    super(externalProperties);
    this.PBR = true;
    this.NUM_SAMPLES = "0";
    this.REALTIME_FILTERING = false;
    this.IBL_CDF_FILTERING = false;
    this.ALBEDO = false;
    this.GAMMAALBEDO = false;
    this.ALBEDODIRECTUV = 0;
    this.VERTEXCOLOR = false;
    this.BASE_WEIGHT = false;
    this.BASE_WEIGHTDIRECTUV = 0;
    this.BASE_DIFFUSE_ROUGHNESS = false;
    this.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
    this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
    this.AMBIENT = false;
    this.AMBIENTDIRECTUV = 0;
    this.AMBIENTINGRAYSCALE = false;
    this.OPACITY = false;
    this.VERTEXALPHA = false;
    this.OPACITYDIRECTUV = 0;
    this.OPACITYRGB = false;
    this.ALPHATEST = false;
    this.DEPTHPREPASS = false;
    this.ALPHABLEND = false;
    this.ALPHAFROMALBEDO = false;
    this.ALPHATESTVALUE = "0.5";
    this.SPECULAROVERALPHA = false;
    this.RADIANCEOVERALPHA = false;
    this.ALPHAFRESNEL = false;
    this.LINEARALPHAFRESNEL = false;
    this.PREMULTIPLYALPHA = false;
    this.EMISSIVE = false;
    this.EMISSIVEDIRECTUV = 0;
    this.GAMMAEMISSIVE = false;
    this.REFLECTIVITY = false;
    this.REFLECTIVITY_GAMMA = false;
    this.REFLECTIVITYDIRECTUV = 0;
    this.SPECULARTERM = false;
    this.MICROSURFACEFROMREFLECTIVITYMAP = false;
    this.MICROSURFACEAUTOMATIC = false;
    this.LODBASEDMICROSFURACE = false;
    this.MICROSURFACEMAP = false;
    this.MICROSURFACEMAPDIRECTUV = 0;
    this.METALLICWORKFLOW = false;
    this.ROUGHNESSSTOREINMETALMAPALPHA = false;
    this.ROUGHNESSSTOREINMETALMAPGREEN = false;
    this.METALLNESSSTOREINMETALMAPBLUE = false;
    this.AOSTOREINMETALMAPRED = false;
    this.METALLIC_REFLECTANCE = false;
    this.METALLIC_REFLECTANCE_GAMMA = false;
    this.METALLIC_REFLECTANCEDIRECTUV = 0;
    this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
    this.REFLECTANCE = false;
    this.REFLECTANCE_GAMMA = false;
    this.REFLECTANCEDIRECTUV = 0;
    this.ENVIRONMENTBRDF = false;
    this.ENVIRONMENTBRDF_RGBD = false;
    this.NORMAL = false;
    this.TANGENT = false;
    this.BUMP = false;
    this.BUMPDIRECTUV = 0;
    this.OBJECTSPACE_NORMALMAP = false;
    this.PARALLAX = false;
    this.PARALLAX_RHS = false;
    this.PARALLAXOCCLUSION = false;
    this.NORMALXYSCALE = true;
    this.LIGHTMAP = false;
    this.LIGHTMAPDIRECTUV = 0;
    this.USELIGHTMAPASSHADOWMAP = false;
    this.GAMMALIGHTMAP = false;
    this.RGBDLIGHTMAP = false;
    this.REFLECTION = false;
    this.REFLECTIONMAP_3D = false;
    this.REFLECTIONMAP_SPHERICAL = false;
    this.REFLECTIONMAP_PLANAR = false;
    this.REFLECTIONMAP_CUBIC = false;
    this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    this.REFLECTIONMAP_PROJECTION = false;
    this.REFLECTIONMAP_SKYBOX = false;
    this.REFLECTIONMAP_EXPLICIT = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR = false;
    this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    this.INVERTCUBICMAP = false;
    this.USESPHERICALFROMREFLECTIONMAP = false;
    this.USEIRRADIANCEMAP = false;
    this.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
    this.USESPHERICALINVERTEX = false;
    this.REFLECTIONMAP_OPPOSITEZ = false;
    this.LODINREFLECTIONALPHA = false;
    this.GAMMAREFLECTION = false;
    this.RGBDREFLECTION = false;
    this.LINEARSPECULARREFLECTION = false;
    this.RADIANCEOCCLUSION = false;
    this.HORIZONOCCLUSION = false;
    this.INSTANCES = false;
    this.THIN_INSTANCES = false;
    this.INSTANCESCOLOR = false;
    this.PREPASS = false;
    this.PREPASS_COLOR = false;
    this.PREPASS_COLOR_INDEX = -1;
    this.PREPASS_IRRADIANCE = false;
    this.PREPASS_IRRADIANCE_INDEX = -1;
    this.PREPASS_ALBEDO = false;
    this.PREPASS_ALBEDO_INDEX = -1;
    this.PREPASS_ALBEDO_SQRT = false;
    this.PREPASS_ALBEDO_SQRT_INDEX = -1;
    this.PREPASS_DEPTH = false;
    this.PREPASS_DEPTH_INDEX = -1;
    this.PREPASS_SCREENSPACE_DEPTH = false;
    this.PREPASS_SCREENSPACE_DEPTH_INDEX = -1;
    this.PREPASS_NORMALIZED_VIEW_DEPTH = false;
    this.PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;
    this.PREPASS_NORMAL = false;
    this.PREPASS_NORMAL_INDEX = -1;
    this.PREPASS_NORMAL_WORLDSPACE = false;
    this.PREPASS_WORLD_NORMAL = false;
    this.PREPASS_WORLD_NORMAL_INDEX = -1;
    this.PREPASS_POSITION = false;
    this.PREPASS_POSITION_INDEX = -1;
    this.PREPASS_LOCAL_POSITION = false;
    this.PREPASS_LOCAL_POSITION_INDEX = -1;
    this.PREPASS_VELOCITY = false;
    this.PREPASS_VELOCITY_INDEX = -1;
    this.PREPASS_VELOCITY_LINEAR = false;
    this.PREPASS_VELOCITY_LINEAR_INDEX = -1;
    this.PREPASS_REFLECTIVITY = false;
    this.PREPASS_REFLECTIVITY_INDEX = -1;
    this.SCENE_MRT_COUNT = 0;
    this.NUM_BONE_INFLUENCERS = 0;
    this.BonesPerMesh = 0;
    this.BONETEXTURE = false;
    this.BONES_VELOCITY_ENABLED = false;
    this.NONUNIFORMSCALING = false;
    this.MORPHTARGETS = false;
    this.MORPHTARGETS_POSITION = false;
    this.MORPHTARGETS_NORMAL = false;
    this.MORPHTARGETS_TANGENT = false;
    this.MORPHTARGETS_UV = false;
    this.MORPHTARGETS_UV2 = false;
    this.MORPHTARGETS_COLOR = false;
    this.MORPHTARGETTEXTURE_HASPOSITIONS = false;
    this.MORPHTARGETTEXTURE_HASNORMALS = false;
    this.MORPHTARGETTEXTURE_HASTANGENTS = false;
    this.MORPHTARGETTEXTURE_HASUVS = false;
    this.MORPHTARGETTEXTURE_HASUV2S = false;
    this.MORPHTARGETTEXTURE_HASCOLORS = false;
    this.NUM_MORPH_INFLUENCERS = 0;
    this.MORPHTARGETS_TEXTURE = false;
    this.MULTIVIEW = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY = false;
    this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
    this.USEPHYSICALLIGHTFALLOFF = false;
    this.USEGLTFLIGHTFALLOFF = false;
    this.TWOSIDEDLIGHTING = false;
    this.MIRRORED = false;
    this.SHADOWFLOAT = false;
    this.CLIPPLANE = false;
    this.CLIPPLANE2 = false;
    this.CLIPPLANE3 = false;
    this.CLIPPLANE4 = false;
    this.CLIPPLANE5 = false;
    this.CLIPPLANE6 = false;
    this.POINTSIZE = false;
    this.FOG = false;
    this.LOGARITHMICDEPTH = false;
    this.CAMERA_ORTHOGRAPHIC = false;
    this.CAMERA_PERSPECTIVE = false;
    this.AREALIGHTSUPPORTED = true;
    this.FORCENORMALFORWARD = false;
    this.SPECULARAA = false;
    this.UNLIT = false;
    this.DECAL_AFTER_DETAIL = false;
    this.DEBUGMODE = 0;
    this.USE_VERTEX_PULLING = false;
    this.CLUSTLIGHT_SLICES = 0;
    this.CLUSTLIGHT_BATCH = 0;
    this.rebuild();
  }
  /**
   * Resets the PBR Material defines.
   */
  reset() {
    super.reset();
    this.ALPHATESTVALUE = "0.5";
    this.PBR = true;
    this.NORMALXYSCALE = true;
  }
};
var PBRBaseMaterialBase = class extends ImageProcessingMixin(PushMaterial) {
};
var PBRBaseMaterial = class _PBRBaseMaterial extends PBRBaseMaterialBase {
  /**
   * Enables realtime filtering on the texture.
   */
  get realTimeFiltering() {
    return this._realTimeFiltering;
  }
  set realTimeFiltering(b) {
    this._realTimeFiltering = b;
    this.markAsDirty(1);
  }
  /**
   * Quality switch for realtime filtering
   */
  get realTimeFilteringQuality() {
    return this._realTimeFilteringQuality;
  }
  set realTimeFilteringQuality(n) {
    this._realTimeFilteringQuality = n;
    this.markAsDirty(1);
  }
  /**
   * Can this material render to several textures at once
   */
  get canRenderToMRT() {
    return true;
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name, scene, forceGLSL = false) {
    super(name, scene, void 0, forceGLSL || _PBRBaseMaterial.ForceGLSL);
    this._directIntensity = 1;
    this._emissiveIntensity = 1;
    this._environmentIntensity = 1;
    this._specularIntensity = 1;
    this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
    this._disableBumpMap = false;
    this._albedoTexture = null;
    this._baseWeightTexture = null;
    this._baseDiffuseRoughnessTexture = null;
    this._ambientTexture = null;
    this._ambientTextureStrength = 1;
    this._ambientTextureImpactOnAnalyticalLights = _PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this._opacityTexture = null;
    this._reflectionTexture = null;
    this._emissiveTexture = null;
    this._reflectivityTexture = null;
    this._metallicTexture = null;
    this._metallic = null;
    this._roughness = null;
    this._metallicF0Factor = 1;
    this._metallicReflectanceColor = Color3.White();
    this._useOnlyMetallicFromMetallicReflectanceTexture = false;
    this._metallicReflectanceTexture = null;
    this._reflectanceTexture = null;
    this._microSurfaceTexture = null;
    this._bumpTexture = null;
    this._lightmapTexture = null;
    this._ambientColor = new Color3(0, 0, 0);
    this._albedoColor = new Color3(1, 1, 1);
    this._baseWeight = 1;
    this._baseDiffuseRoughness = null;
    this._reflectivityColor = new Color3(1, 1, 1);
    this._reflectionColor = new Color3(1, 1, 1);
    this._emissiveColor = new Color3(0, 0, 0);
    this._microSurface = 0.9;
    this._useLightmapAsShadowmap = false;
    this._useHorizonOcclusion = true;
    this._useRadianceOcclusion = true;
    this._useAlphaFromAlbedoTexture = false;
    this._useSpecularOverAlpha = true;
    this._useMicroSurfaceFromReflectivityMapAlpha = false;
    this._useRoughnessFromMetallicTextureAlpha = true;
    this._useRoughnessFromMetallicTextureGreen = false;
    this._useMetallnessFromMetallicTextureBlue = false;
    this._useAmbientOcclusionFromMetallicTextureRed = false;
    this._useAmbientInGrayScale = false;
    this._useAutoMicroSurfaceFromReflectivityMap = false;
    this._lightFalloff = _PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
    this._useRadianceOverAlpha = true;
    this._useObjectSpaceNormalMap = false;
    this._useParallax = false;
    this._useParallaxOcclusion = false;
    this._parallaxScaleBias = 0.05;
    this._disableLighting = false;
    this._maxSimultaneousLights = 4;
    this._invertNormalMapX = false;
    this._invertNormalMapY = false;
    this._twoSidedLighting = false;
    this._alphaCutOff = 0.4;
    this._useAlphaFresnel = false;
    this._useLinearAlphaFresnel = false;
    this._environmentBRDFTexture = null;
    this._forceIrradianceInFragment = false;
    this._realTimeFiltering = false;
    this._realTimeFilteringQuality = 8;
    this._forceNormalForward = false;
    this._enableSpecularAntiAliasing = false;
    this._renderTargets = new SmartArray(16);
    this._globalAmbientColor = new Color3(0, 0, 0);
    this._unlit = false;
    this._applyDecalMapAfterDetailMap = false;
    this._debugMode = 0;
    this._shadersLoaded = false;
    this._breakShaderLoadedCheck = false;
    this.debugMode = 0;
    this.debugLimit = -1;
    this.debugFactor = 1;
    this._cacheHasRenderTargetTextures = false;
    this.brdf = new PBRBRDFConfiguration(this);
    this.clearCoat = new PBRClearCoatConfiguration(this);
    this.iridescence = new PBRIridescenceConfiguration(this);
    this.anisotropy = new PBRAnisotropicConfiguration(this);
    this.sheen = new PBRSheenConfiguration(this);
    this.subSurface = new PBRSubSurfaceConfiguration(this);
    this.detailMap = new DetailMapConfiguration(this);
    this._attachImageProcessingConfiguration(null);
    this.getRenderTargetTextures = () => {
      this._renderTargets.reset();
      if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
        this._renderTargets.push(this._reflectionTexture);
      }
      this._eventInfo.renderTargets = this._renderTargets;
      this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
      return this._renderTargets;
    };
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
    this.prePassConfiguration = new PrePassConfiguration();
  }
  /**
   * Gets a boolean indicating that current material needs to register RTT
   */
  get hasRenderTargetTextures() {
    if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
      return true;
    }
    return this._cacheHasRenderTargetTextures;
  }
  /**
   * Can this material render to prepass
   */
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  /**
   * @returns the name of the material class.
   */
  getClassName() {
    return "PBRBaseMaterial";
  }
  /**
   * Returns true if alpha blending should be disabled.
   */
  get _disableAlphaBlending() {
    return this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST || this.subSurface?.disableAlphaBlending;
  }
  /**
   * @returns whether or not this material should be rendered in alpha blend mode.
   */
  needAlphaBlending() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsBlend;
    }
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
  }
  /**
   * @returns whether or not this material should be rendered in alpha test mode.
   */
  needAlphaTesting() {
    if (this._hasTransparencyMode) {
      return this._transparencyModeIsTest;
    }
    if (this.subSurface?.disableAlphaBlending) {
      return false;
    }
    return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === _PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
  }
  /**
   * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
   */
  _shouldUseAlphaFromAlbedoTexture() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE;
  }
  /**
   * @returns whether or not there is a usable alpha channel for transparency.
   */
  _hasAlphaChannel() {
    return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
  }
  /**
   * @returns the texture used for the alpha test.
   */
  getAlphaTestTexture() {
    return this._albedoTexture;
  }
  /**
   * Specifies that the submesh is ready to be used.
   * @param mesh - BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
   * @param useInstances - Specifies that instances should be used.
   * @returns - boolean indicating that the submesh is ready or not.
   */
  isReadyForSubMesh(mesh, subMesh, useInstances) {
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    const drawWrapper = subMesh._drawWrapper;
    if (drawWrapper.effect && this.isFrozen) {
      if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {
        return true;
      }
    }
    if (!subMesh.materialDefines) {
      this._callbackPluginEventGeneric(4, this._eventInfo);
      subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
    }
    const defines = subMesh.materialDefines;
    if (this._isReadyForSubMesh(subMesh)) {
      return true;
    }
    const scene = this.getScene();
    const engine = scene.getEngine();
    if (defines._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          if (!this._albedoTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          if (!this._baseWeightTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          if (!this._baseDiffuseRoughnessTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          if (!this._ambientTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          if (!this._opacityTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        const reflectionTexture = this._getReflectionTexture();
        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!reflectionTexture.isReadyOrNotBlocking()) {
            return false;
          }
          if (reflectionTexture.irradianceTexture) {
            if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else {
            if (!reflectionTexture.sphericalPolynomial && reflectionTexture.getInternalTexture()?._sphericalPolynomialPromise) {
              return false;
            }
          }
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          if (!this._lightmapTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          if (!this._emissiveTexture.isReadyOrNotBlocking()) {
            return false;
          }
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            if (!this._metallicTexture.isReadyOrNotBlocking()) {
              return false;
            }
          } else if (this._reflectivityTexture) {
            if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._metallicReflectanceTexture) {
            if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._reflectanceTexture) {
            if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
          if (this._microSurfaceTexture) {
            if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
              return false;
            }
          }
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          if (!this._bumpTexture.isReady()) {
            return false;
          }
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          if (!this._environmentBRDFTexture.isReady()) {
            return false;
          }
        }
      }
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    if (!this._eventInfo.isReadyForSubMesh) {
      return false;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady()) {
        return false;
      }
    }
    if (defines["AREALIGHTUSED"] || defines["CLUSTLIGHT_BATCH"]) {
      for (let index = 0; index < mesh.lightSources.length; index++) {
        if (!mesh.lightSources[index]._isReady()) {
          return false;
        }
      }
    }
    if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      mesh.createNormals(true);
      Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
    }
    const previousEffect = subMesh.effect;
    const lightDisposed = defines._areLightsDisposed;
    let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);
    let forceWasNotReadyPreviously = false;
    if (effect) {
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = subMesh;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
      if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
        effect = previousEffect;
        defines.markAsUnprocessed();
        forceWasNotReadyPreviously = this.isFrozen;
        if (lightDisposed) {
          defines._areLightsDisposed = true;
          return false;
        }
      } else {
        scene.resetCachedMaterial();
        subMesh.setEffect(effect, defines, this._materialContext);
      }
    }
    if (!subMesh.effect || !subMesh.effect.isReady()) {
      return false;
    }
    defines._renderId = scene.getRenderId();
    drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
    drawWrapper._wasPreviouslyUsingInstances = !!useInstances;
    this._checkScenePerformancePriority();
    return true;
  }
  /**
   * Specifies if the material uses metallic roughness workflow.
   * @returns boolean specifying if the material uses metallic roughness workflow.
   */
  isMetallicWorkflow() {
    if (this._metallic != null || this._roughness != null || this._metallicTexture) {
      return true;
    }
    return false;
  }
  _prepareEffect(mesh, renderingMesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null) {
    this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);
    if (!defines.isDirty) {
      return null;
    }
    defines.markAsProcessed();
    const scene = this.getScene();
    const engine = scene.getEngine();
    const fallbacks = new EffectFallbacks();
    let fallbackRank = 0;
    if (defines.USESPHERICALINVERTEX) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
    }
    if (defines.FOG) {
      fallbacks.addFallback(fallbackRank, "FOG");
    }
    if (defines.SPECULARAA) {
      fallbacks.addFallback(fallbackRank, "SPECULARAA");
    }
    if (defines.POINTSIZE) {
      fallbacks.addFallback(fallbackRank, "POINTSIZE");
    }
    if (defines.LOGARITHMICDEPTH) {
      fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
    }
    if (defines.PARALLAX) {
      fallbacks.addFallback(fallbackRank, "PARALLAX");
    }
    if (defines.PARALLAX_RHS) {
      fallbacks.addFallback(fallbackRank, "PARALLAX_RHS");
    }
    if (defines.PARALLAXOCCLUSION) {
      fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
    }
    if (defines.ENVIRONMENTBRDF) {
      fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
    }
    if (defines.TANGENT) {
      fallbacks.addFallback(fallbackRank++, "TANGENT");
    }
    if (defines.BUMP) {
      fallbacks.addFallback(fallbackRank++, "BUMP");
    }
    fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
    if (defines.SPECULARTERM) {
      fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
    }
    if (defines.USESPHERICALFROMREFLECTIONMAP) {
      fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
    }
    if (defines.USEIRRADIANCEMAP) {
      fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
    }
    if (defines.LIGHTMAP) {
      fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
    }
    if (defines.NORMAL) {
      fallbacks.addFallback(fallbackRank++, "NORMAL");
    }
    if (defines.AMBIENT) {
      fallbacks.addFallback(fallbackRank++, "AMBIENT");
    }
    if (defines.EMISSIVE) {
      fallbacks.addFallback(fallbackRank++, "EMISSIVE");
    }
    if (defines.VERTEXCOLOR) {
      fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
    }
    if (defines.MORPHTARGETS) {
      fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
    }
    if (defines.MULTIVIEW) {
      fallbacks.addFallback(0, "MULTIVIEW");
    }
    const attribs = [VertexBuffer.PositionKind];
    if (defines.NORMAL) {
      attribs.push(VertexBuffer.NormalKind);
    }
    if (defines.TANGENT) {
      attribs.push(VertexBuffer.TangentKind);
    }
    for (let i = 1; i <= 6; ++i) {
      if (defines["UV" + i]) {
        attribs.push(`uv${i === 1 ? "" : i}`);
      }
    }
    if (defines.VERTEXCOLOR) {
      attribs.push(VertexBuffer.ColorKind);
    }
    PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
    PrepareAttributesForInstances(attribs, defines);
    PrepareAttributesForMorphTargets(attribs, mesh, defines);
    PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
    let shaderName = "pbr";
    const uniforms = [
      "world",
      "view",
      "viewProjection",
      "vEyePosition",
      "vLightsType",
      "vAmbientColor",
      "vAlbedoColor",
      "baseWeight",
      "baseDiffuseRoughness",
      "vReflectivityColor",
      "vMetallicReflectanceFactors",
      "vEmissiveColor",
      "visibility",
      "vFogInfos",
      "vFogColor",
      "pointSize",
      "vAlbedoInfos",
      "vBaseWeightInfos",
      "vBaseDiffuseRoughnessInfos",
      "vAmbientInfos",
      "vOpacityInfos",
      "vEmissiveInfos",
      "vReflectivityInfos",
      "vMetallicReflectanceInfos",
      "vReflectanceInfos",
      "vMicroSurfaceSamplerInfos",
      "vBumpInfos",
      "vLightmapInfos",
      "mBones",
      "albedoMatrix",
      "baseWeightMatrix",
      "baseDiffuseRoughnessMatrix",
      "ambientMatrix",
      "opacityMatrix",
      "emissiveMatrix",
      "reflectivityMatrix",
      "normalMatrix",
      "microSurfaceSamplerMatrix",
      "bumpMatrix",
      "lightmapMatrix",
      "metallicReflectanceMatrix",
      "reflectanceMatrix",
      "vLightingIntensity",
      "logarithmicDepthConstant",
      "vTangentSpaceParams",
      "boneTextureWidth",
      "vDebugMode",
      "morphTargetTextureInfo",
      "morphTargetTextureIndices",
      "cameraInfo"
    ];
    const samplers = [
      "albedoSampler",
      "baseWeightSampler",
      "baseDiffuseRoughnessSampler",
      "reflectivitySampler",
      "ambientSampler",
      "emissiveSampler",
      "bumpSampler",
      "lightmapSampler",
      "opacitySampler",
      "microSurfaceSampler",
      "environmentBrdfSampler",
      "boneSampler",
      "metallicReflectanceSampler",
      "reflectanceSampler",
      "morphTargets",
      "oitDepthSampler",
      "oitFrontColorSampler",
      "areaLightsLTC1Sampler",
      "areaLightsLTC2Sampler"
    ];
    PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);
    const uniformBuffers = ["Material", "Scene", "Mesh"];
    const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
    this._eventInfo.fallbacks = fallbacks;
    this._eventInfo.fallbackRank = fallbackRank;
    this._eventInfo.defines = defines;
    this._eventInfo.uniforms = uniforms;
    this._eventInfo.attributes = attribs;
    this._eventInfo.samplers = samplers;
    this._eventInfo.uniformBuffersNames = uniformBuffers;
    this._eventInfo.customCode = void 0;
    this._eventInfo.mesh = mesh;
    this._eventInfo.indexParameters = indexParameters;
    this._callbackPluginEventGeneric(128, this._eventInfo);
    MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);
    PrePassConfiguration.AddUniforms(uniforms);
    PrePassConfiguration.AddSamplers(samplers);
    AddClipPlaneUniforms(uniforms);
    if (ImageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
    }
    PrepareUniformsAndSamplersList({
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines,
      maxSimultaneousLights: this._maxSimultaneousLights
    });
    const csnrOptions = {};
    if (this.customShaderNameResolve) {
      shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
    }
    const join = defines.toString();
    const effect = engine.createEffect(shaderName, {
      attributes: attribs,
      uniformsNames: uniforms,
      uniformBuffersNames: uniformBuffers,
      samplers,
      defines: join,
      fallbacks,
      onCompiled,
      onError,
      indexParameters,
      processFinalCode: csnrOptions.processFinalCode,
      processCodeAfterIncludes: this._eventInfo.customCode,
      multiTarget: defines.PREPASS,
      shaderLanguage: this._shaderLanguage,
      extraInitializationsAsync: this._shadersLoaded ? void 0 : async () => {
        if (this.shaderLanguage === 1) {
          await Promise.all([import("./pbr.vertex-DBWDNJO6.js"), import("./pbr.fragment-CURBSDIY.js")]);
        } else {
          await Promise.all([import("./pbr.vertex-GZDG3RHX.js"), import("./pbr.fragment-IFMFOHHN.js")]);
        }
        this._shadersLoaded = true;
      }
    }, engine);
    this._eventInfo.customCode = void 0;
    return effect;
  }
  _prepareDefines(mesh, renderingMesh, defines, useInstances = null, useClipPlane = null) {
    const useThinInstances = renderingMesh.hasThinInstances;
    const scene = this.getScene();
    const engine = scene.getEngine();
    PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
    defines._needNormals = true;
    PrepareDefinesForMultiview(scene, defines);
    const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
    PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
    PrepareDefinesForOIT(scene, defines, oit);
    MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);
    defines.METALLICWORKFLOW = this.isMetallicWorkflow();
    if (defines._areTexturesDirty) {
      defines._needUVs = false;
      for (let i = 1; i <= 6; ++i) {
        defines["MAINUV" + i] = false;
      }
      if (scene.texturesEnabled) {
        defines.ALBEDODIRECTUV = 0;
        defines.BASE_WEIGHTDIRECTUV = 0;
        defines.BASE_DIFFUSE_ROUGHNESSDIRECTUV = 0;
        defines.AMBIENTDIRECTUV = 0;
        defines.OPACITYDIRECTUV = 0;
        defines.EMISSIVEDIRECTUV = 0;
        defines.REFLECTIVITYDIRECTUV = 0;
        defines.MICROSURFACEMAPDIRECTUV = 0;
        defines.METALLIC_REFLECTANCEDIRECTUV = 0;
        defines.REFLECTANCEDIRECTUV = 0;
        defines.BUMPDIRECTUV = 0;
        defines.LIGHTMAPDIRECTUV = 0;
        if (engine.getCaps().textureLOD) {
          defines.LODBASEDMICROSFURACE = true;
        }
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
          defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
        } else {
          defines.ALBEDO = false;
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          PrepareDefinesForMergedUV(this._baseWeightTexture, defines, "BASE_WEIGHT");
        } else {
          defines.BASE_WEIGHT = false;
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          PrepareDefinesForMergedUV(this._baseDiffuseRoughnessTexture, defines, "BASE_DIFFUSE_ROUGHNESS");
        } else {
          defines.BASE_DIFFUSE_ROUGHNESS = false;
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
          defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
        } else {
          defines.AMBIENT = false;
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
          defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
        } else {
          defines.OPACITY = false;
        }
        const reflectionTexture = this._getReflectionTexture();
        const useSHInFragment = this._forceIrradianceInFragment || this.realTimeFiltering || this._twoSidedLighting || engine.getCaps().maxVaryingVectors <= 8 || this._baseDiffuseRoughnessTexture != null;
        PrepareDefinesForIBL(scene, reflectionTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
          defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
          defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
          defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
        } else {
          defines.LIGHTMAP = false;
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
          defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
        } else {
          defines.EMISSIVE = false;
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
            defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
            defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
            defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
            defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
            defines.REFLECTIVITY_GAMMA = false;
          } else if (this._reflectivityTexture) {
            PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
            defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
            defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
            defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
          } else {
            defines.REFLECTIVITY = false;
          }
          if (this._metallicReflectanceTexture || this._reflectanceTexture) {
            defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture;
            if (this._metallicReflectanceTexture) {
              PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
              defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
            } else {
              defines.METALLIC_REFLECTANCE = false;
            }
            if (this._reflectanceTexture && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
              PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
              defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
            } else {
              defines.REFLECTANCE = false;
            }
          } else {
            defines.METALLIC_REFLECTANCE = false;
            defines.REFLECTANCE = false;
          }
          if (this._microSurfaceTexture) {
            PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
          } else {
            defines.MICROSURFACEMAP = false;
          }
        } else {
          defines.REFLECTIVITY = false;
          defines.MICROSURFACEMAP = false;
        }
        if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
          if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            defines.PARALLAX = true;
            defines.PARALLAX_RHS = scene.useRightHandedSystem;
            defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
          } else {
            defines.PARALLAX = false;
          }
          defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else {
          defines.BUMP = false;
          defines.PARALLAX = false;
          defines.PARALLAX_RHS = false;
          defines.PARALLAXOCCLUSION = false;
          defines.OBJECTSPACE_NORMALMAP = false;
        }
        if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
          defines.ENVIRONMENTBRDF = true;
          defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
        } else {
          defines.ENVIRONMENTBRDF = false;
          defines.ENVIRONMENTBRDF_RGBD = false;
        }
        if (this._shouldUseAlphaFromAlbedoTexture()) {
          defines.ALPHAFROMALBEDO = true;
        } else {
          defines.ALPHAFROMALBEDO = false;
        }
      }
      defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
      if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = false;
      } else if (this._lightFalloff === _PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
        defines.USEPHYSICALLIGHTFALLOFF = false;
        defines.USEGLTFLIGHTFALLOFF = true;
      } else {
        defines.USEPHYSICALLIGHTFALLOFF = true;
        defines.USEGLTFLIGHTFALLOFF = false;
      }
      defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
      if (!this.backFaceCulling && this._twoSidedLighting) {
        defines.TWOSIDEDLIGHTING = true;
      } else {
        defines.TWOSIDEDLIGHTING = false;
      }
      defines.MIRRORED = !!scene._mirroredCameraPosition;
      defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
    }
    if (defines._areTexturesDirty || defines._areMiscDirty) {
      defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
      defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
      defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
      defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
      defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
    }
    if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(defines);
    }
    defines.FORCENORMALFORWARD = this._forceNormalForward;
    defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
    defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
    if (defines._areMiscDirty) {
      PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this.needAlphaTestingForMesh(mesh), defines, this._applyDecalMapAfterDetailMap, this._useVertexPulling, renderingMesh, this._setVertexOutputInvariant);
      defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
      defines.DEBUGMODE = this._debugMode;
    }
    PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
    this._eventInfo.defines = defines;
    this._eventInfo.mesh = mesh;
    this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
    PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== _PBRBaseMaterial.PBRMATERIAL_OPAQUE);
    this._callbackPluginEventPrepareDefines(this._eventInfo);
  }
  /**
   * Force shader compilation
   * @param mesh - Define the mesh we want to force the compilation for
   * @param onCompiled - Define a callback triggered when the compilation completes
   * @param options - Define the options used to create the compilation
   */
  forceCompilation(mesh, onCompiled, options) {
    const localOptions = {
      clipPlane: false,
      useInstances: false,
      ...options
    };
    if (!this._uniformBufferLayoutBuilt) {
      this.buildUniformLayout();
    }
    this._callbackPluginEventGeneric(4, this._eventInfo);
    const checkReady = () => {
      if (this._breakShaderLoadedCheck) {
        return;
      }
      const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
      const effect = this._prepareEffect(mesh, mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane);
      if (this._onEffectCreatedObservable) {
        onCreatedEffectParameters.effect = effect;
        onCreatedEffectParameters.subMesh = null;
        this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
      }
      if (effect.isReady()) {
        if (onCompiled) {
          onCompiled(this);
        }
      } else {
        effect.onCompileObservable.add(() => {
          if (onCompiled) {
            onCompiled(this);
          }
        });
      }
    };
    checkReady();
  }
  /**
   * Initializes the uniform buffer layout for the shader.
   */
  buildUniformLayout() {
    const ubo = this._uniformBuffer;
    ubo.addUniform("vAlbedoInfos", 2);
    ubo.addUniform("vBaseWeightInfos", 2);
    ubo.addUniform("vBaseDiffuseRoughnessInfos", 2);
    ubo.addUniform("vAmbientInfos", 4);
    ubo.addUniform("vOpacityInfos", 2);
    ubo.addUniform("vEmissiveInfos", 2);
    ubo.addUniform("vLightmapInfos", 2);
    ubo.addUniform("vReflectivityInfos", 3);
    ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
    ubo.addUniform("vBumpInfos", 3);
    ubo.addUniform("albedoMatrix", 16);
    ubo.addUniform("baseWeightMatrix", 16);
    ubo.addUniform("baseDiffuseRoughnessMatrix", 16);
    ubo.addUniform("ambientMatrix", 16);
    ubo.addUniform("opacityMatrix", 16);
    ubo.addUniform("emissiveMatrix", 16);
    ubo.addUniform("lightmapMatrix", 16);
    ubo.addUniform("reflectivityMatrix", 16);
    ubo.addUniform("microSurfaceSamplerMatrix", 16);
    ubo.addUniform("bumpMatrix", 16);
    ubo.addUniform("vTangentSpaceParams", 2);
    ubo.addUniform("vAlbedoColor", 4);
    ubo.addUniform("baseWeight", 1);
    ubo.addUniform("baseDiffuseRoughness", 1);
    ubo.addUniform("vLightingIntensity", 4);
    ubo.addUniform("pointSize", 1);
    ubo.addUniform("vReflectivityColor", 4);
    ubo.addUniform("vEmissiveColor", 3);
    ubo.addUniform("vAmbientColor", 3);
    ubo.addUniform("vDebugMode", 2);
    ubo.addUniform("vMetallicReflectanceFactors", 4);
    ubo.addUniform("vMetallicReflectanceInfos", 2);
    ubo.addUniform("metallicReflectanceMatrix", 16);
    ubo.addUniform("vReflectanceInfos", 2);
    ubo.addUniform("reflectanceMatrix", 16);
    ubo.addUniform("cameraInfo", 4);
    PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);
    super.buildUniformLayout();
  }
  /**
   * Binds the submesh data.
   * @param world - The world matrix.
   * @param mesh - The BJS mesh.
   * @param subMesh - A submesh of the BJS mesh.
   */
  bindForSubMesh(world, mesh, subMesh) {
    const scene = this.getScene();
    const defines = subMesh.materialDefines;
    if (!defines) {
      return;
    }
    const effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._activeEffect = effect;
    mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
    mesh.transferToEffect(world);
    const engine = scene.getEngine();
    this._uniformBuffer.bindToEffect(effect, "Material");
    this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
    MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);
    const camera = scene.activeCamera;
    if (camera) {
      this._uniformBuffer.updateFloat4("cameraInfo", camera.minZ, camera.maxZ, 0, 0);
    } else {
      this._uniformBuffer.updateFloat4("cameraInfo", 0, 0, 0, 0);
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
    if (defines.OBJECTSPACE_NORMALMAP) {
      world.toNormalMatrix(this._normalMatrix);
      this.bindOnlyNormalMatrix(this._normalMatrix);
    }
    const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);
    BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
    let reflectionTexture = null;
    const ubo = this._uniformBuffer;
    if (mustRebind) {
      this.bindViewProjection(effect);
      reflectionTexture = this._getReflectionTexture();
      if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {
        if (scene.texturesEnabled) {
          if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
            ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
            BindTextureMatrix(this._albedoTexture, ubo, "albedo");
          }
          if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
            ubo.updateFloat2("vBaseWeightInfos", this._baseWeightTexture.coordinatesIndex, this._baseWeightTexture.level);
            BindTextureMatrix(this._baseWeightTexture, ubo, "baseWeight");
          }
          if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
            ubo.updateFloat2("vBaseDiffuseRoughnessInfos", this._baseDiffuseRoughnessTexture.coordinatesIndex, this._baseDiffuseRoughnessTexture.level);
            BindTextureMatrix(this._baseDiffuseRoughnessTexture, ubo, "baseDiffuseRoughness");
          }
          if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
            ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
            BindTextureMatrix(this._ambientTexture, ubo, "ambient");
          }
          if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
            ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
            BindTextureMatrix(this._opacityTexture, ubo, "opacity");
          }
          if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
            ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
            BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
          }
          if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
            ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
            BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
          }
          if (MaterialFlags.SpecularTextureEnabled) {
            if (this._metallicTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
              BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
            } else if (this._reflectivityTexture) {
              ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
              BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
            }
            if (this._metallicReflectanceTexture) {
              ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
              BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
            }
            if (this._reflectanceTexture && defines.REFLECTANCE) {
              ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
              BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
            }
            if (this._microSurfaceTexture) {
              ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
              BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
            ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
            BindTextureMatrix(this._bumpTexture, ubo, "bump");
            if (scene._mirroredCameraPosition) {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
            } else {
              ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
            }
          }
          BindIBLParameters(scene, defines, ubo, this._reflectionColor, reflectionTexture, this.realTimeFiltering, true, true, true, true, true);
        }
        if (this.pointsCloud) {
          ubo.updateFloat("pointSize", this.pointSize);
        }
        if (defines.METALLICWORKFLOW) {
          TmpColors.Color4[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
          TmpColors.Color4[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
          const ior = this.subSurface?._indexOfRefraction ?? 1.5;
          const outsideIOR = 1;
          TmpColors.Color4[0].b = ior;
          const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
          TmpColors.Color4[0].a = f0;
          ubo.updateDirectColor4("vReflectivityColor", TmpColors.Color4[0]);
          ubo.updateColor4("vMetallicReflectanceFactors", this._metallicReflectanceColor, this._metallicF0Factor);
        } else {
          ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
        }
        ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
        if (!defines.SS_REFRACTION && this.subSurface?._linkRefractionWithTransparency) {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
        } else {
          ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
        }
        ubo.updateFloat("baseWeight", this._baseWeight);
        ubo.updateFloat("baseDiffuseRoughness", this._baseDiffuseRoughness || 0);
        this._lightingInfos.x = this._directIntensity;
        this._lightingInfos.y = this._emissiveIntensity;
        this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
        this._lightingInfos.w = this._specularIntensity;
        ubo.updateVector4("vLightingIntensity", this._lightingInfos);
        scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
        ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
        ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
      }
      if (scene.texturesEnabled) {
        if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
          ubo.setTexture("albedoSampler", this._albedoTexture);
        }
        if (this._baseWeightTexture && MaterialFlags.BaseWeightTextureEnabled) {
          ubo.setTexture("baseWeightSampler", this._baseWeightTexture);
        }
        if (this._baseDiffuseRoughnessTexture && MaterialFlags.BaseDiffuseRoughnessTextureEnabled) {
          ubo.setTexture("baseDiffuseRoughnessSampler", this._baseDiffuseRoughnessTexture);
        }
        if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
          ubo.setTexture("ambientSampler", this._ambientTexture);
        }
        if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
          ubo.setTexture("opacitySampler", this._opacityTexture);
        }
        BindIBLSamplers(scene, defines, ubo, reflectionTexture, this.realTimeFiltering);
        if (defines.ENVIRONMENTBRDF) {
          ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
        }
        if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
          ubo.setTexture("emissiveSampler", this._emissiveTexture);
        }
        if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
          ubo.setTexture("lightmapSampler", this._lightmapTexture);
        }
        if (MaterialFlags.SpecularTextureEnabled) {
          if (this._metallicTexture) {
            ubo.setTexture("reflectivitySampler", this._metallicTexture);
          } else if (this._reflectivityTexture) {
            ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
          }
          if (this._metallicReflectanceTexture) {
            ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
          }
          if (this._reflectanceTexture && defines.REFLECTANCE) {
            ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
          }
          if (this._microSurfaceTexture) {
            ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
          }
        }
        if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
          ubo.setTexture("bumpSampler", this._bumpTexture);
        }
      }
      if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
        this.getScene().depthPeelingRenderer.bind(effect);
      }
      this._eventInfo.subMesh = subMesh;
      this._callbackPluginEventBindForSubMesh(this._eventInfo);
      BindClipPlane(this._activeEffect, this, scene);
      this.bindEyePosition(effect);
    } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
      this._needToBindSceneUbo = true;
    }
    if (mustRebind || !this.isFrozen) {
      if (scene.lightsEnabled && !this._disableLighting) {
        BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
      }
      if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || this.subSurface.refractionTexture || mesh.receiveShadows || defines.PREPASS || defines["CLUSTLIGHT_BATCH"]) {
        this.bindView(effect);
      }
      BindFogParameters(scene, mesh, this._activeEffect, true);
      if (defines.NUM_MORPH_INFLUENCERS) {
        BindMorphTargetParameters(mesh, this._activeEffect);
      }
      if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
        mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);
      }
      this._imageProcessingConfiguration.bind(this._activeEffect);
      BindLogDepth(defines, this._activeEffect, scene);
    }
    this._afterBind(mesh, this._activeEffect, subMesh);
    ubo.update();
  }
  /**
   * Returns the animatable textures.
   * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
   * @returns - Array of animatable textures.
   */
  getAnimatables() {
    const results = super.getAnimatables();
    if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
      results.push(this._albedoTexture);
    }
    if (this._baseWeightTexture && this._baseWeightTexture.animations && this._baseWeightTexture.animations.length > 0) {
      results.push(this._baseWeightTexture);
    }
    if (this._baseDiffuseRoughnessTexture && this._baseDiffuseRoughnessTexture.animations && this._baseDiffuseRoughnessTexture.animations.length > 0) {
      results.push(this._baseDiffuseRoughnessTexture);
    }
    if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
      results.push(this._ambientTexture);
    }
    if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
      results.push(this._opacityTexture);
    }
    if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
      results.push(this._reflectionTexture);
    }
    if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
      results.push(this._emissiveTexture);
    }
    if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
      results.push(this._metallicTexture);
    } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
      results.push(this._reflectivityTexture);
    }
    if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
      results.push(this._bumpTexture);
    }
    if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
      results.push(this._lightmapTexture);
    }
    if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
      results.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
      results.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
      results.push(this._microSurfaceTexture);
    }
    return results;
  }
  /**
   * Returns the texture used for reflections.
   * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
   */
  _getReflectionTexture() {
    if (this._reflectionTexture) {
      return this._reflectionTexture;
    }
    return this.getScene().environmentTexture;
  }
  /**
   * Returns an array of the actively used textures.
   * @returns - Array of BaseTextures
   */
  getActiveTextures() {
    const activeTextures = super.getActiveTextures();
    if (this._albedoTexture) {
      activeTextures.push(this._albedoTexture);
    }
    if (this._baseWeightTexture) {
      activeTextures.push(this._baseWeightTexture);
    }
    if (this._baseDiffuseRoughnessTexture) {
      activeTextures.push(this._baseDiffuseRoughnessTexture);
    }
    if (this._ambientTexture) {
      activeTextures.push(this._ambientTexture);
    }
    if (this._opacityTexture) {
      activeTextures.push(this._opacityTexture);
    }
    if (this._reflectionTexture) {
      activeTextures.push(this._reflectionTexture);
    }
    if (this._emissiveTexture) {
      activeTextures.push(this._emissiveTexture);
    }
    if (this._reflectivityTexture) {
      activeTextures.push(this._reflectivityTexture);
    }
    if (this._metallicTexture) {
      activeTextures.push(this._metallicTexture);
    }
    if (this._metallicReflectanceTexture) {
      activeTextures.push(this._metallicReflectanceTexture);
    }
    if (this._reflectanceTexture) {
      activeTextures.push(this._reflectanceTexture);
    }
    if (this._microSurfaceTexture) {
      activeTextures.push(this._microSurfaceTexture);
    }
    if (this._bumpTexture) {
      activeTextures.push(this._bumpTexture);
    }
    if (this._lightmapTexture) {
      activeTextures.push(this._lightmapTexture);
    }
    return activeTextures;
  }
  /**
   * Checks to see if a texture is used in the material.
   * @param texture - Base texture to use.
   * @returns - Boolean specifying if a texture is used in the material.
   */
  hasTexture(texture) {
    if (super.hasTexture(texture)) {
      return true;
    }
    if (this._albedoTexture === texture) {
      return true;
    }
    if (this._baseWeightTexture === texture) {
      return true;
    }
    if (this._baseDiffuseRoughnessTexture === texture) {
      return true;
    }
    if (this._ambientTexture === texture) {
      return true;
    }
    if (this._opacityTexture === texture) {
      return true;
    }
    if (this._reflectionTexture === texture) {
      return true;
    }
    if (this._emissiveTexture === texture) {
      return true;
    }
    if (this._reflectivityTexture === texture) {
      return true;
    }
    if (this._metallicTexture === texture) {
      return true;
    }
    if (this._metallicReflectanceTexture === texture) {
      return true;
    }
    if (this._reflectanceTexture === texture) {
      return true;
    }
    if (this._microSurfaceTexture === texture) {
      return true;
    }
    if (this._bumpTexture === texture) {
      return true;
    }
    if (this._lightmapTexture === texture) {
      return true;
    }
    return false;
  }
  /**
   * Sets the required values to the prepass renderer.
   * It can't be sets when subsurface scattering of this material is disabled.
   * When scene have ability to enable subsurface prepass effect, it will enable.
   * @returns - If prepass is enabled or not.
   */
  setPrePassRenderer() {
    if (!this.subSurface?.isScatteringEnabled) {
      return false;
    }
    const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
    if (subSurfaceConfiguration) {
      subSurfaceConfiguration.enabled = true;
    }
    return true;
  }
  /**
   * Disposes the resources of the material.
   * @param forceDisposeEffect - Forces the disposal of effects.
   * @param forceDisposeTextures - Forces the disposal of all textures.
   */
  dispose(forceDisposeEffect, forceDisposeTextures) {
    this._breakShaderLoadedCheck = true;
    if (forceDisposeTextures) {
      if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
        this._environmentBRDFTexture.dispose();
      }
      this._albedoTexture?.dispose();
      this._baseWeightTexture?.dispose();
      this._baseDiffuseRoughnessTexture?.dispose();
      this._ambientTexture?.dispose();
      this._opacityTexture?.dispose();
      this._reflectionTexture?.dispose();
      this._emissiveTexture?.dispose();
      this._metallicTexture?.dispose();
      this._reflectivityTexture?.dispose();
      this._bumpTexture?.dispose();
      this._lightmapTexture?.dispose();
      this._metallicReflectanceTexture?.dispose();
      this._reflectanceTexture?.dispose();
      this._microSurfaceTexture?.dispose();
    }
    this._renderTargets.dispose();
    if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
      this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
    }
    super.dispose(forceDisposeEffect, forceDisposeTextures);
  }
};
PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
PBRBaseMaterial.ForceGLSL = false;
__decorate([
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRBaseMaterial.prototype, "debugMode", void 0);

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial = class _PBRMaterial extends PBRBaseMaterial {
  /**
   * Stores the refracted light information in a texture.
   */
  get refractionTexture() {
    return this.subSurface.refractionTexture;
  }
  set refractionTexture(value) {
    this.subSurface.refractionTexture = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    } else if (!this.subSurface.linkRefractionWithTransparency) {
      this.subSurface.isRefractionEnabled = false;
    }
  }
  /**
   * Index of refraction of the material base layer.
   * https://en.wikipedia.org/wiki/List_of_refractive_indices
   *
   * This does not only impact refraction but also the Base F0 of Dielectric Materials.
   *
   * From dielectric fresnel rules: F0 = square((iorT - iorI) / (iorT + iorI))
   */
  get indexOfRefraction() {
    return this.subSurface.indexOfRefraction;
  }
  set indexOfRefraction(value) {
    this.subSurface.indexOfRefraction = value;
  }
  /**
   * Controls if refraction needs to be inverted on Y. This could be useful for procedural texture.
   */
  get invertRefractionY() {
    return this.subSurface.invertRefractionY;
  }
  set invertRefractionY(value) {
    this.subSurface.invertRefractionY = value;
  }
  /**
   * This parameters will make the material used its opacity to control how much it is refracting against not.
   * Materials half opaque for instance using refraction could benefit from this control.
   */
  get linkRefractionWithTransparency() {
    return this.subSurface.linkRefractionWithTransparency;
  }
  set linkRefractionWithTransparency(value) {
    this.subSurface.linkRefractionWithTransparency = value;
    if (value) {
      this.subSurface.isRefractionEnabled = true;
    }
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  get usePhysicalLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
  }
  /**
   * BJS is using an hardcoded light falloff based on a manually sets up range.
   * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
   * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
   */
  set usePhysicalLightFalloff(value) {
    if (value !== this.usePhysicalLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  get useGLTFLightFalloff() {
    return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
  }
  /**
   * In order to support the falloff compatibility with gltf, a special mode has been added
   * to reproduce the gltf light falloff.
   */
  set useGLTFLightFalloff(value) {
    if (value !== this.useGLTFLightFalloff) {
      this._markAllSubMeshesAsTexturesDirty();
      if (value) {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      } else {
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
      }
    }
  }
  /**
   * Instantiates a new PBRMaterial instance.
   *
   * @param name The material name
   * @param scene The scene the material will be use in.
   * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
   */
  constructor(name, scene, forceGLSL = false) {
    super(name, scene, forceGLSL);
    this.directIntensity = 1;
    this.emissiveIntensity = 1;
    this.environmentIntensity = 1;
    this.specularIntensity = 1;
    this.disableBumpMap = false;
    this.ambientTextureStrength = 1;
    this.ambientTextureImpactOnAnalyticalLights = _PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    this.metallicF0Factor = 1;
    this.metallicReflectanceColor = Color3.White();
    this.useOnlyMetallicFromMetallicReflectanceTexture = false;
    this.ambientColor = new Color3(0, 0, 0);
    this.albedoColor = new Color3(1, 1, 1);
    this.baseWeight = 1;
    this.reflectivityColor = new Color3(1, 1, 1);
    this.reflectionColor = new Color3(1, 1, 1);
    this.emissiveColor = new Color3(0, 0, 0);
    this.microSurface = 1;
    this.useLightmapAsShadowmap = false;
    this.useAlphaFromAlbedoTexture = false;
    this.forceAlphaTest = false;
    this.alphaCutOff = 0.4;
    this.useSpecularOverAlpha = true;
    this.useMicroSurfaceFromReflectivityMapAlpha = false;
    this.useRoughnessFromMetallicTextureAlpha = true;
    this.useRoughnessFromMetallicTextureGreen = false;
    this.useMetallnessFromMetallicTextureBlue = false;
    this.useAmbientOcclusionFromMetallicTextureRed = false;
    this.useAmbientInGrayScale = false;
    this.useAutoMicroSurfaceFromReflectivityMap = false;
    this.useRadianceOverAlpha = true;
    this.useObjectSpaceNormalMap = false;
    this.useParallax = false;
    this.useParallaxOcclusion = false;
    this.parallaxScaleBias = 0.05;
    this.disableLighting = false;
    this.forceIrradianceInFragment = false;
    this.maxSimultaneousLights = 4;
    this.invertNormalMapX = false;
    this.invertNormalMapY = false;
    this.twoSidedLighting = false;
    this.useAlphaFresnel = false;
    this.useLinearAlphaFresnel = false;
    this.environmentBRDFTexture = null;
    this.forceNormalForward = false;
    this.enableSpecularAntiAliasing = false;
    this.useHorizonOcclusion = true;
    this.useRadianceOcclusion = true;
    this.unlit = false;
    this.applyDecalMapAfterDetailMap = false;
    this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
  }
  /**
   * @returns the name of this material class.
   */
  getClassName() {
    return "PBRMaterial";
  }
  /**
   * Makes a duplicate of the current material.
   * @param name - name to use for the new material.
   * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g diffuse and opacity), only clone it once and reuse it on the other channels. Default false.
   * @param rootUrl defines the root URL to use to load textures
   * @returns cloned material instance
   */
  clone(name, cloneTexturesOnlyOnce = true, rootUrl = "") {
    const clone = SerializationHelper.Clone(() => new _PBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });
    clone.id = name;
    clone.name = name;
    this.stencil.copyTo(clone.stencil);
    this._clonePlugins(clone, rootUrl);
    return clone;
  }
  /**
   * Serializes this PBR Material.
   * @returns - An object with the serialized material.
   */
  serialize() {
    const serializationObject = super.serialize();
    serializationObject.customType = "BABYLON.PBRMaterial";
    return serializationObject;
  }
  // Statics
  /**
   * Parses a PBR Material from a serialized object.
   * @param source - Serialized object.
   * @param scene - BJS scene instance.
   * @param rootUrl - url for the scene object
   * @returns - PBRMaterial
   */
  static Parse(source, scene, rootUrl) {
    const material = SerializationHelper.Parse(() => new _PBRMaterial(source.name, scene), source, scene, rootUrl);
    if (source.stencil) {
      material.stencil.parse(source.stencil, scene, rootUrl);
    }
    Material._ParsePlugins(source, material, scene, rootUrl);
    if (source.clearCoat) {
      material.clearCoat.parse(source.clearCoat, scene, rootUrl);
    }
    if (source.anisotropy) {
      material.anisotropy.parse(source.anisotropy, scene, rootUrl);
    }
    if (source.brdf) {
      material.brdf.parse(source.brdf, scene, rootUrl);
    }
    if (source.sheen) {
      material.sheen.parse(source.sheen, scene, rootUrl);
    }
    if (source.subSurface) {
      material.subSurface.parse(source.subSurface, scene, rootUrl);
    }
    if (source.iridescence) {
      material.iridescence.parse(source.iridescence, scene, rootUrl);
    }
    return material;
  }
};
PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "directIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "specularIntensity", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "disableBumpMap", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "baseWeightTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "baseDiffuseRoughnessTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureStrength", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "opacityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallic", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "roughness", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicF0Factor", void 0);
__decorate([
  serializeAsColor3(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectanceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurfaceTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "bumpTexture", void 0);
__decorate([
  serializeAsTexture(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
], PBRMaterial.prototype, "lightmapTexture", void 0);
__decorate([
  serializeAsColor3("ambient"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "ambientColor", void 0);
__decorate([
  serializeAsColor3("albedo"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "albedoColor", void 0);
__decorate([
  serialize("baseWeight"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "baseWeight", void 0);
__decorate([
  serialize("baseDiffuseRoughness"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "baseDiffuseRoughness", void 0);
__decorate([
  serializeAsColor3("reflectivity"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectivityColor", void 0);
__decorate([
  serializeAsColor3("reflection"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "reflectionColor", void 0);
__decorate([
  serializeAsColor3("emissive"),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "emissiveColor", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "microSurface", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "forceAlphaTest", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
], PBRMaterial.prototype, "alphaCutOff", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
__decorate([
  serialize()
], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
__decorate([
  serialize()
], PBRMaterial.prototype, "useGLTFLightFalloff", null);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallax", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "parallaxScaleBias", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "disableLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsLightsDirty")
], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapX", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "invertNormalMapY", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "twoSidedLighting", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useAlphaFresnel", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
__decorate([
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "forceNormalForward", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsTexturesDirty")
], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "unlit", void 0);
__decorate([
  serialize(),
  expandToProperty("_markAllSubMeshesAsMiscDirty")
], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
RegisterClass("BABYLON.PBRMaterial", PBRMaterial);

export {
  MaterialBRDFDefines,
  PBRBRDFConfiguration,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  PBRMaterial
};
//# sourceMappingURL=chunk-V3LGLGDY.js.map
