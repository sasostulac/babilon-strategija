{
  "version": 3,
  "sources": ["../../../dev/loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts", "../../../dev/loaders/src/glTF/2.0/Extensions/objectModelMapping.ts", "../../../dev/loaders/src/glTF/2.0/glTFLoaderAnimation.ts"],
  "sourcesContent": ["import type { IObjectInfo, IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\r\n\r\n/**\r\n * Adding an exception here will break traversing through the glTF object tree.\r\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\r\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\r\n */\r\nexport const OptionalPathExceptionsList: {\r\n    regex: RegExp;\r\n}[] = [\r\n    {\r\n        // get the node as object when reading an extension\r\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\r\n    },\r\n];\r\n\r\n/**\r\n * A converter that takes a glTF Object Model JSON Pointer\r\n * and transforms it into an ObjectAccessorContainer, allowing\r\n * objects referenced in the glTF to be associated with their\r\n * respective Babylon.js objects.\r\n */\r\nexport class GLTFPathToObjectConverter<T, BabylonType, BabylonValue> implements IPathToObjectConverter<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n    public constructor(\r\n        private _gltf: IGLTF,\r\n        private _infoTree: any\r\n    ) {}\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     * - \"/nodes.length\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     *\r\n     * @param path The path to convert\r\n     * @returns The object and info associated with the path\r\n     */\r\n    public convert(path: string): IObjectInfo<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n        let objectTree: any = this._gltf;\r\n        let infoTree: any = this._infoTree;\r\n        let target: any = undefined;\r\n\r\n        if (!path.startsWith(\"/\")) {\r\n            throw new Error(\"Path must start with a /\");\r\n        }\r\n        const parts = path.split(\"/\");\r\n        parts.shift();\r\n\r\n        //if the last part has \".length\" in it, separate that as an extra part\r\n        if (parts[parts.length - 1].includes(\".length\")) {\r\n            const lastPart = parts[parts.length - 1];\r\n            const split = lastPart.split(\".\");\r\n            parts.pop();\r\n            parts.push(...split);\r\n        }\r\n\r\n        let ignoreObjectTree = false;\r\n\r\n        for (const part of parts) {\r\n            const isLength = part === \"length\";\r\n            if (isLength && !infoTree.__array__) {\r\n                throw new Error(`Path ${path} is invalid`);\r\n            }\r\n            if (infoTree.__ignoreObjectTree__) {\r\n                ignoreObjectTree = true;\r\n            }\r\n            if (infoTree.__array__ && !isLength) {\r\n                infoTree = infoTree.__array__;\r\n            } else {\r\n                infoTree = infoTree[part];\r\n                if (!infoTree) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n            }\r\n            if (!ignoreObjectTree) {\r\n                if (objectTree === undefined) {\r\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\r\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\r\n                    if (!exception) {\r\n                        throw new Error(`Path ${path} is invalid`);\r\n                    }\r\n                } else if (!isLength) {\r\n                    objectTree = objectTree?.[part];\r\n                }\r\n            }\r\n\r\n            if (infoTree.__target__ || isLength) {\r\n                target = objectTree;\r\n            }\r\n        }\r\n\r\n        return {\r\n            object: target,\r\n            info: infoTree,\r\n        };\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { IAnimation, ICamera, IGLTF, IKHRLightsPunctual_Light, IMaterial, IMesh, INode } from \"../glTFLoaderInterfaces\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport type { Color3 } from \"core/Maths/math.color\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport type { Light } from \"core/Lights/light\";\nimport type { Nullable } from \"core/types\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport type { IEXTLightsImageBased_LightImageBased } from \"babylonjs-gltf2interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IInterpolationPropertyInfo, IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Mesh } from \"core/Meshes/mesh\";\n\nexport interface IGLTFObjectModelTree {\n    cameras: IGLTFObjectModelTreeCamerasObject;\n    nodes: IGLTFObjectModelTreeNodesObject;\n    materials: IGLTFObjectModelTreeMaterialsObject;\n    extensions: IGLTFObjectModelTreeExtensionsObject;\n    animations: {\n        length: IObjectAccessor<IAnimation[], AnimationGroup[], number>;\n        __array__: {};\n    };\n    meshes: {\n        length: IObjectAccessor<IMesh[], (Mesh | undefined)[], number>;\n        __array__: {};\n    };\n}\n\nexport interface IGLTFObjectModelTreeNodesObject<GLTFTargetType = INode, BabylonTargetType = TransformNode> {\n    length: IObjectAccessor<GLTFTargetType[], BabylonTargetType[], number>;\n    __array__: {\n        __target__: boolean;\n        translation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        rotation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Quaternion>;\n        scale: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        matrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        globalMatrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        weights: {\n            length: IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n            __array__: { __target__: boolean } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n        } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number[]>;\n        extensions: {\n            EXT_lights_ies?: {\n                multiplier: IObjectAccessor<INode, Light, number>;\n                color: IObjectAccessor<INode, Light, Color3>;\n            };\n            KHR_node_visibility?: {\n                visible: IObjectAccessor<INode, Mesh, boolean>;\n            };\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeCamerasObject {\n    __array__: {\n        __target__: boolean;\n        orthographic: {\n            xmag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            ymag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n        };\n        perspective: {\n            yfov: IObjectAccessor<ICamera, ICamera, number>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n            aspectRatio: IObjectAccessor<ICamera, ICamera, Nullable<number>>;\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeMaterialsObject {\n    __array__: {\n        __target__: boolean;\n        pbrMetallicRoughness: {\n            baseColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color4>;\n            metallicFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            roughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n        };\n        emissiveFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n        normalTexture: {\n            scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        occlusionTexture: {\n            strength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyRotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_clearcoat: {\n                clearcoatFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatNormalTexture: {\n                    scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_dispersion: {\n                dispersion: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_emissive_strength: {\n                emissiveStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_ior: {\n                ior: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_iridescence: {\n                iridescenceFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceIor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMinimum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMaximum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_sheen: {\n                sheenColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                sheenRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_specular: {\n                specularFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                specularColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_transmission: {\n                transmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                diffuseTransmissionColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<Color3>>;\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_volume: {\n                thicknessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                attenuationColor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                attenuationDistance: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n        };\n    };\n}\n\ninterface ITextureDefinition {\n    offset: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n    rotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n    scale: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n}\n\nexport interface IGLTFObjectModelTreeMeshesObject {}\n\nexport interface IGLTFObjectModelTreeExtensionsObject {\n    KHR_lights_punctual: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IKHRLightsPunctual_Light, Light, Color3>;\n                intensity: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                range: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                spot: {\n                    innerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                    outerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_ies: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n        };\n    };\n    EXT_lights_image_based: {\n        lights: {\n            __array__: {\n                __target__: boolean;\n                intensity: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, number>;\n                rotation: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, Quaternion>;\n            };\n            length: IObjectAccessor<IEXTLightsImageBased_LightImageBased[], BaseTexture[], number>;\n        };\n    };\n}\n\nconst nodesTree: IGLTFObjectModelTreeNodesObject = {\n    length: {\n        type: \"number\",\n        get: (nodes: INode[]) => nodes.length,\n        getTarget: (nodes: INode[]) => nodes.map((node) => node._babylonTransformNode!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.position,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node: INode) => node._babylonTransformNode?.rotationQuaternion!,\n            set: (value: Quaternion, node: INode) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.scaling,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node: INode) => node._numMorphTargets,\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node: INode, index?: number) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node: INode, index?: number) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node: INode) => Matrix.Compose(node._babylonTransformNode?.scaling!, node._babylonTransformNode?.rotationQuaternion!, node._babylonTransformNode?.position!),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node: INode) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate =\n                    node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                } else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node: INode) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n            KHR_node_visibility: {\n                visible: {\n                    type: \"boolean\",\n                    get: (node: INode) => {\n                        return node._primitiveBabylonMeshes ? node._primitiveBabylonMeshes[0].isVisible : false;\n                    },\n                    getTarget: () => undefined, // TODO: what should this return?\n                    set: (value: boolean, node: INode) => {\n                        if (node._primitiveBabylonMeshes) {\n                            node._primitiveBabylonMeshes.forEach((mesh) => (mesh.isVisible = value));\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations: IAnimation[]) => animations.length,\n        getTarget: (animations: IAnimation[]) => animations.map((animation) => animation._babylonAnimationGroup!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes: IMesh[]) => meshes.length,\n        getTarget: (meshes: IMesh[]) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst camerasTree: IGLTFObjectModelTreeCamerasObject = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera: ICamera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value: Vector2, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.fov,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\n\nconst materialsTree: IGLTFObjectModelTreeMaterialsObject = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value: Color3, material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value: number, material, index?, payload?) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value: number, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value: Color4, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture!.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst extensionsTree: IGLTFObjectModelTreeExtensionsObject = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.range,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.innerAngle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).innerAngle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.angle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).angle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture!),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\n\nfunction GetTexture(material: IMaterial, payload: any, textureType: keyof PBRMaterial, textureInObject?: string) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material: IMaterial, _index?: number, payload?: any) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial as PBRMaterial;\n}\nfunction GenerateTextureMap(textureType: keyof PBRMaterial, textureInObject?: string): ITextureDefinition {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index?, payload?) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\n\nconst objectModelMapping: IGLTFObjectModelTree = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf: IGLTF) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key: string): IObjectAccessor | undefined {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key: string, interpolation?: IInterpolationPropertyInfo[]): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        (current as IObjectAccessor).interpolation = interpolation;\n    }\n}\n\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any>(\n    key: string,\n    accessor: IObjectAccessor<GLTFTargetType, BabylonTargetType, BabylonValueType>\n): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n", "import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { SetInterpolationForKey } from \"./Extensions/objectModelMapping\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(\r\n        public readonly type: number,\r\n        public readonly name: string,\r\n        public readonly getValue: GetValueFn,\r\n        public readonly getStride: (target: any) => number\r\n    ) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode!, babylonAnimation: this._buildAnimation(name, fps, keys) });\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    }))\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/nodes/{}/translation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/rotation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)]);\r\nSetInterpolationForKey(\"/nodes/{}/scale\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/weights\", [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)]);\r\n"],
  "mappings": "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",
  "names": []
}
