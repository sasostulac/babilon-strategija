{
  "version": 3,
  "sources": ["../../../dev/core/src/PostProcesses/thinPassPostProcess.ts", "../../../dev/core/src/PostProcesses/passPostProcess.ts", "../../../dev/core/src/Misc/textureTools.ts"],
  "sourcesContent": ["import type { Nullable, EffectWrapperCreationOptions, AbstractEngine } from \"core/index\";\r\nimport { EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport { Engine } from \"../Engines/engine\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class ThinPassPostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"pass\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/pass.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/pass.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Constructs a new pass post process\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        const localOptions: EffectWrapperCreationOptions = {\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassPostProcess.FragmentUrl,\r\n            ...options,\r\n        };\r\n\r\n        if (!localOptions.engine) {\r\n            localOptions.engine = Engine.LastCreatedEngine!;\r\n        }\r\n\r\n        super(localOptions);\r\n    }\r\n}\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class ThinPassCubePostProcess extends EffectWrapper {\r\n    /**\r\n     * The fragment shader url\r\n     */\r\n    public static readonly FragmentUrl = \"passCube\";\r\n\r\n    protected override _gatherImports(useWebGPU: boolean, list: Promise<any>[]) {\r\n        if (useWebGPU) {\r\n            this._webGPUReady = true;\r\n            list.push(Promise.all([import(\"../ShadersWGSL/passCube.fragment\")]));\r\n        } else {\r\n            list.push(Promise.all([import(\"../Shaders/passCube.fragment\")]));\r\n        }\r\n\r\n        super._gatherImports(useWebGPU, list);\r\n    }\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name Name of the effect\r\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\r\n     * @param options Options to configure the effect\r\n     */\r\n    constructor(name: string, engine: Nullable<AbstractEngine> = null, options?: EffectWrapperCreationOptions) {\r\n        super({\r\n            ...options,\r\n            name,\r\n            engine: engine || Engine.LastCreatedEngine!,\r\n            useShaderStore: true,\r\n            useAsPostProcess: true,\r\n            fragmentShader: ThinPassCubePostProcess.FragmentUrl,\r\n            defines: \"#define POSITIVEX\",\r\n        });\r\n    }\r\n\r\n    private _face = 0;\r\n\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    public get face(): number {\r\n        return this._face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        if (value < 0 || value > 5) {\r\n            return;\r\n        }\r\n\r\n        this._face = value;\r\n        switch (this._face) {\r\n            case 0:\r\n                this.updateEffect(\"#define POSITIVEX\");\r\n                break;\r\n            case 1:\r\n                this.updateEffect(\"#define NEGATIVEX\");\r\n                break;\r\n            case 2:\r\n                this.updateEffect(\"#define POSITIVEY\");\r\n                break;\r\n            case 3:\r\n                this.updateEffect(\"#define NEGATIVEY\");\r\n                break;\r\n            case 4:\r\n                this.updateEffect(\"#define POSITIVEZ\");\r\n                break;\r\n            case 5:\r\n                this.updateEffect(\"#define NEGATIVEZ\");\r\n                break;\r\n        }\r\n    }\r\n}\r\n", "import type { Nullable } from \"../types\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { PostProcessOptions } from \"./postProcess\";\r\nimport { PostProcess } from \"./postProcess\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\n\r\nimport type { Scene } from \"../scene\";\r\nimport { ThinPassCubePostProcess, ThinPassPostProcess } from \"./thinPassPostProcess\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\n\r\n/**\r\n * PassPostProcess which produces an output the same as it's input\r\n */\r\nexport class PassPostProcess extends PostProcess {\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassPostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassPostProcess\";\r\n    }\r\n\r\n    /**\r\n     * Creates the PassPostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassPostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassPostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.PassPostProcess\", PassPostProcess);\r\n\r\n/**\r\n * PassCubePostProcess which produces an output the same as it's input (which must be a cube texture)\r\n */\r\nexport class PassCubePostProcess extends PostProcess {\r\n    /**\r\n     * Gets or sets the cube face to display.\r\n     *  * 0 is +X\r\n     *  * 1 is -X\r\n     *  * 2 is +Y\r\n     *  * 3 is -Y\r\n     *  * 4 is +Z\r\n     *  * 5 is -Z\r\n     */\r\n    @serialize()\r\n    public get face(): number {\r\n        return this._effectWrapper.face;\r\n    }\r\n\r\n    public set face(value: number) {\r\n        this._effectWrapper.face = value;\r\n    }\r\n\r\n    /**\r\n     * Gets a string identifying the name of the class\r\n     * @returns \"PassCubePostProcess\" string\r\n     */\r\n    public override getClassName(): string {\r\n        return \"PassCubePostProcess\";\r\n    }\r\n\r\n    protected override _effectWrapper: ThinPassCubePostProcess;\r\n\r\n    /**\r\n     * Creates the PassCubePostProcess\r\n     * @param name The name of the effect.\r\n     * @param options The required width/height ratio to downsize to before computing the render pass.\r\n     * @param camera The camera to apply the render pass to.\r\n     * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)\r\n     * @param engine The engine which the post process will be applied. (default: current engine)\r\n     * @param reusable If the post process can be reused on the same frame. (default: false)\r\n     * @param textureType The type of texture to be used when performing the post processing.\r\n     * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)\r\n     */\r\n    constructor(\r\n        name: string,\r\n        options: number | PostProcessOptions,\r\n        camera: Nullable<Camera> = null,\r\n        samplingMode?: number,\r\n        engine?: AbstractEngine,\r\n        reusable?: boolean,\r\n        textureType: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        blockCompilation = false\r\n    ) {\r\n        const localOptions = {\r\n            size: typeof options === \"number\" ? options : undefined,\r\n            camera,\r\n            samplingMode,\r\n            engine,\r\n            reusable,\r\n            textureType,\r\n            blockCompilation,\r\n            ...(options as PostProcessOptions),\r\n        };\r\n\r\n        super(name, ThinPassPostProcess.FragmentUrl, {\r\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinPassCubePostProcess(name, engine, localOptions) : undefined,\r\n            ...localOptions,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static override _Parse(parsedPostProcess: any, targetCamera: Camera, scene: Scene, rootUrl: string) {\r\n        return SerializationHelper.Parse(\r\n            () => {\r\n                return new PassCubePostProcess(\r\n                    parsedPostProcess.name,\r\n                    parsedPostProcess.options,\r\n                    targetCamera,\r\n                    parsedPostProcess.renderTargetSamplingMode,\r\n                    parsedPostProcess._engine,\r\n                    parsedPostProcess.reusable\r\n                );\r\n            },\r\n            parsedPostProcess,\r\n            scene,\r\n            rootUrl\r\n        );\r\n    }\r\n}\r\n\r\nAbstractEngine._RescalePostProcessFactory = (engine: AbstractEngine) => {\r\n    return new PassPostProcess(\"rescale\", 1, null, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, engine, false, Constants.TEXTURETYPE_UNSIGNED_BYTE);\r\n};\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { InternalTexture } from \"../Materials/Textures/internalTexture\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { PassPostProcess } from \"../PostProcesses/passPostProcess\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport type { Observable } from \"./observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\n\r\n/**\r\n * Uses the GPU to create a copy texture rescaled at a given size\r\n * @param texture Texture to copy from\r\n * @param width defines the desired width\r\n * @param height defines the desired height\r\n * @param useBilinearMode defines if bilinear mode has to be used\r\n * @returns the generated texture\r\n */\r\nexport function CreateResizedCopy(texture: Texture, width: number, height: number, useBilinearMode: boolean = true): Texture {\r\n    const scene = <Scene>texture.getScene();\r\n    const engine = scene.getEngine();\r\n\r\n    const rtt = new RenderTargetTexture(\r\n        \"resized\" + texture.name,\r\n        { width: width, height: height },\r\n        scene,\r\n        !texture.noMipmap,\r\n        true,\r\n        (<InternalTexture>texture._texture).type,\r\n        false,\r\n        texture.samplingMode,\r\n        false\r\n    );\r\n\r\n    rtt.wrapU = texture.wrapU;\r\n    rtt.wrapV = texture.wrapV;\r\n    rtt.uOffset = texture.uOffset;\r\n    rtt.vOffset = texture.vOffset;\r\n    rtt.uScale = texture.uScale;\r\n    rtt.vScale = texture.vScale;\r\n    rtt.uAng = texture.uAng;\r\n    rtt.vAng = texture.vAng;\r\n    rtt.wAng = texture.wAng;\r\n    rtt.coordinatesIndex = texture.coordinatesIndex;\r\n    rtt.level = texture.level;\r\n    rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;\r\n    (<InternalTexture>rtt._texture).isReady = false;\r\n\r\n    texture.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n    texture.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n\r\n    const passPostProcess = new PassPostProcess(\r\n        \"pass\",\r\n        1,\r\n        null,\r\n        useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE,\r\n        engine,\r\n        false,\r\n        Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n    );\r\n    passPostProcess.externalTextureSamplerBinding = true;\r\n    passPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n        e.executeWhenCompiled(() => {\r\n            passPostProcess.onApply = function (effect) {\r\n                effect.setTexture(\"textureSampler\", texture);\r\n            };\r\n\r\n            const internalTexture = rtt.renderTarget;\r\n\r\n            if (internalTexture) {\r\n                scene.postProcessManager.directRender([passPostProcess], internalTexture);\r\n\r\n                engine.unBindFramebuffer(internalTexture);\r\n                rtt.disposeFramebufferObjects();\r\n                passPostProcess.dispose();\r\n\r\n                rtt.getInternalTexture()!.isReady = true;\r\n            }\r\n        });\r\n    });\r\n\r\n    return rtt;\r\n}\r\n\r\n/**\r\n * Apply a post process to a texture\r\n * @param postProcessName name of the fragment post process\r\n * @param internalTexture the texture to encode\r\n * @param scene the scene hosting the texture\r\n * @param type type of the output texture. If not provided, use the one from internalTexture\r\n * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n * @param format format of the output texture. If not provided, use the one from internalTexture\r\n * @param width width of the output texture. If not provided, use the one from internalTexture\r\n * @param height height of the output texture. If not provided, use the one from internalTexture\r\n * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n */\r\n// eslint-disable-next-line @typescript-eslint/promise-function-async\r\nexport function ApplyPostProcess(\r\n    postProcessName: string,\r\n    internalTexture: InternalTexture,\r\n    scene: Scene,\r\n    type?: number,\r\n    samplingMode?: number,\r\n    format?: number,\r\n    width?: number,\r\n    height?: number\r\n): Promise<InternalTexture> {\r\n    // Gets everything ready.\r\n    const engine = internalTexture.getEngine();\r\n\r\n    internalTexture.isReady = false;\r\n\r\n    samplingMode = samplingMode ?? internalTexture.samplingMode;\r\n    type = type ?? internalTexture.type;\r\n    format = format ?? internalTexture.format;\r\n    width = width ?? internalTexture.width;\r\n    height = height ?? internalTexture.height;\r\n\r\n    if (type === -1) {\r\n        type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        // Create the post process\r\n        const postProcess = new PostProcess(\"postprocess\", postProcessName, null, null, 1, null, samplingMode, engine, false, undefined, type, undefined, null, false, format);\r\n        postProcess.externalTextureSamplerBinding = true;\r\n\r\n        // Hold the output of the decoding.\r\n        const encodedTexture = engine.createRenderTargetTexture(\r\n            { width: width, height: height },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: false,\r\n                generateStencilBuffer: false,\r\n                samplingMode,\r\n                type,\r\n                format,\r\n            }\r\n        );\r\n\r\n        postProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                // PP Render Pass\r\n                postProcess.onApply = (effect) => {\r\n                    effect._bindTexture(\"textureSampler\", internalTexture);\r\n                    effect.setFloat2(\"scale\", 1, 1);\r\n                };\r\n                scene.postProcessManager.directRender([postProcess], encodedTexture, true);\r\n\r\n                // Cleanup\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._releaseTexture(internalTexture);\r\n                if (postProcess) {\r\n                    postProcess.dispose();\r\n                }\r\n\r\n                // Internal Swap\r\n                encodedTexture._swapAndDie(internalTexture);\r\n\r\n                // Ready to get rolling again.\r\n                internalTexture.type = type!;\r\n                internalTexture.format = Constants.TEXTUREFORMAT_RGBA;\r\n                internalTexture.isReady = true;\r\n\r\n                resolve(internalTexture);\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n// ref: http://stackoverflow.com/questions/32633585/how-do-you-convert-to-half-floats-in-javascript\r\nlet floatView: Float32Array;\r\nlet int32View: Int32Array;\r\n/**\r\n * Converts a number to half float\r\n * @param value number to convert\r\n * @returns converted number\r\n */\r\nexport function ToHalfFloat(value: number): number {\r\n    if (!floatView) {\r\n        floatView = new Float32Array(1);\r\n        int32View = new Int32Array(floatView.buffer);\r\n    }\r\n\r\n    floatView[0] = value;\r\n    const x = int32View[0];\r\n\r\n    let bits = (x >> 16) & 0x8000; /* Get the sign */\r\n    let m = (x >> 12) & 0x07ff; /* Keep one extra bit for rounding */\r\n    const e = (x >> 23) & 0xff; /* Using int is faster here */\r\n\r\n    /* If zero, or denormal, or exponent underflows too much for a denormal\r\n     * half, return signed zero. */\r\n    if (e < 103) {\r\n        return bits;\r\n    }\r\n\r\n    /* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\r\n    if (e > 142) {\r\n        bits |= 0x7c00;\r\n        /* If exponent was 0xff and one mantissa bit was set, it means NaN,\r\n         * not Inf, so make sure we set one mantissa bit too. */\r\n        bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\r\n        return bits;\r\n    }\r\n\r\n    /* If exponent underflows but not too much, return a denormal */\r\n    if (e < 113) {\r\n        m |= 0x0800;\r\n        /* Extra rounding may overflow and set mantissa to 0 and exponent\r\n         * to 1, which is OK. */\r\n        bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\r\n        return bits;\r\n    }\r\n\r\n    bits |= ((e - 112) << 10) | (m >> 1);\r\n    bits += m & 1;\r\n    return bits;\r\n}\r\n\r\n/**\r\n * Converts a half float to a number\r\n * @param value half float to convert\r\n * @returns converted half float\r\n */\r\nexport function FromHalfFloat(value: number): number {\r\n    const s = (value & 0x8000) >> 15;\r\n    const e = (value & 0x7c00) >> 10;\r\n    const f = value & 0x03ff;\r\n\r\n    if (e === 0) {\r\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\r\n    } else if (e == 0x1f) {\r\n        return f ? NaN : (s ? -1 : 1) * Infinity;\r\n    }\r\n\r\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\r\n}\r\n\r\nfunction IsCompressedTextureFormat(format: number): boolean {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Waits for when the given texture is ready to be used (downloaded, converted, mip mapped...)\r\n * @param texture the texture to wait for\r\n * @returns a promise that resolves when the texture is ready\r\n */\r\nexport async function WhenTextureReadyAsync(texture: BaseTexture): Promise<void> {\r\n    if (texture.isReady()) {\r\n        return;\r\n    }\r\n\r\n    if (texture.loadingError) {\r\n        throw new Error(texture.errorObject?.message || `Texture ${texture.name} errored while loading.`);\r\n    }\r\n\r\n    const onLoadObservable = (texture as any).onLoadObservable as Observable<BaseTexture>;\r\n    if (onLoadObservable) {\r\n        return await new Promise((res) => onLoadObservable.addOnce(() => res()));\r\n    }\r\n\r\n    const onLoadedObservable = texture._texture?.onLoadedObservable;\r\n    if (onLoadedObservable) {\r\n        return await new Promise((res) => onLoadedObservable.addOnce(() => res()));\r\n    }\r\n\r\n    throw new Error(`Cannot determine readiness of texture ${texture.name}.`);\r\n}\r\n\r\n/**\r\n * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format, which cannot be read using readPixels.\r\n * @internal\r\n */\r\nasync function ReadPixelsUsingRTT(texture: BaseTexture, width: number, height: number, face: number, lod: number): Promise<Uint8Array> {\r\n    const scene = texture.getScene()!;\r\n    const engine = scene.getEngine();\r\n\r\n    if (!engine.isWebGPU) {\r\n        if (texture.isCube) {\r\n            await import(\"../Shaders/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/lod.fragment\");\r\n        }\r\n    } else {\r\n        if (texture.isCube) {\r\n            await import(\"../ShadersWGSL/lodCube.fragment\");\r\n        } else {\r\n            await import(\"../ShadersWGSL/lod.fragment\");\r\n        }\r\n    }\r\n\r\n    let lodPostProcess: PostProcess;\r\n\r\n    if (!texture.isCube) {\r\n        lodPostProcess = new PostProcess(\"lod\", \"lod\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    } else {\r\n        const faceDefines = [\"#define POSITIVEX\", \"#define NEGATIVEX\", \"#define POSITIVEY\", \"#define NEGATIVEY\", \"#define POSITIVEZ\", \"#define NEGATIVEZ\"];\r\n        lodPostProcess = new PostProcess(\"lodCube\", \"lodCube\", {\r\n            uniforms: [\"lod\", \"gamma\"],\r\n            samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,\r\n            engine,\r\n            defines: faceDefines[face],\r\n            shaderLanguage: engine.isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\r\n        });\r\n    }\r\n\r\n    await new Promise((resolve) => {\r\n        lodPostProcess.onEffectCreatedObservable.addOnce((e) => {\r\n            e.executeWhenCompiled(() => {\r\n                resolve(0);\r\n            });\r\n        });\r\n    });\r\n\r\n    const rtt = new RenderTargetTexture(\"temp\", { width: width, height: height }, scene, false);\r\n\r\n    lodPostProcess.onApply = function (effect) {\r\n        effect.setTexture(\"textureSampler\", texture);\r\n        effect.setFloat(\"lod\", lod);\r\n        effect.setInt(\"gamma\", texture.gammaSpace ? 1 : 0);\r\n    };\r\n\r\n    const internalTexture = texture.getInternalTexture();\r\n\r\n    try {\r\n        if (rtt.renderTarget && internalTexture) {\r\n            const samplingMode = internalTexture.samplingMode;\r\n            if (lod !== 0) {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);\r\n            } else {\r\n                texture.updateSamplingMode(Texture.NEAREST_NEAREST);\r\n            }\r\n\r\n            scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);\r\n            texture.updateSamplingMode(samplingMode);\r\n\r\n            //Reading datas from WebGL\r\n            const bufferView = await engine.readPixels(0, 0, width, height);\r\n            const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);\r\n\r\n            // Unbind\r\n            engine.unBindFramebuffer(rtt.renderTarget);\r\n\r\n            return data;\r\n        } else {\r\n            throw Error(\"Render to texture failed.\");\r\n        }\r\n    } finally {\r\n        rtt.dispose();\r\n        lodPostProcess.dispose();\r\n    }\r\n}\r\n\r\n/**\r\n * Gets the pixel data of the specified texture, either by reading it directly\r\n * or by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n * This is convenient to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n * @param texture the source texture\r\n * @param width the target width of the result, which does not have to match the source texture width\r\n * @param height the target height of the result, which does not have to match the source texture height\r\n * @param face if the texture has multiple faces, the face index to use for the source\r\n * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n * @returns the 8-bit texture data\r\n */\r\nexport async function GetTextureDataAsync(texture: BaseTexture, width?: number, height?: number, face: number = 0, lod: number = 0): Promise<Uint8Array> {\r\n    await WhenTextureReadyAsync(texture);\r\n\r\n    const { width: textureWidth, height: textureHeight } = texture.getSize();\r\n    const targetWidth = width ?? textureWidth;\r\n    const targetHeight = height ?? textureHeight;\r\n\r\n    // If the internal texture format is compressed, we cannot read the pixels directly.\r\n    // Or, if we're resizing the texture, we need to use a render target texture.\r\n    if (IsCompressedTextureFormat(texture.textureFormat) || targetWidth !== textureWidth || targetHeight !== textureHeight) {\r\n        return await ReadPixelsUsingRTT(texture, targetWidth, targetHeight, face, lod);\r\n    }\r\n\r\n    let data = (await texture.readPixels(face, lod)) as Nullable<Uint8Array | Float32Array>;\r\n    if (!data) {\r\n        throw new Error(`Failed to read pixels from texture ${texture.name}.`);\r\n    }\r\n\r\n    // Convert float RGBA values to uint8, if necessary.\r\n    if (data instanceof Float32Array) {\r\n        const data2 = new Uint8Array(data.length);\r\n        let n = data.length;\r\n        while (n--) {\r\n            const v = data[n];\r\n            data2[n] = Math.round(Clamp(v) * 255);\r\n        }\r\n        data = data2;\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * Class used to host texture specific utilities\r\n */\r\nexport const TextureTools = {\r\n    /**\r\n     * Uses the GPU to create a copy texture rescaled at a given size\r\n     * @param texture Texture to copy from\r\n     * @param width defines the desired width\r\n     * @param height defines the desired height\r\n     * @param useBilinearMode defines if bilinear mode has to be used\r\n     * @returns the generated texture\r\n     */\r\n    CreateResizedCopy,\r\n\r\n    /**\r\n     * Apply a post process to a texture\r\n     * @param postProcessName name of the fragment post process\r\n     * @param internalTexture the texture to encode\r\n     * @param scene the scene hosting the texture\r\n     * @param type type of the output texture. If not provided, use the one from internalTexture\r\n     * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture\r\n     * @param format format of the output texture. If not provided, use the one from internalTexture\r\n     * @returns a promise with the internalTexture having its texture replaced by the result of the processing\r\n     */\r\n    ApplyPostProcess,\r\n    /**\r\n     * Converts a number to half float\r\n     * @param value number to convert\r\n     * @returns converted number\r\n     */\r\n    ToHalfFloat,\r\n\r\n    /**\r\n     * Converts a half float to a number\r\n     * @param value half float to convert\r\n     * @returns converted half float\r\n     */\r\n    FromHalfFloat,\r\n\r\n    /**\r\n     * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.\r\n     * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.\r\n     * @param texture the source texture\r\n     * @param width the width of the result, which does not have to match the source texture width\r\n     * @param height the height of the result, which does not have to match the source texture height\r\n     * @param face if the texture has multiple faces, the face index to use for the source\r\n     * @param lod if the texture has multiple LODs, the lod index to use for the source\r\n     * @returns the 8-bit texture data\r\n     */\r\n    GetTextureDataAsync,\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
