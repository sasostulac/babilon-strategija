import {
  LoadImage
} from "./chunk-3HK5Y47I.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  AbstractEngine,
  InternalTexture,
  _GetCompatibleTextureLoader
} from "./chunk-OF4ZSZ6U.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Misc/urlTools.js
function GetExtensionFromUrl(url) {
  const urlWithoutUriParams = url.split("?")[0];
  const lastDot = urlWithoutUriParams.lastIndexOf(".");
  const extension = lastDot > -1 ? urlWithoutUriParams.substring(lastDot).toLowerCase() : "";
  return extension;
}

// node_modules/@babylonjs/core/Engines/AbstractEngine/abstractEngine.cubeTexture.js
AbstractEngine.prototype._partialLoadFile = function(url, index, loadedFiles, onfinish, onErrorCallBack = null) {
  const onload = (data) => {
    loadedFiles[index] = data;
    loadedFiles._internalCount++;
    if (loadedFiles._internalCount === 6) {
      onfinish(loadedFiles);
    }
  };
  const onerror = (request, exception) => {
    if (onErrorCallBack && request) {
      onErrorCallBack(request.status + " " + request.statusText, exception);
    }
  };
  this._loadFile(url, onload, void 0, void 0, true, onerror);
};
AbstractEngine.prototype._cascadeLoadFiles = function(scene, onfinish, files, onError = null) {
  const loadedFiles = [];
  loadedFiles._internalCount = 0;
  for (let index = 0; index < 6; index++) {
    this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
  }
};
AbstractEngine.prototype._cascadeLoadImgs = function(scene, texture, onfinish, files, onError = null, mimeType) {
  const loadedImages = [];
  loadedImages._internalCount = 0;
  for (let index = 0; index < 6; index++) {
    this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);
  }
};
AbstractEngine.prototype._partialLoadImg = function(url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {
  const tokenPendingData = RandomGUID();
  const onload = (img) => {
    loadedImages[index] = img;
    loadedImages._internalCount++;
    if (scene) {
      scene.removePendingData(tokenPendingData);
    }
    if (loadedImages._internalCount === 6 && onfinish) {
      onfinish(texture, loadedImages);
    }
  };
  const onerror = (message, exception) => {
    if (scene) {
      scene.removePendingData(tokenPendingData);
    }
    if (onErrorCallBack) {
      onErrorCallBack(message, exception);
    }
  };
  LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
  if (scene) {
    scene.addPendingData(tokenPendingData);
  }
};
AbstractEngine.prototype.createCubeTextureBase = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false, buffer = null) {
  const texture = fallback ? fallback : new InternalTexture(
    this,
    7
    /* InternalTextureSource.Cube */
  );
  texture.isCube = true;
  texture.url = rootUrl;
  texture.generateMipMaps = !noMipmap;
  texture._lodGenerationScale = lodScale;
  texture._lodGenerationOffset = lodOffset;
  texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.version > 1 || this.isWebGPU || !!noMipmap);
  if (texture !== fallback) {
    texture.label = rootUrl.substring(0, 60);
  }
  if (!this._doNotHandleContextLost) {
    texture._extension = forcedExtension;
    texture._files = files;
    texture._buffer = buffer;
  }
  const originalRootUrl = rootUrl;
  if (this._transformTextureUrl && !fallback) {
    rootUrl = this._transformTextureUrl(rootUrl);
  }
  const extension = forcedExtension ?? GetExtensionFromUrl(rootUrl);
  const loaderPromise = _GetCompatibleTextureLoader(extension);
  const localOnError = (message, exception) => {
    texture.dispose();
    if (onError) {
      onError(message, exception);
    } else if (message) {
      Logger.Warn(message);
    }
  };
  const onInternalError = (request, exception) => {
    if (rootUrl === originalRootUrl) {
      if (request) {
        localOnError(request.status + " " + request.statusText, exception);
      }
    } else {
      Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);
      this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, localOnError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer, buffer);
    }
  };
  if (loaderPromise) {
    loaderPromise.then((loader) => {
      const onLoadData = (data) => {
        if (beforeLoadCubeDataCallback) {
          beforeLoadCubeDataCallback(texture, data);
        }
        loader.loadCubeData(data, texture, createPolynomials, onLoad, (message, exception) => {
          localOnError(message, exception);
        });
      };
      if (buffer) {
        onLoadData(buffer);
      } else if (files && files.length === 6) {
        if (loader.supportCascades) {
          this._cascadeLoadFiles(scene, (images) => onLoadData(images.map((image) => new Uint8Array(image))), files, localOnError);
        } else {
          localOnError("Textures type does not support cascades.");
        }
      } else {
        this._loadFile(rootUrl, (data) => onLoadData(new Uint8Array(data)), void 0, scene ? scene.offlineProvider || null : void 0, true, onInternalError);
      }
    });
  } else {
    if (!files || files.length === 0) {
      throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");
    }
    this._cascadeLoadImgs(scene, texture, (texture2, imgs) => {
      if (imageHandler) {
        imageHandler(texture2, imgs);
      }
    }, files, localOnError);
  }
  this._internalTexturesCache.push(texture);
  return texture;
};

export {
  GetExtensionFromUrl
};
//# sourceMappingURL=chunk-2BY6AA4I.js.map
