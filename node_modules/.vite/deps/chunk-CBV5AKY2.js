import {
  Engine,
  PostProcess,
  RenderTargetTexture
} from "./chunk-X4TNHLCS.js";
import {
  Texture
} from "./chunk-IKA6V2KA.js";
import {
  SerializationHelper
} from "./chunk-S6GWJ2HV.js";
import {
  __decorate,
  serialize
} from "./chunk-URVCX2UN.js";
import {
  EffectWrapper
} from "./chunk-SMWNVZJL.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  AbstractEngine
} from "./chunk-OF4ZSZ6U.js";
import {
  Clamp
} from "./chunk-QCCD6NMF.js";

// node_modules/@babylonjs/core/PostProcesses/thinPassPostProcess.js
var ThinPassPostProcess = class _ThinPassPostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(Promise.all([import("./pass.fragment-SEWSX62O.js")]));
    } else {
      list.push(Promise.all([import("./pass.fragment-5HHADSLF.js")]));
    }
    super._gatherImports(useWebGPU, list);
  }
  /**
   * Constructs a new pass post process
   * @param name Name of the effect
   * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
   * @param options Options to configure the effect
   */
  constructor(name, engine = null, options) {
    const localOptions = {
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinPassPostProcess.FragmentUrl,
      ...options
    };
    if (!localOptions.engine) {
      localOptions.engine = Engine.LastCreatedEngine;
    }
    super(localOptions);
  }
};
ThinPassPostProcess.FragmentUrl = "pass";
var ThinPassCubePostProcess = class _ThinPassCubePostProcess extends EffectWrapper {
  _gatherImports(useWebGPU, list) {
    if (useWebGPU) {
      this._webGPUReady = true;
      list.push(Promise.all([import("./passCube.fragment-FBK4KLVN.js")]));
    } else {
      list.push(Promise.all([import("./passCube.fragment-YRC54QZC.js")]));
    }
    super._gatherImports(useWebGPU, list);
  }
  /**
   * Creates the PassCubePostProcess
   * @param name Name of the effect
   * @param engine Engine to use to render the effect. If not provided, the last created engine will be used
   * @param options Options to configure the effect
   */
  constructor(name, engine = null, options) {
    super({
      ...options,
      name,
      engine: engine || Engine.LastCreatedEngine,
      useShaderStore: true,
      useAsPostProcess: true,
      fragmentShader: _ThinPassCubePostProcess.FragmentUrl,
      defines: "#define POSITIVEX"
    });
    this._face = 0;
  }
  /**
   * Gets or sets the cube face to display.
   *  * 0 is +X
   *  * 1 is -X
   *  * 2 is +Y
   *  * 3 is -Y
   *  * 4 is +Z
   *  * 5 is -Z
   */
  get face() {
    return this._face;
  }
  set face(value) {
    if (value < 0 || value > 5) {
      return;
    }
    this._face = value;
    switch (this._face) {
      case 0:
        this.updateEffect("#define POSITIVEX");
        break;
      case 1:
        this.updateEffect("#define NEGATIVEX");
        break;
      case 2:
        this.updateEffect("#define POSITIVEY");
        break;
      case 3:
        this.updateEffect("#define NEGATIVEY");
        break;
      case 4:
        this.updateEffect("#define POSITIVEZ");
        break;
      case 5:
        this.updateEffect("#define NEGATIVEZ");
        break;
    }
  }
};
ThinPassCubePostProcess.FragmentUrl = "passCube";

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess = class _PassPostProcess extends PostProcess {
  /**
   * Gets a string identifying the name of the class
   * @returns "PassPostProcess" string
   */
  getClassName() {
    return "PassPostProcess";
  }
  /**
   * Creates the PassPostProcess
   * @param name The name of the effect.
   * @param options The required width/height ratio to downsize to before computing the render pass.
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType The type of texture to be used when performing the post processing.
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   */
  constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    const localOptions = {
      size: typeof options === "number" ? options : void 0,
      camera,
      samplingMode,
      engine,
      reusable,
      textureType,
      blockCompilation,
      ...options
    };
    super(name, ThinPassPostProcess.FragmentUrl, {
      effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinPassPostProcess(name, engine, localOptions) : void 0,
      ...localOptions
    });
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _PassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
RegisterClass("BABYLON.PassPostProcess", PassPostProcess);
var PassCubePostProcess = class _PassCubePostProcess extends PostProcess {
  /**
   * Gets or sets the cube face to display.
   *  * 0 is +X
   *  * 1 is -X
   *  * 2 is +Y
   *  * 3 is -Y
   *  * 4 is +Z
   *  * 5 is -Z
   */
  get face() {
    return this._effectWrapper.face;
  }
  set face(value) {
    this._effectWrapper.face = value;
  }
  /**
   * Gets a string identifying the name of the class
   * @returns "PassCubePostProcess" string
   */
  getClassName() {
    return "PassCubePostProcess";
  }
  /**
   * Creates the PassCubePostProcess
   * @param name The name of the effect.
   * @param options The required width/height ratio to downsize to before computing the render pass.
   * @param camera The camera to apply the render pass to.
   * @param samplingMode The sampling mode to be used when computing the pass. (default: 0)
   * @param engine The engine which the post process will be applied. (default: current engine)
   * @param reusable If the post process can be reused on the same frame. (default: false)
   * @param textureType The type of texture to be used when performing the post processing.
   * @param blockCompilation If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)
   */
  constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
    const localOptions = {
      size: typeof options === "number" ? options : void 0,
      camera,
      samplingMode,
      engine,
      reusable,
      textureType,
      blockCompilation,
      ...options
    };
    super(name, ThinPassPostProcess.FragmentUrl, {
      effectWrapper: typeof options === "number" || !options.effectWrapper ? new ThinPassCubePostProcess(name, engine, localOptions) : void 0,
      ...localOptions
    });
  }
  /**
   * @internal
   */
  static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
    return SerializationHelper.Parse(() => {
      return new _PassCubePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
    }, parsedPostProcess, scene, rootUrl);
  }
};
__decorate([
  serialize()
], PassCubePostProcess.prototype, "face", null);
AbstractEngine._RescalePostProcessFactory = (engine) => {
  return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
};

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  const rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  const passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.onEffectCreatedObservable.addOnce((e) => {
    e.executeWhenCompiled(() => {
      passPostProcess.onApply = function(effect) {
        effect.setTexture("textureSampler", texture);
      };
      const internalTexture = rtt.renderTarget;
      if (internalTexture) {
        scene.postProcessManager.directRender([passPostProcess], internalTexture);
        engine.unBindFramebuffer(internalTexture);
        rtt.disposeFramebufferObjects();
        passPostProcess.dispose();
        rtt.getInternalTexture().isReady = true;
      }
    });
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
  const engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode ?? internalTexture.samplingMode;
  type = type ?? internalTexture.type;
  format = format ?? internalTexture.format;
  width = width ?? internalTexture.width;
  height = height ?? internalTexture.height;
  if (type === -1) {
    type = 0;
  }
  return new Promise((resolve) => {
    const postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    const encodedTexture = engine.createRenderTargetTexture({ width, height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.onEffectCreatedObservable.addOnce((e) => {
      e.executeWhenCompiled(() => {
        postProcess.onApply = (effect) => {
          effect._bindTexture("textureSampler", internalTexture);
          effect.setFloat2("scale", 1, 1);
        };
        scene.postProcessManager.directRender([postProcess], encodedTexture, true);
        engine.restoreDefaultFramebuffer();
        engine._releaseTexture(internalTexture);
        if (postProcess) {
          postProcess.dispose();
        }
        encodedTexture._swapAndDie(internalTexture);
        internalTexture.type = type;
        internalTexture.format = 5;
        internalTexture.isReady = true;
        resolve(internalTexture);
      });
    });
  });
}
var floatView;
var int32View;
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  const s = (value & 32768) >> 15;
  const e = (value & 31744) >> 10;
  const f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
function IsCompressedTextureFormat(format) {
  switch (format) {
    case 36492:
    case 36493:
    case 36495:
    case 36494:
    case 33779:
    case 35919:
    case 33778:
    case 35918:
    case 33777:
    case 33776:
    case 35917:
    case 35916:
    case 37808:
    case 37840:
    case 36196:
    case 37492:
    case 37493:
    case 37494:
    case 37495:
    case 37496:
    case 37497:
      return true;
    default:
      return false;
  }
}
async function WhenTextureReadyAsync(texture) {
  if (texture.isReady()) {
    return;
  }
  if (texture.loadingError) {
    throw new Error(texture.errorObject?.message || `Texture ${texture.name} errored while loading.`);
  }
  const onLoadObservable = texture.onLoadObservable;
  if (onLoadObservable) {
    return await new Promise((res) => onLoadObservable.addOnce(() => res()));
  }
  const onLoadedObservable = texture._texture?.onLoadedObservable;
  if (onLoadedObservable) {
    return await new Promise((res) => onLoadedObservable.addOnce(() => res()));
  }
  throw new Error(`Cannot determine readiness of texture ${texture.name}.`);
}
async function ReadPixelsUsingRTT(texture, width, height, face, lod) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  if (!engine.isWebGPU) {
    if (texture.isCube) {
      await import("./lodCube.fragment-M5CXHMQ3.js");
    } else {
      await import("./lod.fragment-DZ52BSID.js");
    }
  } else {
    if (texture.isCube) {
      await import("./lodCube.fragment-CMZGCZXF.js");
    } else {
      await import("./lod.fragment-XRIDMUOO.js");
    }
  }
  let lodPostProcess;
  if (!texture.isCube) {
    lodPostProcess = new PostProcess("lod", "lod", {
      uniforms: ["lod", "gamma"],
      samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,
      engine,
      shaderLanguage: engine.isWebGPU ? 1 : 0
    });
  } else {
    const faceDefines = ["#define POSITIVEX", "#define NEGATIVEX", "#define POSITIVEY", "#define NEGATIVEY", "#define POSITIVEZ", "#define NEGATIVEZ"];
    lodPostProcess = new PostProcess("lodCube", "lodCube", {
      uniforms: ["lod", "gamma"],
      samplingMode: Texture.NEAREST_NEAREST_MIPNEAREST,
      engine,
      defines: faceDefines[face],
      shaderLanguage: engine.isWebGPU ? 1 : 0
    });
  }
  await new Promise((resolve) => {
    lodPostProcess.onEffectCreatedObservable.addOnce((e) => {
      e.executeWhenCompiled(() => {
        resolve(0);
      });
    });
  });
  const rtt = new RenderTargetTexture("temp", { width, height }, scene, false);
  lodPostProcess.onApply = function(effect) {
    effect.setTexture("textureSampler", texture);
    effect.setFloat("lod", lod);
    effect.setInt("gamma", texture.gammaSpace ? 1 : 0);
  };
  const internalTexture = texture.getInternalTexture();
  try {
    if (rtt.renderTarget && internalTexture) {
      const samplingMode = internalTexture.samplingMode;
      if (lod !== 0) {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST_MIPNEAREST);
      } else {
        texture.updateSamplingMode(Texture.NEAREST_NEAREST);
      }
      scene.postProcessManager.directRender([lodPostProcess], rtt.renderTarget, true);
      texture.updateSamplingMode(samplingMode);
      const bufferView = await engine.readPixels(0, 0, width, height);
      const data = new Uint8Array(bufferView.buffer, 0, bufferView.byteLength);
      engine.unBindFramebuffer(rtt.renderTarget);
      return data;
    } else {
      throw Error("Render to texture failed.");
    }
  } finally {
    rtt.dispose();
    lodPostProcess.dispose();
  }
}
async function GetTextureDataAsync(texture, width, height, face = 0, lod = 0) {
  await WhenTextureReadyAsync(texture);
  const { width: textureWidth, height: textureHeight } = texture.getSize();
  const targetWidth = width ?? textureWidth;
  const targetHeight = height ?? textureHeight;
  if (IsCompressedTextureFormat(texture.textureFormat) || targetWidth !== textureWidth || targetHeight !== textureHeight) {
    return await ReadPixelsUsingRTT(texture, targetWidth, targetHeight, face, lod);
  }
  let data = await texture.readPixels(face, lod);
  if (!data) {
    throw new Error(`Failed to read pixels from texture ${texture.name}.`);
  }
  if (data instanceof Float32Array) {
    const data2 = new Uint8Array(data.length);
    let n = data.length;
    while (n--) {
      const v = data[n];
      data2[n] = Math.round(Clamp(v) * 255);
    }
    data = data2;
  }
  return data;
}
var TextureTools = {
  /**
   * Uses the GPU to create a copy texture rescaled at a given size
   * @param texture Texture to copy from
   * @param width defines the desired width
   * @param height defines the desired height
   * @param useBilinearMode defines if bilinear mode has to be used
   * @returns the generated texture
   */
  CreateResizedCopy,
  /**
   * Apply a post process to a texture
   * @param postProcessName name of the fragment post process
   * @param internalTexture the texture to encode
   * @param scene the scene hosting the texture
   * @param type type of the output texture. If not provided, use the one from internalTexture
   * @param samplingMode sampling mode to use to sample the source texture. If not provided, use the one from internalTexture
   * @param format format of the output texture. If not provided, use the one from internalTexture
   * @returns a promise with the internalTexture having its texture replaced by the result of the processing
   */
  ApplyPostProcess,
  /**
   * Converts a number to half float
   * @param value number to convert
   * @returns converted number
   */
  ToHalfFloat,
  /**
   * Converts a half float to a number
   * @param value half float to convert
   * @returns converted half float
   */
  FromHalfFloat,
  /**
   * Gets the data of the specified texture by rendering it to an intermediate RGBA texture and retrieving the bytes from it.
   * This is convienent to get 8-bit RGBA values for a texture in a GPU compressed format.
   * @param texture the source texture
   * @param width the width of the result, which does not have to match the source texture width
   * @param height the height of the result, which does not have to match the source texture height
   * @param face if the texture has multiple faces, the face index to use for the source
   * @param lod if the texture has multiple LODs, the lod index to use for the source
   * @returns the 8-bit texture data
   */
  GetTextureDataAsync
};

export {
  ThinPassPostProcess,
  ThinPassCubePostProcess,
  PassPostProcess,
  PassCubePostProcess,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  WhenTextureReadyAsync,
  GetTextureDataAsync,
  TextureTools
};
//# sourceMappingURL=chunk-CBV5AKY2.js.map
