import {
  LightConstants
} from "./chunk-WAGTS43G.js";
import {
  Texture
} from "./chunk-IKA6V2KA.js";
import {
  AbstractEngine
} from "./chunk-OF4ZSZ6U.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js
function AddClipPlaneUniforms(uniforms) {
  if (uniforms.indexOf("vClipPlane") === -1) {
    uniforms.push("vClipPlane");
  }
  if (uniforms.indexOf("vClipPlane2") === -1) {
    uniforms.push("vClipPlane2");
  }
  if (uniforms.indexOf("vClipPlane3") === -1) {
    uniforms.push("vClipPlane3");
  }
  if (uniforms.indexOf("vClipPlane4") === -1) {
    uniforms.push("vClipPlane4");
  }
  if (uniforms.indexOf("vClipPlane5") === -1) {
    uniforms.push("vClipPlane5");
  }
  if (uniforms.indexOf("vClipPlane6") === -1) {
    uniforms.push("vClipPlane6");
  }
}
function PrepareStringDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);
  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);
  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);
  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);
  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);
  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);
  if (clipPlane) {
    defines.push("#define CLIPPLANE");
  }
  if (clipPlane2) {
    defines.push("#define CLIPPLANE2");
  }
  if (clipPlane3) {
    defines.push("#define CLIPPLANE3");
  }
  if (clipPlane4) {
    defines.push("#define CLIPPLANE4");
  }
  if (clipPlane5) {
    defines.push("#define CLIPPLANE5");
  }
  if (clipPlane6) {
    defines.push("#define CLIPPLANE6");
  }
}
function PrepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  let changed = false;
  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);
  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);
  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);
  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);
  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);
  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);
  if (defines["CLIPPLANE"] !== clipPlane) {
    defines["CLIPPLANE"] = clipPlane;
    changed = true;
  }
  if (defines["CLIPPLANE2"] !== clipPlane2) {
    defines["CLIPPLANE2"] = clipPlane2;
    changed = true;
  }
  if (defines["CLIPPLANE3"] !== clipPlane3) {
    defines["CLIPPLANE3"] = clipPlane3;
    changed = true;
  }
  if (defines["CLIPPLANE4"] !== clipPlane4) {
    defines["CLIPPLANE4"] = clipPlane4;
    changed = true;
  }
  if (defines["CLIPPLANE5"] !== clipPlane5) {
    defines["CLIPPLANE5"] = clipPlane5;
    changed = true;
  }
  if (defines["CLIPPLANE6"] !== clipPlane6) {
    defines["CLIPPLANE6"] = clipPlane6;
    changed = true;
  }
  return changed;
}
function BindClipPlane(effect, primaryHolder, secondaryHolder) {
  let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;
  SetClipPlane(effect, "vClipPlane", clipPlane);
  clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;
  SetClipPlane(effect, "vClipPlane2", clipPlane);
  clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;
  SetClipPlane(effect, "vClipPlane3", clipPlane);
  clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;
  SetClipPlane(effect, "vClipPlane4", clipPlane);
  clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;
  SetClipPlane(effect, "vClipPlane5", clipPlane);
  clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;
  SetClipPlane(effect, "vClipPlane6", clipPlane);
}
function SetClipPlane(effect, uniformName, clipPlane) {
  if (clipPlane) {
    effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
  }
}

// node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags = class {
  /**
   * Are diffuse textures enabled in the application.
   */
  static get DiffuseTextureEnabled() {
    return this._DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(value) {
    if (this._DiffuseTextureEnabled === value) {
      return;
    }
    this._DiffuseTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Is the OpenPBR Base Weight texture enabled in the application.
   */
  static get BaseWeightTextureEnabled() {
    return this._BaseWeightTextureEnabled;
  }
  static set BaseWeightTextureEnabled(value) {
    if (this._BaseWeightTextureEnabled === value) {
      return;
    }
    this._BaseWeightTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Is the OpenPBR Base Diffuse Roughness texture enabled in the application.
   */
  static get BaseDiffuseRoughnessTextureEnabled() {
    return this._BaseDiffuseRoughnessTextureEnabled;
  }
  static set BaseDiffuseRoughnessTextureEnabled(value) {
    if (this._BaseDiffuseRoughnessTextureEnabled === value) {
      return;
    }
    this._BaseDiffuseRoughnessTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are detail textures enabled in the application.
   */
  static get DetailTextureEnabled() {
    return this._DetailTextureEnabled;
  }
  static set DetailTextureEnabled(value) {
    if (this._DetailTextureEnabled === value) {
      return;
    }
    this._DetailTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are decal maps enabled in the application.
   */
  static get DecalMapEnabled() {
    return this._DecalMapEnabled;
  }
  static set DecalMapEnabled(value) {
    if (this._DecalMapEnabled === value) {
      return;
    }
    this._DecalMapEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are ambient textures enabled in the application.
   */
  static get AmbientTextureEnabled() {
    return this._AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(value) {
    if (this._AmbientTextureEnabled === value) {
      return;
    }
    this._AmbientTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are opacity textures enabled in the application.
   */
  static get OpacityTextureEnabled() {
    return this._OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(value) {
    if (this._OpacityTextureEnabled === value) {
      return;
    }
    this._OpacityTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are reflection textures enabled in the application.
   */
  static get ReflectionTextureEnabled() {
    return this._ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(value) {
    if (this._ReflectionTextureEnabled === value) {
      return;
    }
    this._ReflectionTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are emissive textures enabled in the application.
   */
  static get EmissiveTextureEnabled() {
    return this._EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(value) {
    if (this._EmissiveTextureEnabled === value) {
      return;
    }
    this._EmissiveTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are specular textures enabled in the application.
   */
  static get SpecularTextureEnabled() {
    return this._SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(value) {
    if (this._SpecularTextureEnabled === value) {
      return;
    }
    this._SpecularTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are bump textures enabled in the application.
   */
  static get BumpTextureEnabled() {
    return this._BumpTextureEnabled;
  }
  static set BumpTextureEnabled(value) {
    if (this._BumpTextureEnabled === value) {
      return;
    }
    this._BumpTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are lightmap textures enabled in the application.
   */
  static get LightmapTextureEnabled() {
    return this._LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(value) {
    if (this._LightmapTextureEnabled === value) {
      return;
    }
    this._LightmapTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are refraction textures enabled in the application.
   */
  static get RefractionTextureEnabled() {
    return this._RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(value) {
    if (this._RefractionTextureEnabled === value) {
      return;
    }
    this._RefractionTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are color grading textures enabled in the application.
   */
  static get ColorGradingTextureEnabled() {
    return this._ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(value) {
    if (this._ColorGradingTextureEnabled === value) {
      return;
    }
    this._ColorGradingTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are fresnels enabled in the application.
   */
  static get FresnelEnabled() {
    return this._FresnelEnabled;
  }
  static set FresnelEnabled(value) {
    if (this._FresnelEnabled === value) {
      return;
    }
    this._FresnelEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(4);
  }
  /**
   * Are clear coat textures enabled in the application.
   */
  static get ClearCoatTextureEnabled() {
    return this._ClearCoatTextureEnabled;
  }
  static set ClearCoatTextureEnabled(value) {
    if (this._ClearCoatTextureEnabled === value) {
      return;
    }
    this._ClearCoatTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are clear coat bump textures enabled in the application.
   */
  static get ClearCoatBumpTextureEnabled() {
    return this._ClearCoatBumpTextureEnabled;
  }
  static set ClearCoatBumpTextureEnabled(value) {
    if (this._ClearCoatBumpTextureEnabled === value) {
      return;
    }
    this._ClearCoatBumpTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are clear coat tint textures enabled in the application.
   */
  static get ClearCoatTintTextureEnabled() {
    return this._ClearCoatTintTextureEnabled;
  }
  static set ClearCoatTintTextureEnabled(value) {
    if (this._ClearCoatTintTextureEnabled === value) {
      return;
    }
    this._ClearCoatTintTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are sheen textures enabled in the application.
   */
  static get SheenTextureEnabled() {
    return this._SheenTextureEnabled;
  }
  static set SheenTextureEnabled(value) {
    if (this._SheenTextureEnabled === value) {
      return;
    }
    this._SheenTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are anisotropic textures enabled in the application.
   */
  static get AnisotropicTextureEnabled() {
    return this._AnisotropicTextureEnabled;
  }
  static set AnisotropicTextureEnabled(value) {
    if (this._AnisotropicTextureEnabled === value) {
      return;
    }
    this._AnisotropicTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are thickness textures enabled in the application.
   */
  static get ThicknessTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set ThicknessTextureEnabled(value) {
    if (this._ThicknessTextureEnabled === value) {
      return;
    }
    this._ThicknessTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are refraction intensity textures enabled in the application.
   */
  static get RefractionIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set RefractionIntensityTextureEnabled(value) {
    if (this._RefractionIntensityTextureEnabled === value) {
      return;
    }
    this._RefractionIntensityTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are translucency intensity textures enabled in the application.
   */
  static get TranslucencyIntensityTextureEnabled() {
    return this._TranslucencyIntensityTextureEnabled;
  }
  static set TranslucencyIntensityTextureEnabled(value) {
    if (this._TranslucencyIntensityTextureEnabled === value) {
      return;
    }
    this._TranslucencyIntensityTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are translucency tint textures enabled in the application.
   */
  static get TranslucencyColorTextureEnabled() {
    return this._TranslucencyColorTextureEnabled;
  }
  static set TranslucencyColorTextureEnabled(value) {
    if (this._TranslucencyColorTextureEnabled === value) {
      return;
    }
    this._TranslucencyColorTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
  /**
   * Are translucency intensity textures enabled in the application.
   */
  static get IridescenceTextureEnabled() {
    return this._IridescenceTextureEnabled;
  }
  static set IridescenceTextureEnabled(value) {
    if (this._IridescenceTextureEnabled === value) {
      return;
    }
    this._IridescenceTextureEnabled = value;
    AbstractEngine.MarkAllMaterialsAsDirty(1);
  }
};
MaterialFlags._DiffuseTextureEnabled = true;
MaterialFlags._BaseWeightTextureEnabled = true;
MaterialFlags._BaseDiffuseRoughnessTextureEnabled = true;
MaterialFlags._DetailTextureEnabled = true;
MaterialFlags._DecalMapEnabled = true;
MaterialFlags._AmbientTextureEnabled = true;
MaterialFlags._OpacityTextureEnabled = true;
MaterialFlags._ReflectionTextureEnabled = true;
MaterialFlags._EmissiveTextureEnabled = true;
MaterialFlags._SpecularTextureEnabled = true;
MaterialFlags._BumpTextureEnabled = true;
MaterialFlags._LightmapTextureEnabled = true;
MaterialFlags._RefractionTextureEnabled = true;
MaterialFlags._ColorGradingTextureEnabled = true;
MaterialFlags._FresnelEnabled = true;
MaterialFlags._ClearCoatTextureEnabled = true;
MaterialFlags._ClearCoatBumpTextureEnabled = true;
MaterialFlags._ClearCoatTintTextureEnabled = true;
MaterialFlags._SheenTextureEnabled = true;
MaterialFlags._AnisotropicTextureEnabled = true;
MaterialFlags._ThicknessTextureEnabled = true;
MaterialFlags._RefractionIntensityTextureEnabled = true;
MaterialFlags._TranslucencyIntensityTextureEnabled = true;
MaterialFlags._TranslucencyColorTextureEnabled = true;
MaterialFlags._IridescenceTextureEnabled = true;

// node_modules/@babylonjs/core/Materials/materialHelper.functions.pure.js
function BindLogDepth(defines, effect, scene) {
  if (!defines || defines["LOGARITHMICDEPTH"] || defines.indexOf && defines.indexOf("LOGARITHMICDEPTH") >= 0) {
    const camera = scene.activeCamera;
    if (camera.mode === 1) {
      Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
    }
    effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
  }
}

// node_modules/@babylonjs/core/Materials/materialHelper.functions.js
var TempFogColor = { r: 0, g: 0, b: 0 };
var TmpMorphInfluencers = {
  NUM_MORPH_INFLUENCERS: 0,
  NORMAL: false,
  TANGENT: false,
  UV: false,
  UV2: false,
  COLOR: false
};
function BindFogParameters(scene, mesh, effect, linearSpace = false) {
  if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== 0) {
    effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
    if (linearSpace) {
      scene.fogColor.toLinearSpaceToRef(TempFogColor, scene.getEngine().useExactSrgbConversions);
      effect.setColor3("vFogColor", TempFogColor);
    } else {
      effect.setColor3("vFogColor", scene.fogColor);
    }
  }
}
function PrepareDefinesAndAttributesForMorphTargets(morphTargetManager, defines, attribs, mesh, usePositionMorph, useNormalMorph, useTangentMorph, useUVMorph, useUV2Morph, useColorMorph) {
  const numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;
  if (numMorphInfluencers <= 0) {
    return 0;
  }
  defines.push("#define MORPHTARGETS");
  if (morphTargetManager.hasPositions) {
    defines.push("#define MORPHTARGETTEXTURE_HASPOSITIONS");
  }
  if (morphTargetManager.hasNormals) {
    defines.push("#define MORPHTARGETTEXTURE_HASNORMALS");
  }
  if (morphTargetManager.hasTangents) {
    defines.push("#define MORPHTARGETTEXTURE_HASTANGENTS");
  }
  if (morphTargetManager.hasUVs) {
    defines.push("#define MORPHTARGETTEXTURE_HASUVS");
  }
  if (morphTargetManager.hasUV2s) {
    defines.push("#define MORPHTARGETTEXTURE_HASUV2S");
  }
  if (morphTargetManager.hasColors) {
    defines.push("#define MORPHTARGETTEXTURE_HASCOLORS");
  }
  if (morphTargetManager.supportsPositions && usePositionMorph) {
    defines.push("#define MORPHTARGETS_POSITION");
  }
  if (morphTargetManager.supportsNormals && useNormalMorph) {
    defines.push("#define MORPHTARGETS_NORMAL");
  }
  if (morphTargetManager.supportsTangents && useTangentMorph) {
    defines.push("#define MORPHTARGETS_TANGENT");
  }
  if (morphTargetManager.supportsUVs && useUVMorph) {
    defines.push("#define MORPHTARGETS_UV");
  }
  if (morphTargetManager.supportsUV2s && useUV2Morph) {
    defines.push("#define MORPHTARGETS_UV2");
  }
  if (morphTargetManager.supportsColors && useColorMorph) {
    defines.push("#define MORPHTARGETS_COLOR");
  }
  defines.push("#define NUM_MORPH_INFLUENCERS " + numMorphInfluencers);
  if (morphTargetManager.isUsingTextureForTargets) {
    defines.push("#define MORPHTARGETS_TEXTURE");
  }
  TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = numMorphInfluencers;
  TmpMorphInfluencers.NORMAL = useNormalMorph;
  TmpMorphInfluencers.TANGENT = useTangentMorph;
  TmpMorphInfluencers.UV = useUVMorph;
  TmpMorphInfluencers.UV2 = useUV2Morph;
  TmpMorphInfluencers.COLOR = useColorMorph;
  PrepareAttributesForMorphTargets(attribs, mesh, TmpMorphInfluencers, usePositionMorph);
  return numMorphInfluencers;
}
function PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {
  TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
  TmpMorphInfluencers.NORMAL = false;
  TmpMorphInfluencers.TANGENT = false;
  TmpMorphInfluencers.UV = false;
  TmpMorphInfluencers.UV2 = false;
  TmpMorphInfluencers.COLOR = false;
  PrepareAttributesForMorphTargets(attribs, mesh, TmpMorphInfluencers, true);
}
function PrepareAttributesForMorphTargets(attribs, mesh, defines, usePositionMorph = true) {
  const influencers = defines["NUM_MORPH_INFLUENCERS"];
  if (influencers > 0 && EngineStore.LastCreatedEngine) {
    const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
    const manager = mesh.morphTargetManager;
    if (manager?.isUsingTextureForTargets) {
      return;
    }
    const position = manager && manager.supportsPositions && usePositionMorph;
    const normal = manager && manager.supportsNormals && defines["NORMAL"];
    const tangent = manager && manager.supportsTangents && defines["TANGENT"];
    const uv = manager && manager.supportsUVs && defines["UV1"];
    const uv2 = manager && manager.supportsUV2s && defines["UV2"];
    const color = manager && manager.supportsColors && defines["VERTEXCOLOR"];
    for (let index = 0; index < influencers; index++) {
      if (position) {
        attribs.push(`position` + index);
      }
      if (normal) {
        attribs.push(`normal` + index);
      }
      if (tangent) {
        attribs.push(`tangent` + index);
      }
      if (uv) {
        attribs.push(`uv_` + index);
      }
      if (uv2) {
        attribs.push(`uv2_` + index);
      }
      if (color) {
        attribs.push(`color` + index);
      }
      if (attribs.length > maxAttributesCount) {
        Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
      }
    }
  }
}
function PushAttributesForInstances(attribs, needsPreviousMatrices = false) {
  attribs.push("world0");
  attribs.push("world1");
  attribs.push("world2");
  attribs.push("world3");
  if (needsPreviousMatrices) {
    attribs.push("previousWorld0");
    attribs.push("previousWorld1");
    attribs.push("previousWorld2");
    attribs.push("previousWorld3");
  }
}
function BindMorphTargetParameters(abstractMesh, effect) {
  const manager = abstractMesh.morphTargetManager;
  if (!abstractMesh || !manager) {
    return;
  }
  effect.setFloatArray("morphTargetInfluences", manager.influences);
}
function BindSceneUniformBuffer(effect, sceneUbo) {
  sceneUbo.bindToEffect(effect, "Scene");
}
function BindIBLParameters(scene, defines, ubo, reflectionColor, reflectionTexture = null, realTimeFiltering = false, supportTextureInfo = false, supportLocalProjection = false, usePBR = false, supportSH = false, useColor = false, reflectionBlur = 0) {
  if (scene.texturesEnabled) {
    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
      ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
      ubo.updateFloat2("vReflectionInfos", reflectionTexture.level * scene.iblIntensity, reflectionBlur);
      if (supportLocalProjection && reflectionTexture.boundingBoxSize) {
        const cubeTexture = reflectionTexture;
        ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
        ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
      }
      if (realTimeFiltering) {
        const width = reflectionTexture.getSize().width;
        ubo.updateFloat2("vReflectionFilteringInfo", width, Math.log2(width));
      }
      if (supportSH && !defines.USEIRRADIANCEMAP) {
        const polynomials = reflectionTexture.sphericalPolynomial;
        if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
          if (defines.SPHERICAL_HARMONICS) {
            const preScaledHarmonics = polynomials.preScaledHarmonics;
            ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
            ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
            ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
            ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
            ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
            ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
            ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
            ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
            ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
          } else {
            ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
            ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
            ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
            ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
            ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
            ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
            ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
            ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
            ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
          }
        }
      } else if (usePBR) {
        if (defines.USEIRRADIANCEMAP && defines.USE_IRRADIANCE_DOMINANT_DIRECTION) {
          ubo.updateVector3("vReflectionDominantDirection", reflectionTexture.irradianceTexture._dominantDirection);
        }
      }
      if (supportTextureInfo) {
        ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
      }
    }
  }
  if (useColor) {
    ubo.updateColor3("vReflectionColor", reflectionColor);
  }
}
function BindIBLSamplers(scene, defines, ubo, reflectionTexture = null, realTimeFiltering = false) {
  if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
    if (defines.LODBASEDMICROSFURACE) {
      ubo.setTexture("reflectionSampler", reflectionTexture);
    } else {
      ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
      ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
      ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
    }
    if (defines.USEIRRADIANCEMAP) {
      ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
    }
    const cdfGenerator = scene.iblCdfGenerator;
    if (realTimeFiltering && cdfGenerator) {
      ubo.setTexture("icdfSampler", cdfGenerator.getIcdfTexture());
    }
  }
}
function PrepareDefinesForMergedUV(texture, defines, key) {
  defines._needUVs = true;
  defines[key] = true;
  if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {
    defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
    defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
  } else {
    defines[key + "DIRECTUV"] = 0;
  }
}
function BindTextureMatrix(texture, uniformBuffer, key) {
  const matrix = texture.getTextureMatrix();
  uniformBuffer.updateMatrix(key + "Matrix", matrix);
}
function PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {
  const enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
  if (enabled) {
    attribs.push("bakedVertexAnimationSettingsInstanced");
  }
}
function CopyBonesTransformationMatrices(source, target) {
  target.set(source);
  return target;
}
function BindBonesParameters(mesh, effect, prePassConfiguration) {
  if (!effect || !mesh) {
    return;
  }
  if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
    mesh.computeBonesUsingShaders = false;
  }
  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
    const skeleton = mesh.skeleton;
    if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
      const boneTexture = skeleton.getTransformMatrixTexture(mesh);
      effect.setTexture("boneSampler", boneTexture);
      effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
    } else {
      const matrices = skeleton.getTransformMatrices(mesh);
      if (matrices) {
        effect.setMatrices("mBones", matrices);
        if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
          if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
          }
          effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
          CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
        }
      }
    }
  }
}
function BindLightProperties(light, effect, lightIndex) {
  light.transferToEffect(effect, lightIndex + "");
}
function BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {
  light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
}
function BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {
  const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
  for (let i = 0; i < len; i++) {
    const light = mesh.lightSources[i];
    BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
  }
}
function PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {
  if (defines["NUM_BONE_INFLUENCERS"] > 0) {
    fallbacks.addCPUSkinningFallback(0, mesh);
    attribs.push(`matricesIndices`);
    attribs.push(`matricesWeights`);
    if (defines["NUM_BONE_INFLUENCERS"] > 4) {
      attribs.push(`matricesIndicesExtra`);
      attribs.push(`matricesWeightsExtra`);
    }
  }
}
function PrepareAttributesForInstances(attribs, defines) {
  if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
    PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
  }
  if (defines.INSTANCESCOLOR) {
    attribs.push(`instanceColor`);
  }
}
function HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {
  let lightFallbackRank = 0;
  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
    if (!defines["LIGHT" + lightIndex]) {
      break;
    }
    if (lightIndex > 0) {
      lightFallbackRank = rank + lightIndex;
      fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
    }
    if (!defines["SHADOWS"]) {
      if (defines["SHADOW" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOW" + lightIndex);
      }
      if (defines["SHADOWPCF" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
      }
      if (defines["SHADOWPCSS" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
      }
      if (defines["SHADOWPOISSON" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
      }
      if (defines["SHADOWESM" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
      }
      if (defines["SHADOWCLOSEESM" + lightIndex]) {
        fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
      }
    }
  }
  return lightFallbackRank++;
}
function GetFogState(mesh, scene) {
  return scene.fogEnabled && mesh.applyFog && scene.fogMode !== 0;
}
function PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false, useVertexPulling = false, renderingMesh, setVertexOutputInvariant) {
  if (defines._areMiscDirty) {
    defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
    defines["POINTSIZE"] = pointsCloud;
    defines["FOG"] = fogEnabled && GetFogState(mesh, scene);
    defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
    defines["ALPHATEST"] = alphaTest;
    defines["DECAL_AFTER_DETAIL"] = applyDecalAfterDetail;
    defines["USE_VERTEX_PULLING"] = useVertexPulling;
    const indexBuffer = renderingMesh?.geometry?.getIndexBuffer();
    defines["VERTEX_PULLING_USE_INDEX_BUFFER"] = !!indexBuffer;
    defines["VERTEX_PULLING_INDEX_BUFFER_32BITS"] = indexBuffer ? indexBuffer.is32Bits : false;
    defines["VERTEXOUTPUT_INVARIANT"] = !!setVertexOutputInvariant;
  }
}
function PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {
  if (!defines._areLightsDirty) {
    return defines._needNormals;
  }
  let lightIndex = 0;
  const state = {
    needNormals: defines._needNormals,
    // prevents overriding previous reflection or other needs for normals
    needRebuild: false,
    lightmapMode: false,
    shadowEnabled: false,
    specularEnabled: false
  };
  if (scene.lightsEnabled && !disableLighting) {
    for (const light of mesh.lightSources) {
      PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
      lightIndex++;
      if (lightIndex === maxSimultaneousLights) {
        break;
      }
    }
  }
  defines["SPECULARTERM"] = state.specularEnabled;
  defines["SHADOWS"] = state.shadowEnabled;
  const maxLightCount = Math.max(maxSimultaneousLights, defines["MAXLIGHTCOUNT"] || 0);
  for (let index = lightIndex; index < maxLightCount; index++) {
    if (defines["LIGHT" + index] !== void 0) {
      defines["LIGHT" + index] = false;
      defines["HEMILIGHT" + index] = false;
      defines["POINTLIGHT" + index] = false;
      defines["DIRLIGHT" + index] = false;
      defines["SPOTLIGHT" + index] = false;
      defines["AREALIGHT" + index] = false;
      defines["CLUSTLIGHT" + index] = false;
      defines["SHADOW" + index] = false;
      defines["SHADOWCSM" + index] = false;
      defines["SHADOWCSMDEBUG" + index] = false;
      defines["SHADOWCSMNUM_CASCADES" + index] = false;
      defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
      defines["SHADOWCSMNOBLEND" + index] = false;
      defines["SHADOWCSM_RIGHTHANDED" + index] = false;
      defines["SHADOWPCF" + index] = false;
      defines["SHADOWPCSS" + index] = false;
      defines["SHADOWPOISSON" + index] = false;
      defines["SHADOWESM" + index] = false;
      defines["SHADOWCLOSEESM" + index] = false;
      defines["SHADOWCUBE" + index] = false;
      defines["SHADOWLOWQUALITY" + index] = false;
      defines["SHADOWMEDIUMQUALITY" + index] = false;
    }
  }
  defines["MAXLIGHTCOUNT"] = maxSimultaneousLights;
  const caps = scene.getEngine().getCaps();
  if (defines["SHADOWFLOAT"] === void 0) {
    state.needRebuild = true;
  }
  defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
  defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
  if (state.needRebuild) {
    defines.rebuild();
  }
  return state.needNormals;
}
function PrepareDefinesForIBL(scene, reflectionTexture, defines, realTimeFiltering = false, realTimeFilteringQuality = 8, forceSHInVertex = false) {
  if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
    if (!reflectionTexture.isReadyOrNotBlocking()) {
      return false;
    }
    defines._needNormals = true;
    defines.REFLECTION = true;
    defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
    defines.RGBDREFLECTION = reflectionTexture.isRGBD;
    defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
    defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
    defines.USEIRRADIANCEMAP = false;
    const engine = scene.getEngine();
    if (realTimeFiltering && realTimeFilteringQuality > 0) {
      defines.NUM_SAMPLES = "" + realTimeFilteringQuality;
      if (engine._features.needTypeSuffixInShaderConstants) {
        defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
      }
      defines.REALTIME_FILTERING = true;
      if (scene.iblCdfGenerator) {
        defines.IBL_CDF_FILTERING = true;
      }
    } else {
      defines.REALTIME_FILTERING = false;
    }
    defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
    defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
    defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
    defines.REFLECTIONMAP_CUBIC = false;
    defines.REFLECTIONMAP_EXPLICIT = false;
    defines.REFLECTIONMAP_PLANAR = false;
    defines.REFLECTIONMAP_PROJECTION = false;
    defines.REFLECTIONMAP_SKYBOX = false;
    defines.REFLECTIONMAP_SPHERICAL = false;
    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    switch (reflectionTexture.coordinatesMode) {
      case Texture.EXPLICIT_MODE:
        defines.REFLECTIONMAP_EXPLICIT = true;
        break;
      case Texture.PLANAR_MODE:
        defines.REFLECTIONMAP_PLANAR = true;
        break;
      case Texture.PROJECTION_MODE:
        defines.REFLECTIONMAP_PROJECTION = true;
        break;
      case Texture.SKYBOX_MODE:
        defines.REFLECTIONMAP_SKYBOX = true;
        break;
      case Texture.SPHERICAL_MODE:
        defines.REFLECTIONMAP_SPHERICAL = true;
        break;
      case Texture.EQUIRECTANGULAR_MODE:
        defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
        break;
      case Texture.FIXED_EQUIRECTANGULAR_MODE:
        defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
        break;
      case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
        defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
        break;
      case Texture.CUBIC_MODE:
      case Texture.INVCUBIC_MODE:
      default:
        defines.REFLECTIONMAP_CUBIC = true;
        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
        break;
    }
    if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
      if (reflectionTexture.irradianceTexture) {
        defines.USEIRRADIANCEMAP = true;
        defines.USESPHERICALFROMREFLECTIONMAP = false;
        defines.USESPHERICALINVERTEX = false;
        if (reflectionTexture.irradianceTexture._dominantDirection) {
          defines.USE_IRRADIANCE_DOMINANT_DIRECTION = true;
        }
      } else if (reflectionTexture.isCube) {
        defines.USESPHERICALFROMREFLECTIONMAP = true;
        defines.USEIRRADIANCEMAP = false;
        defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
        defines.USESPHERICALINVERTEX = forceSHInVertex;
      }
    }
  } else {
    defines.REFLECTION = false;
    defines.REFLECTIONMAP_3D = false;
    defines.REFLECTIONMAP_SPHERICAL = false;
    defines.REFLECTIONMAP_PLANAR = false;
    defines.REFLECTIONMAP_CUBIC = false;
    defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
    defines.REFLECTIONMAP_PROJECTION = false;
    defines.REFLECTIONMAP_SKYBOX = false;
    defines.REFLECTIONMAP_EXPLICIT = false;
    defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
    defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
    defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
    defines.INVERTCUBICMAP = false;
    defines.USESPHERICALFROMREFLECTIONMAP = false;
    defines.USEIRRADIANCEMAP = false;
    defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;
    defines.USESPHERICALINVERTEX = false;
    defines.REFLECTIONMAP_OPPOSITEZ = false;
    defines.LODINREFLECTIONALPHA = false;
    defines.GAMMAREFLECTION = false;
    defines.RGBDREFLECTION = false;
    defines.LINEARSPECULARREFLECTION = false;
  }
  return true;
}
function PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {
  state.needNormals = true;
  if (defines["LIGHT" + lightIndex] === void 0) {
    state.needRebuild = true;
  }
  defines["LIGHT" + lightIndex] = true;
  defines["SPOTLIGHT" + lightIndex] = false;
  defines["HEMILIGHT" + lightIndex] = false;
  defines["POINTLIGHT" + lightIndex] = false;
  defines["DIRLIGHT" + lightIndex] = false;
  defines["AREALIGHT" + lightIndex] = false;
  defines["CLUSTLIGHT" + lightIndex] = false;
  light.prepareLightSpecificDefines(defines, lightIndex);
  defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
  defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
  defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
  switch (light.falloffType) {
    case LightConstants.FALLOFF_GLTF:
      defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
      break;
    case LightConstants.FALLOFF_PHYSICAL:
      defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
      break;
    case LightConstants.FALLOFF_STANDARD:
      defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
      break;
  }
  if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
    state.specularEnabled = true;
  }
  defines["SHADOW" + lightIndex] = false;
  defines["SHADOWCSM" + lightIndex] = false;
  defines["SHADOWCSMDEBUG" + lightIndex] = false;
  defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
  defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
  defines["SHADOWCSMNOBLEND" + lightIndex] = false;
  defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
  defines["SHADOWPCF" + lightIndex] = false;
  defines["SHADOWPCSS" + lightIndex] = false;
  defines["SHADOWPOISSON" + lightIndex] = false;
  defines["SHADOWESM" + lightIndex] = false;
  defines["SHADOWCLOSEESM" + lightIndex] = false;
  defines["SHADOWCUBE" + lightIndex] = false;
  defines["SHADOWLOWQUALITY" + lightIndex] = false;
  defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
  if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
    const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();
    if (shadowGenerator) {
      const shadowMap = shadowGenerator.getShadowMap();
      if (shadowMap) {
        if (shadowMap.renderList && shadowMap.renderList.length > 0) {
          state.shadowEnabled = true;
          shadowGenerator.prepareDefines(defines, lightIndex);
        }
      }
    }
  }
  if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {
    state.lightmapMode = true;
    defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
    defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;
  } else {
    defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
    defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
  }
}
function PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {
  let changed = PrepareDefinesForCamera(scene, defines);
  if (useClipPlane !== false) {
    changed = PrepareDefinesForClipPlanes(material, scene, defines);
  }
  if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
    defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
    changed = true;
  }
  if (defines["INSTANCES"] !== useInstances) {
    defines["INSTANCES"] = useInstances;
    changed = true;
  }
  if (defines["THIN_INSTANCES"] !== useThinInstances) {
    defines["THIN_INSTANCES"] = useThinInstances;
    changed = true;
  }
  if (changed) {
    defines.markAsUnprocessed();
  }
}
function PrepareDefinesForBones(mesh, defines) {
  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
    defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
    const materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
    if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
      defines["BONETEXTURE"] = true;
    } else {
      defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
      defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
      const prePassRenderer = mesh.getScene().prePassRenderer;
      if (prePassRenderer && prePassRenderer.enabled) {
        const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
        defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
      }
    }
  } else {
    defines["NUM_BONE_INFLUENCERS"] = 0;
    defines["BonesPerMesh"] = 0;
    if (defines["BONETEXTURE"] !== void 0) {
      defines["BONETEXTURE"] = false;
    }
  }
}
function PrepareDefinesForMorphTargets(mesh, defines) {
  const manager = mesh.morphTargetManager;
  if (manager) {
    defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
    defines["MORPHTARGETS_UV2"] = manager.supportsUV2s && defines["UV2"];
    defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
    defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
    defines["MORPHTARGETS_POSITION"] = manager.supportsPositions;
    defines["MORPHTARGETS_COLOR"] = manager.supportsColors;
    defines["MORPHTARGETTEXTURE_HASUVS"] = manager.hasUVs;
    defines["MORPHTARGETTEXTURE_HASUV2S"] = manager.hasUV2s;
    defines["MORPHTARGETTEXTURE_HASTANGENTS"] = manager.hasTangents;
    defines["MORPHTARGETTEXTURE_HASNORMALS"] = manager.hasNormals;
    defines["MORPHTARGETTEXTURE_HASPOSITIONS"] = manager.hasPositions;
    defines["MORPHTARGETTEXTURE_HASCOLORS"] = manager.hasColors;
    defines["NUM_MORPH_INFLUENCERS"] = manager.numMaxInfluencers || manager.numInfluencers;
    defines["MORPHTARGETS"] = defines["NUM_MORPH_INFLUENCERS"] > 0;
    defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
  } else {
    defines["MORPHTARGETS_UV"] = false;
    defines["MORPHTARGETS_UV2"] = false;
    defines["MORPHTARGETS_TANGENT"] = false;
    defines["MORPHTARGETS_NORMAL"] = false;
    defines["MORPHTARGETS_POSITION"] = false;
    defines["MORPHTARGETS_COLOR"] = false;
    defines["MORPHTARGETTEXTURE_HASUVS"] = false;
    defines["MORPHTARGETTEXTURE_HASUV2S"] = false;
    defines["MORPHTARGETTEXTURE_HASTANGENTS"] = false;
    defines["MORPHTARGETTEXTURE_HASNORMALS"] = false;
    defines["MORPHTARGETTEXTURE_HASPOSITIONS"] = false;
    defines["MORPHTARGETTEXTURE_HAS_COLORS"] = false;
    defines["MORPHTARGETS"] = false;
    defines["NUM_MORPH_INFLUENCERS"] = 0;
  }
}
function PrepareDefinesForBakedVertexAnimation(mesh, defines) {
  const manager = mesh.bakedVertexAnimationManager;
  defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
}
function PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {
  if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
    return false;
  }
  defines._normals = defines._needNormals;
  defines._uvs = defines._needUVs;
  defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(`normal`);
  if (defines._needNormals && mesh.isVerticesDataPresent(`tangent`)) {
    defines["TANGENT"] = true;
  }
  for (let i = 1; i <= 6; ++i) {
    defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`) : false;
  }
  if (useVertexColor) {
    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(`color`);
    defines["VERTEXCOLOR"] = hasVertexColors;
    defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
  }
  if (mesh.isVerticesDataPresent(`instanceColor`) && (mesh.hasInstances || mesh.hasThinInstances)) {
    defines["INSTANCESCOLOR"] = true;
  }
  if (useBones) {
    PrepareDefinesForBones(mesh, defines);
  }
  if (useMorphTargets) {
    PrepareDefinesForMorphTargets(mesh, defines);
  }
  if (useBakedVertexAnimation) {
    PrepareDefinesForBakedVertexAnimation(mesh, defines);
  }
  return true;
}
function PrepareDefinesForMultiview(scene, defines) {
  if (scene.activeCamera) {
    const previousMultiview = defines.MULTIVIEW;
    defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
    if (defines.MULTIVIEW != previousMultiview) {
      defines.markAsUnprocessed();
    }
  }
}
function PrepareDefinesForOIT(scene, defines, needAlphaBlending) {
  const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
  const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
  defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
  defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
  if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
    defines.markAsUnprocessed();
  }
}
function PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {
  const previousPrePass = defines.PREPASS;
  if (!defines._arePrePassDirty) {
    return;
  }
  const texturesList = [
    {
      type: 1,
      define: "PREPASS_POSITION",
      index: "PREPASS_POSITION_INDEX"
    },
    {
      type: 9,
      define: "PREPASS_LOCAL_POSITION",
      index: "PREPASS_LOCAL_POSITION_INDEX"
    },
    {
      type: 2,
      define: "PREPASS_VELOCITY",
      index: "PREPASS_VELOCITY_INDEX"
    },
    {
      type: 11,
      define: "PREPASS_VELOCITY_LINEAR",
      index: "PREPASS_VELOCITY_LINEAR_INDEX"
    },
    {
      type: 3,
      define: "PREPASS_REFLECTIVITY",
      index: "PREPASS_REFLECTIVITY_INDEX"
    },
    {
      type: 0,
      define: "PREPASS_IRRADIANCE",
      index: "PREPASS_IRRADIANCE_INDEX"
    },
    {
      type: 7,
      define: "PREPASS_ALBEDO_SQRT",
      index: "PREPASS_ALBEDO_SQRT_INDEX"
    },
    {
      type: 5,
      define: "PREPASS_DEPTH",
      index: "PREPASS_DEPTH_INDEX"
    },
    {
      type: 10,
      define: "PREPASS_SCREENSPACE_DEPTH",
      index: "PREPASS_SCREENSPACE_DEPTH_INDEX"
    },
    {
      type: 6,
      define: "PREPASS_NORMAL",
      index: "PREPASS_NORMAL_INDEX"
    },
    {
      type: 8,
      define: "PREPASS_WORLD_NORMAL",
      index: "PREPASS_WORLD_NORMAL_INDEX"
    }
  ];
  if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
    defines.PREPASS = true;
    defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
    defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;
    defines.PREPASS_COLOR = true;
    defines.PREPASS_COLOR_INDEX = 0;
    for (let i = 0; i < texturesList.length; i++) {
      const index = scene.prePassRenderer.getIndex(texturesList[i].type);
      if (index !== -1) {
        defines[texturesList[i].define] = true;
        defines[texturesList[i].index] = index;
      } else {
        defines[texturesList[i].define] = false;
      }
    }
  } else {
    defines.PREPASS = false;
    for (let i = 0; i < texturesList.length; i++) {
      defines[texturesList[i].define] = false;
    }
  }
  if (defines.PREPASS != previousPrePass) {
    defines.markAsUnprocessed();
    defines.markAsImageProcessingDirty();
  }
}
function PrepareDefinesForCamera(scene, defines) {
  let changed = false;
  if (scene.activeCamera) {
    const wasOrtho = defines["CAMERA_ORTHOGRAPHIC"] ? 1 : 0;
    const wasPersp = defines["CAMERA_PERSPECTIVE"] ? 1 : 0;
    const isOrtho = scene.activeCamera.mode === 1 ? 1 : 0;
    const isPersp = scene.activeCamera.mode === 0 ? 1 : 0;
    if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {
      defines["CAMERA_ORTHOGRAPHIC"] = isOrtho === 1;
      defines["CAMERA_PERSPECTIVE"] = isPersp === 1;
      changed = true;
    }
  }
  return changed;
}
function PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false, iesLightTexture = false, clusteredLightTextures = false) {
  if (uniformBuffersList) {
    uniformBuffersList.push("Light" + lightIndex);
  }
  if (updateOnlyBuffersList) {
    return;
  }
  uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightWidth" + lightIndex, "vLightHeight" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "vSliceData" + lightIndex, "vSliceRanges" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
  samplersList.push("shadowTexture" + lightIndex);
  samplersList.push("depthTexture" + lightIndex);
  uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
  if (projectedLightTexture) {
    samplersList.push("projectionLightTexture" + lightIndex);
    uniformsList.push("textureProjectionMatrix" + lightIndex);
  }
  if (iesLightTexture) {
    samplersList.push("iesLightTexture" + lightIndex);
  }
  if (clusteredLightTextures) {
    samplersList.push("lightDataTexture" + lightIndex);
    samplersList.push("tileMaskTexture" + lightIndex);
  }
}
function PrepareUniformsAndSamplersForIBL(uniformsList, samplersList, useSH) {
  const iblUniforms = [
    "vReflectionMicrosurfaceInfos",
    "vReflectionDominantDirection",
    "reflectionMatrix",
    "vReflectionInfos",
    "vReflectionPosition",
    "vReflectionSize",
    "vReflectionColor",
    "vReflectionFilteringInfo"
  ];
  if (useSH) {
    iblUniforms.push("vSphericalX", "vSphericalY", "vSphericalZ", "vSphericalXX_ZZ", "vSphericalYY_ZZ", "vSphericalZZ", "vSphericalXY", "vSphericalYZ", "vSphericalZX", "vSphericalL00", "vSphericalL1_1", "vSphericalL10", "vSphericalL11", "vSphericalL2_2", "vSphericalL2_1", "vSphericalL20", "vSphericalL21", "vSphericalL22");
  }
  uniformsList.push(...iblUniforms);
  const iblSamplers = ["reflectionSampler", "reflectionSamplerLow", "reflectionSamplerHigh", "irradianceSampler", "icdfSampler"];
  samplersList.push(...iblSamplers);
}
function PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {
  let uniformsList;
  let uniformBuffersList;
  if (uniformsListOrOptions.uniformsNames) {
    const options = uniformsListOrOptions;
    uniformsList = options.uniformsNames;
    uniformBuffersList = options.uniformBuffersNames;
    samplersList = options.samplers;
    defines = options.defines;
    maxSimultaneousLights = options.maxSimultaneousLights || 0;
  } else {
    uniformsList = uniformsListOrOptions;
    if (!samplersList) {
      samplersList = [];
    }
  }
  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
    if (!defines["LIGHT" + lightIndex]) {
      break;
    }
    PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList, false, defines["IESLIGHTTEXTURE" + lightIndex], defines["CLUSTLIGHT" + lightIndex]);
  }
  if (defines["NUM_MORPH_INFLUENCERS"]) {
    uniformsList.push("morphTargetInfluences");
    uniformsList.push("morphTargetCount");
  }
  if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
    uniformsList.push("bakedVertexAnimationSettings");
    uniformsList.push("bakedVertexAnimationTextureSizeInverted");
    uniformsList.push("bakedVertexAnimationTime");
    samplersList.push("bakedVertexAnimationTexture");
  }
}
function PrepareUniformLayoutForIBL(ubo, supportTextureInfo = false, supportLocalProjection = false, usePBR = false, supportSH = false, useColor = false) {
  ubo.addUniform("vReflectionInfos", 2);
  ubo.addUniform("reflectionMatrix", 16);
  if (supportTextureInfo) {
    ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
  }
  if (supportLocalProjection) {
    ubo.addUniform("vReflectionPosition", 3);
    ubo.addUniform("vReflectionSize", 3);
  }
  if (usePBR) {
    ubo.addUniform("vReflectionFilteringInfo", 2);
    ubo.addUniform("vReflectionDominantDirection", 3);
  }
  if (useColor) {
    ubo.addUniform("vReflectionColor", 3);
  }
  if (supportSH) {
    ubo.addUniform("vSphericalL00", 3);
    ubo.addUniform("vSphericalL1_1", 3);
    ubo.addUniform("vSphericalL10", 3);
    ubo.addUniform("vSphericalL11", 3);
    ubo.addUniform("vSphericalL2_2", 3);
    ubo.addUniform("vSphericalL2_1", 3);
    ubo.addUniform("vSphericalL20", 3);
    ubo.addUniform("vSphericalL21", 3);
    ubo.addUniform("vSphericalL22", 3);
    ubo.addUniform("vSphericalX", 3);
    ubo.addUniform("vSphericalY", 3);
    ubo.addUniform("vSphericalZ", 3);
    ubo.addUniform("vSphericalXX_ZZ", 3);
    ubo.addUniform("vSphericalYY_ZZ", 3);
    ubo.addUniform("vSphericalZZ", 3);
    ubo.addUniform("vSphericalXY", 3);
    ubo.addUniform("vSphericalYZ", 3);
    ubo.addUniform("vSphericalZX", 3);
  }
}

export {
  AddClipPlaneUniforms,
  PrepareStringDefinesForClipPlanes,
  PrepareDefinesForClipPlanes,
  BindClipPlane,
  MaterialFlags,
  BindLogDepth,
  BindFogParameters,
  PrepareDefinesAndAttributesForMorphTargets,
  PrepareAttributesForMorphTargetsInfluencers,
  PrepareAttributesForMorphTargets,
  PushAttributesForInstances,
  BindMorphTargetParameters,
  BindSceneUniformBuffer,
  BindIBLParameters,
  BindIBLSamplers,
  PrepareDefinesForMergedUV,
  BindTextureMatrix,
  PrepareAttributesForBakedVertexAnimation,
  BindBonesParameters,
  BindLightProperties,
  BindLight,
  BindLights,
  PrepareAttributesForBones,
  PrepareAttributesForInstances,
  HandleFallbacksForShadows,
  GetFogState,
  PrepareDefinesForMisc,
  PrepareDefinesForLights,
  PrepareDefinesForIBL,
  PrepareDefinesForLight,
  PrepareDefinesForFrameBoundValues,
  PrepareDefinesForBones,
  PrepareDefinesForMorphTargets,
  PrepareDefinesForBakedVertexAnimation,
  PrepareDefinesForAttributes,
  PrepareDefinesForMultiview,
  PrepareDefinesForOIT,
  PrepareDefinesForPrePass,
  PrepareDefinesForCamera,
  PrepareUniformsAndSamplersForLight,
  PrepareUniformsAndSamplersForIBL,
  PrepareUniformsAndSamplersList,
  PrepareUniformLayoutForIBL
};
//# sourceMappingURL=chunk-2VHVG2NH.js.map
