import {
  InstancedMesh
} from "./chunk-PF7TCB4E.js";
import {
  AbstractMesh,
  Mesh,
  SceneLoaderFlags,
  TransformNode
} from "./chunk-JPDS7OIY.js";
import {
  Camera,
  Scene
} from "./chunk-VEFBIZWV.js";
import {
  Light
} from "./chunk-DILINRTI.js";
import {
  Tags
} from "./chunk-KEOAMMZ7.js";
import {
  Tools
} from "./chunk-V4HVSPHY.js";
import {
  ErrorCodes,
  IsBase64DataUrl,
  RuntimeError
} from "./chunk-XHCADOMZ.js";
import {
  WebRequest
} from "./chunk-2ZEUD233.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import {
  AbstractEngine
} from "./chunk-5OVANEI2.js";
import {
  EngineStore
} from "./chunk-WWEEGZBW.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/assetContainer.js
var AbstractAssetContainer = class {
  constructor() {
    this.rootNodes = [];
    this.cameras = [];
    this.lights = [];
    this.meshes = [];
    this.skeletons = [];
    this.particleSystems = [];
    this.animations = [];
    this.animationGroups = [];
    this.multiMaterials = [];
    this.materials = [];
    this.morphTargetManagers = [];
    this.geometries = [];
    this.transformNodes = [];
    this.actionManagers = [];
    this.textures = [];
    this._environmentTexture = null;
    this.postProcesses = [];
    this.sounds = null;
    this.effectLayers = [];
    this.layers = [];
    this.reflectionProbes = [];
  }
  /**
   * Texture used in all pbr material as the reflection texture.
   * As in the majority of the scene they are the same (exception for multi room and so on),
   * this is easier to reference from here than from all the materials.
   */
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(value) {
    this._environmentTexture = value;
  }
  /**
   * @returns all meshes, lights, cameras, transformNodes and bones
   */
  getNodes() {
    let nodes = [];
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    for (const skeleton of this.skeletons) {
      nodes = nodes.concat(skeleton.bones);
    }
    return nodes;
  }
};
var KeepAssets = class extends AbstractAssetContainer {
};
var InstantiatedEntries = class {
  constructor() {
    this.rootNodes = [];
    this.skeletons = [];
    this.animationGroups = [];
  }
  /**
   * Disposes the instantiated entries from the scene
   */
  dispose() {
    const rootNodes = this.rootNodes;
    for (const rootNode of rootNodes) {
      rootNode.dispose();
    }
    rootNodes.length = 0;
    const skeletons = this.skeletons;
    for (const skeleton of skeletons) {
      skeleton.dispose();
    }
    skeletons.length = 0;
    const animationGroups = this.animationGroups;
    for (const animationGroup of animationGroups) {
      animationGroup.dispose();
    }
    animationGroups.length = 0;
  }
};
var AssetContainer = class extends AbstractAssetContainer {
  /**
   * Instantiates an AssetContainer.
   * @param scene The scene the AssetContainer belongs to.
   */
  constructor(scene) {
    super();
    this._wasAddedToScene = false;
    scene = scene || EngineStore.LastCreatedScene;
    if (!scene) {
      return;
    }
    this.scene = scene;
    this["proceduralTextures"] = [];
    scene.onDisposeObservable.add(() => {
      if (!this._wasAddedToScene) {
        this.dispose();
      }
    });
    this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {
      for (const geometry of this.geometries) {
        geometry._rebuild();
      }
      for (const mesh of this.meshes) {
        mesh._rebuild();
      }
      for (const system of this.particleSystems) {
        system.rebuild();
      }
      for (const texture of this.textures) {
        texture._rebuild();
      }
    });
  }
  /**
   * Given a list of nodes, return a topological sorting of them.
   * @param nodes
   * @returns a sorted array of nodes
   */
  _topologicalSort(nodes) {
    const nodesUidMap = /* @__PURE__ */ new Map();
    for (const node of nodes) {
      nodesUidMap.set(node.uniqueId, node);
    }
    const dependencyGraph = {
      dependsOn: /* @__PURE__ */ new Map(),
      // given a node id, what are the ids of the nodes it depends on
      dependedBy: /* @__PURE__ */ new Map()
      // given a node id, what are the ids of the nodes that depend on it
    };
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      dependencyGraph.dependsOn.set(nodeId, /* @__PURE__ */ new Set());
      dependencyGraph.dependedBy.set(nodeId, /* @__PURE__ */ new Set());
    }
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      const dependsOn = dependencyGraph.dependsOn.get(nodeId);
      if (node instanceof InstancedMesh) {
        const masterMesh = node.sourceMesh;
        if (nodesUidMap.has(masterMesh.uniqueId)) {
          dependsOn.add(masterMesh.uniqueId);
          dependencyGraph.dependedBy.get(masterMesh.uniqueId).add(nodeId);
        }
      }
      const dependedBy = dependencyGraph.dependedBy.get(nodeId);
      for (const child of node.getDescendants()) {
        const childId = child.uniqueId;
        if (nodesUidMap.has(childId)) {
          dependedBy.add(childId);
          const childDependsOn = dependencyGraph.dependsOn.get(childId);
          childDependsOn.add(nodeId);
        }
      }
    }
    const sortedNodes = [];
    const leaves = [];
    for (const node of nodes) {
      const nodeId = node.uniqueId;
      if (dependencyGraph.dependsOn.get(nodeId).size === 0) {
        leaves.push(node);
        nodesUidMap.delete(nodeId);
      }
    }
    const visitList = leaves;
    while (visitList.length > 0) {
      const nodeToVisit = visitList.shift();
      sortedNodes.push(nodeToVisit);
      const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId);
      for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {
        const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId);
        dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);
        if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {
          visitList.push(nodesUidMap.get(dependedByVisitedNodeId));
          nodesUidMap.delete(dependedByVisitedNodeId);
        }
      }
    }
    if (nodesUidMap.size > 0) {
      Logger.Error("SceneSerializer._topologicalSort: There were unvisited nodes:");
      nodesUidMap.forEach((node) => {
        Logger.Error(node.name);
      });
    }
    return sortedNodes;
  }
  _addNodeAndDescendantsToList(list, addedIds, rootNode, predicate) {
    if (!rootNode || predicate && !predicate(rootNode) || addedIds.has(rootNode.uniqueId)) {
      return;
    }
    list.push(rootNode);
    addedIds.add(rootNode.uniqueId);
    for (const child of rootNode.getDescendants(true)) {
      this._addNodeAndDescendantsToList(list, addedIds, child, predicate);
    }
  }
  /**
   * Check if a specific node is contained in this asset container.
   * @param node the node to check
   * @returns true if the node is contained in this container, otherwise false.
   */
  _isNodeInContainer(node) {
    if (node instanceof AbstractMesh && this.meshes.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof Light && this.lights.indexOf(node) !== -1) {
      return true;
    }
    if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {
      return true;
    }
    return false;
  }
  /**
   * For every node in the scene, check if its parent node is also in the scene.
   * @returns true if every node's parent is also in the scene, otherwise false.
   */
  _isValidHierarchy() {
    for (const node of this.meshes) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.transformNodes) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.lights) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    for (const node of this.cameras) {
      if (node.parent && !this._isNodeInContainer(node.parent)) {
        Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
        return false;
      }
    }
    return true;
  }
  /**
   * Instantiate or clone all meshes and add the new ones to the scene.
   * Skeletons and animation groups will all be cloned
   * @param nameFunction defines an optional function used to get new names for clones
   * @param cloneMaterials defines an optional boolean that defines if materials must be cloned as well (false by default)
   * @param options defines an optional list of options to control how to instantiate / clone models
   * @param options.doNotInstantiate defines if the model must be instantiated or just cloned
   * @param options.predicate defines a predicate used to filter whih mesh to instantiate/clone
   * @returns a list of rootNodes, skeletons and animation groups that were duplicated
   */
  instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
    }
    const conversionMap = {};
    const storeMap = {};
    const result = new InstantiatedEntries();
    const alreadySwappedSkeletons = [];
    const alreadySwappedMaterials = [];
    const localOptions = {
      doNotInstantiate: true,
      ...options
    };
    const onClone = (source, clone) => {
      conversionMap[source.uniqueId] = clone.uniqueId;
      storeMap[clone.uniqueId] = clone;
      if (nameFunction) {
        clone.name = nameFunction(source.name);
      }
      if (clone instanceof Mesh) {
        const clonedMesh = clone;
        if (clonedMesh.morphTargetManager) {
          const oldMorphTargetManager = source.morphTargetManager;
          clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
          for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {
            const oldTarget = oldMorphTargetManager.getTarget(index);
            const newTarget = clonedMesh.morphTargetManager.getTarget(index);
            conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;
            storeMap[newTarget.uniqueId] = newTarget;
          }
        }
      }
    };
    const nodesToSort = [];
    const idsOnSortList = /* @__PURE__ */ new Set();
    for (const transformNode of this.transformNodes) {
      if (transformNode.parent === null) {
        this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);
      }
    }
    for (const mesh of this.meshes) {
      if (mesh.parent === null) {
        this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);
      }
    }
    const sortedNodes = this._topologicalSort(nodesToSort);
    const onNewCreated = (source, clone) => {
      onClone(source, clone);
      if (source.parent) {
        const replicatedParentId = conversionMap[source.parent.uniqueId];
        const replicatedParent = storeMap[replicatedParentId];
        if (replicatedParent) {
          clone.parent = replicatedParent;
        } else {
          clone.parent = source.parent;
        }
      }
      if (clone.position && source.position) {
        clone.position.copyFrom(source.position);
      }
      if (clone.rotationQuaternion && source.rotationQuaternion) {
        clone.rotationQuaternion.copyFrom(source.rotationQuaternion);
      }
      if (clone.rotation && source.rotation) {
        clone.rotation.copyFrom(source.rotation);
      }
      if (clone.scaling && source.scaling) {
        clone.scaling.copyFrom(source.scaling);
      }
      if (clone.material) {
        const mesh = clone;
        if (mesh.material) {
          if (cloneMaterials) {
            const sourceMaterial = source.material;
            if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
              let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
              alreadySwappedMaterials.push(sourceMaterial);
              conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;
              storeMap[swap.uniqueId] = swap;
              if (sourceMaterial.getClassName() === "MultiMaterial") {
                const multi = sourceMaterial;
                for (const material of multi.subMaterials) {
                  if (!material) {
                    continue;
                  }
                  swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                  alreadySwappedMaterials.push(material);
                  conversionMap[material.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                }
                multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);
              }
            }
            if (mesh.getClassName() !== "InstancedMesh") {
              mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];
            }
          } else {
            if (mesh.material.getClassName() === "MultiMaterial") {
              if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                this.scene.addMultiMaterial(mesh.material);
              }
            } else {
              if (this.scene.materials.indexOf(mesh.material) === -1) {
                this.scene.addMaterial(mesh.material);
              }
            }
          }
        }
      }
      if (clone.parent === null) {
        result.rootNodes.push(clone);
      }
    };
    for (const node of sortedNodes) {
      if (node.getClassName() === "InstancedMesh") {
        const instancedNode = node;
        const sourceMesh = instancedNode.sourceMesh;
        const replicatedSourceId = conversionMap[sourceMesh.uniqueId];
        const replicatedSource = typeof replicatedSourceId === "number" ? storeMap[replicatedSourceId] : sourceMesh;
        const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);
        onNewCreated(instancedNode, replicatedInstancedNode);
      } else {
        let canInstance = true;
        if (node.getClassName() === "TransformNode" || node.getClassName() === "Node" || node.skeleton || !node.getTotalVertices || node.getTotalVertices() === 0) {
          canInstance = false;
        } else if (localOptions.doNotInstantiate) {
          if (typeof localOptions.doNotInstantiate === "function") {
            canInstance = !localOptions.doNotInstantiate(node);
          } else {
            canInstance = !localOptions.doNotInstantiate;
          }
        }
        const replicatedNode = canInstance ? node.createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);
        if (!replicatedNode) {
          throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);
        }
        onNewCreated(node, replicatedNode);
      }
    }
    for (const s of this.skeletons) {
      if (localOptions.predicate && !localOptions.predicate(s)) {
        continue;
      }
      const clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
      for (const m of this.meshes) {
        if (m.skeleton === s && !m.isAnInstance) {
          const copy = storeMap[conversionMap[m.uniqueId]];
          if (!copy || copy.isAnInstance) {
            continue;
          }
          copy.skeleton = clone;
          if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
            continue;
          }
          alreadySwappedSkeletons.push(clone);
          for (const bone of clone.bones) {
            if (bone._linkedTransformNode) {
              bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];
            }
          }
        }
      }
      result.skeletons.push(clone);
    }
    for (const o of this.animationGroups) {
      if (localOptions.predicate && !localOptions.predicate(o)) {
        continue;
      }
      const clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, (oldTarget) => {
        const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];
        return newTarget || oldTarget;
      });
      result.animationGroups.push(clone);
    }
    return result;
  }
  /**
   * Adds all the assets from the container to the scene.
   */
  addAllToScene() {
    if (this._wasAddedToScene) {
      return;
    }
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.");
    }
    this._wasAddedToScene = true;
    this.addToScene(null);
    if (this.environmentTexture) {
      this.scene.environmentTexture = this.environmentTexture;
    }
    for (const component of this.scene._serializableComponents) {
      component.addFromContainer(this);
    }
    this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
    this._onContextRestoredObserver = null;
  }
  /**
   * Adds assets from the container to the scene.
   * @param predicate defines a predicate used to select which entity will be added (can be null)
   */
  addToScene(predicate = null) {
    const addedNodes = [];
    for (const o of this.cameras) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addCamera(o);
      addedNodes.push(o);
    }
    for (const o of this.lights) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addLight(o);
      addedNodes.push(o);
    }
    for (const o of this.meshes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addMesh(o);
      addedNodes.push(o);
    }
    for (const o of this.skeletons) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addSkeleton(o);
    }
    for (const o of this.animations) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addAnimation(o);
    }
    for (const o of this.animationGroups) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addAnimationGroup(o);
    }
    for (const o of this.multiMaterials) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addMultiMaterial(o);
    }
    for (const o of this.materials) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addMaterial(o);
    }
    for (const o of this.morphTargetManagers) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addMorphTargetManager(o);
    }
    for (const o of this.geometries) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addGeometry(o);
    }
    for (const o of this.transformNodes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addTransformNode(o);
      addedNodes.push(o);
    }
    for (const o of this.actionManagers) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addActionManager(o);
    }
    for (const o of this.textures) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addTexture(o);
    }
    for (const o of this.reflectionProbes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.addReflectionProbe(o);
    }
    if (addedNodes.length) {
      const nodeSet = new Set(this.scene.meshes);
      for (const light of this.scene.lights) {
        nodeSet.add(light);
      }
      for (const camera of this.scene.cameras) {
        nodeSet.add(camera);
      }
      for (const transformNode of this.scene.transformNodes) {
        nodeSet.add(transformNode);
      }
      for (const skeleton of this.skeletons) {
        for (const bone of skeleton.bones) {
          nodeSet.add(bone);
        }
      }
      for (const addedNode of addedNodes) {
        if (addedNode.parent && !nodeSet.has(addedNode.parent)) {
          if (addedNode.setParent) {
            addedNode.setParent(null);
          } else {
            addedNode.parent = null;
          }
        }
      }
    }
  }
  /**
   * Removes all the assets in the container from the scene
   */
  removeAllFromScene() {
    if (!this._isValidHierarchy()) {
      Tools.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.");
    }
    this._wasAddedToScene = false;
    this.removeFromScene(null);
    if (this.environmentTexture === this.scene.environmentTexture) {
      this.scene.environmentTexture = null;
    }
    for (const component of this.scene._serializableComponents) {
      component.removeFromContainer(this);
    }
  }
  /**
   * Removes assets in the container from the scene
   * @param predicate defines a predicate used to select which entity will be added (can be null)
   */
  removeFromScene(predicate = null) {
    for (const o of this.cameras) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeCamera(o);
    }
    for (const o of this.lights) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeLight(o);
    }
    for (const o of this.meshes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeMesh(o, true);
    }
    for (const o of this.skeletons) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeSkeleton(o);
    }
    for (const o of this.animations) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeAnimation(o);
    }
    for (const o of this.animationGroups) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeAnimationGroup(o);
    }
    for (const o of this.multiMaterials) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeMultiMaterial(o);
    }
    for (const o of this.materials) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeMaterial(o);
    }
    for (const o of this.morphTargetManagers) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeMorphTargetManager(o);
    }
    for (const o of this.geometries) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeGeometry(o);
    }
    for (const o of this.transformNodes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeTransformNode(o);
    }
    for (const o of this.actionManagers) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeActionManager(o);
    }
    for (const o of this.textures) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeTexture(o);
    }
    for (const o of this.reflectionProbes) {
      if (predicate && !predicate(o)) {
        continue;
      }
      this.scene.removeReflectionProbe(o);
    }
  }
  /**
   * Disposes all the assets in the container
   */
  dispose() {
    const cameras = this.cameras.slice(0);
    for (const camera of cameras) {
      camera.dispose();
    }
    this.cameras.length = 0;
    const lights = this.lights.slice(0);
    for (const light of lights) {
      light.dispose();
    }
    this.lights.length = 0;
    const meshes = this.meshes.slice(0);
    for (const mesh of meshes) {
      mesh.dispose();
    }
    this.meshes.length = 0;
    const skeletons = this.skeletons.slice(0);
    for (const skeleton of skeletons) {
      skeleton.dispose();
    }
    this.skeletons.length = 0;
    const animationGroups = this.animationGroups.slice(0);
    for (const animationGroup of animationGroups) {
      animationGroup.dispose();
    }
    this.animationGroups.length = 0;
    const multiMaterials = this.multiMaterials.slice(0);
    for (const multiMaterial of multiMaterials) {
      multiMaterial.dispose();
    }
    this.multiMaterials.length = 0;
    const materials = this.materials.slice(0);
    for (const material of materials) {
      material.dispose();
    }
    this.materials.length = 0;
    const geometries = this.geometries.slice(0);
    for (const geometry of geometries) {
      geometry.dispose();
    }
    this.geometries.length = 0;
    const transformNodes = this.transformNodes.slice(0);
    for (const transformNode of transformNodes) {
      transformNode.dispose();
    }
    this.transformNodes.length = 0;
    const actionManagers = this.actionManagers.slice(0);
    for (const actionManager of actionManagers) {
      actionManager.dispose();
    }
    this.actionManagers.length = 0;
    const textures = this.textures.slice(0);
    for (const texture of textures) {
      texture.dispose();
    }
    this.textures.length = 0;
    const reflectionProbes = this.reflectionProbes.slice(0);
    for (const reflectionProbe of reflectionProbes) {
      reflectionProbe.dispose();
    }
    this.reflectionProbes.length = 0;
    const morphTargetManagers = this.morphTargetManagers.slice(0);
    for (const morphTargetManager of morphTargetManagers) {
      morphTargetManager.dispose();
    }
    this.morphTargetManagers.length = 0;
    if (this.environmentTexture) {
      this.environmentTexture.dispose();
      this.environmentTexture = null;
    }
    for (const component of this.scene._serializableComponents) {
      component.removeFromContainer(this, true);
    }
    if (this._onContextRestoredObserver) {
      this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
      this._onContextRestoredObserver = null;
    }
  }
  _moveAssets(sourceAssets, targetAssets, keepAssets) {
    if (!sourceAssets || !targetAssets) {
      return;
    }
    for (const asset of sourceAssets) {
      let move = true;
      if (keepAssets) {
        for (const keepAsset of keepAssets) {
          if (asset === keepAsset) {
            move = false;
            break;
          }
        }
      }
      if (move) {
        targetAssets.push(asset);
        asset._parentContainer = this;
      }
    }
  }
  /**
   * Removes all the assets contained in the scene and adds them to the container.
   * @param keepAssets Set of assets to keep in the scene. (default: empty)
   */
  moveAllFromScene(keepAssets) {
    this._wasAddedToScene = false;
    if (keepAssets === void 0) {
      keepAssets = new KeepAssets();
    }
    for (const key in this) {
      if (Object.prototype.hasOwnProperty.call(this, key)) {
        this[key] = this[key] || (key === "_environmentTexture" ? null : []);
        this._moveAssets(this.scene[key], this[key], keepAssets[key]);
      }
    }
    this.environmentTexture = this.scene.environmentTexture;
    this.removeAllFromScene();
  }
  /**
   * Adds all meshes in the asset container to a root mesh that can be used to position all the contained meshes. The root mesh is then added to the front of the meshes in the assetContainer.
   * @returns the root mesh
   */
  createRootMesh() {
    const rootMesh = new Mesh("assetContainerRootMesh", this.scene);
    for (const m of this.meshes) {
      if (!m.parent) {
        rootMesh.addChild(m);
      }
    }
    this.meshes.unshift(rootMesh);
    return rootMesh;
  }
  /**
   * Merge animations (direct and animation groups) from this asset container into a scene
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param animatables set of animatables to retarget to a node from the scene
   * @param targetConverter defines a function used to convert animation targets from the asset container to the scene (default: search node by name)
   * @returns an array of the new AnimationGroup added to the scene (empty array if none)
   */
  mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {
    if (!scene) {
      Logger.Error("No scene available to merge animations to");
      return [];
    }
    const _targetConverter = targetConverter ? targetConverter : (target) => {
      let node = null;
      const targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
      const name = target.name.split(".").join("").split("_primitive")[0];
      switch (targetProperty) {
        case "position":
        case "rotationQuaternion":
          node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name);
          break;
        case "influence":
          node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name);
          break;
        default:
          node = scene.getNodeByName(target.name) || scene.getNodeByName(name);
      }
      return node;
    };
    const nodesInAC = this.getNodes();
    for (const nodeInAC of nodesInAC) {
      const nodeInScene = _targetConverter(nodeInAC);
      if (nodeInScene !== null) {
        for (const animationInAC of nodeInAC.animations) {
          const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {
            return animationInScene.targetProperty === animationInAC.targetProperty;
          });
          for (const animationWithSameProperty of animationsWithSameProperty) {
            const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
            if (index > -1) {
              nodeInScene.animations.splice(index, 1);
            }
          }
        }
        nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
      }
    }
    const newAnimationGroups = [];
    const animationGroups = this.animationGroups.slice();
    for (const animationGroupInAC of animationGroups) {
      newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
      for (const animatable of animationGroupInAC.animatables) {
        animatable.stop();
      }
    }
    for (const animatable of animatables) {
      const target = _targetConverter(animatable.target);
      if (target) {
        scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
        scene.stopAnimation(animatable.target);
      }
    }
    return newAnimationGroups;
  }
  /**
   * @since 6.15.0
   * This method checks for any node that has no parent
   * and is not in the rootNodes array, and adds the node
   * there, if so.
   */
  populateRootNodes() {
    this.rootNodes.length = 0;
    for (const m of this.meshes) {
      if (!m.parent && this.rootNodes.indexOf(m) === -1) {
        this.rootNodes.push(m);
      }
    }
    for (const t of this.transformNodes) {
      if (!t.parent && this.rootNodes.indexOf(t) === -1) {
        this.rootNodes.push(t);
      }
    }
    for (const l of this.lights) {
      if (!l.parent && this.rootNodes.indexOf(l) === -1) {
        this.rootNodes.push(l);
      }
    }
    for (const c of this.cameras) {
      if (!c.parent && this.rootNodes.indexOf(c) === -1) {
        this.rootNodes.push(c);
      }
    }
  }
  /**
   * @since 6.26.0
   * Given a root asset, this method will traverse its hierarchy and add it, its children and any materials/skeletons/animation groups to the container.
   * @param root root node
   */
  addAllAssetsToContainer(root) {
    if (!root) {
      return;
    }
    const nodesToVisit = [];
    const visitedNodes = /* @__PURE__ */ new Set();
    nodesToVisit.push(root);
    while (nodesToVisit.length > 0) {
      const nodeToVisit = nodesToVisit.pop();
      if (nodeToVisit instanceof Mesh) {
        if (nodeToVisit.geometry && this.geometries.indexOf(nodeToVisit.geometry) === -1) {
          this.geometries.push(nodeToVisit.geometry);
        }
        this.meshes.push(nodeToVisit);
      } else if (nodeToVisit instanceof InstancedMesh) {
        this.meshes.push(nodeToVisit);
      } else if (nodeToVisit instanceof TransformNode) {
        this.transformNodes.push(nodeToVisit);
      } else if (nodeToVisit instanceof Light) {
        this.lights.push(nodeToVisit);
      } else if (nodeToVisit instanceof Camera) {
        this.cameras.push(nodeToVisit);
      }
      if (nodeToVisit instanceof AbstractMesh) {
        if (nodeToVisit.material && this.materials.indexOf(nodeToVisit.material) === -1) {
          this.materials.push(nodeToVisit.material);
          for (const texture of nodeToVisit.material.getActiveTextures()) {
            if (this.textures.indexOf(texture) === -1) {
              this.textures.push(texture);
            }
          }
        }
        if (nodeToVisit.skeleton && this.skeletons.indexOf(nodeToVisit.skeleton) === -1) {
          this.skeletons.push(nodeToVisit.skeleton);
        }
        if (nodeToVisit.morphTargetManager && this.morphTargetManagers.indexOf(nodeToVisit.morphTargetManager) === -1) {
          this.morphTargetManagers.push(nodeToVisit.morphTargetManager);
        }
      }
      for (const child of nodeToVisit.getChildren()) {
        if (!visitedNodes.has(child)) {
          nodesToVisit.push(child);
        }
      }
      visitedNodes.add(nodeToVisit);
    }
    this.populateRootNodes();
  }
  /**
   * Get from a list of objects by tags
   * @param list the list of objects to use
   * @param tagsQuery the query to use
   * @param filter a predicate to filter for tags
   * @returns
   */
  _getByTags(list, tagsQuery, filter) {
    if (tagsQuery === void 0) {
      return list;
    }
    const listByTags = [];
    for (const i in list) {
      const item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery) && (!filter || filter(item))) {
        listByTags.push(item);
      }
    }
    return listByTags;
  }
  /**
   * Get a list of meshes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Mesh
   */
  getMeshesByTags(tagsQuery, filter) {
    return this._getByTags(this.meshes, tagsQuery, filter);
  }
  /**
   * Get a list of cameras by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Camera
   */
  getCamerasByTags(tagsQuery, filter) {
    return this._getByTags(this.cameras, tagsQuery, filter);
  }
  /**
   * Get a list of lights by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Light
   */
  getLightsByTags(tagsQuery, filter) {
    return this._getByTags(this.lights, tagsQuery, filter);
  }
  /**
   * Get a list of materials by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of Material
   */
  getMaterialsByTags(tagsQuery, filter) {
    return this._getByTags(this.materials, tagsQuery, filter).concat(this._getByTags(this.multiMaterials, tagsQuery, filter));
  }
  /**
   * Get a list of transform nodes by tags
   * @param tagsQuery defines the tags query to use
   * @param filter defines a predicate used to filter results
   * @returns an array of TransformNode
   */
  getTransformNodesByTags(tagsQuery, filter) {
    return this._getByTags(this.transformNodes, tagsQuery, filter);
  }
};

// node_modules/@babylonjs/core/Misc/webRequest.fetch.js
async function _FetchAsync(url, options) {
  const method = options.method || "GET";
  return await new Promise((resolve, reject) => {
    const request = new WebRequest();
    request.addEventListener("readystatechange", () => {
      if (request.readyState == 4) {
        if (request.status == 200) {
          const headerValues = {};
          if (options.responseHeaders) {
            for (const header of options.responseHeaders) {
              headerValues[header] = request.getResponseHeader(header) || "";
            }
          }
          resolve({ response: request.response, headerValues });
        } else {
          reject(`Unable to fetch data from ${url}. Error code: ${request.status}`);
        }
      }
    });
    request.open(method, url);
    request.send();
  });
}

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode;
(function(SceneLoaderAnimationGroupLoadingMode2) {
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
  SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
})(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
function IsFactory(pluginOrFactory) {
  return !!pluginOrFactory.createPlugin;
}
function isFile(value) {
  return !!value.name;
}
var onPluginActivatedObservable = new Observable();
var registeredPlugins = {};
var showingLoadingScreen = false;
function getDefaultPlugin() {
  return registeredPlugins[".babylon"];
}
function getPluginForMimeType(mimeType) {
  for (const registeredPluginKey in registeredPlugins) {
    const registeredPlugin = registeredPlugins[registeredPluginKey];
    if (registeredPlugin.mimeType === mimeType) {
      return registeredPlugin;
    }
  }
  return void 0;
}
function getPluginForExtension(extension, returnDefault) {
  const registeredPlugin = registeredPlugins[extension];
  if (registeredPlugin) {
    return registeredPlugin;
  }
  Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes");
  return returnDefault ? getDefaultPlugin() : void 0;
}
function isPluginForExtensionAvailable(extension) {
  return !!registeredPlugins[extension];
}
function getPluginForDirectLoad(data) {
  for (const extension in registeredPlugins) {
    const plugin = registeredPlugins[extension].plugin;
    if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
      return registeredPlugins[extension];
    }
  }
  return getDefaultPlugin();
}
function getFilenameExtension(sceneFilename) {
  const queryStringPosition = sceneFilename.indexOf("?");
  if (queryStringPosition !== -1) {
    sceneFilename = sceneFilename.substring(0, queryStringPosition);
  }
  const dotPosition = sceneFilename.lastIndexOf(".");
  return sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
}
function getDirectLoad(sceneFilename) {
  if (sceneFilename.substring(0, 5) === "data:") {
    return sceneFilename.substring(5);
  }
  return null;
}
function formatErrorMessage(fileInfo, message, exception) {
  const fromLoad = fileInfo.rawData ? "binary data" : fileInfo.url;
  let errorMessage = "Unable to load from " + fromLoad;
  if (message) {
    errorMessage += `: ${message}`;
  } else if (exception) {
    errorMessage += `: ${exception}`;
  }
  return errorMessage;
}
async function loadDataAsync(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name, pluginOptions) {
  const directLoad = getDirectLoad(fileInfo.url);
  if (fileInfo.rawData && !pluginExtension) {
    throw "When using ArrayBufferView to load data the file extension must be provided.";
  }
  const fileExtension = !directLoad && !pluginExtension ? getFilenameExtension(fileInfo.url) : "";
  let registeredPlugin = pluginExtension ? getPluginForExtension(pluginExtension, true) : directLoad ? getPluginForDirectLoad(fileInfo.url) : getPluginForExtension(fileExtension, false);
  if (!registeredPlugin && fileExtension) {
    if (fileInfo.url && !fileInfo.url.startsWith("blob:")) {
      const response = await _FetchAsync(fileInfo.url, { method: "HEAD", responseHeaders: ["Content-Type"] });
      const mimeType = response.headerValues ? response.headerValues["Content-Type"] : "";
      if (mimeType) {
        registeredPlugin = getPluginForMimeType(mimeType);
      }
    }
    if (!registeredPlugin) {
      registeredPlugin = getDefaultPlugin();
    }
  }
  if (!registeredPlugin) {
    throw new Error(`No plugin or fallback for ${pluginExtension ?? fileInfo.url}`);
  }
  if (pluginOptions?.[registeredPlugin.plugin.name]?.enabled === false) {
    throw new Error(`The '${registeredPlugin.plugin.name}' plugin is disabled via the loader options passed to the loading operation.`);
  }
  if (fileInfo.rawData && !registeredPlugin.isBinary) {
    throw "Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";
  }
  const getPluginInstance = (callback) => {
    if (IsFactory(registeredPlugin.plugin)) {
      const pluginFactory = registeredPlugin.plugin;
      const partialPlugin = pluginFactory.createPlugin(pluginOptions ?? {});
      if (partialPlugin instanceof Promise) {
        partialPlugin.then(callback).catch((error) => {
          onError("Error instantiating plugin.", error);
        });
        return null;
      } else {
        callback(partialPlugin);
        return partialPlugin;
      }
    } else {
      callback(registeredPlugin.plugin);
      return registeredPlugin.plugin;
    }
  };
  return getPluginInstance((plugin) => {
    if (!plugin) {
      throw `The loader plugin corresponding to the '${pluginExtension}' file type has not been found. If using es6, please import the plugin you wish to use before.`;
    }
    onPluginActivatedObservable.notifyObservers(plugin);
    if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
      if (plugin.directLoad) {
        const result = plugin.directLoad(scene, directLoad);
        if (result instanceof Promise) {
          result.then((data) => {
            onSuccess(plugin, data);
          }).catch((error) => {
            onError("Error in directLoad of _loadData: " + error, error);
          });
        } else {
          onSuccess(plugin, result);
        }
      } else {
        onSuccess(plugin, directLoad);
      }
      return;
    }
    const useArrayBuffer = registeredPlugin.isBinary;
    const dataCallback = (data, responseURL) => {
      if (scene.isDisposed) {
        onError("Scene has been disposed");
        return;
      }
      onSuccess(plugin, data, responseURL);
    };
    let request = null;
    let pluginDisposed = false;
    plugin.onDisposeObservable?.add(() => {
      pluginDisposed = true;
      if (request) {
        request.abort();
        request = null;
      }
      onDispose();
    });
    const manifestChecked = () => {
      if (pluginDisposed) {
        return;
      }
      const errorCallback = (request2, exception) => {
        onError(request2?.statusText, exception);
      };
      if (!plugin.loadFile && fileInfo.rawData) {
        throw "Plugin does not support loading ArrayBufferView.";
      }
      request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
    };
    const engine = scene.getEngine();
    let canUseOfflineSupport = engine.enableOfflineSupport;
    if (canUseOfflineSupport) {
      let exceptionFound = false;
      for (const regex of scene.disableOfflineSupportExceptionRules) {
        if (regex.test(fileInfo.url)) {
          exceptionFound = true;
          break;
        }
      }
      canUseOfflineSupport = !exceptionFound;
    }
    if (canUseOfflineSupport && AbstractEngine.OfflineProviderFactory) {
      scene.offlineProvider = AbstractEngine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
    } else {
      manifestChecked();
    }
  });
}
function GetFileInfo(rootUrl, sceneSource) {
  let url;
  let name;
  let file = null;
  let rawData = null;
  if (!sceneSource) {
    url = rootUrl;
    name = Tools.GetFilename(rootUrl);
    rootUrl = Tools.GetFolderPath(rootUrl);
  } else if (isFile(sceneSource)) {
    url = `file:${sceneSource.name}`;
    name = sceneSource.name;
    file = sceneSource;
  } else if (ArrayBuffer.isView(sceneSource)) {
    url = "";
    name = RandomGUID();
    rawData = sceneSource;
  } else if (sceneSource.startsWith("data:")) {
    url = sceneSource;
    name = "";
  } else if (rootUrl) {
    const filename = sceneSource;
    if (filename.substring(0, 1) === "/") {
      Tools.Error("Wrong sceneFilename parameter");
      return null;
    }
    url = rootUrl + filename;
    name = filename;
  } else {
    url = sceneSource;
    name = Tools.GetFilename(sceneSource);
    rootUrl = Tools.GetFolderPath(sceneSource);
  }
  return {
    url,
    rootUrl,
    name,
    file,
    rawData
  };
}
function RegisterSceneLoaderPlugin(plugin) {
  if (typeof plugin.extensions === "string") {
    const extension = plugin.extensions;
    registeredPlugins[extension.toLowerCase()] = {
      plugin,
      isBinary: false
    };
  } else {
    const extensions = plugin.extensions;
    const keys = Object.keys(extensions);
    for (const extension of keys) {
      registeredPlugins[extension.toLowerCase()] = {
        plugin,
        isBinary: extensions[extension].isBinary,
        mimeType: extensions[extension].mimeType
      };
    }
  }
}
function registerSceneLoaderPlugin(plugin) {
  RegisterSceneLoaderPlugin(plugin);
}
function GetRegisteredSceneLoaderPluginMetadata() {
  return Array.from(Object.entries(registeredPlugins).reduce((pluginMap, [extension, extensionRegistration]) => {
    let pluginMetadata = pluginMap.get(extensionRegistration.plugin.name);
    if (!pluginMetadata) {
      pluginMap.set(extensionRegistration.plugin.name, pluginMetadata = []);
    }
    pluginMetadata.push({ extension, isBinary: extensionRegistration.isBinary, mimeType: extensionRegistration.mimeType });
    return pluginMap;
  }, /* @__PURE__ */ new Map())).map(([name, extensions]) => ({ name, extensions }));
}
async function ImportMeshAsync(source, scene, options) {
  const { meshNames, rootUrl = "", onProgress, pluginExtension, name, pluginOptions } = options ?? {};
  return await importMeshAsyncCoreAsync(meshNames, rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);
}
async function importMeshAsync(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to import mesh to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback: " + e, e);
    }
  } : void 0;
  const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
    scene.importedMeshesFiles.push(fileInfo.url);
    if (onSuccess) {
      try {
        onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers);
      } catch (e) {
        errorHandler("Error in onSuccess callback: " + e, e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data, responseURL) => {
    if (plugin.rewriteRootURL) {
      fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
    }
    if (plugin.importMesh) {
      const syncedPlugin = plugin;
      const meshes = [];
      const particleSystems = [];
      const skeletons = [];
      if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
        return;
      }
      scene.loadingPluginName = plugin.name;
      successHandler(meshes, particleSystems, skeletons, [], [], [], [], []);
    } else {
      const asyncedPlugin = plugin;
      asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {
        scene.loadingPluginName = plugin.name;
        successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights, result.spriteManagers);
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name, pluginOptions);
}
async function importMeshAsyncCoreAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      importMeshAsync(
        meshNames,
        rootUrl,
        sceneFilename,
        scene,
        (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights, spriteManagers) => {
          resolve({
            meshes,
            particleSystems,
            skeletons,
            animationGroups,
            transformNodes,
            geometries,
            lights,
            spriteManagers
          });
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function loadSceneImplAsync(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "", pluginOptions = {}) {
  if (!engine) {
    Tools.Error("No engine available");
    return;
  }
  await appendSceneImplAsync(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name, pluginOptions);
}
async function LoadSceneAsync(source, engine, options) {
  const { rootUrl = "", onProgress, pluginExtension, name, pluginOptions } = options ?? {};
  return await loadSceneSharedAsync(rootUrl, source, engine, onProgress, pluginExtension, name, pluginOptions);
}
async function loadSceneAsync(source, engine, options) {
  return await LoadSceneAsync(source, engine, options);
}
async function loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name, pluginOptions) {
  return await new Promise((resolve, reject) => {
    loadSceneImplAsync(rootUrl, sceneFilename, engine, (scene) => {
      resolve(scene);
    }, onProgress, (scene, message, exception) => {
      reject(exception || new Error(message));
    }, pluginExtension, name, pluginOptions);
  });
}
async function appendSceneImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to append to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  if (SceneLoaderFlags.ShowLoadingScreen && !showingLoadingScreen) {
    showingLoadingScreen = true;
    scene.getEngine().displayLoadingUI();
    scene.executeWhenReady(() => {
      scene.getEngine().hideLoadingUI();
      showingLoadingScreen = false;
    });
  }
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback", e);
    }
  } : void 0;
  const successHandler = () => {
    if (onSuccess) {
      try {
        onSuccess(scene);
      } catch (e) {
        errorHandler("Error in onSuccess callback", e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data) => {
    if (plugin.load) {
      const syncedPlugin = plugin;
      if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
        return;
      }
      scene.loadingPluginName = plugin.name;
      successHandler();
    } else {
      const asyncedPlugin = plugin;
      asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {
        scene.loadingPluginName = plugin.name;
        successHandler();
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name, pluginOptions);
}
async function AppendSceneAsync(source, scene, options) {
  const { rootUrl = "", onProgress, pluginExtension, name, pluginOptions } = options ?? {};
  await appendSceneSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);
}
async function appendSceneAsync(source, scene, options) {
  return await AppendSceneAsync(source, scene, options);
}
async function appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      appendSceneImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        (scene2) => {
          resolve(scene2);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function loadAssetContainerImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to load asset container to");
    return null;
  }
  const fileInfo = GetFileInfo(rootUrl, sceneFilename);
  if (!fileInfo) {
    return null;
  }
  const loadingToken = {};
  scene.addPendingData(loadingToken);
  const disposeHandler = () => {
    scene.removePendingData(loadingToken);
  };
  const errorHandler = (message, exception) => {
    const errorMessage = formatErrorMessage(fileInfo, message, exception);
    if (onError) {
      onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
    } else {
      Logger.Error(errorMessage);
    }
    disposeHandler();
  };
  const progressHandler = onProgress ? (event) => {
    try {
      onProgress(event);
    } catch (e) {
      errorHandler("Error in onProgress callback", e);
    }
  } : void 0;
  const successHandler = (assets) => {
    if (onSuccess) {
      try {
        onSuccess(assets);
      } catch (e) {
        errorHandler("Error in onSuccess callback", e);
      }
    }
    scene.removePendingData(loadingToken);
  };
  return await loadDataAsync(fileInfo, scene, (plugin, data) => {
    if (plugin.loadAssetContainer) {
      const syncedPlugin = plugin;
      const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
      if (!assetContainer) {
        return;
      }
      assetContainer.populateRootNodes();
      scene.loadingPluginName = plugin.name;
      successHandler(assetContainer);
    } else if (plugin.loadAssetContainerAsync) {
      const asyncedPlugin = plugin;
      asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {
        assetContainer.populateRootNodes();
        scene.loadingPluginName = plugin.name;
        successHandler(assetContainer);
      }).catch((error) => {
        errorHandler(error.message, error);
      });
    } else {
      errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
    }
  }, progressHandler, errorHandler, disposeHandler, pluginExtension, name, pluginOptions);
}
async function LoadAssetContainerAsync(source, scene, options) {
  const { rootUrl = "", onProgress, pluginExtension, name, pluginOptions } = options ?? {};
  return await loadAssetContainerSharedAsync(rootUrl, source, scene, onProgress, pluginExtension, name, pluginOptions);
}
async function loadAssetContainerAsync(source, scene, options) {
  return await LoadAssetContainerAsync(source, scene, options);
}
async function loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      loadAssetContainerImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        (assets) => {
          resolve(assets);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
async function importAnimationsImplAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = 0, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name = "", pluginOptions = {}) {
  if (!scene) {
    Logger.Error("No scene available to load animations to");
    return;
  }
  if (overwriteAnimations) {
    for (const animatable of scene.animatables) {
      animatable.reset();
    }
    scene.stopAllAnimations();
    const animationGroups = scene.animationGroups.slice();
    for (const animationGroup of animationGroups) {
      animationGroup.dispose();
    }
    const nodes = scene.getNodes();
    for (const node of nodes) {
      if (node.animations) {
        node.animations = [];
      }
    }
  } else {
    switch (animationGroupLoadingMode) {
      case 0:
        const animationGroups = scene.animationGroups.slice();
        for (const animationGroup of animationGroups) {
          animationGroup.dispose();
        }
        break;
      case 1:
        for (const animationGroup of scene.animationGroups) {
          animationGroup.stop();
        }
        break;
      case 2:
        for (const animationGroup of scene.animationGroups) {
          animationGroup.reset();
          animationGroup.restart();
        }
        break;
      case 3:
        break;
      default:
        Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
        return;
    }
  }
  const startingIndexForNewAnimatables = scene.animatables.length;
  const onAssetContainerLoaded = (container) => {
    container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
    container.dispose();
    scene.onAnimationFileImportedObservable.notifyObservers(scene);
    if (onSuccess) {
      onSuccess(scene);
    }
  };
  await loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension, name, pluginOptions);
}
async function ImportAnimationsAsync(source, scene, options) {
  const { rootUrl = "", overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions } = options ?? {};
  await importAnimationsSharedAsync(rootUrl, source, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions);
}
async function importAnimationsAsync(source, scene, options) {
  return await ImportAnimationsAsync(source, scene, options);
}
async function importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name, pluginOptions) {
  return await new Promise((resolve, reject) => {
    try {
      importAnimationsImplAsync(
        rootUrl,
        sceneFilename,
        scene,
        overwriteAnimations,
        animationGroupLoadingMode,
        targetConverter,
        (scene2) => {
          resolve(scene2);
        },
        onProgress,
        (scene2, message, exception) => {
          reject(exception || new Error(message));
        },
        pluginExtension,
        name,
        pluginOptions
        // eslint-disable-next-line github/no-then
      ).catch(reject);
    } catch (error) {
      reject(error);
    }
  });
}
var SceneLoader = class {
  /**
   * Gets or sets a boolean indicating if entire scene must be loaded even if scene contains incremental data
   */
  static get ForceFullSceneLoadingForIncremental() {
    return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(value) {
    SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
  }
  /**
   * Gets or sets a boolean indicating if loading screen must be displayed while loading a scene
   */
  static get ShowLoadingScreen() {
    return SceneLoaderFlags.ShowLoadingScreen;
  }
  static set ShowLoadingScreen(value) {
    SceneLoaderFlags.ShowLoadingScreen = value;
  }
  /**
   * Defines the current logging level (while loading the scene)
   * @ignorenaming
   */
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static get loggingLevel() {
    return SceneLoaderFlags.loggingLevel;
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  static set loggingLevel(value) {
    SceneLoaderFlags.loggingLevel = value;
  }
  /**
   * Gets or set a boolean indicating if matrix weights must be cleaned upon loading
   */
  static get CleanBoneMatrixWeights() {
    return SceneLoaderFlags.CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(value) {
    SceneLoaderFlags.CleanBoneMatrixWeights = value;
  }
  /**
   * Gets the default plugin (used to load Babylon files)
   * @returns the .babylon plugin
   */
  static GetDefaultPlugin() {
    return getDefaultPlugin();
  }
  // Public functions
  /**
   * Gets a plugin that can load the given extension
   * @param extension defines the extension to load
   * @returns a plugin or null if none works
   */
  static GetPluginForExtension(extension) {
    return getPluginForExtension(extension, true)?.plugin;
  }
  /**
   * Gets a boolean indicating that the given extension can be loaded
   * @param extension defines the extension to load
   * @returns true if the extension is supported
   */
  static IsPluginForExtensionAvailable(extension) {
    return isPluginForExtensionAvailable(extension);
  }
  /**
   * Adds a new plugin to the list of registered plugins
   * @param plugin defines the plugin to add
   */
  static RegisterPlugin(plugin) {
    RegisterSceneLoaderPlugin(plugin);
  }
  /**
   * Import meshes into a scene
   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene the instance of BABYLON.Scene to append to
   * @param onSuccess a callback with a list of imported meshes, particleSystems, skeletons, and animationGroups when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @param pluginOptions defines the options to use with the plugin
   * @deprecated Please use the module level {@link ImportMeshAsync} instead
   */
  static ImportMesh(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name, pluginOptions) {
    importMeshAsync(meshNames, rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name, pluginOptions).catch((error) => onError?.(EngineStore.LastCreatedScene, error?.message, error));
  }
  /**
   * Import meshes into a scene
   * @param meshNames an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene the instance of BABYLON.Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file
   * @returns The loaded list of imported meshes, particle systems, skeletons, and animation groups
   * @deprecated Please use the module level {@link ImportMeshAsync} instead
   */
  static async ImportMeshAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name) {
    return await importMeshAsyncCoreAsync(meshNames, rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);
  }
  /**
   * Load a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param engine is the instance of BABYLON.Engine to use to create the scene
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @deprecated Please use the module level {@link LoadSceneAsync} instead
   */
  static Load(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name) {
    loadSceneImplAsync(rootUrl, sceneFilename, engine, onSuccess, onProgress, onError, pluginExtension, name).catch((error) => onError?.(EngineStore.LastCreatedScene, error?.message, error));
  }
  /**
   * Load a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param engine is the instance of BABYLON.Engine to use to create the scene
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns The loaded scene
   * @deprecated Please use the module level {@link LoadSceneAsync} instead
   */
  static async LoadAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name) {
    return await loadSceneSharedAsync(rootUrl, sceneFilename, engine, onProgress, pluginExtension, name);
  }
  /**
   * Append a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @deprecated Please use the module level {@link AppendSceneAsync} instead
   */
  static Append(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name) {
    appendSceneImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
  }
  /**
   * Append a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the name of the file, if the data is binary
   * @returns The given scene
   * @deprecated Please use the module level {@link AppendSceneAsync} instead
   */
  static async AppendAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name) {
    return await appendSceneSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);
  }
  /**
   * Load a scene into an asset container
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead
   */
  static LoadAssetContainer(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name) {
    loadAssetContainerImplAsync(rootUrl, sceneFilename, scene, onSuccess, onProgress, onError, pluginExtension, name).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
  }
  /**
   * Load a scene into an asset container
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene (default: empty string)
   * @param scene is the instance of Scene to append to
   * @param onProgress a callback with a progress event for each file being loaded
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns The loaded asset container
   * @deprecated Please use the module level {@link LoadAssetContainerAsync} instead
   */
  static async LoadAssetContainerAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name) {
    return await loadAssetContainerSharedAsync(rootUrl, sceneFilename, scene, onProgress, pluginExtension, name);
  }
  /**
   * Import animations from a file into a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @deprecated Please use the module level {@link ImportAnimationsAsync} instead
   */
  static ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension, name) {
    importAnimationsImplAsync(
      rootUrl,
      sceneFilename,
      scene,
      overwriteAnimations,
      animationGroupLoadingMode,
      targetConverter,
      onSuccess,
      onProgress,
      onError,
      pluginExtension,
      name
      // eslint-disable-next-line github/no-then
    ).catch((error) => onError?.(scene ?? EngineStore.LastCreatedScene, error?.message, error));
  }
  /**
   * Import animations from a file into a scene
   * @param rootUrl a string that defines the root url for the scene and resources or the concatenation of rootURL and filename (e.g. http://example.com/test.glb)
   * @param sceneFilename a string that defines the name of the scene file or starts with "data:" following by the stringified version of the scene or a File object (default: empty string)
   * @param scene is the instance of BABYLON.Scene to append to (default: last created scene)
   * @param overwriteAnimations when true, animations are cleaned before importing new ones. Animations are appended otherwise
   * @param animationGroupLoadingMode defines how to handle old animations groups before importing new ones
   * @param targetConverter defines a function used to convert animation targets from loaded scene to current scene (default: search node by name)
   * @param onSuccess a callback with the scene when import succeeds
   * @param onProgress a callback with a progress event for each file being loaded
   * @param onError a callback with the scene, a message, and possibly an exception when import fails
   * @param pluginExtension the extension used to determine the plugin
   * @param name defines the filename, if the data is binary
   * @returns the updated scene with imported animations
   * @deprecated Please use the module level {@link ImportAnimationsAsync} instead
   */
  static async ImportAnimationsAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onSuccess, onProgress, onError, pluginExtension, name) {
    return await importAnimationsSharedAsync(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, onProgress, pluginExtension, name);
  }
};
SceneLoader.NO_LOGGING = 0;
SceneLoader.MINIMAL_LOGGING = 1;
SceneLoader.SUMMARY_LOGGING = 2;
SceneLoader.DETAILED_LOGGING = 3;
SceneLoader.OnPluginActivatedObservable = onPluginActivatedObservable;

export {
  AbstractAssetContainer,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  SceneLoaderAnimationGroupLoadingMode,
  RegisterSceneLoaderPlugin,
  registerSceneLoaderPlugin,
  GetRegisteredSceneLoaderPluginMetadata,
  ImportMeshAsync,
  LoadSceneAsync,
  loadSceneAsync,
  AppendSceneAsync,
  appendSceneAsync,
  LoadAssetContainerAsync,
  loadAssetContainerAsync,
  ImportAnimationsAsync,
  importAnimationsAsync,
  SceneLoader
};
//# sourceMappingURL=chunk-GTV4JERF.js.map
