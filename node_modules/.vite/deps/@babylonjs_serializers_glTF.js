import {
  DracoEncoder,
  GreasedLineBaseMesh,
  LinesMesh,
  ProceduralTexture,
  SpecularPowerToRoughness
} from "./chunk-YZYGGOGS.js";
import {
  OpenPBRMaterial
} from "./chunk-YJPQAKMU.js";
import {
  MorphTarget,
  RawTexture,
  Scalar,
  TargetCamera
} from "./chunk-JHEX2SWQ.js";
import {
  Animation
} from "./chunk-TSMTS3RY.js";
import "./chunk-QCIHLJPD.js";
import {
  DumpTools
} from "./chunk-3FSMXJUD.js";
import "./chunk-OLUA2UG4.js";
import {
  Constants
} from "./chunk-4ZZTRAG2.js";
import {
  PBRBaseMaterial,
  PBRMaterial
} from "./chunk-V3LGLGDY.js";
import "./chunk-I3TMUHRM.js";
import "./chunk-OXJQIT7Z.js";
import "./chunk-I5VRO6IR.js";
import "./chunk-QE4LR6WB.js";
import {
  GetTextureDataAsync,
  TextureTools
} from "./chunk-PMTD2I4J.js";
import {
  InstancedMesh
} from "./chunk-PF7TCB4E.js";
import {
  AbstractMesh,
  Mesh,
  MultiMaterial,
  StandardMaterial,
  TransformNode
} from "./chunk-JPDS7OIY.js";
import "./chunk-CXGX3PZM.js";
import {
  Material
} from "./chunk-43CLNRDT.js";
import "./chunk-A4ZWE3KB.js";
import {
  Camera
} from "./chunk-VEFBIZWV.js";
import {
  Light,
  ShadowLight
} from "./chunk-DILINRTI.js";
import "./chunk-VJOELCDK.js";
import "./chunk-UCQRX3RS.js";
import "./chunk-5L7L3C5R.js";
import "./chunk-WKXRXUEO.js";
import "./chunk-HGHYVV6G.js";
import "./chunk-T2KPYHB2.js";
import "./chunk-GFXF2AHA.js";
import "./chunk-TOAF46MT.js";
import "./chunk-6W4IL5BZ.js";
import "./chunk-GJUHN7CQ.js";
import "./chunk-TXNJXLHN.js";
import "./chunk-ZDMLZ54Z.js";
import "./chunk-4YTIJHCE.js";
import "./chunk-HZV6LONH.js";
import "./chunk-LMU2RTUR.js";
import "./chunk-XZQW7V5M.js";
import "./chunk-4G5IUL4P.js";
import "./chunk-GTGQLCHH.js";
import "./chunk-OQDLFVF3.js";
import "./chunk-RWNDBSCB.js";
import "./chunk-727VTLHD.js";
import "./chunk-XY4T45S3.js";
import "./chunk-FSW2QHX7.js";
import "./chunk-DDBXBNWX.js";
import {
  Engine
} from "./chunk-A4D5JG2T.js";
import "./chunk-BEJPWP7R.js";
import "./chunk-XJITC4RP.js";
import "./chunk-WAGTS43G.js";
import "./chunk-LJSODA3L.js";
import {
  Texture
} from "./chunk-RLP7VL7I.js";
import "./chunk-KEOAMMZ7.js";
import "./chunk-URVCX2UN.js";
import {
  Color3,
  Color4
} from "./chunk-5HS37WJT.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector3,
  Vector4
} from "./chunk-H4PB4IWT.js";
import {
  Epsilon
} from "./chunk-JKI5MLKH.js";
import "./chunk-E3DHVNB4.js";
import "./chunk-M7IZCQVV.js";
import {
  AreIndices32Bits,
  EnumerateFloatValues,
  GetTypeByteLength,
  GetTypedArrayData,
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  Tools
} from "./chunk-V4HVSPHY.js";
import {
  GetMimeType
} from "./chunk-XHCADOMZ.js";
import "./chunk-2ZEUD233.js";
import "./chunk-IW7YW5OA.js";
import "./chunk-S7NDMBDF.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-I4NFOKIT.js";
import {
  Effect
} from "./chunk-5OVANEI2.js";
import "./chunk-OWCZTH5B.js";
import "./chunk-AZNEH5GV.js";
import {
  EngineStore
} from "./chunk-WWEEGZBW.js";
import "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import "./chunk-QCCD6NMF.js";
import "./chunk-4U4OQIRL.js";
import "./chunk-FX6MN5HL.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@babylonjs/serializers/glTF/glTFFileExporter.js
var __IGLTFExporterExtension = 0;

// node_modules/@babylonjs/serializers/glTF/2.0/glTFData.js
var GLTFData = class {
  constructor() {
    this.files = {};
  }
  /**
   * @deprecated Use files instead
   */
  get glTFFiles() {
    return this.files;
  }
  /**
   * Downloads the glTF data as files based on their names and data
   */
  downloadFiles() {
    for (const key in this.files) {
      const value = this.files[key];
      const blob = new Blob([value], { type: GetMimeType(key) });
      Tools.Download(blob, key);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFMaterialExporter.js
var Epsilon2 = 1e-6;
var DielectricSpecular = new Color3(0.04, 0.04, 0.04);
var MaxSpecularPower = 1024;
var White = Color3.White();
var Black = Color3.BlackReadOnly;
function GetFileExtensionFromMimeType(mimeType) {
  switch (mimeType) {
    case "image/jpeg":
      return ".jpg";
    case "image/png":
      return ".png";
    case "image/webp":
      return ".webp";
    case "image/avif":
      return ".avif";
    case "image/ktx2":
      return ".ktx2";
  }
}
async function GetCachedImageAsync(babylonTexture) {
  const internalTexture = babylonTexture.getInternalTexture();
  if (!internalTexture || internalTexture.source !== 1) {
    return null;
  }
  if (internalTexture.invertY) {
    return null;
  }
  const buffer = internalTexture._buffer;
  let data;
  let mimeType = babylonTexture.mimeType;
  if (!buffer) {
    data = await Tools.LoadFileAsync(internalTexture.url);
    mimeType = GetMimeType(internalTexture.url) || mimeType;
  } else if (ArrayBuffer.isView(buffer)) {
    data = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    data = buffer;
  } else if (buffer instanceof Blob) {
    data = await buffer.arrayBuffer();
    mimeType = buffer.type || mimeType;
  } else if (typeof buffer === "string") {
    data = await Tools.LoadFileAsync(buffer);
    mimeType = GetMimeType(buffer) || mimeType;
  } else if (typeof HTMLImageElement !== "undefined" && buffer instanceof HTMLImageElement) {
    data = await Tools.LoadFileAsync(buffer.src);
    mimeType = GetMimeType(buffer.src) || mimeType;
  }
  if (data && mimeType) {
    return { data, mimeType };
  }
  return null;
}
function _SolveMetallic(diffuse, specular, oneMinusSpecularStrength) {
  if (specular < DielectricSpecular.r) {
    return 0;
  }
  const a = DielectricSpecular.r;
  const b = diffuse * oneMinusSpecularStrength / (1 - DielectricSpecular.r) + specular - 2 * DielectricSpecular.r;
  const c = DielectricSpecular.r - specular;
  const d = b * b - 4 * a * c;
  return Scalar.Clamp((-b + Math.sqrt(d)) / (2 * a), 0, 1);
}
function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial) {
  const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);
  const opacity = babylonStandardMaterial.alpha;
  const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);
  const roughness = SpecularPowerToRoughness(specularPower);
  const glTFPbrMetallicRoughness = {
    baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],
    metallicFactor: 0,
    roughnessFactor: roughness
  };
  return glTFPbrMetallicRoughness;
}
function SetAlphaMode(glTFMaterial, babylonMaterial) {
  if (babylonMaterial.needAlphaBlending()) {
    glTFMaterial.alphaMode = "BLEND";
  } else if (babylonMaterial.needAlphaTesting()) {
    glTFMaterial.alphaMode = "MASK";
    glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;
  }
}
function CreateWhiteTexture(width, height, scene) {
  const data = new Uint8Array(width * height * 4);
  for (let i = 0; i < data.length; i = i + 4) {
    data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 255;
  }
  const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);
  return rawTexture;
}
function ConvertPixelArrayToFloat32(pixels) {
  if (pixels instanceof Uint8Array) {
    const length = pixels.length;
    const buffer = new Float32Array(pixels.length);
    for (let i = 0; i < length; ++i) {
      buffer[i] = pixels[i] / 255;
    }
    return buffer;
  } else if (pixels instanceof Float32Array) {
    return pixels;
  } else {
    throw new Error("Unsupported pixel format!");
  }
}
var GLTFMaterialExporter = class {
  constructor(_exporter) {
    this._exporter = _exporter;
    this._textureMap = /* @__PURE__ */ new Map();
    this._internalTextureToImage = {};
  }
  getTextureInfo(babylonTexture) {
    return babylonTexture ? this._textureMap.get(babylonTexture) ?? null : null;
  }
  async exportStandardMaterialAsync(babylonStandardMaterial, hasUVs) {
    const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);
    const material = { name: babylonStandardMaterial.name };
    if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {
      if (!babylonStandardMaterial.twoSidedLighting) {
        Tools.Warn(babylonStandardMaterial.name + ": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.");
      }
      material.doubleSided = true;
    }
    if (hasUVs) {
      const promises = [];
      const diffuseTexture = babylonStandardMaterial.diffuseTexture;
      if (diffuseTexture) {
        promises.push(this.exportTextureAsync(diffuseTexture).then((textureInfo) => {
          if (textureInfo) {
            pbrMetallicRoughness.baseColorTexture = textureInfo;
          }
        }));
      }
      const bumpTexture = babylonStandardMaterial.bumpTexture;
      if (bumpTexture) {
        promises.push(this.exportTextureAsync(bumpTexture).then((textureInfo) => {
          if (textureInfo) {
            material.normalTexture = textureInfo;
            if (bumpTexture.level !== 1) {
              material.normalTexture.scale = bumpTexture.level;
            }
          }
        }));
      }
      const emissiveTexture = babylonStandardMaterial.emissiveTexture;
      if (emissiveTexture) {
        material.emissiveFactor = [1, 1, 1];
        promises.push(this.exportTextureAsync(emissiveTexture).then((textureInfo) => {
          if (textureInfo) {
            material.emissiveTexture = textureInfo;
          }
        }));
      }
      const ambientTexture = babylonStandardMaterial.ambientTexture;
      if (ambientTexture) {
        promises.push(this.exportTextureAsync(ambientTexture).then((textureInfo) => {
          if (textureInfo) {
            const occlusionTexture = {
              index: textureInfo.index
            };
            material.occlusionTexture = occlusionTexture;
          }
        }));
      }
      if (promises.length > 0) {
        this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);
        await Promise.all(promises);
      }
    }
    if (babylonStandardMaterial.alpha < 1 || babylonStandardMaterial.opacityTexture) {
      if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {
        material.alphaMode = "BLEND";
      } else {
        Tools.Warn(babylonStandardMaterial.name + ": glTF 2.0 does not support alpha mode: " + babylonStandardMaterial.alphaMode.toString());
      }
    }
    if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon2)) {
      material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();
    }
    material.pbrMetallicRoughness = pbrMetallicRoughness;
    SetAlphaMode(material, babylonStandardMaterial);
    await this._finishMaterialAsync(material, babylonStandardMaterial);
    const materials = this._exporter._materials;
    materials.push(material);
    return materials.length - 1;
  }
  async _finishMaterialAsync(glTFMaterial, babylonMaterial) {
    const textures = await this._exporter._extensionsPostExportMaterialAdditionalTexturesAsync("exportMaterial", glTFMaterial, babylonMaterial);
    const promises = [];
    for (const texture of textures) {
      promises.push(this.exportTextureAsync(texture));
    }
    await Promise.all(promises);
    await this._exporter._extensionsPostExportMaterialAsync("exportMaterial", glTFMaterial, babylonMaterial);
  }
  async _getImageDataAsync(buffer, width, height, mimeType) {
    return await DumpTools.DumpDataAsync(width, height, buffer, mimeType, void 0, false, true);
  }
  /**
   * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null
   * @param texture1 first texture to resize
   * @param texture2 second texture to resize
   * @param scene babylonjs scene
   * @returns resized textures or null
   */
  _resizeTexturesToSameDimensions(texture1, texture2, scene) {
    const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };
    const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };
    let resizedTexture1;
    let resizedTexture2;
    if (texture1Size.width < texture2Size.width) {
      if (texture1 && texture1 instanceof Texture) {
        resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);
      } else {
        resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);
      }
      resizedTexture2 = texture2;
    } else if (texture1Size.width > texture2Size.width) {
      if (texture2 && texture2 instanceof Texture) {
        resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);
      } else {
        resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);
      }
      resizedTexture1 = texture1;
    } else {
      resizedTexture1 = texture1;
      resizedTexture2 = texture2;
    }
    return {
      texture1: resizedTexture1,
      texture2: resizedTexture2
    };
  }
  /**
   * Convert Specular Glossiness Textures to Metallic Roughness
   * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness
   * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-.js/babylon.pbrUtilities.js
   * @param diffuseTexture texture used to store diffuse information
   * @param specularGlossinessTexture texture used to store specular and glossiness information
   * @param factors specular glossiness material factors
   * @param mimeType the mime type to use for the texture
   * @returns pbr metallic roughness interface or null
   */
  async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(diffuseTexture, specularGlossinessTexture, factors, mimeType) {
    const promises = new Array();
    if (!(diffuseTexture || specularGlossinessTexture)) {
      return await Promise.reject("diffuse and specular glossiness textures are not defined!");
    }
    const scene = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;
    if (scene) {
      const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);
      const diffuseSize = resizedTextures.texture1?.getSize();
      let diffuseBuffer;
      let specularGlossinessBuffer;
      const width = diffuseSize.width;
      const height = diffuseSize.height;
      const diffusePixels = await resizedTextures.texture1.readPixels();
      const specularPixels = await resizedTextures.texture2.readPixels();
      if (diffusePixels) {
        diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);
      } else {
        return await Promise.reject("Failed to retrieve pixels from diffuse texture!");
      }
      if (specularPixels) {
        specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);
      } else {
        return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");
      }
      const byteLength = specularGlossinessBuffer.byteLength;
      const metallicRoughnessBuffer = new Uint8Array(byteLength);
      const baseColorBuffer = new Uint8Array(byteLength);
      const strideSize = 4;
      const maxBaseColor = new Color3(0, 0, 0);
      let maxMetallic = 0;
      let maxRoughness = 0;
      for (let h = 0; h < height; ++h) {
        for (let w = 0; w < width; ++w) {
          const offset = (width * h + w) * strideSize;
          const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2]).toLinearSpace(scene.getEngine().useExactSrgbConversions).multiply(factors.diffuseColor);
          const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2]).toLinearSpace(scene.getEngine().useExactSrgbConversions).multiply(factors.specularColor);
          const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;
          const specularGlossiness = {
            diffuseColor,
            specularColor,
            glossiness
          };
          const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);
          maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);
          maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);
          maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);
          maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic);
          maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness);
          baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;
          baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;
          baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;
          baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;
          metallicRoughnessBuffer[offset] = 0;
          metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness * 255;
          metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic * 255;
          metallicRoughnessBuffer[offset + 3] = 255;
        }
      }
      const metallicRoughnessFactors = {
        baseColor: maxBaseColor,
        metallic: maxMetallic,
        roughness: maxRoughness
      };
      let writeOutMetallicRoughnessTexture = false;
      let writeOutBaseColorTexture = false;
      for (let h = 0; h < height; ++h) {
        for (let w = 0; w < width; ++w) {
          const destinationOffset = (width * h + w) * strideSize;
          baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon2 ? metallicRoughnessFactors.baseColor.r : 1;
          baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon2 ? metallicRoughnessFactors.baseColor.g : 1;
          baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon2 ? metallicRoughnessFactors.baseColor.b : 1;
          const linearBaseColorPixel = Color3.FromInts(baseColorBuffer[destinationOffset], baseColorBuffer[destinationOffset + 1], baseColorBuffer[destinationOffset + 2]);
          const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);
          baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;
          baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;
          baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;
          if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon2)) {
            writeOutBaseColorTexture = true;
          }
          metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness > Epsilon2 ? metallicRoughnessFactors.roughness : 1;
          metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic > Epsilon2 ? metallicRoughnessFactors.metallic : 1;
          const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);
          if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon2)) {
            writeOutMetallicRoughnessTexture = true;
          }
        }
      }
      if (writeOutMetallicRoughnessTexture) {
        promises.push(this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {
          metallicRoughnessFactors.metallicRoughnessTextureData = data;
        }));
      }
      if (writeOutBaseColorTexture) {
        promises.push(this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {
          metallicRoughnessFactors.baseColorTextureData = data;
        }));
      }
      return await Promise.all(promises).then(() => {
        return metallicRoughnessFactors;
      });
    } else {
      return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!");
    }
  }
  /**
   * Converts specular glossiness material properties to metallic roughness
   * @param specularGlossiness interface with specular glossiness material properties
   * @returns interface with metallic roughness material properties
   */
  _convertSpecularGlossinessToMetallicRoughness(specularGlossiness) {
    const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);
    const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);
    const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);
    const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);
    const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1 - DielectricSpecular.r) / Math.max(1 - metallic, Epsilon2));
    const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic, Epsilon2));
    let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);
    baseColor = baseColor.clampToRef(0, 1, baseColor);
    const metallicRoughness = {
      baseColor,
      metallic,
      roughness: 1 - specularGlossiness.glossiness
    };
    return metallicRoughness;
  }
  /**
   * Calculates the surface reflectance, independent of lighting conditions
   * @param color Color source to calculate brightness from
   * @returns number representing the perceived brightness, or zero if color is undefined
   */
  _getPerceivedBrightness(color) {
    return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);
  }
  /**
   * Returns the maximum color component value
   * @param color
   * @returns maximum color component value, or zero if color is null or undefined
   */
  _getMaxComponent(color) {
    return Math.max(color.r, Math.max(color.g, color.b));
  }
  /**
   * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors
   * @param baseColor Base color of the material
   * @param metallic Metallic factor of the material
   * @param roughness Roughness factor of the material
   * @param albedoTexture Albedo texture of the material
   * @param metallicTexture Metallic texture of the material
   * @param roughnessTexture Roughness texture of the material
   * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
   * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface
   * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied
   * @returns glTF PBR Metallic Roughness factors
   */
  async _convertMetalRoughFactorsToMetallicRoughnessAsync(baseColor, metallic, roughness, albedoTexture, metallicTexture, roughnessTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs) {
    const promises = [];
    const metallicRoughness = {
      baseColor,
      metallic,
      roughness
    };
    if (hasUVs) {
      if (albedoTexture) {
        promises.push(this.exportTextureAsync(albedoTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;
          }
        }));
      }
      if (metallicTexture) {
        promises.push(this.exportTextureAsync(metallicTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;
          }
        }));
      }
    }
    if (promises.length > 0) {
      this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
      await Promise.all(promises);
    }
    return metallicRoughness;
  }
  _getTextureSampler(texture) {
    const sampler = {};
    if (!texture || !(texture instanceof Texture)) {
      return sampler;
    }
    const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);
    if (wrapS !== 10497) {
      sampler.wrapS = wrapS;
    }
    const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);
    if (wrapT !== 10497) {
      sampler.wrapT = wrapT;
    }
    switch (texture.samplingMode) {
      case Texture.LINEAR_LINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9729;
        break;
      }
      case Texture.LINEAR_NEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9728;
        break;
      }
      case Texture.NEAREST_LINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9729;
        break;
      }
      case Texture.NEAREST_LINEAR_MIPLINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9987;
        break;
      }
      case Texture.NEAREST_NEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9728;
        break;
      }
      case Texture.NEAREST_LINEAR_MIPNEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9985;
        break;
      }
      case Texture.LINEAR_NEAREST_MIPNEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9984;
        break;
      }
      case Texture.LINEAR_NEAREST_MIPLINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9986;
        break;
      }
      case Texture.NEAREST_NEAREST_MIPLINEAR: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9986;
        break;
      }
      case Texture.LINEAR_LINEAR_MIPLINEAR: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9987;
        break;
      }
      case Texture.LINEAR_LINEAR_MIPNEAREST: {
        sampler.magFilter = 9729;
        sampler.minFilter = 9985;
        break;
      }
      case Texture.NEAREST_NEAREST_MIPNEAREST: {
        sampler.magFilter = 9728;
        sampler.minFilter = 9984;
        break;
      }
    }
    return sampler;
  }
  _getGLTFTextureWrapMode(wrapMode) {
    switch (wrapMode) {
      case Texture.WRAP_ADDRESSMODE: {
        return 10497;
      }
      case Texture.CLAMP_ADDRESSMODE: {
        return 33071;
      }
      case Texture.MIRROR_ADDRESSMODE: {
        return 33648;
      }
      default: {
        Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);
        return 10497;
      }
    }
  }
  /**
   * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors
   * @param babylonPBRMaterial BJS PBR Metallic Roughness Material
   * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface
   * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied
   * @returns glTF PBR Metallic Roughness factors
   */
  async _convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, pbrMetallicRoughness, hasUVs) {
    const mimeType = "image/png";
    const specGloss = {
      diffuseColor: babylonPBRMaterial._albedoColor,
      specularColor: babylonPBRMaterial._reflectivityColor,
      glossiness: babylonPBRMaterial._microSurface
    };
    const albedoTexture = babylonPBRMaterial._albedoTexture;
    const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;
    const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;
    if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {
      return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");
    }
    if ((albedoTexture || reflectivityTexture) && hasUVs) {
      this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
      const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);
      const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType);
      const textures = this._exporter._textures;
      if (metallicRoughnessFactors.baseColorTextureData) {
        const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);
        pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);
      }
      if (metallicRoughnessFactors.metallicRoughnessTextureData) {
        const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);
        pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);
      }
      return metallicRoughnessFactors;
    } else {
      return this._convertSpecularGlossinessToMetallicRoughness(specGloss);
    }
  }
  async exportPBRMaterialAsync(babylonPBRMaterial, hasUVs) {
    const glTFPbrMetallicRoughness = {};
    const glTFMaterial = {
      name: babylonPBRMaterial.name
    };
    const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();
    if (useMetallicRoughness) {
      const albedoColor = babylonPBRMaterial._albedoColor;
      const alpha = babylonPBRMaterial.alpha;
      if (albedoColor) {
        glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];
      }
    }
    const metallicRoughness = useMetallicRoughness ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial._albedoColor, babylonPBRMaterial._metallic, babylonPBRMaterial._roughness, babylonPBRMaterial._albedoTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial._metallicTexture, babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs) : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial);
    const materials = this._exporter._materials;
    materials.push(glTFMaterial);
    return materials.length - 1;
  }
  async _setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs) {
    SetAlphaMode(glTFMaterial, babylonPBRMaterial);
    if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon2) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon2)) {
      glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];
    }
    if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {
      glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;
    }
    if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {
      glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;
    }
    if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {
      if (!babylonPBRMaterial._twoSidedLighting) {
        Tools.Warn(babylonPBRMaterial.name + ": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.");
      }
      glTFMaterial.doubleSided = true;
    }
    if (hasUVs) {
      const promises = [];
      const bumpTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._bumpTexture : babylonPBRMaterial.geometryNormalTexture;
      if (bumpTexture) {
        promises.push(this.exportTextureAsync(bumpTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFMaterial.normalTexture = glTFTexture;
            if (bumpTexture.level !== 1) {
              glTFMaterial.normalTexture.scale = bumpTexture.level;
            }
          }
        }));
      }
      const ambientTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._ambientTexture : babylonPBRMaterial.ambientOcclusionTexture;
      if (ambientTexture) {
        promises.push(this.exportTextureAsync(ambientTexture).then((glTFTexture) => {
          if (glTFTexture) {
            const occlusionTexture = {
              index: glTFTexture.index,
              texCoord: glTFTexture.texCoord,
              extensions: glTFTexture.extensions
            };
            glTFMaterial.occlusionTexture = occlusionTexture;
            if (babylonPBRMaterial instanceof PBRBaseMaterial) {
              occlusionTexture.strength = babylonPBRMaterial._ambientTextureStrength;
            } else {
              occlusionTexture.strength = babylonPBRMaterial.ambientOcclusionTexture.level;
            }
          }
        }));
      }
      const emissiveTexture = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveTexture : babylonPBRMaterial.emissionColorTexture;
      if (emissiveTexture) {
        promises.push(this.exportTextureAsync(emissiveTexture).then((glTFTexture) => {
          if (glTFTexture) {
            glTFMaterial.emissiveTexture = glTFTexture;
          }
        }));
      }
      if (promises.length > 0) {
        this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);
        await Promise.all(promises);
      }
    }
    const emissiveColor = babylonPBRMaterial instanceof PBRBaseMaterial ? babylonPBRMaterial._emissiveColor : babylonPBRMaterial.emissionColor;
    if (!emissiveColor.equalsWithEpsilon(Black, Epsilon2)) {
      glTFMaterial.emissiveFactor = emissiveColor.asArray();
    }
    glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;
  }
  async exportOpenPBRMaterialAsync(babylonOpenPBRMaterial, hasUVs) {
    const glTFPbrMetallicRoughness = {};
    const glTFMaterial = {
      name: babylonOpenPBRMaterial.name
    };
    const albedoColor = babylonOpenPBRMaterial.baseColor;
    const alpha = babylonOpenPBRMaterial.geometryOpacity;
    if (albedoColor) {
      glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];
    }
    const metallicRoughness = await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonOpenPBRMaterial.baseColor, babylonOpenPBRMaterial.baseMetalness, babylonOpenPBRMaterial.specularRoughness, babylonOpenPBRMaterial.baseColorTexture, babylonOpenPBRMaterial.baseMetalnessTexture, babylonOpenPBRMaterial.specularRoughnessTexture, babylonOpenPBRMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonOpenPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, hasUVs);
    await this._finishMaterialAsync(glTFMaterial, babylonOpenPBRMaterial);
    const materials = this._exporter._materials;
    materials.push(glTFMaterial);
    return materials.length - 1;
  }
  async exportTextureAsync(babylonTexture) {
    let textureInfo = this._textureMap.get(babylonTexture);
    if (textureInfo) {
      return textureInfo;
    }
    const samplerIndex = this._exportTextureSampler(babylonTexture);
    const imageIndex = await this._exportTextureImageAsync(babylonTexture);
    textureInfo = this._exportTextureInfo(imageIndex, samplerIndex, babylonTexture.coordinatesIndex);
    this._textureMap.set(babylonTexture, textureInfo);
    this._exporter._extensionsPostExportTextures("exporter", textureInfo, babylonTexture);
    return textureInfo;
  }
  async _exportTextureImageAsync(babylonTexture) {
    const requestedMimeType = babylonTexture.mimeType ?? "none";
    const internalTextureToImage = this._internalTextureToImage;
    const internalTextureUniqueId = babylonTexture.getInternalTexture().uniqueId;
    internalTextureToImage[internalTextureUniqueId] = internalTextureToImage[internalTextureUniqueId] || {};
    let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][requestedMimeType];
    if (imageIndexPromise === void 0) {
      imageIndexPromise = (async () => {
        const cache = await GetCachedImageAsync(babylonTexture);
        if (cache && (requestedMimeType === "none" || cache.mimeType === requestedMimeType)) {
          return this._exportImage(babylonTexture.name, cache.mimeType, cache.data);
        }
        let mimeType = "image/png";
        if (requestedMimeType !== "none") {
          switch (requestedMimeType) {
            case "image/jpeg":
            case "image/png":
            case "image/webp":
              mimeType = requestedMimeType;
              break;
            default:
              Tools.Warn(`Unsupported media type: ${requestedMimeType}. Exporting texture as PNG.`);
              break;
          }
        }
        const size = babylonTexture.getSize();
        const pixels = await GetTextureDataAsync(babylonTexture);
        const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);
        return this._exportImage(babylonTexture.name, mimeType, data);
      })();
      internalTextureToImage[internalTextureUniqueId][requestedMimeType] = imageIndexPromise;
    }
    return await imageIndexPromise;
  }
  _exportImage(name, mimeType, data) {
    const images = this._exporter._images;
    let image;
    if (this._exporter._shouldUseGlb) {
      image = {
        name,
        mimeType,
        bufferView: void 0
        // Will be updated later by BufferManager
      };
      const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));
      this._exporter._bufferManager.setBufferView(image, bufferView);
    } else {
      const baseName = name.replace(/\.\/|\/|\.\\|\\/g, "_");
      const extension = GetFileExtensionFromMimeType(mimeType);
      let fileName = baseName + extension;
      if (images.some((image2) => image2.uri === fileName)) {
        fileName = `${baseName}_${Tools.RandomId()}${extension}`;
      }
      image = {
        name,
        uri: fileName
      };
      this._exporter._imageData[fileName] = { data, mimeType };
    }
    images.push(image);
    return images.length - 1;
  }
  _exportTextureInfo(imageIndex, samplerIndex, coordinatesIndex) {
    const textures = this._exporter._textures;
    let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);
    if (textureIndex === -1) {
      textureIndex = textures.length;
      textures.push({
        source: imageIndex,
        sampler: samplerIndex
      });
    }
    const textureInfo = { index: textureIndex };
    if (coordinatesIndex) {
      textureInfo.texCoord = coordinatesIndex;
    }
    return textureInfo;
  }
  _exportTextureSampler(texture) {
    const sampler = this._getTextureSampler(texture);
    const samplers = this._exporter._samplers;
    const samplerIndex = samplers.findIndex((s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT);
    if (samplerIndex !== -1) {
      return samplerIndex;
    }
    samplers.push(sampler);
    return samplers.length - 1;
  }
};

// node_modules/@babylonjs/serializers/exportUtils.js
var ConvertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());
function IsNoopNode(node, useRightHandedSystem) {
  if (!(node instanceof TransformNode)) {
    return false;
  }
  if (useRightHandedSystem) {
    const matrix = node.getWorldMatrix();
    if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {
      return false;
    }
  } else {
    const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, TmpVectors.Matrix[0]);
    if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {
      return false;
    }
  }
  if (node instanceof AbstractMesh && node.geometry) {
    return false;
  }
  return true;
}

// node_modules/@babylonjs/serializers/glTF/2.0/glTFUtilities.js
var DefaultTranslation = Vector3.ZeroReadOnly;
var DefaultRotation = Quaternion.Identity();
var DefaultScale = Vector3.OneReadOnly;
var DefaultLoaderCameraParentScaleLh = new Vector3(-1, 1, 1);
function GetVertexBufferInfo(vertexBuffer, meshes) {
  const { byteOffset, byteStride, type, normalized } = vertexBuffer;
  const componentCount = vertexBuffer.getSize();
  const totalVertices = meshes.reduce((max, current) => {
    return current.getTotalVertices() > max ? current.getTotalVertices() : max;
  }, -Number.MAX_VALUE);
  const count = totalVertices * componentCount;
  const kind = vertexBuffer.getKind();
  return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };
}
function GetAccessorElementCount(accessorType) {
  switch (accessorType) {
    case "MAT2":
      return 4;
    case "MAT3":
      return 9;
    case "MAT4":
      return 16;
    case "SCALAR":
      return 1;
    case "VEC2":
      return 2;
    case "VEC3":
      return 3;
    case "VEC4":
      return 4;
  }
}
function FloatsNeed16BitInteger(floatArray) {
  return floatArray.some((value) => value >= 256);
}
function IsStandardVertexAttribute(type) {
  switch (type) {
    case VertexBuffer.PositionKind:
    case VertexBuffer.NormalKind:
    case VertexBuffer.TangentKind:
    case VertexBuffer.ColorKind:
    case VertexBuffer.MatricesIndicesKind:
    case VertexBuffer.MatricesIndicesExtraKind:
    case VertexBuffer.MatricesWeightsKind:
    case VertexBuffer.MatricesWeightsExtraKind:
    case VertexBuffer.UVKind:
    case VertexBuffer.UV2Kind:
    case VertexBuffer.UV3Kind:
    case VertexBuffer.UV4Kind:
    case VertexBuffer.UV5Kind:
    case VertexBuffer.UV6Kind:
      return true;
  }
  return false;
}
function GetAccessorType(kind, hasVertexColorAlpha) {
  if (kind == VertexBuffer.ColorKind) {
    return hasVertexColorAlpha ? "VEC4" : "VEC3";
  }
  switch (kind) {
    case VertexBuffer.PositionKind:
    case VertexBuffer.NormalKind:
      return "VEC3";
    case VertexBuffer.TangentKind:
    case VertexBuffer.MatricesIndicesKind:
    case VertexBuffer.MatricesIndicesExtraKind:
    case VertexBuffer.MatricesWeightsKind:
    case VertexBuffer.MatricesWeightsExtraKind:
      return "VEC4";
    case VertexBuffer.UVKind:
    case VertexBuffer.UV2Kind:
    case VertexBuffer.UV3Kind:
    case VertexBuffer.UV4Kind:
    case VertexBuffer.UV5Kind:
    case VertexBuffer.UV6Kind:
      return "VEC2";
  }
  throw new Error(`Unknown kind ${kind}`);
}
function GetAttributeType(kind) {
  switch (kind) {
    case VertexBuffer.PositionKind:
      return "POSITION";
    case VertexBuffer.NormalKind:
      return "NORMAL";
    case VertexBuffer.TangentKind:
      return "TANGENT";
    case VertexBuffer.ColorKind:
      return "COLOR_0";
    case VertexBuffer.UVKind:
      return "TEXCOORD_0";
    case VertexBuffer.UV2Kind:
      return "TEXCOORD_1";
    case VertexBuffer.UV3Kind:
      return "TEXCOORD_2";
    case VertexBuffer.UV4Kind:
      return "TEXCOORD_3";
    case VertexBuffer.UV5Kind:
      return "TEXCOORD_4";
    case VertexBuffer.UV6Kind:
      return "TEXCOORD_5";
    case VertexBuffer.MatricesIndicesKind:
      return "JOINTS_0";
    case VertexBuffer.MatricesIndicesExtraKind:
      return "JOINTS_1";
    case VertexBuffer.MatricesWeightsKind:
      return "WEIGHTS_0";
    case VertexBuffer.MatricesWeightsExtraKind:
      return "WEIGHTS_1";
  }
  throw new Error(`Unknown kind: ${kind}`);
}
function GetPrimitiveMode(fillMode) {
  switch (fillMode) {
    case Material.TriangleFillMode:
      return 4;
    case Material.TriangleStripDrawMode:
      return 5;
    case Material.TriangleFanDrawMode:
      return 6;
    case Material.PointListDrawMode:
    case Material.PointFillMode:
      return 0;
    case Material.LineLoopDrawMode:
      return 2;
    case Material.LineListDrawMode:
      return 1;
    case Material.LineStripDrawMode:
      return 3;
  }
  throw new Error(`Unknown fill mode: ${fillMode}`);
}
function IsTriangleFillMode(fillMode) {
  switch (fillMode) {
    case Material.TriangleFillMode:
    case Material.TriangleStripDrawMode:
    case Material.TriangleFanDrawMode:
      return true;
  }
  return false;
}
function NormalizeTangent(tangent) {
  const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);
  if (length > 0) {
    tangent.x /= length;
    tangent.y /= length;
    tangent.z /= length;
  }
}
function ConvertToRightHandedPosition(value) {
  value.x *= -1;
  return value;
}
function ConvertToRightHandedTransformMatrix(matrix) {
  ConvertHandednessMatrix.invertToRef(TmpVectors.Matrix[0]).multiplyToRef(matrix, matrix).multiplyToRef(ConvertHandednessMatrix, matrix);
  return matrix;
}
function ConvertToRightHandedRotation(value) {
  if (value.x * value.x + value.y * value.y > 0.5) {
    const absX = Math.abs(value.x);
    const absY = Math.abs(value.y);
    if (absX > absY) {
      const sign = Math.sign(value.x);
      value.x = absX;
      value.y *= -sign;
      value.z *= -sign;
      value.w *= sign;
    } else {
      const sign = Math.sign(value.y);
      value.x *= -sign;
      value.y = absY;
      value.z *= sign;
      value.w *= -sign;
    }
  } else {
    const absZ = Math.abs(value.z);
    const absW = Math.abs(value.w);
    if (absZ > absW) {
      const sign = Math.sign(value.z);
      value.x *= -sign;
      value.y *= sign;
      value.z = absZ;
      value.w *= -sign;
    } else {
      const sign = Math.sign(value.w);
      value.x *= sign;
      value.y *= -sign;
      value.z *= -sign;
      value.w = absW;
    }
  }
  return value;
}
function Rotate180Y(rotation) {
  rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);
}
function CollapseChildIntoParent(node, parentNode) {
  const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);
  const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);
  const parentMatrix = Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);
  const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);
  const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);
  const matrix = Matrix.ComposeToRef(DefaultScale, rotation, translation, TmpVectors.Matrix[1]);
  parentMatrix.multiplyToRef(matrix, matrix);
  matrix.decompose(void 0, parentRotation, parentTranslation);
  if (parentTranslation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
    delete parentNode.translation;
  } else {
    parentNode.translation = parentTranslation.asArray();
  }
  if (parentRotation.equalsWithEpsilon(DefaultRotation, Epsilon)) {
    delete parentNode.rotation;
  } else {
    parentNode.rotation = parentRotation.asArray();
  }
  if (parentNode.scale) {
    delete parentNode.scale;
  }
}
function IsChildCollapsible(babylonNode, parentBabylonNode) {
  if (!(parentBabylonNode instanceof TransformNode)) {
    return false;
  }
  const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;
  if (!isOnlyDescendant) {
    return false;
  }
  const scene = babylonNode.getScene();
  const expectedScale = babylonNode instanceof TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;
  if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, Epsilon)) {
    Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);
    return false;
  }
  return true;
}
function IndicesArrayToTypedSubarray(indices, start, count, is32Bits) {
  let processedIndices = indices;
  if (start !== 0 || count !== indices.length) {
    processedIndices = Array.isArray(indices) ? indices.slice(start, start + count) : indices.subarray(start, start + count);
  }
  if (processedIndices instanceof Int32Array) {
    return new Uint32Array(processedIndices.buffer, processedIndices.byteOffset, processedIndices.length);
  }
  if (Array.isArray(processedIndices)) {
    return is32Bits ? new Uint32Array(processedIndices) : new Uint16Array(processedIndices);
  }
  return processedIndices;
}
function DataArrayToUint8Array(data) {
  if (data instanceof Array) {
    const floatData = new Float32Array(data);
    return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);
  }
  return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);
}
function GetMinMax(data, vertexBuffer, start, count) {
  const { byteOffset, byteStride, type, normalized } = vertexBuffer;
  const size = vertexBuffer.getSize();
  const min = new Array(size).fill(Infinity);
  const max = new Array(size).fill(-Infinity);
  EnumerateFloatValues(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {
    for (let i = 0; i < size; i++) {
      min[i] = Math.min(min[i], values[i]);
      max[i] = Math.max(max[i], values[i]);
    }
  });
  return { min, max };
}
function OmitDefaultValues(object, defaultValues) {
  for (const [key, value] of Object.entries(object)) {
    const defaultValue = defaultValues[key];
    if (Array.isArray(value) && Array.isArray(defaultValue) && AreArraysEqual(value, defaultValue) || value === defaultValue) {
      delete object[key];
    }
  }
  return object;
}
function AreArraysEqual(array1, array2) {
  return array1.length === array2.length && array1.every((val, i) => val === array2[i]);
}

// node_modules/@babylonjs/serializers/glTF/2.0/dataWriter.js
var TypedArrayToWriteMethod = /* @__PURE__ */ new Map([
  [Int8Array, (d, b, v) => d.setInt8(b, v)],
  [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],
  [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],
  [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],
  [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],
  [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],
  [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],
  [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],
  [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)]
]);
var DataWriter = class {
  writeTypedArray(value) {
    this._checkGrowBuffer(value.byteLength);
    const setMethod = TypedArrayToWriteMethod.get(value.constructor);
    for (let i = 0; i < value.length; i++) {
      setMethod(this._dataView, this._byteOffset, value[i]);
      this._byteOffset += value.BYTES_PER_ELEMENT;
    }
  }
  constructor(byteLength) {
    this._data = new Uint8Array(byteLength);
    this._dataView = new DataView(this._data.buffer);
    this._byteOffset = 0;
  }
  get byteOffset() {
    return this._byteOffset;
  }
  getOutputData() {
    return new Uint8Array(this._data.buffer, 0, this._byteOffset);
  }
  writeUInt8(value) {
    this._checkGrowBuffer(1);
    this._dataView.setUint8(this._byteOffset, value);
    this._byteOffset++;
  }
  writeInt8(value) {
    this._checkGrowBuffer(1);
    this._dataView.setInt8(this._byteOffset, value);
    this._byteOffset++;
  }
  writeInt16(entry) {
    this._checkGrowBuffer(2);
    this._dataView.setInt16(this._byteOffset, entry, true);
    this._byteOffset += 2;
  }
  writeUInt16(value) {
    this._checkGrowBuffer(2);
    this._dataView.setUint16(this._byteOffset, value, true);
    this._byteOffset += 2;
  }
  writeInt32(entry) {
    this._checkGrowBuffer(4);
    this._dataView.setInt32(this._byteOffset, entry, true);
    this._byteOffset += 4;
  }
  writeUInt32(value) {
    this._checkGrowBuffer(4);
    this._dataView.setUint32(this._byteOffset, value, true);
    this._byteOffset += 4;
  }
  writeFloat32(value) {
    this._checkGrowBuffer(4);
    this._dataView.setFloat32(this._byteOffset, value, true);
    this._byteOffset += 4;
  }
  writeFloat64(value) {
    this._checkGrowBuffer(8);
    this._dataView.setFloat64(this._byteOffset, value, true);
    this._byteOffset += 8;
  }
  _checkGrowBuffer(byteLength) {
    const newByteLength = this.byteOffset + byteLength;
    if (newByteLength > this._data.byteLength) {
      const newData = new Uint8Array(newByteLength * 2);
      newData.set(this._data);
      this._data = newData;
      this._dataView = new DataView(this._data.buffer);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/bufferManager.js
function GetHighestByteAlignment(byteLength) {
  if (byteLength % 4 === 0) {
    return 4;
  }
  if (byteLength % 2 === 0) {
    return 2;
  }
  return 1;
}
var BufferManager = class {
  constructor() {
    this._bufferViewToData = /* @__PURE__ */ new Map();
    this._bufferViewToProperties = /* @__PURE__ */ new Map();
    this._accessorToBufferView = /* @__PURE__ */ new Map();
  }
  /**
   * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.
   * @param bufferViews The list of bufferViews to be populated while writing the binary
   * @returns The binary buffer
   */
  generateBinary(bufferViews) {
    let totalByteLength = 0;
    this._bufferViewToData.forEach((data) => {
      totalByteLength += data.byteLength;
    });
    const dataWriter = new DataWriter(totalByteLength);
    const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));
    for (const bufferView of orderedBufferViews) {
      bufferView.byteOffset = dataWriter.byteOffset;
      bufferViews.push(bufferView);
      const bufferViewIndex = bufferViews.length - 1;
      const properties = this.getPropertiesWithBufferView(bufferView);
      for (const object of properties) {
        object.bufferView = bufferViewIndex;
      }
      dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView));
      this._bufferViewToData.delete(bufferView);
    }
    return dataWriter.getOutputData();
  }
  /**
   * Creates a buffer view based on the supplied arguments
   * @param data a TypedArray to create the bufferView for
   * @param byteStride byte distance between consecutive elements
   * @returns bufferView for glTF
   */
  createBufferView(data, byteStride) {
    const bufferView = {
      buffer: 0,
      byteOffset: void 0,
      // byteOffset will be set later, when we write the binary and decide bufferView ordering
      byteLength: data.byteLength,
      byteStride
    };
    this._bufferViewToData.set(bufferView, data);
    return bufferView;
  }
  /**
   * Creates an accessor based on the supplied arguments and assigns it to the bufferView
   * @param bufferView The glTF bufferView referenced by this accessor
   * @param type The type of the accessor
   * @param componentType The datatype of components in the attribute
   * @param count The number of attributes referenced by this accessor
   * @param byteOffset The offset relative to the start of the bufferView in bytes
   * @param minMax Minimum and maximum value of each component in this attribute
   * @param normalized Specifies whether integer data values are normalized before usage
   * @returns accessor for glTF
   */
  createAccessor(bufferView, type, componentType, count, byteOffset, minMax, normalized) {
    this._verifyBufferView(bufferView);
    const accessor = {
      bufferView: void 0,
      // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering
      componentType,
      count,
      type,
      min: minMax?.min,
      max: minMax?.max,
      normalized,
      byteOffset
    };
    this.setBufferView(accessor, bufferView);
    this._accessorToBufferView.set(accessor, bufferView);
    return accessor;
  }
  /**
   * Assigns a bufferView to a glTF object that references it
   * @param object The glTF object
   * @param bufferView The bufferView to assign
   */
  setBufferView(object, bufferView) {
    this._verifyBufferView(bufferView);
    const properties = this.getPropertiesWithBufferView(bufferView);
    properties.push(object);
  }
  /**
   * Removes buffer view from the binary data, as well as from all its known references
   * @param bufferView the bufferView to remove
   */
  removeBufferView(bufferView) {
    const properties = this.getPropertiesWithBufferView(bufferView);
    for (const object of properties) {
      if (object.bufferView !== void 0) {
        delete object.bufferView;
      }
    }
    this._bufferViewToData.delete(bufferView);
    this._bufferViewToProperties.delete(bufferView);
    this._accessorToBufferView.forEach((bv, accessor) => {
      if (bv === bufferView) {
        if (accessor.byteOffset !== void 0) {
          delete accessor.byteOffset;
        }
        this._accessorToBufferView.delete(accessor);
      }
    });
  }
  getBufferView(accessor) {
    const bufferView = this._accessorToBufferView.get(accessor);
    this._verifyBufferView(bufferView);
    return bufferView;
  }
  getPropertiesWithBufferView(bufferView) {
    this._verifyBufferView(bufferView);
    this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);
    return this._bufferViewToProperties.get(bufferView);
  }
  getData(bufferView) {
    this._verifyBufferView(bufferView);
    return this._bufferViewToData.get(bufferView);
  }
  _verifyBufferView(bufferView) {
    if (bufferView === void 0 || !this._bufferViewToData.has(bufferView)) {
      throw new Error(`BufferView ${bufferView} not found in BufferManager.`);
    }
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFAnimation.js
var _TangentType;
(function(_TangentType2) {
  _TangentType2[_TangentType2["INTANGENT"] = 0] = "INTANGENT";
  _TangentType2[_TangentType2["OUTTANGENT"] = 1] = "OUTTANGENT";
})(_TangentType || (_TangentType = {}));
var _GLTFAnimation = class __GLTFAnimation {
  /**
   * Determine if a node is transformable - ie has properties it should be part of animation of transformation.
   * @param babylonNode the node to test
   * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.
   */
  static _IsTransformable(babylonNode) {
    return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);
  }
  /**
   * @ignore
   *
   * Creates glTF channel animation from BabylonJS animation.
   * @param babylonTransformNode - BabylonJS mesh.
   * @param animation - animation.
   * @param animationChannelTargetPath - The target animation channel.
   * @param useQuaternion - Specifies if quaternions are used.
   * @returns nullable IAnimationData
   */
  static _CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate) {
    if (this._IsTransformable(babylonTransformNode)) {
      const inputs = [];
      const outputs = [];
      const keyFrames = animation.getKeys();
      const minMaxKeyFrames = __GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);
      const interpolationOrBake = __GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);
      const interpolation = interpolationOrBake.interpolationType;
      const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;
      if (shouldBakeAnimation) {
        __GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);
      } else {
        if (interpolation === "LINEAR" || interpolation === "STEP") {
          __GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);
        } else if (interpolation === "CUBICSPLINE") {
          __GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);
        } else {
          __GLTFAnimation._CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minMaxKeyFrames.min, minMaxKeyFrames.max, animation.framePerSecond, animationSampleRate, inputs, outputs, minMaxKeyFrames, useQuaternion);
        }
      }
      if (inputs.length && outputs.length) {
        const result = {
          inputs,
          outputs,
          samplerInterpolation: interpolation,
          inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),
          inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond)
        };
        return result;
      }
    }
    return null;
  }
  static _DeduceAnimationInfo(animation) {
    let animationChannelTargetPath = null;
    let dataAccessorType = "VEC3";
    let useQuaternion = false;
    const property = animation.targetProperty.split(".");
    switch (property[0]) {
      case "scaling": {
        animationChannelTargetPath = "scale";
        break;
      }
      case "position": {
        animationChannelTargetPath = "translation";
        break;
      }
      case "rotation": {
        dataAccessorType = "VEC4";
        animationChannelTargetPath = "rotation";
        break;
      }
      case "rotationQuaternion": {
        dataAccessorType = "VEC4";
        useQuaternion = true;
        animationChannelTargetPath = "rotation";
        break;
      }
      case "influence": {
        dataAccessorType = "SCALAR";
        animationChannelTargetPath = "weights";
        break;
      }
      default: {
        Tools.Error(`Unsupported animatable property ${property[0]}`);
      }
    }
    if (animationChannelTargetPath) {
      return { animationChannelTargetPath, dataAccessorType, useQuaternion };
    } else {
      Tools.Error("animation channel target path and data accessor type could be deduced");
    }
    return null;
  }
  /**
   * @ignore
   * Create node animations from the transform node animations
   * @param babylonNode
   * @param runtimeGLTFAnimation
   * @param idleGLTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {
    let glTFAnimation;
    if (__GLTFAnimation._IsTransformable(babylonNode)) {
      if (babylonNode.animations) {
        for (const animation of babylonNode.animations) {
          if (shouldExportAnimation && !shouldExportAnimation(animation)) {
            continue;
          }
          const animationInfo = __GLTFAnimation._DeduceAnimationInfo(animation);
          if (animationInfo) {
            glTFAnimation = {
              name: animation.name,
              samplers: [],
              channels: []
            };
            __GLTFAnimation._AddAnimation(`${animation.name}`, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded);
            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {
              idleGLTFAnimations.push(glTFAnimation);
            }
          }
        }
      }
    }
  }
  /**
   * @ignore
   * Create individual morph animations from the mesh's morph target animation tracks
   * @param babylonNode
   * @param runtimeGLTFAnimation
   * @param idleGLTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, nodeMap, nodes, bufferManager, bufferViews, accessors, animationSampleRate, useRightHanded, shouldExportAnimation) {
    let glTFAnimation;
    if (babylonNode instanceof Mesh) {
      const morphTargetManager = babylonNode.morphTargetManager;
      if (morphTargetManager) {
        for (let i = 0; i < morphTargetManager.numTargets; ++i) {
          const morphTarget = morphTargetManager.getTarget(i);
          for (const animation of morphTarget.animations) {
            if (shouldExportAnimation && !shouldExportAnimation(animation)) {
              continue;
            }
            const combinedAnimation = new Animation(`${animation.name}`, "influence", animation.framePerSecond, animation.dataType, animation.loopMode, animation.enableBlending);
            const combinedAnimationKeys = [];
            const animationKeys = animation.getKeys();
            for (let j = 0; j < animationKeys.length; ++j) {
              const animationKey = animationKeys[j];
              for (let k = 0; k < morphTargetManager.numTargets; ++k) {
                if (k == i) {
                  combinedAnimationKeys.push(animationKey);
                } else {
                  combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });
                }
              }
            }
            combinedAnimation.setKeys(combinedAnimationKeys);
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(combinedAnimation);
            if (animationInfo) {
              glTFAnimation = {
                name: combinedAnimation.name,
                samplers: [],
                channels: []
              };
              __GLTFAnimation._AddAnimation(animation.name, animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation, babylonNode, combinedAnimation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, useRightHanded, morphTargetManager.numTargets);
              if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {
                idleGLTFAnimations.push(glTFAnimation);
              }
            }
          }
        }
      }
    }
  }
  /**
   * @internal
   * Create node and morph animations from the animation groups
   * @param babylonScene
   * @param glTFAnimations
   * @param nodeMap
   * @param nodes
   * @param bufferManager
   * @param bufferViews
   * @param accessors
   * @param animationSampleRate
   */
  static _CreateNodeAndMorphAnimationFromAnimationGroups(babylonScene, glTFAnimations, nodeMap, bufferManager, bufferViews, accessors, animationSampleRate, leftHandedNodes, shouldExportAnimation) {
    let glTFAnimation;
    if (babylonScene.animationGroups) {
      const animationGroups = babylonScene.animationGroups;
      for (const animationGroup of animationGroups) {
        const morphAnimations = /* @__PURE__ */ new Map();
        const sampleAnimations = /* @__PURE__ */ new Map();
        const morphAnimationMeshes = /* @__PURE__ */ new Set();
        const animationGroupFrameDiff = animationGroup.to - animationGroup.from;
        glTFAnimation = {
          name: animationGroup.name,
          channels: [],
          samplers: []
        };
        for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {
          const targetAnimation = animationGroup.targetedAnimations[i];
          const target = targetAnimation.target;
          const animation = targetAnimation.animation;
          if (shouldExportAnimation && !shouldExportAnimation(animation)) {
            continue;
          }
          const convertToRightHanded = leftHandedNodes.has(target);
          if (this._IsTransformable(target) || target.length === 1 && this._IsTransformable(target[0])) {
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);
            if (animationInfo) {
              const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;
              if (babylonTransformNode) {
                __GLTFAnimation._AddAnimation(`${animation.name}`, glTFAnimation, babylonTransformNode, animation, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, convertToRightHanded);
              }
            }
          } else if (target instanceof MorphTarget || target.length === 1 && target[0] instanceof MorphTarget) {
            const animationInfo = __GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);
            if (animationInfo) {
              const babylonMorphTarget = target instanceof MorphTarget ? target : target[0];
              if (babylonMorphTarget) {
                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {
                  for (let j = 0; j < morphTargetManager.numTargets; ++j) {
                    if (morphTargetManager.getTarget(j) === babylonMorphTarget) {
                      return true;
                    }
                  }
                  return false;
                });
                if (babylonMorphTargetManager) {
                  const babylonMesh = babylonScene.meshes.find((mesh) => {
                    return mesh.morphTargetManager === babylonMorphTargetManager;
                  });
                  if (babylonMesh) {
                    if (!morphAnimations.has(babylonMesh)) {
                      morphAnimations.set(babylonMesh, /* @__PURE__ */ new Map());
                    }
                    morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);
                    morphAnimationMeshes.add(babylonMesh);
                    sampleAnimations.set(babylonMesh, animation);
                  }
                }
              }
            }
          } else {
          }
        }
        morphAnimationMeshes.forEach((mesh) => {
          const morphTargetManager = mesh.morphTargetManager;
          let combinedAnimationGroup = null;
          const animationKeys = [];
          const sampleAnimation = sampleAnimations.get(mesh);
          const sampleAnimationKeys = sampleAnimation.getKeys();
          const numAnimationKeys = sampleAnimationKeys.length;
          for (let i = 0; i < numAnimationKeys; ++i) {
            for (let j = 0; j < morphTargetManager.numTargets; ++j) {
              const morphTarget = morphTargetManager.getTarget(j);
              const animationsByMorphTarget = morphAnimations.get(mesh);
              if (animationsByMorphTarget) {
                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);
                if (morphTargetAnimation) {
                  if (!combinedAnimationGroup) {
                    combinedAnimationGroup = new Animation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, "influence", morphTargetAnimation.framePerSecond, Animation.ANIMATIONTYPE_FLOAT, morphTargetAnimation.loopMode, morphTargetAnimation.enableBlending);
                  }
                  animationKeys.push(morphTargetAnimation.getKeys()[i]);
                } else {
                  animationKeys.push({
                    frame: animationGroup.from + animationGroupFrameDiff / numAnimationKeys * i,
                    value: morphTarget.influence,
                    inTangent: sampleAnimationKeys[0].inTangent ? 0 : void 0,
                    outTangent: sampleAnimationKeys[0].outTangent ? 0 : void 0
                  });
                }
              }
            }
          }
          combinedAnimationGroup.setKeys(animationKeys);
          const animationInfo = __GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup);
          if (animationInfo) {
            __GLTFAnimation._AddAnimation(`${animationGroup.name}_${mesh.name}_MorphWeightAnimation`, glTFAnimation, mesh, combinedAnimationGroup, animationInfo.dataAccessorType, animationInfo.animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, animationInfo.useQuaternion, animationSampleRate, false, morphTargetManager?.numTargets);
          }
        });
        if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {
          glTFAnimations.push(glTFAnimation);
        }
      }
    }
  }
  static _AddAnimation(name, glTFAnimation, babylonTransformNode, animation, dataAccessorType, animationChannelTargetPath, nodeMap, bufferManager, bufferViews, accessors, useQuaternion, animationSampleRate, convertToRightHanded, morphAnimationChannels) {
    const animationData = __GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);
    let bufferView;
    let accessor;
    let keyframeAccessorIndex;
    let dataAccessorIndex;
    let animationSampler;
    let animationChannel;
    if (animationData) {
      if (morphAnimationChannels) {
        let index = 0;
        let currentInput = 0;
        const newInputs = [];
        while (animationData.inputs.length > 0) {
          currentInput = animationData.inputs.shift();
          if (index % morphAnimationChannels == 0) {
            newInputs.push(currentInput);
          }
          index++;
        }
        animationData.inputs = newInputs;
      }
      const nodeIndex = nodeMap.get(babylonTransformNode);
      const inputData = new Float32Array(animationData.inputs);
      bufferView = bufferManager.createBufferView(inputData);
      accessor = bufferManager.createAccessor(bufferView, "SCALAR", 5126, animationData.inputs.length, void 0, {
        min: [animationData.inputsMin],
        max: [animationData.inputsMax]
      });
      accessors.push(accessor);
      keyframeAccessorIndex = accessors.length - 1;
      const rotationQuaternion = new Quaternion();
      const eulerVec3 = new Vector3();
      const position = new Vector3();
      const isCamera = babylonTransformNode instanceof Camera;
      const elementCount = GetAccessorElementCount(dataAccessorType);
      const outputData = new Float32Array(animationData.outputs.length * elementCount);
      animationData.outputs.forEach(function(output, index) {
        let outputToWrite = output;
        switch (animationChannelTargetPath) {
          case "translation":
            if (convertToRightHanded) {
              Vector3.FromArrayToRef(output, 0, position);
              ConvertToRightHandedPosition(position);
              position.toArray(outputToWrite);
            }
            break;
          case "rotation":
            if (output.length === 4) {
              Quaternion.FromArrayToRef(output, 0, rotationQuaternion);
            } else {
              outputToWrite = new Array(4);
              Vector3.FromArrayToRef(output, 0, eulerVec3);
              Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);
            }
            if (convertToRightHanded) {
              ConvertToRightHandedRotation(rotationQuaternion);
              if (isCamera) {
                Rotate180Y(rotationQuaternion);
              }
            }
            rotationQuaternion.toArray(outputToWrite);
            break;
        }
        outputData.set(outputToWrite, index * elementCount);
      });
      bufferView = bufferManager.createBufferView(outputData);
      accessor = bufferManager.createAccessor(bufferView, dataAccessorType, 5126, animationData.outputs.length);
      accessors.push(accessor);
      dataAccessorIndex = accessors.length - 1;
      animationSampler = {
        interpolation: animationData.samplerInterpolation,
        input: keyframeAccessorIndex,
        output: dataAccessorIndex
      };
      glTFAnimation.samplers.push(animationSampler);
      animationChannel = {
        sampler: glTFAnimation.samplers.length - 1,
        target: {
          node: nodeIndex,
          path: animationChannelTargetPath
        }
      };
      glTFAnimation.channels.push(animationChannel);
    }
  }
  /**
   * Create a baked animation
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation corresponding to the BabylonJS mesh
   * @param animationChannelTargetPath animation target channel
   * @param minFrame minimum animation frame
   * @param maxFrame maximum animation frame
   * @param fps frames per second of the animation
   * @param sampleRate
   * @param inputs input key frames of the animation
   * @param outputs output key frame data of the animation
   * @param minMaxFrames
   * @param minMaxFrames.min
   * @param minMaxFrames.max
   * @param useQuaternion specifies if quaternions should be used
   */
  static _CreateBakedAnimation(babylonTransformNode, animation, animationChannelTargetPath, minFrame, maxFrame, fps, sampleRate, inputs, outputs, minMaxFrames, useQuaternion) {
    let value;
    const quaternionCache = Quaternion.Identity();
    let previousTime = null;
    let time;
    let maxUsedFrame = null;
    let currKeyFrame = null;
    let nextKeyFrame = null;
    let prevKeyFrame = null;
    let endFrame = null;
    minMaxFrames.min = Tools.FloatRound(minFrame / fps);
    const keyFrames = animation.getKeys();
    for (let i = 0, length = keyFrames.length; i < length; ++i) {
      endFrame = null;
      currKeyFrame = keyFrames[i];
      if (i + 1 < length) {
        nextKeyFrame = keyFrames[i + 1];
        if (currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value) || currKeyFrame.value === nextKeyFrame.value) {
          if (i === 0) {
            endFrame = currKeyFrame.frame;
          } else {
            continue;
          }
        } else {
          endFrame = nextKeyFrame.frame;
        }
      } else {
        prevKeyFrame = keyFrames[i - 1];
        if (currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value) || currKeyFrame.value === prevKeyFrame.value) {
          continue;
        } else {
          endFrame = maxFrame;
        }
      }
      if (endFrame) {
        for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {
          time = Tools.FloatRound(f / fps);
          if (time === previousTime) {
            continue;
          }
          previousTime = time;
          maxUsedFrame = time;
          const state = {
            key: 0,
            repeatCount: 0,
            loopMode: animation.loopMode
          };
          value = animation._interpolate(f, state);
          __GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);
        }
      }
    }
    if (maxUsedFrame) {
      minMaxFrames.max = maxUsedFrame;
    }
  }
  static _ConvertFactorToVector3OrQuaternion(factor, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion) {
    const basePositionRotationOrScale = __GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);
    const property = animation.targetProperty.split(".");
    const componentName = property ? property[1] : "";
    const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);
    switch (componentName) {
      case "x":
      case "y":
      case "z": {
        value[componentName] = factor;
        break;
      }
      case "w": {
        value.w = factor;
        break;
      }
      default: {
        Tools.Error(`glTFAnimation: Unsupported component name "${componentName}"!`);
      }
    }
    return value;
  }
  static _SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion) {
    let cacheValue;
    inputs.push(time);
    if (animationChannelTargetPath === "weights") {
      outputs.push([value]);
      return;
    }
    if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {
      value = this._ConvertFactorToVector3OrQuaternion(value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);
    }
    if (animationChannelTargetPath === "rotation") {
      if (useQuaternion) {
        quaternionCache = value;
      } else {
        cacheValue = value;
        Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);
      }
      outputs.push(quaternionCache.asArray());
    } else {
      cacheValue = value;
      outputs.push(cacheValue.asArray());
    }
  }
  /**
   * Creates linear animation from the animation key frames
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation
   * @param animationChannelTargetPath The target animation channel
   * @param inputs Array to store the key frame times
   * @param outputs Array to store the key frame data
   * @param useQuaternion Specifies if quaternions are used in the animation
   */
  static _CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {
    for (const keyFrame of animation.getKeys()) {
      inputs.push(keyFrame.frame / animation.framePerSecond);
      __GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);
    }
  }
  /**
   * Creates cubic spline animation from the animation key frames
   * @param babylonTransformNode BabylonJS mesh
   * @param animation BabylonJS animation
   * @param animationChannelTargetPath The target animation channel
   * @param inputs Array to store the key frame times
   * @param outputs Array to store the key frame data
   * @param useQuaternion Specifies if quaternions are used in the animation
   */
  static _CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion) {
    animation.getKeys().forEach(function(keyFrame) {
      inputs.push(keyFrame.frame / animation.framePerSecond);
      __GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE", keyFrame, useQuaternion);
      __GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);
      __GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, "CUBICSPLINE", keyFrame, useQuaternion);
    });
  }
  static _GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion) {
    let basePositionRotationOrScale;
    if (animationChannelTargetPath === "rotation") {
      if (useQuaternion) {
        const q = babylonTransformNode.rotationQuaternion;
        basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();
      } else {
        const r = babylonTransformNode.rotation;
        basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();
      }
    } else if (animationChannelTargetPath === "translation") {
      const p = babylonTransformNode.position;
      basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();
    } else {
      const s = babylonTransformNode.scaling;
      basePositionRotationOrScale = (s ?? Vector3.One()).asArray();
    }
    return basePositionRotationOrScale;
  }
  /**
   * Adds a key frame value
   * @param keyFrame
   * @param animation
   * @param outputs
   * @param animationChannelTargetPath
   * @param babylonTransformNode
   * @param useQuaternion
   */
  static _AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion) {
    let newPositionRotationOrScale;
    const animationType = animation.dataType;
    if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {
      let value = keyFrame.value.asArray();
      if (animationChannelTargetPath === "rotation") {
        const array = Vector3.FromArray(value);
        const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);
        value = rotationQuaternion.asArray();
      }
      outputs.push(value);
    } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {
      if (animationChannelTargetPath === "weights") {
        outputs.push([keyFrame.value]);
      } else {
        newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(keyFrame.value, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);
        if (newPositionRotationOrScale) {
          if (animationChannelTargetPath === "rotation") {
            const posRotScale = useQuaternion ? newPositionRotationOrScale : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();
            outputs.push(posRotScale.asArray());
          }
          outputs.push(newPositionRotationOrScale.asArray());
        }
      }
    } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {
      outputs.push(keyFrame.value.normalize().asArray());
    } else {
      Tools.Error("glTFAnimation: Unsupported key frame values for animation!");
    }
  }
  /**
   * @internal
   * Determine the interpolation based on the key frames
   * @param keyFrames
   * @param animationChannelTargetPath
   * @param useQuaternion
   */
  static _DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion) {
    let interpolationType;
    let shouldBakeAnimation = false;
    let key;
    if (animationChannelTargetPath === "rotation" && !useQuaternion) {
      return { interpolationType: "LINEAR", shouldBakeAnimation: true };
    }
    for (let i = 0, length = keyFrames.length; i < length; ++i) {
      key = keyFrames[i];
      if (key.inTangent || key.outTangent) {
        if (interpolationType) {
          if (interpolationType !== "CUBICSPLINE") {
            interpolationType = "LINEAR";
            shouldBakeAnimation = true;
            break;
          }
        } else {
          interpolationType = "CUBICSPLINE";
        }
      } else {
        if (interpolationType) {
          if (interpolationType === "CUBICSPLINE" || key.interpolation && key.interpolation === 1 && interpolationType !== "STEP") {
            interpolationType = "LINEAR";
            shouldBakeAnimation = true;
            break;
          }
        } else {
          if (key.interpolation && key.interpolation === 1) {
            interpolationType = "STEP";
          } else {
            interpolationType = "LINEAR";
          }
        }
      }
    }
    if (!interpolationType) {
      interpolationType = "LINEAR";
    }
    return { interpolationType, shouldBakeAnimation };
  }
  /**
   * Adds an input tangent or output tangent to the output data
   * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion
   * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)
   * @param outputs The animation data by keyframe
   * @param animationChannelTargetPath The target animation channel
   * @param interpolation The interpolation type
   * @param keyFrame The key frame with the animation data
   * @param useQuaternion Specifies if quaternions are used
   */
  static _AddSplineTangent(tangentType, outputs, animationChannelTargetPath, interpolation, keyFrame, useQuaternion) {
    let tangent;
    const tangentValue = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;
    if (interpolation === "CUBICSPLINE") {
      if (animationChannelTargetPath === "rotation") {
        if (tangentValue) {
          if (useQuaternion) {
            tangent = tangentValue.asArray();
          } else {
            const array = tangentValue;
            tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();
          }
        } else {
          tangent = [0, 0, 0, 0];
        }
      } else if (animationChannelTargetPath === "weights") {
        if (tangentValue) {
          tangent = [tangentValue];
        } else {
          tangent = [0];
        }
      } else {
        if (tangentValue) {
          tangent = tangentValue.asArray();
        } else {
          tangent = [0, 0, 0];
        }
      }
      outputs.push(tangent);
    }
  }
  /**
   * Get the minimum and maximum key frames' frame values
   * @param keyFrames animation key frames
   * @returns the minimum and maximum key frame value
   */
  static _CalculateMinMaxKeyFrames(keyFrames) {
    let min = Infinity;
    let max = -Infinity;
    keyFrames.forEach(function(keyFrame) {
      min = Math.min(min, keyFrame.frame);
      max = Math.max(max, keyFrame.frame);
    });
    return { min, max };
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFMorphTargetsUtilities.js
function BuildMorphTargetBuffers(morphTarget, mesh, bufferManager, bufferViews, accessors, convertToRightHanded) {
  const result = {
    attributes: {},
    influence: morphTarget.influence,
    name: morphTarget.name
  };
  const geometry = mesh.geometry;
  if (!geometry) {
    Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen.");
    return result;
  }
  const flipX = convertToRightHanded ? -1 : 1;
  const floatSize = 4;
  const difference = Vector3.Zero();
  let vertexStart = 0;
  let vertexCount = 0;
  if (morphTarget.hasPositions) {
    const morphPositions = morphTarget.getPositions();
    const originalPositions = geometry.getVerticesData(VertexBuffer.PositionKind);
    if (originalPositions) {
      const positionData = new Float32Array(originalPositions.length);
      const min = [Infinity, Infinity, Infinity];
      const max = [-Infinity, -Infinity, -Infinity];
      vertexCount = originalPositions.length / 3;
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalPosition = Vector3.FromArray(originalPositions, i * 3);
        const morphPosition = Vector3.FromArray(morphPositions, i * 3);
        morphPosition.subtractToRef(originalPosition, difference);
        difference.x *= flipX;
        min[0] = Math.min(min[0], difference.x);
        max[0] = Math.max(max[0], difference.x);
        min[1] = Math.min(min[1], difference.y);
        max[1] = Math.max(max[1], difference.y);
        min[2] = Math.min(min[2], difference.z);
        max[2] = Math.max(max[2], difference.z);
        positionData[i * 3] = difference.x;
        positionData[i * 3 + 1] = difference.y;
        positionData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, morphPositions.length / 3, 0, { min, max });
      accessors.push(accessor);
      result.attributes["POSITION"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);
    }
  }
  if (morphTarget.hasNormals) {
    const morphNormals = morphTarget.getNormals();
    const originalNormals = geometry.getVerticesData(VertexBuffer.NormalKind);
    if (originalNormals) {
      const normalData = new Float32Array(originalNormals.length);
      vertexCount = originalNormals.length / 3;
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();
        const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();
        morphNormal.subtractToRef(originalNormal, difference);
        normalData[i * 3] = difference.x * flipX;
        normalData[i * 3 + 1] = difference.y;
        normalData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, morphNormals.length / 3, 0);
      accessors.push(accessor);
      result.attributes["NORMAL"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);
    }
  }
  if (morphTarget.hasTangents) {
    const morphTangents = morphTarget.getTangents();
    const originalTangents = geometry.getVerticesData(VertexBuffer.TangentKind);
    if (originalTangents) {
      vertexCount = originalTangents.length / 4;
      const tangentData = new Float32Array(vertexCount * 3);
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        const originalTangent = Vector3.FromArray(originalTangents, i * 4);
        NormalizeTangent(originalTangent);
        const morphTangent = Vector3.FromArray(morphTangents, i * 3);
        NormalizeTangent(morphTangent);
        morphTangent.subtractToRef(originalTangent, difference);
        tangentData[i * 3] = difference.x * flipX;
        tangentData[i * 3 + 1] = difference.y;
        tangentData[i * 3 + 2] = difference.z;
      }
      const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);
      const accessor = bufferManager.createAccessor(bufferView, "VEC3", 5126, vertexCount, 0);
      accessors.push(accessor);
      result.attributes["TANGENT"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);
    }
  }
  if (morphTarget.hasColors) {
    const morphColors = morphTarget.getColors();
    const originalColors = geometry.getVerticesData(VertexBuffer.ColorKind);
    const buffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);
    if (originalColors && buffer) {
      const componentSize = buffer.getSize();
      vertexCount = originalColors.length / componentSize;
      const colorData = new Float32Array(vertexCount * componentSize);
      vertexStart = 0;
      for (let i = vertexStart; i < vertexCount; ++i) {
        if (componentSize === 3) {
          const originalColor = Vector3.FromArray(originalColors, i * componentSize);
          const morphColor = Vector3.FromArray(morphColors, i * componentSize);
          morphColor.subtractToRef(originalColor, difference);
          colorData[i * 3] = difference.x;
          colorData[i * 3 + 1] = difference.y;
          colorData[i * 3 + 2] = difference.z;
        } else if (componentSize === 4) {
          const difference4 = new Vector4();
          const originalColor = Vector4.FromArray(originalColors, i * componentSize);
          const morphColor = Vector4.FromArray(morphColors, i * componentSize);
          morphColor.subtractToRef(originalColor, difference4);
          colorData[i * 4] = difference4.x;
          colorData[i * 4 + 1] = difference4.y;
          colorData[i * 4 + 2] = difference4.z;
          colorData[i * 4 + 3] = difference4.w;
        } else {
          Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);
        }
      }
      const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);
      const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? "VEC3" : "VEC4", 5126, vertexCount, 0);
      accessors.push(accessor);
      result.attributes["COLOR_0"] = accessors.length - 1;
    } else {
      Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);
    }
  }
  return result;
}

// node_modules/@babylonjs/serializers/glTF/2.0/glTFExporter.js
var ExporterState = class {
  constructor(convertToRightHanded, wasAddedByNoopNode) {
    this._indicesAccessorMap = /* @__PURE__ */ new Map();
    this._vertexBufferViewMap = /* @__PURE__ */ new Map();
    this._vertexAccessorMap = /* @__PURE__ */ new Map();
    this._remappedBufferView = /* @__PURE__ */ new Map();
    this._meshMorphTargetMap = /* @__PURE__ */ new Map();
    this._vertexMapColorAlpha = /* @__PURE__ */ new Map();
    this._exportedNodes = /* @__PURE__ */ new Set();
    this._meshMap = /* @__PURE__ */ new Map();
    this.convertedToRightHandedBuffers = /* @__PURE__ */ new Map();
    this.convertToRightHanded = convertToRightHanded;
    this.wasAddedByNoopNode = wasAddedByNoopNode;
  }
  getIndicesAccessor(indices, start, count, offset, flip) {
    return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);
  }
  setIndicesAccessor(indices, start, count, offset, flip, accessorIndex) {
    let map1 = this._indicesAccessorMap.get(indices);
    if (!map1) {
      map1 = /* @__PURE__ */ new Map();
      this._indicesAccessorMap.set(indices, map1);
    }
    let map2 = map1.get(start);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      map1.set(start, map2);
    }
    let map3 = map2.get(count);
    if (!map3) {
      map3 = /* @__PURE__ */ new Map();
      map2.set(count, map3);
    }
    let map4 = map3.get(offset);
    if (!map4) {
      map4 = /* @__PURE__ */ new Map();
      map3.set(offset, map4);
    }
    map4.set(flip, accessorIndex);
  }
  pushExportedNode(node) {
    if (!this._exportedNodes.has(node)) {
      this._exportedNodes.add(node);
    }
  }
  getNodesSet() {
    return this._exportedNodes;
  }
  getVertexBufferView(buffer) {
    return this._vertexBufferViewMap.get(buffer);
  }
  setVertexBufferView(buffer, bufferView) {
    this._vertexBufferViewMap.set(buffer, bufferView);
  }
  setRemappedBufferView(buffer, vertexBuffer, bufferView) {
    this._remappedBufferView.set(buffer, /* @__PURE__ */ new Map());
    this._remappedBufferView.get(buffer).set(vertexBuffer, bufferView);
  }
  getRemappedBufferView(buffer, vertexBuffer) {
    return this._remappedBufferView.get(buffer)?.get(vertexBuffer);
  }
  getVertexAccessor(vertexBuffer, start, count) {
    return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);
  }
  setVertexAccessor(vertexBuffer, start, count, accessorIndex) {
    let map1 = this._vertexAccessorMap.get(vertexBuffer);
    if (!map1) {
      map1 = /* @__PURE__ */ new Map();
      this._vertexAccessorMap.set(vertexBuffer, map1);
    }
    let map2 = map1.get(start);
    if (!map2) {
      map2 = /* @__PURE__ */ new Map();
      map1.set(start, map2);
    }
    map2.set(count, accessorIndex);
  }
  hasVertexColorAlpha(vertexBuffer) {
    return this._vertexMapColorAlpha.get(vertexBuffer) || false;
  }
  setHasVertexColorAlpha(vertexBuffer, hasAlpha) {
    return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);
  }
  getMesh(mesh) {
    return this._meshMap.get(mesh);
  }
  setMesh(mesh, meshIndex) {
    this._meshMap.set(mesh, meshIndex);
  }
  bindMorphDataToMesh(mesh, morphData) {
    const morphTargets = this._meshMorphTargetMap.get(mesh) || [];
    this._meshMorphTargetMap.set(mesh, morphTargets);
    if (morphTargets.indexOf(morphData) === -1) {
      morphTargets.push(morphData);
    }
  }
  getMorphTargetsFromMesh(mesh) {
    return this._meshMorphTargetMap.get(mesh);
  }
};
var GLTFExporter = class _GLTFExporter {
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async
  _ApplyExtension(node, extensions, index, actionAsync) {
    if (index >= extensions.length) {
      return Promise.resolve(node);
    }
    const currentPromise = actionAsync(extensions[index], node);
    if (!currentPromise) {
      return this._ApplyExtension(node, extensions, index + 1, actionAsync);
    }
    return currentPromise.then(async (newNode) => newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async
  _ApplyExtensions(node, actionAsync) {
    const extensions = [];
    for (const name of _GLTFExporter._ExtensionNames) {
      extensions.push(this._extensions[name]);
    }
    return this._ApplyExtension(node, extensions, 0, actionAsync);
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _extensionsPostExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded) {
    return this._ApplyExtensions(
      node,
      // eslint-disable-next-line @typescript-eslint/promise-function-async
      (extension, node2) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node2, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)
    );
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _extensionsPostExportMaterialAsync(context, material, babylonMaterial) {
    return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));
  }
  /**
   * Get additional textures for a material
   * @param context The context when loading the asset
   * @param material The glTF material
   * @param babylonMaterial The Babylon.js material
   * @returns List of additional textures
   */
  async _extensionsPostExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial) {
    const output = [];
    await Promise.all(_GLTFExporter._ExtensionNames.map(async (name) => {
      const extension = this._extensions[name];
      if (extension.postExportMaterialAdditionalTexturesAsync) {
        const textures = await extension.postExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial);
        output.push(...textures);
      }
    }));
    return output;
  }
  _extensionsPostExportTextures(context, textureInfo, babylonTexture) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.postExportTexture) {
        extension.postExportTexture(context, textureInfo, babylonTexture);
      }
    }
  }
  _extensionsPostExportMeshPrimitive(primitive) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.postExportMeshPrimitive) {
        extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);
      }
    }
  }
  async _extensionsPreGenerateBinaryAsync() {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.preGenerateBinaryAsync) {
        await extension.preGenerateBinaryAsync(this._bufferManager);
      }
    }
  }
  _forEachExtensions(action) {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = this._extensions[name];
      if (extension.enabled) {
        action(extension);
      }
    }
  }
  _extensionsOnExporting() {
    this._forEachExtensions((extension) => {
      var _a, _b, _c;
      if (extension.wasUsed) {
        (_a = this._glTF).extensionsUsed || (_a.extensionsUsed = []);
        if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {
          this._glTF.extensionsUsed.push(extension.name);
        }
        if (extension.required) {
          (_b = this._glTF).extensionsRequired || (_b.extensionsRequired = []);
          if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {
            this._glTF.extensionsRequired.push(extension.name);
          }
        }
        (_c = this._glTF).extensions || (_c.extensions = {});
        if (extension.onExporting) {
          extension.onExporting();
        }
      }
    });
  }
  _loadExtensions() {
    for (const name of _GLTFExporter._ExtensionNames) {
      const extension = _GLTFExporter._ExtensionFactories[name](this);
      this._extensions[name] = extension;
    }
  }
  constructor(babylonScene = EngineStore.LastCreatedScene, options) {
    this._glTF = {
      asset: { generator: `Babylon.js v${Engine.Version}`, version: "2.0" }
    };
    this._animations = [];
    this._accessors = [];
    this._bufferViews = [];
    this._cameras = [];
    this._images = [];
    this._materials = [];
    this._meshes = [];
    this._nodes = [];
    this._samplers = [];
    this._scenes = [];
    this._skins = [];
    this._textures = [];
    this._imageData = {};
    this._shouldUseGlb = false;
    this._materialExporter = new GLTFMaterialExporter(this);
    this._extensions = {};
    this._bufferManager = new BufferManager();
    this._shouldExportNodeMap = /* @__PURE__ */ new Map();
    this._nodeMap = /* @__PURE__ */ new Map();
    this._materialMap = /* @__PURE__ */ new Map();
    this._camerasMap = /* @__PURE__ */ new Map();
    this._nodesCameraMap = /* @__PURE__ */ new Map();
    this._skinMap = /* @__PURE__ */ new Map();
    this._nodesSkinMap = /* @__PURE__ */ new Map();
    this._materialNeedsUVsSet = /* @__PURE__ */ new Set();
    if (!babylonScene) {
      throw new Error("No scene available to export");
    }
    this._babylonScene = babylonScene;
    this._options = {
      shouldExportNode: () => true,
      shouldExportAnimation: () => true,
      metadataSelector: (metadata) => metadata?.gltf?.extras,
      animationSampleRate: 1 / 60,
      exportWithoutWaitingForScene: false,
      exportUnusedUVs: false,
      removeNoopRootNodes: true,
      includeCoordinateSystemConversionNodes: false,
      meshCompressionMethod: "None",
      ...options
    };
    this._loadExtensions();
  }
  dispose() {
    for (const key in this._extensions) {
      const extension = this._extensions[key];
      extension.dispose();
    }
  }
  get options() {
    return this._options;
  }
  static RegisterExtension(name, factory, order = 100) {
    if (_GLTFExporter.UnregisterExtension(name)) {
      Tools.Warn(`Extension with the name ${name} already exists`);
    }
    _GLTFExporter._ExtensionFactories[name] = factory;
    const extensionOrder = order ?? 0;
    _GLTFExporter._ExtensionOrders[name] = extensionOrder;
    let insertIndex = _GLTFExporter._ExtensionNames.length;
    for (let i = 0; i < _GLTFExporter._ExtensionNames.length; i++) {
      const existingName = _GLTFExporter._ExtensionNames[i];
      const existingOrder = _GLTFExporter._ExtensionOrders[existingName];
      if (extensionOrder < existingOrder) {
        insertIndex = i;
        break;
      }
    }
    _GLTFExporter._ExtensionNames.splice(insertIndex, 0, name);
  }
  static UnregisterExtension(name) {
    if (!_GLTFExporter._ExtensionFactories[name]) {
      return false;
    }
    delete _GLTFExporter._ExtensionFactories[name];
    delete _GLTFExporter._ExtensionOrders[name];
    const index = _GLTFExporter._ExtensionNames.indexOf(name);
    if (index !== -1) {
      _GLTFExporter._ExtensionNames.splice(index, 1);
    }
    return true;
  }
  _generateJSON(bufferByteLength, fileName, prettyPrint) {
    const buffer = { byteLength: bufferByteLength };
    if (buffer.byteLength) {
      this._glTF.buffers = [buffer];
    }
    if (this._nodes && this._nodes.length) {
      this._glTF.nodes = this._nodes;
    }
    if (this._meshes && this._meshes.length) {
      this._glTF.meshes = this._meshes;
    }
    if (this._scenes && this._scenes.length) {
      this._glTF.scenes = this._scenes;
      this._glTF.scene = 0;
    }
    if (this._cameras && this._cameras.length) {
      this._glTF.cameras = this._cameras;
    }
    if (this._bufferViews && this._bufferViews.length) {
      this._glTF.bufferViews = this._bufferViews;
    }
    if (this._accessors && this._accessors.length) {
      this._glTF.accessors = this._accessors;
    }
    if (this._animations && this._animations.length) {
      this._glTF.animations = this._animations;
    }
    if (this._materials && this._materials.length) {
      this._glTF.materials = this._materials;
    }
    if (this._textures && this._textures.length) {
      this._glTF.textures = this._textures;
    }
    if (this._samplers && this._samplers.length) {
      this._glTF.samplers = this._samplers;
    }
    if (this._skins && this._skins.length) {
      this._glTF.skins = this._skins;
    }
    if (this._images && this._images.length) {
      this._glTF.images = this._images;
    }
    if (!this._shouldUseGlb) {
      buffer.uri = fileName + ".bin";
    }
    return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);
  }
  async generateGLTFAsync(glTFPrefix) {
    const binaryBuffer = await this._generateBinaryAsync();
    this._extensionsOnExporting();
    const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);
    const bin = new Blob([binaryBuffer], { type: "application/octet-stream" });
    const glTFFileName = glTFPrefix + ".gltf";
    const glTFBinFile = glTFPrefix + ".bin";
    const container = new GLTFData();
    container.files[glTFFileName] = jsonText;
    container.files[glTFBinFile] = bin;
    if (this._imageData) {
      for (const image in this._imageData) {
        container.files[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });
      }
    }
    return container;
  }
  async _generateBinaryAsync() {
    await this._exportSceneAsync();
    await this._extensionsPreGenerateBinaryAsync();
    return this._bufferManager.generateBinary(this._bufferViews);
  }
  /**
   * Pads the number to a multiple of 4
   * @param num number to pad
   * @returns padded number
   */
  _getPadding(num) {
    const remainder = num % 4;
    const padding = remainder === 0 ? remainder : 4 - remainder;
    return padding;
  }
  async generateGLBAsync(glTFPrefix) {
    this._shouldUseGlb = true;
    const binaryBuffer = await this._generateBinaryAsync();
    this._extensionsOnExporting();
    const jsonText = this._generateJSON(binaryBuffer.byteLength);
    const glbFileName = glTFPrefix + ".glb";
    const headerLength = 12;
    const chunkLengthPrefix = 8;
    let jsonLength = jsonText.length;
    let encodedJsonText;
    if (typeof TextEncoder !== "undefined") {
      const encoder = new TextEncoder();
      encodedJsonText = encoder.encode(jsonText);
      jsonLength = encodedJsonText.length;
    }
    const jsonPadding = this._getPadding(jsonLength);
    const binPadding = this._getPadding(binaryBuffer.byteLength);
    const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;
    const dataWriter = new DataWriter(byteLength);
    dataWriter.writeUInt32(1179937895);
    dataWriter.writeUInt32(2);
    dataWriter.writeUInt32(byteLength);
    dataWriter.writeUInt32(jsonLength + jsonPadding);
    dataWriter.writeUInt32(1313821514);
    if (encodedJsonText) {
      dataWriter.writeTypedArray(encodedJsonText);
    } else {
      const blankCharCode = "_".charCodeAt(0);
      for (let i = 0; i < jsonLength; ++i) {
        const charCode = jsonText.charCodeAt(i);
        if (charCode != jsonText.codePointAt(i)) {
          dataWriter.writeUInt8(blankCharCode);
        } else {
          dataWriter.writeUInt8(charCode);
        }
      }
    }
    for (let i = 0; i < jsonPadding; ++i) {
      dataWriter.writeUInt8(32);
    }
    dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);
    dataWriter.writeUInt32(5130562);
    dataWriter.writeTypedArray(binaryBuffer);
    for (let i = 0; i < binPadding; ++i) {
      dataWriter.writeUInt8(0);
    }
    const container = new GLTFData();
    container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: "application/octet-stream" });
    return container;
  }
  _setNodeTransformation(node, babylonTransformNode, convertToRightHanded) {
    if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      Tools.Warn("Pivot points are not supported in the glTF serializer");
    }
    if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);
      if (convertToRightHanded) {
        ConvertToRightHandedPosition(translation);
      }
      node.translation = translation.asArray();
    }
    if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {
      node.scale = babylonTransformNode.scaling.asArray();
    }
    const rotationQuaternion = babylonTransformNode.rotationQuaternion?.clone() || Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);
    if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {
      if (convertToRightHanded) {
        ConvertToRightHandedRotation(rotationQuaternion);
      }
      node.rotation = rotationQuaternion.normalize().asArray();
    }
  }
  _setCameraTransformation(node, babylonCamera, convertToRightHanded) {
    const translation = TmpVectors.Vector3[0];
    const rotationQuaternion = TmpVectors.Quaternion[0];
    const cameraWorldMatrix = babylonCamera.getWorldMatrix();
    if (babylonCamera.parent) {
      const parentInvWorldMatrix = babylonCamera.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
      const cameraLocal = cameraWorldMatrix.multiplyToRef(parentInvWorldMatrix, TmpVectors.Matrix[1]);
      cameraLocal.decompose(void 0, rotationQuaternion, translation);
    } else {
      cameraWorldMatrix.decompose(void 0, rotationQuaternion, translation);
    }
    if (!translation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {
      if (convertToRightHanded) {
        ConvertToRightHandedPosition(translation);
      }
      node.translation = translation.asArray();
    }
    if (convertToRightHanded) {
      ConvertToRightHandedRotation(rotationQuaternion);
    }
    if (!this._babylonScene.useRightHandedSystem) {
      Rotate180Y(rotationQuaternion);
    }
    if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {
      node.rotation = rotationQuaternion.asArray();
    }
  }
  // Export babylon cameras to glTF cameras
  _listAvailableCameras() {
    for (const camera of this._babylonScene.cameras) {
      const glTFCamera = {
        type: camera.mode === Camera.PERSPECTIVE_CAMERA ? "perspective" : "orthographic"
      };
      if (camera.name) {
        glTFCamera.name = camera.name;
      }
      if (glTFCamera.type === "perspective") {
        glTFCamera.perspective = {
          aspectRatio: camera.getEngine().getAspectRatio(camera),
          yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),
          znear: camera.minZ,
          zfar: camera.maxZ
        };
      } else if (glTFCamera.type === "orthographic") {
        const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;
        const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;
        glTFCamera.orthographic = {
          xmag: halfWidth,
          ymag: halfHeight,
          znear: camera.minZ,
          zfar: camera.maxZ
        };
      }
      this._camerasMap.set(camera, glTFCamera);
    }
  }
  // Cleanup unused cameras and assign index to nodes.
  _exportAndAssignCameras() {
    const gltfCameras = Array.from(this._camerasMap.values());
    for (const gltfCamera of gltfCameras) {
      const usedNodes = this._nodesCameraMap.get(gltfCamera);
      if (usedNodes !== void 0) {
        this._cameras.push(gltfCamera);
        for (const node of usedNodes) {
          node.camera = this._cameras.length - 1;
        }
      }
    }
  }
  // Collects all skins in a skins map so nodes can reference it during node parsing.
  _listAvailableSkeletons() {
    for (const skeleton of this._babylonScene.skeletons) {
      if (skeleton.bones.length <= 0) {
        continue;
      }
      const skin = { joints: [] };
      this._skinMap.set(skeleton, skin);
    }
  }
  _exportAndAssignSkeletons(leftHandNodes) {
    for (const skeleton of this._babylonScene.skeletons) {
      if (skeleton.bones.length <= 0) {
        continue;
      }
      const skin = this._skinMap.get(skeleton);
      if (skin == void 0) {
        continue;
      }
      const boneIndexMap = {};
      let maxBoneIndex = -1;
      for (let i = 0; i < skeleton.bones.length; ++i) {
        const bone = skeleton.bones[i];
        const boneIndex = bone.getIndex() ?? i;
        if (boneIndex !== -1) {
          boneIndexMap[boneIndex] = bone;
          if (boneIndex > maxBoneIndex) {
            maxBoneIndex = boneIndex;
          }
        }
      }
      const inverseBindMatrices = [];
      for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {
        const bone = boneIndexMap[boneIndex];
        const transformNode = bone.getTransformNode();
        const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : void 0;
        if (nodeIndex === void 0) {
          Tools.Warn("Exporting a bone without a linked transform node is currently unsupported.");
          continue;
        }
        skin.joints.push(nodeIndex);
        const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();
        if (leftHandNodes.has(transformNode)) {
          ConvertToRightHandedTransformMatrix(boneMatrix);
        }
        inverseBindMatrices.push(boneMatrix);
      }
      const skinnedNodes = this._nodesSkinMap.get(skin);
      if (skin.joints.length > 0 && skinnedNodes !== void 0) {
        const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16);
        inverseBindMatrices.forEach((mat, index) => {
          inverseBindMatricesData.set(mat.m, index * 16);
        });
        const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);
        this._accessors.push(this._bufferManager.createAccessor(bufferView, "MAT4", 5126, inverseBindMatrices.length));
        skin.inverseBindMatrices = this._accessors.length - 1;
        this._skins.push(skin);
        const skinIndex = this._skins.length - 1;
        for (const skinnedNode of skinnedNodes) {
          skinnedNode.skin = skinIndex;
        }
      }
    }
  }
  async _exportSceneAsync() {
    const scene = { nodes: [] };
    if (this._babylonScene.metadata) {
      const extras = this._options.metadataSelector(this._babylonScene.metadata);
      if (extras) {
        scene.extras = extras;
      }
    }
    const rootNodesRH = new Array();
    const rootNodesLH = new Array();
    const rootNoopNodesRH = new Array();
    for (const rootNode of this._babylonScene.rootNodes) {
      if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {
        rootNoopNodesRH.push(...rootNode.getChildren());
      } else if (this._babylonScene.useRightHandedSystem) {
        rootNodesRH.push(rootNode);
      } else {
        rootNodesLH.push(rootNode);
      }
    }
    this._listAvailableCameras();
    this._listAvailableSkeletons();
    const stateLH = new ExporterState(true, false);
    scene.nodes.push(...await this._exportNodesAsync(rootNodesLH, stateLH));
    const stateRH = new ExporterState(false, false);
    scene.nodes.push(...await this._exportNodesAsync(rootNodesRH, stateRH));
    const noopRH = new ExporterState(false, true);
    scene.nodes.push(...await this._exportNodesAsync(rootNoopNodesRH, noopRH));
    if (scene.nodes.length) {
      this._scenes.push(scene);
    }
    this._exportAndAssignCameras();
    this._exportAndAssignSkeletons(stateLH.getNodesSet());
    if (this._babylonScene.animationGroups.length) {
      _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene, this._animations, this._nodeMap, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, stateLH.getNodesSet(), this._options.shouldExportAnimation);
    }
  }
  _shouldExportNode(babylonNode) {
    let result = this._shouldExportNodeMap.get(babylonNode);
    if (result === void 0) {
      result = this._options.shouldExportNode(babylonNode);
      this._shouldExportNodeMap.set(babylonNode, result);
    }
    return result;
  }
  async _exportNodesAsync(babylonRootNodes, state) {
    const nodes = new Array();
    this._exportBuffers(babylonRootNodes, state);
    for (const babylonNode of babylonRootNodes) {
      await this._exportNodeAsync(babylonNode, nodes, state);
    }
    return nodes;
  }
  _collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state) {
    if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {
      const vertexBuffers = babylonNode.geometry.getVertexBuffers();
      if (vertexBuffers) {
        for (const kind in vertexBuffers) {
          if (!IsStandardVertexAttribute(kind)) {
            continue;
          }
          const vertexBuffer = vertexBuffers[kind];
          state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);
          const buffer = vertexBuffer._buffer;
          const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];
          bufferToVertexBuffersMap.set(buffer, vertexBufferArray);
          if (vertexBufferArray.indexOf(vertexBuffer) === -1) {
            vertexBufferArray.push(vertexBuffer);
          }
          const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];
          vertexBufferToMeshesMap.set(vertexBuffer, meshes);
          if (meshes.indexOf(babylonNode) === -1) {
            meshes.push(babylonNode);
          }
        }
      }
      const morphTargetManager = babylonNode.morphTargetManager;
      if (morphTargetManager) {
        for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {
          const morphTarget = morphTargetManager.getTarget(morphIndex);
          const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];
          morphTargetsToMeshesMap.set(morphTarget, meshes);
          if (meshes.indexOf(babylonNode) === -1) {
            meshes.push(babylonNode);
          }
        }
      }
    }
    for (const babylonChildNode of babylonNode.getChildren()) {
      this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);
    }
  }
  _exportBuffers(babylonRootNodes, state) {
    const bufferToVertexBuffersMap = /* @__PURE__ */ new Map();
    const vertexBufferToMeshesMap = /* @__PURE__ */ new Map();
    const morphTargetsMeshesMap = /* @__PURE__ */ new Map();
    for (const babylonNode of babylonRootNodes) {
      this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);
    }
    const buffers = Array.from(bufferToVertexBuffersMap.keys());
    for (const buffer of buffers) {
      const data = buffer.getData();
      if (!data) {
        throw new Error("Buffer data is not available");
      }
      const vertexBuffers = bufferToVertexBuffersMap.get(buffer);
      if (!vertexBuffers) {
        continue;
      }
      const byteStride = vertexBuffers[0].byteStride;
      if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {
        throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");
      }
      const bytes = DataArrayToUint8Array(data).slice();
      for (const vertexBuffer of vertexBuffers) {
        const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
        const { byteOffset, byteStride: byteStride2, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);
        switch (kind) {
          // Normalize normals and tangents.
          case VertexBuffer.NormalKind:
          case VertexBuffer.TangentKind: {
            EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
              const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);
              if (length > 0) {
                const invLength = 1 / length;
                values[0] *= invLength;
                values[1] *= invLength;
                values[2] *= invLength;
              }
            });
            break;
          }
          // Convert StandardMaterial vertex colors from gamma to linear space.
          case VertexBuffer.ColorKind: {
            const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;
            if (stdMaterialCount == 0) {
              break;
            }
            if (stdMaterialCount != meshes.length) {
              Logger.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");
              break;
            }
            if (type == VertexBuffer.UNSIGNED_BYTE) {
              Logger.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");
            }
            const vertexData3 = new Color3();
            const vertexData4 = new Color4();
            const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;
            EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
              if (values.length === 3) {
                vertexData3.fromArray(values, 0);
                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);
                vertexData3.toArray(values, 0);
              } else {
                vertexData4.fromArray(values, 0);
                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);
                vertexData4.toArray(values, 0);
              }
            });
          }
        }
      }
      if (state.convertToRightHanded) {
        for (const vertexBuffer of vertexBuffers) {
          const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
          const { byteOffset, byteStride: byteStride2, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);
          switch (kind) {
            case VertexBuffer.PositionKind:
            case VertexBuffer.NormalKind:
            case VertexBuffer.TangentKind: {
              EnumerateFloatValues(bytes, byteOffset, byteStride2, componentCount, type, count, normalized, (values) => {
                values[0] = -values[0];
              });
            }
          }
        }
        state.convertedToRightHandedBuffers.set(buffer, bytes);
      }
      const bufferView = this._bufferManager.createBufferView(bytes, byteStride);
      state.setVertexBufferView(buffer, bufferView);
      const floatMatricesIndices = /* @__PURE__ */ new Map();
      for (const vertexBuffer of vertexBuffers) {
        const meshes = vertexBufferToMeshesMap.get(vertexBuffer);
        const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);
        switch (kind) {
          case VertexBuffer.MatricesIndicesKind:
          case VertexBuffer.MatricesIndicesExtraKind: {
            if (vertexBuffer.type == VertexBuffer.FLOAT) {
              const floatData = vertexBuffer.getFloatData(totalVertices);
              if (floatData !== null) {
                floatMatricesIndices.set(vertexBuffer, floatData);
              }
            }
          }
        }
      }
      if (floatMatricesIndices.size !== 0) {
        Logger.Warn(`Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`);
      }
      const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());
      for (const vertexBuffer of floatArrayVertexBuffers) {
        const array = floatMatricesIndices.get(vertexBuffer);
        if (!array) {
          continue;
        }
        const is16Bit = FloatsNeed16BitInteger(array);
        const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);
        for (let index = 0; index < array.length; index++) {
          newArray[index] = array[index];
        }
        const bufferView2 = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));
        state.setRemappedBufferView(buffer, vertexBuffer, bufferView2);
      }
    }
    const morphTargets = Array.from(morphTargetsMeshesMap.keys());
    for (const morphTarget of morphTargets) {
      const meshes = morphTargetsMeshesMap.get(morphTarget);
      if (!meshes) {
        continue;
      }
      const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);
      for (const mesh of meshes) {
        state.bindMorphDataToMesh(mesh, glTFMorphTarget);
      }
    }
  }
  /**
   * Processes a node to be exported to the glTF file
   * @returns A promise that resolves once the node has been exported
   * @internal
   */
  async _exportNodeAsync(babylonNode, parentNodeChildren, state) {
    let nodeIndex = this._nodeMap.get(babylonNode);
    if (nodeIndex !== void 0) {
      if (!parentNodeChildren.includes(nodeIndex)) {
        parentNodeChildren.push(nodeIndex);
      }
      return;
    }
    const node = await this._createNodeAsync(babylonNode, state);
    if (node) {
      nodeIndex = this._nodes.length;
      this._nodes.push(node);
      this._nodeMap.set(babylonNode, nodeIndex);
      state.pushExportedNode(babylonNode);
      parentNodeChildren.push(nodeIndex);
      const runtimeGLTFAnimation = {
        name: "runtime animations",
        channels: [],
        samplers: []
      };
      const idleGLTFAnimations = [];
      if (!this._babylonScene.animationGroups.length) {
        _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);
        if (babylonNode.animations.length) {
          _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(babylonNode, runtimeGLTFAnimation, idleGLTFAnimations, this._nodeMap, this._nodes, this._bufferManager, this._bufferViews, this._accessors, this._animationSampleRate, state.convertToRightHanded, this._options.shouldExportAnimation);
        }
      }
      if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {
        this._animations.push(runtimeGLTFAnimation);
      }
      idleGLTFAnimations.forEach((idleGLTFAnimation) => {
        if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {
          this._animations.push(idleGLTFAnimation);
        }
      });
    }
    const children = node ? [] : parentNodeChildren;
    for (const babylonChildNode of babylonNode.getChildren()) {
      await this._exportNodeAsync(babylonChildNode, children, state);
    }
    if (node && children.length) {
      node.children = children;
    }
  }
  /**
   * Creates a glTF node from a Babylon.js node. If skipped, returns null.
   * @internal
   */
  async _createNodeAsync(babylonNode, state) {
    if (!this._shouldExportNode(babylonNode)) {
      return null;
    }
    const node = {};
    if (babylonNode.name) {
      node.name = babylonNode.name;
    }
    if (babylonNode.metadata) {
      const extras = this._options.metadataSelector(babylonNode.metadata);
      if (extras) {
        node.extras = extras;
      }
    }
    if (babylonNode instanceof TransformNode) {
      this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);
      if (babylonNode instanceof AbstractMesh) {
        const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : babylonNode;
        if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {
          node.mesh = await this._exportMeshAsync(babylonMesh, state);
        }
        if (babylonNode.skeleton) {
          const skin = this._skinMap.get(babylonNode.skeleton);
          if (skin !== void 0) {
            if (this._nodesSkinMap.get(skin) === void 0) {
              this._nodesSkinMap.set(skin, []);
            }
            this._nodesSkinMap.get(skin)?.push(node);
          }
        }
      }
    }
    if (babylonNode instanceof TargetCamera) {
      const gltfCamera = this._camerasMap.get(babylonNode);
      if (gltfCamera) {
        if (this._nodesCameraMap.get(gltfCamera) === void 0) {
          this._nodesCameraMap.set(gltfCamera, []);
        }
        this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);
        const parentBabylonNode = babylonNode.parent;
        if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {
          const parentNodeIndex = this._nodeMap.get(parentBabylonNode);
          if (parentNodeIndex !== void 0) {
            const parentNode = this._nodes[parentNodeIndex];
            CollapseChildIntoParent(node, parentNode);
            this._nodesCameraMap.get(gltfCamera)?.push(parentNode);
            return null;
          }
        }
        this._nodesCameraMap.get(gltfCamera)?.push(node);
      }
    }
    const processedNode = await this._extensionsPostExportNodeAsync("exportNodeAsync", node, babylonNode, this._nodeMap, state.convertToRightHanded);
    if (!processedNode) {
      Logger.Warn(`Not exporting node ${babylonNode.name}`);
      return null;
    }
    return node;
  }
  _exportIndices(indices, is32Bits, start, count, offset, fillMode, sideOrientation, state, primitive) {
    let indicesToExport = indices;
    primitive.mode = GetPrimitiveMode(fillMode);
    const flip = sideOrientation !== Material.CounterClockWiseSideOrientation && IsTriangleFillMode(fillMode);
    if (flip) {
      if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {
        throw new Error("Triangle strip/fan fill mode is not implemented");
      }
      primitive.mode = GetPrimitiveMode(fillMode);
      const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);
      if (indices) {
        for (let i = 0; i + 2 < count; i += 3) {
          newIndices[i] = indices[start + i] + offset;
          newIndices[i + 1] = indices[start + i + 2] + offset;
          newIndices[i + 2] = indices[start + i + 1] + offset;
        }
      } else {
        for (let i = 0; i + 2 < count; i += 3) {
          newIndices[i] = i;
          newIndices[i + 1] = i + 2;
          newIndices[i + 2] = i + 1;
        }
      }
      indicesToExport = newIndices;
    } else if (indices && offset !== 0) {
      const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);
      for (let i = 0; i < count; i++) {
        newIndices[i] = indices[start + i] + offset;
      }
      indicesToExport = newIndices;
    }
    if (indicesToExport) {
      let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);
      if (accessorIndex === void 0) {
        const bytes = IndicesArrayToTypedSubarray(indicesToExport, start, count, is32Bits);
        const bufferView = this._bufferManager.createBufferView(bytes);
        const componentType = is32Bits ? 5125 : 5123;
        this._accessors.push(this._bufferManager.createAccessor(bufferView, "SCALAR", componentType, count, 0));
        accessorIndex = this._accessors.length - 1;
        state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);
      }
      primitive.indices = accessorIndex;
    }
  }
  _exportVertexBuffer(vertexBuffer, babylonMaterial, start, count, state, primitive) {
    const kind = vertexBuffer.getKind();
    if (!IsStandardVertexAttribute(kind)) {
      return;
    }
    if (kind.startsWith("uv") && !this._options.exportUnusedUVs) {
      if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {
        return;
      }
    }
    let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);
    if (accessorIndex === void 0) {
      const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData();
      const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : void 0;
      const isFloatMatricesIndices = (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;
      const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;
      const vertexBufferNormalized = isFloatMatricesIndices ? void 0 : vertexBuffer.normalized;
      const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer) : state.getVertexBufferView(vertexBuffer._buffer);
      const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;
      this._accessors.push(this._bufferManager.createAccessor(
        bufferView,
        GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),
        vertexBufferType,
        count,
        byteOffset,
        minMax,
        vertexBufferNormalized
        // TODO: Find other places where this is needed.
      ));
      accessorIndex = this._accessors.length - 1;
      state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);
    }
    primitive.attributes[GetAttributeType(kind)] = accessorIndex;
  }
  async _exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive) {
    let materialIndex = this._materialMap.get(babylonMaterial);
    if (materialIndex === void 0) {
      const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith("uv"));
      babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex] : babylonMaterial;
      if (babylonMaterial instanceof PBRBaseMaterial) {
        materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);
      } else if (babylonMaterial instanceof StandardMaterial) {
        materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        materialIndex = await this._materialExporter.exportOpenPBRMaterialAsync(babylonMaterial, hasUVs);
      } else {
        Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);
        return;
      }
      this._materialMap.set(babylonMaterial, materialIndex);
    }
    primitive.material = materialIndex;
  }
  async _exportMeshAsync(babylonMesh, state) {
    let meshIndex = state.getMesh(babylonMesh);
    if (meshIndex !== void 0) {
      return meshIndex;
    }
    const mesh = { primitives: [] };
    meshIndex = this._meshes.length;
    this._meshes.push(mesh);
    state.setMesh(babylonMesh, meshIndex);
    const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();
    const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();
    const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);
    const isLinesMesh = babylonMesh instanceof LinesMesh;
    const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;
    const subMeshes = babylonMesh.subMeshes;
    if (vertexBuffers && subMeshes && subMeshes.length > 0) {
      for (const subMesh of subMeshes) {
        const primitive = { attributes: {} };
        const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;
        if (isGreasedLineMesh) {
          const material = {
            name: babylonMaterial.name
          };
          const babylonLinesMesh = babylonMesh;
          const colorWhite = Color3.White();
          const alpha = babylonLinesMesh.material?.alpha ?? 1;
          const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;
          if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {
            material.pbrMetallicRoughness = {
              baseColorFactor: [...color.asArray(), alpha]
            };
          }
          this._materials.push(material);
          primitive.material = this._materials.length - 1;
        } else if (isLinesMesh) {
          const material = {
            name: babylonMaterial.name
          };
          const babylonLinesMesh = babylonMesh;
          if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {
            material.pbrMetallicRoughness = {
              baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha]
            };
          }
          this._materials.push(material);
          primitive.material = this._materials.length - 1;
        } else {
          await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);
        }
        const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode;
        let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);
        if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {
          sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
        }
        this._exportIndices(indices, indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535, indices ? subMesh.indexStart : subMesh.verticesStart, indices ? subMesh.indexCount : subMesh.verticesCount, -subMesh.verticesStart, fillMode, sideOrientation, state, primitive);
        for (const vertexBuffer of Object.values(vertexBuffers)) {
          this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);
        }
        if (morphTargets) {
          primitive.targets = [];
          for (const gltfMorphTarget of morphTargets) {
            primitive.targets.push(gltfMorphTarget.attributes);
          }
        }
        mesh.primitives.push(primitive);
        this._extensionsPostExportMeshPrimitive(primitive);
      }
    }
    if (morphTargets) {
      mesh.weights = [];
      if (!mesh.extras) {
        mesh.extras = {};
      }
      mesh.extras.targetNames = [];
      for (const gltfMorphTarget of morphTargets) {
        mesh.weights.push(gltfMorphTarget.influence);
        mesh.extras.targetNames.push(gltfMorphTarget.name);
      }
    }
    return meshIndex;
  }
};
GLTFExporter._ExtensionNames = new Array();
GLTFExporter._ExtensionFactories = {};
GLTFExporter._ExtensionOrders = {};

// node_modules/@babylonjs/serializers/glTF/2.0/glTFSerializer.js
var GLTF2Export = class {
  /**
   * Exports the scene to .gltf file format
   * @param scene Babylon scene
   * @param fileName Name to use for the .gltf file
   * @param options Exporter options
   * @returns Returns the exported data
   */
  static async GLTFAsync(scene, fileName, options) {
    if (!options || !options.exportWithoutWaitingForScene) {
      await scene.whenReadyAsync();
    }
    const exporter = new GLTFExporter(scene, options);
    const data = await exporter.generateGLTFAsync(fileName.replace(/\.[^/.]+$/, ""));
    exporter.dispose();
    return data;
  }
  /**
   * Exports the scene to .glb file format
   * @param scene Babylon scene
   * @param fileName Name to use for the .glb file
   * @param options Exporter options
   * @returns Returns the exported data
   */
  static async GLBAsync(scene, fileName, options) {
    if (!options || !options.exportWithoutWaitingForScene) {
      await scene.whenReadyAsync();
    }
    const exporter = new GLTFExporter(scene, options);
    const data = await exporter.generateGLBAsync(fileName.replace(/\.[^/.]+$/, ""));
    exporter.dispose();
    return data;
  }
};

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.js
var NAME = "EXT_mesh_gpu_instancing";
function ColorBufferToRGBAToRGB(colorBuffer, instanceCount) {
  const colorBufferRgb = new Float32Array(instanceCount * 3);
  for (let i = 0; i < instanceCount; i++) {
    colorBufferRgb[i * 3 + 0] = colorBuffer[i * 4 + 0];
    colorBufferRgb[i * 3 + 1] = colorBuffer[i * 4 + 1];
    colorBufferRgb[i * 3 + 2] = colorBuffer[i * 4 + 2];
  }
  return colorBufferRgb;
}
var EXT_mesh_gpu_instancing = class {
  constructor(exporter) {
    this.name = NAME;
    this.enabled = true;
    this.required = false;
    this._instanceColorWarned = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After node is exported
   * @param context the GLTF context when loading the asset
   * @param node the node exported
   * @param babylonNode the corresponding babylon node
   * @param nodeMap map from babylon node id to node index
   * @param convertToRightHanded true if we need to convert data from left hand to right hand system.
   * @param bufferManager buffer manager
   * @returns nullable promise, resolves with the node
   */
  async postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, bufferManager) {
    return await new Promise((resolve) => {
      if (node && babylonNode instanceof Mesh) {
        if (babylonNode.hasThinInstances && this._exporter) {
          this._wasUsed = true;
          const noTranslation = Vector3.Zero();
          const noRotation = Quaternion.Identity();
          const noScale = Vector3.One();
          const matrix = babylonNode.thinInstanceGetWorldMatrices();
          const iwt = TmpVectors.Vector3[2];
          const iwr = TmpVectors.Quaternion[1];
          const iws = TmpVectors.Vector3[3];
          let hasAnyInstanceWorldTranslation = false;
          let hasAnyInstanceWorldRotation = false;
          let hasAnyInstanceWorldScale = false;
          const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);
          const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);
          const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);
          let i = 0;
          for (const m of matrix) {
            m.decompose(iws, iwr, iwt);
            if (convertToRightHanded) {
              ConvertToRightHandedPosition(iwt);
              ConvertToRightHandedRotation(iwr);
            }
            translationBuffer.set(iwt.asArray(), i * 3);
            rotationBuffer.set(iwr.normalize().asArray(), i * 4);
            scaleBuffer.set(iws.asArray(), i * 3);
            hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);
            hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);
            hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);
            i++;
          }
          const extension = {
            attributes: {}
          };
          if (hasAnyInstanceWorldTranslation) {
            extension.attributes["TRANSLATION"] = this._buildAccessor(translationBuffer, "VEC3", babylonNode.thinInstanceCount, bufferManager);
          }
          if (hasAnyInstanceWorldRotation) {
            extension.attributes["ROTATION"] = this._buildAccessor(rotationBuffer, "VEC4", babylonNode.thinInstanceCount, bufferManager);
          }
          if (hasAnyInstanceWorldScale) {
            extension.attributes["SCALE"] = this._buildAccessor(scaleBuffer, "VEC3", babylonNode.thinInstanceCount, bufferManager);
          }
          let colorBuffer = babylonNode._userThinInstanceBuffersStorage?.data?.instanceColor;
          if (colorBuffer) {
            const instanceCount = babylonNode.thinInstanceCount;
            const accessorType = "VEC3";
            if (babylonNode.hasVertexAlpha && colorBuffer.length === instanceCount * 4) {
              if (!this._instanceColorWarned) {
                Logger.Warn("EXT_mesh_gpu_instancing: Exporting instance colors as RGB, alpha channel of instance color is not exported");
                this._instanceColorWarned = true;
              }
              colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);
            } else if (colorBuffer.length === instanceCount * 4) {
              colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);
            }
            if (colorBuffer.length === instanceCount * 3) {
              extension.attributes["_COLOR_0"] = this._buildAccessor(colorBuffer, accessorType, instanceCount, bufferManager);
            }
          }
          node.extensions = node.extensions || {};
          node.extensions[NAME] = extension;
        }
      }
      resolve(node);
    });
  }
  _buildAccessor(buffer, type, count, bufferManager) {
    const bv = bufferManager.createBufferView(buffer);
    const accessor = bufferManager.createAccessor(bv, type, 5126, count);
    this._exporter._accessors.push(accessor);
    return this._exporter._accessors.length - 1;
  }
};
GLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_draco_mesh_compression.js
var NAME2 = "KHR_draco_mesh_compression";
function GetDracoAttributeName(glTFName) {
  if (glTFName === "POSITION") {
    return "POSITION";
  } else if (glTFName === "NORMAL") {
    return "NORMAL";
  } else if (glTFName.startsWith("COLOR")) {
    return "COLOR";
  } else if (glTFName.startsWith("TEXCOORD")) {
    return "TEX_COORD";
  }
  return "GENERIC";
}
var KHR_draco_mesh_compression = class {
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /** @internal */
  constructor(exporter) {
    this.name = NAME2;
    this.required = true;
    this._bufferViewsUsed = /* @__PURE__ */ new Set();
    this._accessorsUsed = /* @__PURE__ */ new Set();
    this._encodePromises = [];
    this._wasUsed = false;
    this.enabled = exporter.options.meshCompressionMethod === "Draco" && DracoEncoder.DefaultAvailable;
  }
  /** @internal */
  dispose() {
  }
  /** @internal */
  postExportMeshPrimitive(primitive, bufferManager, accessors) {
    if (!this.enabled) {
      return;
    }
    if (primitive.mode !== 4 && primitive.mode !== 5) {
      Logger.Warn("Cannot compress primitive with mode " + primitive.mode + ".");
      return;
    }
    const primitiveBufferViews = [];
    const primitiveAccessors = [];
    let indices = null;
    if (primitive.indices !== void 0) {
      const accessor = accessors[primitive.indices];
      const bufferView = bufferManager.getBufferView(accessor);
      indices = bufferManager.getData(bufferView).slice();
      primitiveBufferViews.push(bufferView);
      primitiveAccessors.push(accessor);
    }
    const attributes = [];
    for (const [name, accessorIndex] of Object.entries(primitive.attributes)) {
      const accessor = accessors[accessorIndex];
      const bufferView = bufferManager.getBufferView(accessor);
      const size = GetAccessorElementCount(accessor.type);
      const data = GetTypedArrayData(bufferManager.getData(bufferView), size, accessor.componentType, accessor.byteOffset || 0, bufferView.byteStride || GetTypeByteLength(accessor.componentType) * size, accessor.count, true);
      attributes.push({ kind: name, dracoName: GetDracoAttributeName(name), size: GetAccessorElementCount(accessor.type), data });
      primitiveBufferViews.push(bufferView);
      primitiveAccessors.push(accessor);
    }
    const options = {
      method: primitive.targets ? "MESH_SEQUENTIAL_ENCODING" : "MESH_EDGEBREAKER_ENCODING"
    };
    const promise = DracoEncoder.Default._encodeAsync(attributes, indices, options).then((encodedData) => {
      if (!encodedData) {
        Logger.Error("Draco encoding failed for primitive.");
        return;
      }
      const dracoInfo = {
        bufferView: -1,
        // bufferView will be set to a real index later, when we write the binary and decide bufferView ordering
        attributes: encodedData.attributeIds
      };
      const bufferView = bufferManager.createBufferView(encodedData.data);
      bufferManager.setBufferView(dracoInfo, bufferView);
      for (const bufferView2 of primitiveBufferViews) {
        this._bufferViewsUsed.add(bufferView2);
      }
      for (const accessor of primitiveAccessors) {
        this._accessorsUsed.add(accessor);
      }
      primitive.extensions || (primitive.extensions = {});
      primitive.extensions[NAME2] = dracoInfo;
    }).catch((error) => {
      Logger.Error("Draco encoding failed for primitive: " + error);
    });
    this._encodePromises.push(promise);
    this._wasUsed = true;
  }
  /** @internal */
  async preGenerateBinaryAsync(bufferManager) {
    if (!this.enabled) {
      return;
    }
    await Promise.all(this._encodePromises);
    this._bufferViewsUsed.forEach((bufferView) => {
      const references = bufferManager.getPropertiesWithBufferView(bufferView);
      const onlyUsedByEncodedPrimitives = references.every((object) => {
        return this._accessorsUsed.has(object);
      });
      if (onlyUsedByEncodedPrimitives) {
        bufferManager.removeBufferView(bufferView);
      }
    });
    this._bufferViewsUsed.clear();
    this._accessorsUsed.clear();
  }
};
GLTFExporter.RegisterExtension(NAME2, (exporter) => new KHR_draco_mesh_compression(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_lights_punctual.js
var NAME3 = "KHR_lights_punctual";
var DEFAULTS = {
  name: "",
  color: [1, 1, 1],
  intensity: 1,
  range: Number.MAX_VALUE
};
var SPOTDEFAULTS = {
  innerConeAngle: 0,
  outerConeAngle: Math.PI / 4
};
var LIGHTDIRECTION = Vector3.Backward();
var KHR_lights_punctual = class {
  /**
   * @internal
   */
  constructor(exporter) {
    this.name = NAME3;
    this.enabled = true;
    this.required = false;
    this._exporter = exporter;
  }
  /** @internal */
  dispose() {
    this._lights = null;
  }
  /** @internal */
  get wasUsed() {
    return !!this._lights;
  }
  /** @internal */
  onExporting() {
    this._exporter._glTF.extensions[NAME3] = this._lights;
  }
  /**
   * Define this method to modify the default behavior when exporting a node
   * @param context The context when exporting the node
   * @param node glTF node
   * @param babylonNode BabylonJS node
   * @param nodeMap Node mapping of babylon node to glTF node index
   * @param convertToRightHanded Flag to convert the values to right-handed
   * @returns nullable INode promise
   */
  async postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded) {
    return await new Promise((resolve) => {
      if (!(babylonNode instanceof Light)) {
        resolve(node);
        return;
      }
      const lightType = babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT ? "point" : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT ? "directional" : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT ? "spot" : null;
      if (!lightType || !(babylonNode instanceof ShadowLight)) {
        Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME3}`);
        resolve(node);
        return;
      }
      if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {
        Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME3} specification!`);
      }
      if (!babylonNode.position.equalsToFloats(0, 0, 0)) {
        const translation = TmpVectors.Vector3[0].copyFrom(babylonNode.position);
        if (convertToRightHanded) {
          ConvertToRightHandedPosition(translation);
        }
        node.translation = translation.asArray();
      }
      if (lightType !== "point") {
        const direction = babylonNode.direction.normalizeToRef(TmpVectors.Vector3[0]);
        if (convertToRightHanded) {
          ConvertToRightHandedPosition(direction);
        }
        const lightRotationQuaternion = Quaternion.FromUnitVectorsToRef(LIGHTDIRECTION, direction, TmpVectors.Quaternion[0]);
        if (!Quaternion.IsIdentity(lightRotationQuaternion)) {
          node.rotation = lightRotationQuaternion.asArray();
        }
      }
      const light = {
        type: lightType,
        name: babylonNode.name,
        color: babylonNode.diffuse.asArray(),
        intensity: babylonNode.intensity,
        range: babylonNode.range
      };
      OmitDefaultValues(light, DEFAULTS);
      if (lightType === "spot") {
        const babylonSpotLight = babylonNode;
        light.spot = {
          innerConeAngle: babylonSpotLight.innerAngle / 2,
          outerConeAngle: babylonSpotLight.angle / 2
        };
        OmitDefaultValues(light.spot, SPOTDEFAULTS);
      }
      this._lights || (this._lights = {
        lights: []
      });
      this._lights.lights.push(light);
      const lightReference = {
        light: this._lights.lights.length - 1
      };
      const parentBabylonNode = babylonNode.parent;
      if (parentBabylonNode && IsChildCollapsible(babylonNode, parentBabylonNode)) {
        const parentNodeIndex = nodeMap.get(parentBabylonNode);
        if (parentNodeIndex) {
          const parentNode = this._exporter._nodes[parentNodeIndex];
          CollapseChildIntoParent(node, parentNode);
          parentNode.extensions || (parentNode.extensions = {});
          parentNode.extensions[NAME3] = lightReference;
          resolve(null);
          return;
        }
      }
      node.extensions || (node.extensions = {});
      node.extensions[NAME3] = lightReference;
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME3, (exporter) => new KHR_lights_punctual(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_anisotropy.js
var NAME4 = "KHR_materials_anisotropy";
function OpenpbrAnisotropyStrengthToGltf(baseRoughness, anisotropy) {
  const baseAlpha = baseRoughness * baseRoughness;
  const roughnessT = baseAlpha * Math.sqrt(2 / (1 + (1 - anisotropy) * (1 - anisotropy)));
  const roughnessB = (1 - anisotropy) * roughnessT;
  const newBaseRoughness = Math.sqrt(roughnessB);
  const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1 - baseAlpha, 1e-4)), 1);
  return { newBaseRoughness, newAnisotropyStrength };
}
function CopyTextureTransform(source, destination) {
  destination.uOffset = source.uOffset;
  destination.vOffset = source.vOffset;
  destination.uScale = source.uScale;
  destination.vScale = source.vScale;
  destination.uAng = source.uAng;
  destination.vAng = source.vAng;
  destination.wAng = source.wAng;
  destination.uRotationCenter = source.uRotationCenter;
  destination.vRotationCenter = source.vRotationCenter;
}
var AnisotropyMergeFragment = `
    precision highp float;
#ifdef HAS_TANGENT_TEXTURE
    uniform sampler2D tangentTexture;
#endif
#ifdef HAS_ANISOTROPY_TEXTURE
    uniform sampler2D anisotropyTexture;
#endif
    uniform int useRoughnessFromMetallicGreen;
    uniform int useAnisotropyFromTangentBlue;

    varying vec2 vUV;

    void main() {
        vec2 tangent = vec2(1.0, 0.0);
        float anisotropy = 1.0;
        #ifdef HAS_TANGENT_TEXTURE
            // Tangent texture is present
            vec4 tangentSample = texture2D(tangentTexture, vUV);
            tangent = tangentSample.rg;

            if (useAnisotropyFromTangentBlue > 0) {
                anisotropy = tangentSample.b;
            }
        #endif
        #ifdef HAS_ANISOTROPY_TEXTURE
            // Anisotropy texture is present
            vec4 anisotropySample = texture2D(anisotropyTexture, vUV);
            anisotropy = anisotropySample.r;
        #endif
        
        // Output: RG = tangent XY, B = anisotropy strength
        vec4 anisotropyData = vec4(tangent.x, tangent.y, anisotropy, 1.0);
        gl_FragColor = anisotropyData;
    }
`;
async function CreateMergedAnisotropyTexture(babylonMaterial) {
  const scene = babylonMaterial.getScene();
  if (!Effect.ShadersStore["anisotropyMergeFragmentShader"]) {
    Effect.ShadersStore["anisotropyMergeFragmentShader"] = AnisotropyMergeFragment;
  }
  const anisoStrengthTexture = babylonMaterial.specularRoughnessAnisotropyTexture;
  const tangentTexture = babylonMaterial.geometryTangentTexture;
  if (!(anisoStrengthTexture || tangentTexture)) {
    return null;
  }
  const width = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().width : 1, tangentTexture ? tangentTexture.getSize().width : 1);
  const height = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().height : 1, tangentTexture ? tangentTexture.getSize().height : 1);
  const textureOptions = {
    type: Constants.TEXTURETYPE_UNSIGNED_BYTE,
    format: Constants.TEXTUREFORMAT_RGBA,
    samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,
    generateDepthBuffer: false,
    generateStencilBuffer: false,
    generateMipMaps: false
  };
  const rtTexture = new ProceduralTexture(babylonMaterial.name + "_anisotropy", {
    width,
    height
  }, "anisotropyMerge", scene, textureOptions);
  rtTexture.refreshRate = -1;
  let defines = "";
  if (tangentTexture) {
    defines += "#define HAS_TANGENT_TEXTURE\n";
    rtTexture.setTexture("tangentTexture", tangentTexture);
    CopyTextureTransform(tangentTexture, rtTexture);
  }
  rtTexture.setVector2("tangentVector", babylonMaterial.geometryTangent);
  if (anisoStrengthTexture) {
    defines += "#define HAS_ANISOTROPY_TEXTURE\n";
    rtTexture.setTexture("anisotropyTexture", anisoStrengthTexture);
    CopyTextureTransform(anisoStrengthTexture, rtTexture);
  }
  rtTexture.setInt("useAnisotropyFromTangentBlue", babylonMaterial._useSpecularRoughnessAnisotropyFromTangentTexture ? 1 : 0);
  rtTexture.defines = defines;
  return await new Promise((resolve, reject) => {
    rtTexture.executeWhenReady(() => {
      try {
        rtTexture.render();
        resolve(rtTexture);
      } catch (error) {
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  });
}
var KHR_materials_anisotropy = class {
  constructor(exporter) {
    this.name = NAME4;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._anisoTexturesMap = {};
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with the additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRBaseMaterial) {
      if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {
        if (babylonMaterial.anisotropy.texture) {
          additionalTextures.push(babylonMaterial.anisotropy.texture);
        }
        return additionalTextures;
      }
    } else if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.specularRoughnessAnisotropy > 0) {
        const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);
        if (anisoTexture) {
          additionalTextures.push(anisoTexture);
          this._anisoTexturesMap[babylonMaterial.id] = anisoTexture;
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      var _a;
      if (babylonMaterial instanceof PBRBaseMaterial) {
        if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const anisotropyTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.anisotropy.texture);
        const anisotropyInfo = {
          anisotropyStrength: babylonMaterial.anisotropy.intensity,
          anisotropyRotation: babylonMaterial.anisotropy.angle,
          anisotropyTexture: anisotropyTextureInfo ?? void 0
        };
        if (anisotropyInfo.anisotropyTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME4] = anisotropyInfo;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        if (babylonMaterial.specularRoughnessAnisotropy > 0) {
          this._wasUsed = true;
          node.extensions = node.extensions || {};
          let roughnessTexture = babylonMaterial.specularRoughnessTexture;
          if (babylonMaterial._useRoughnessFromMetallicTextureGreen) {
            roughnessTexture = babylonMaterial.baseMetalnessTexture;
          }
          const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];
          if (!roughnessTexture && !mergedAnisoTexture) {
            let newBaseRoughness = babylonMaterial.specularRoughness;
            let newAnisotropyStrength = babylonMaterial.specularRoughnessAnisotropy;
            if (!babylonMaterial._useGltfStyleAnisotropy) {
              const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.specularRoughness, babylonMaterial.specularRoughnessAnisotropy);
              newBaseRoughness = newParams.newBaseRoughness;
              newAnisotropyStrength = newParams.newAnisotropyStrength;
            }
            if (node.pbrMetallicRoughness) {
              node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;
            }
            const anisotropyInfo2 = {
              anisotropyStrength: newAnisotropyStrength,
              anisotropyRotation: babylonMaterial.geometryTangentAngle + Math.PI * 0.5,
              anisotropyTexture: void 0
            };
            node.extensions[NAME4] = anisotropyInfo2;
            return resolve(node);
          }
          const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;
          const anisotropyInfo = {
            anisotropyStrength: babylonMaterial.specularRoughnessAnisotropy,
            anisotropyRotation: babylonMaterial.geometryTangentAngle,
            anisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : void 0,
            extensions: {}
          };
          if (!babylonMaterial._useGltfStyleAnisotropy) {
            anisotropyInfo.extensions["EXT_materials_anisotropy_openpbr"] = {
              openPbrAnisotropyEnabled: true
            };
            (_a = this._exporter._glTF).extensionsUsed || (_a.extensionsUsed = []);
            if (this._exporter._glTF.extensionsUsed.indexOf("EXT_materials_anisotropy_openpbr") === -1) {
              this._exporter._glTF.extensionsUsed.push("EXT_materials_anisotropy_openpbr");
            }
          }
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
          node.extensions[NAME4] = anisotropyInfo;
        }
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME4, (exporter) => new KHR_materials_anisotropy(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_clearcoat.js
var NAME5 = "KHR_materials_clearcoat";
var KHR_materials_clearcoat = class {
  constructor(exporter) {
    this.name = NAME5;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRBaseMaterial) {
      if (babylonMaterial.clearCoat.isEnabled) {
        if (babylonMaterial.clearCoat.texture) {
          additionalTextures.push(babylonMaterial.clearCoat.texture);
        }
        if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {
          additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);
        }
        if (babylonMaterial.clearCoat.bumpTexture) {
          additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);
        }
        return additionalTextures;
      }
    } else if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.coatWeight > 0) {
        if (babylonMaterial.coatWeightTexture) {
          additionalTextures.push(babylonMaterial.coatWeightTexture);
        }
        if (babylonMaterial.geometryCoatNormalTexture) {
          additionalTextures.push(babylonMaterial.geometryCoatNormalTexture);
        }
        if (babylonMaterial.coatRoughnessTexture) {
          additionalTextures.push(babylonMaterial.coatRoughnessTexture);
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRBaseMaterial) {
        if (!babylonMaterial.clearCoat.isEnabled) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);
        let clearCoatTextureRoughnessInfo;
        if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {
          clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);
        } else {
          clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);
        }
        if (babylonMaterial.clearCoat.isTintEnabled) {
          Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);
        }
        if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {
          Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);
        }
        const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);
        const clearCoatInfo = {
          clearcoatFactor: babylonMaterial.clearCoat.intensity,
          clearcoatTexture: clearCoatTextureInfo ?? void 0,
          clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,
          clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? void 0,
          clearcoatNormalTexture: clearCoatNormalTextureInfo ?? void 0
        };
        if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME5] = clearCoatInfo;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        if (babylonMaterial.coatWeight == 0) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);
        let clearCoatTextureRoughnessInfo;
        if (babylonMaterial.useCoatRoughnessFromWeightTexture) {
          clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);
        } else {
          clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatRoughnessTexture);
        }
        if (babylonMaterial.coatColorTexture) {
          Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);
        }
        const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.geometryCoatNormalTexture);
        const clearCoatInfo = {
          clearcoatFactor: babylonMaterial.coatWeight,
          clearcoatTexture: clearCoatTextureInfo ?? void 0,
          clearcoatRoughnessFactor: babylonMaterial.coatRoughness,
          clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? void 0,
          clearcoatNormalTexture: clearCoatNormalTextureInfo ?? void 0
        };
        if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME5] = clearCoatInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME5, (exporter) => new KHR_materials_clearcoat(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_clearcoat_darkening.js
var NAME6 = "KHR_materials_clearcoat_darkening";
var KHR_materials_clearcoat_darkening = class {
  constructor(exporter) {
    this.name = NAME6;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.coatDarkening) {
        if (babylonMaterial.coatDarkeningTexture) {
          additionalTextures.push(babylonMaterial.coatDarkeningTexture);
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      let coatDarkeningFactor = null;
      let coatDarkeningTexture = null;
      if (babylonMaterial instanceof OpenPBRMaterial) {
        coatDarkeningFactor = babylonMaterial.coatDarkening;
        coatDarkeningTexture = babylonMaterial.coatDarkeningTexture;
      }
      if (coatDarkeningFactor === null || coatDarkeningFactor === 1 && coatDarkeningTexture === null) {
        return resolve(node);
      }
      const parentExt = node.extensions ? node.extensions["KHR_materials_clearcoat"] : null;
      if (!parentExt) {
        return resolve(node);
      }
      this._wasUsed = true;
      const coatDarkeningTextureInfo = this._exporter._materialExporter.getTextureInfo(coatDarkeningTexture);
      const coatDarkeningInfo = {
        clearcoatDarkeningFactor: coatDarkeningFactor,
        clearcoatDarkeningTexture: coatDarkeningTextureInfo ?? void 0
      };
      if (coatDarkeningInfo.clearcoatDarkeningTexture !== null) {
        this._exporter._materialNeedsUVsSet.add(babylonMaterial);
      }
      parentExt.extensions = parentExt.extensions || {};
      parentExt.extensions[NAME6] = coatDarkeningInfo;
      return resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME6, (exporter) => new KHR_materials_clearcoat_darkening(exporter), 105);

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_clearcoat_ior.js
var NAME7 = "KHR_materials_clearcoat_ior";
var KHR_materials_clearcoat_ior = class {
  /**
   * @param exporter The glTF exporter
   */
  constructor(exporter) {
    this.name = NAME7;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  /** @internal */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      let coatIor = null;
      if (babylonMaterial instanceof OpenPBRMaterial) {
        coatIor = babylonMaterial.coatIor;
      } else if (babylonMaterial instanceof PBRMaterial) {
        coatIor = babylonMaterial.clearCoat.indexOfRefraction;
      }
      if (coatIor === null || coatIor === 1.5) {
        return resolve(node);
      }
      const parentExt = node.extensions ? node.extensions["KHR_materials_clearcoat"] : null;
      if (!parentExt) {
        return resolve(node);
      }
      this._wasUsed = true;
      const coatIorInfo = {
        clearcoatIor: coatIor
      };
      this._exporter;
      parentExt.extensions = parentExt.extensions || {};
      parentExt.extensions[NAME7] = coatIorInfo;
      return resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME7, (exporter) => new KHR_materials_clearcoat_ior(exporter), 105);

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_clearcoat_color.js
var NAME8 = "KHR_materials_clearcoat_color";
var KHR_materials_clearcoat_color = class {
  constructor(exporter) {
    this.name = NAME8;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRBaseMaterial) {
      if (babylonMaterial.clearCoat.isEnabled) {
        if (babylonMaterial.clearCoat.tintTexture) {
          additionalTextures.push(babylonMaterial.clearCoat.tintTexture);
        }
        return additionalTextures;
      }
    } else if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.coatWeight > 0) {
        if (babylonMaterial.coatColorTexture) {
          additionalTextures.push(babylonMaterial.coatColorTexture);
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRBaseMaterial) {
        if (!babylonMaterial.clearCoat.isEnabled) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        const parentExt = node.extensions ? node.extensions["KHR_materials_clearcoat"] : null;
        if (!parentExt) {
          resolve(node);
          return;
        }
        const coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.tintTexture);
        const clearCoatInfo = {
          clearcoatColorFactor: babylonMaterial.clearCoat.tintColor.asArray(),
          clearcoatColorTexture: coatColorTextureInfo ?? void 0
        };
        if (clearCoatInfo.clearcoatColorTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        parentExt.extensions = parentExt.extensions || {};
        parentExt.extensions[NAME8] = clearCoatInfo;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        if (babylonMaterial.coatWeight == 0) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        const parentExt = node.extensions ? node.extensions["KHR_materials_clearcoat"] : null;
        if (!parentExt) {
          resolve(node);
          return;
        }
        const coatColorTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.coatWeightTexture);
        const clearCoatInfo = {
          clearcoatColorFactor: babylonMaterial.coatColor.asArray(),
          clearcoatColorTexture: coatColorTextureInfo ?? void 0
        };
        if (clearCoatInfo.clearcoatColorTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        parentExt.extensions = parentExt.extensions || {};
        parentExt.extensions[NAME8] = clearCoatInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME8, (exporter) => new KHR_materials_clearcoat_color(exporter), 105);

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_clearcoat_anisotropy.js
var NAME9 = "KHR_materials_clearcoat_anisotropy";
function OpenpbrAnisotropyStrengthToGltf2(baseRoughness, anisotropy) {
  const baseAlpha = baseRoughness * baseRoughness;
  const roughnessT = baseAlpha * Math.sqrt(2 / (1 + (1 - anisotropy) * (1 - anisotropy)));
  const roughnessB = (1 - anisotropy) * roughnessT;
  const newBaseRoughness = Math.sqrt(roughnessB);
  const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1 - baseAlpha, 1e-4)), 1);
  return { newBaseRoughness, newAnisotropyStrength };
}
function CopyTextureTransform2(source, destination) {
  destination.uOffset = source.uOffset;
  destination.vOffset = source.vOffset;
  destination.uScale = source.uScale;
  destination.vScale = source.vScale;
  destination.uAng = source.uAng;
  destination.vAng = source.vAng;
  destination.wAng = source.wAng;
  destination.uRotationCenter = source.uRotationCenter;
  destination.vRotationCenter = source.vRotationCenter;
}
var AnisotropyMergeFragment2 = `
    precision highp float;
#ifdef HAS_TANGENT_TEXTURE
    uniform sampler2D tangentTexture;
#endif
#ifdef HAS_ANISOTROPY_TEXTURE
    uniform sampler2D anisotropyTexture;
#endif
    uniform int useRoughnessFromMetallicGreen;
    uniform int useAnisotropyFromTangentBlue;

    varying vec2 vUV;

    void main() {
        vec2 tangent = vec2(1.0, 0.0);
        float anisotropy = 1.0;
        #ifdef HAS_TANGENT_TEXTURE
            // Tangent texture is present
            vec4 tangentSample = texture2D(tangentTexture, vUV);
            tangent = tangentSample.rg;

            if (useAnisotropyFromTangentBlue > 0) {
                anisotropy = tangentSample.b;
            }
        #endif
        #ifdef HAS_ANISOTROPY_TEXTURE
            // Anisotropy texture is present
            vec4 anisotropySample = texture2D(anisotropyTexture, vUV);
            anisotropy = anisotropySample.r;
        #endif
        
        // Output: RG = tangent XY, B = anisotropy strength
        vec4 anisotropyData = vec4(tangent.x, tangent.y, anisotropy, 1.0);
        gl_FragColor = anisotropyData;
    }
`;
async function CreateMergedAnisotropyTexture2(babylonMaterial) {
  const scene = babylonMaterial.getScene();
  if (!Effect.ShadersStore["anisotropyMergeFragmentShader"]) {
    Effect.ShadersStore["anisotropyMergeFragmentShader"] = AnisotropyMergeFragment2;
  }
  const anisoStrengthTexture = babylonMaterial.coatRoughnessAnisotropyTexture;
  const tangentTexture = babylonMaterial.geometryCoatTangentTexture;
  if (!(anisoStrengthTexture || tangentTexture)) {
    return null;
  }
  const width = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().width : 1, tangentTexture ? tangentTexture.getSize().width : 1);
  const height = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().height : 1, tangentTexture ? tangentTexture.getSize().height : 1);
  const textureOptions = {
    type: Constants.TEXTURETYPE_UNSIGNED_BYTE,
    format: Constants.TEXTUREFORMAT_RGBA,
    samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,
    generateDepthBuffer: false,
    generateStencilBuffer: false,
    generateMipMaps: false
  };
  const rtTexture = new ProceduralTexture(babylonMaterial.name + "_anisotropy", {
    width,
    height
  }, "anisotropyMerge", scene, textureOptions);
  rtTexture.refreshRate = -1;
  let defines = "";
  if (tangentTexture) {
    defines += "#define HAS_TANGENT_TEXTURE\n";
    rtTexture.setTexture("tangentTexture", tangentTexture);
    CopyTextureTransform2(tangentTexture, rtTexture);
  }
  rtTexture.setVector2("tangentVector", babylonMaterial.geometryTangent);
  if (anisoStrengthTexture) {
    defines += "#define HAS_ANISOTROPY_TEXTURE\n";
    rtTexture.setTexture("anisotropyTexture", anisoStrengthTexture);
    CopyTextureTransform2(anisoStrengthTexture, rtTexture);
  }
  rtTexture.setInt("useAnisotropyFromTangentBlue", babylonMaterial._useCoatRoughnessAnisotropyFromTangentTexture ? 1 : 0);
  rtTexture.defines = defines;
  return await new Promise((resolve, reject) => {
    rtTexture.executeWhenReady(() => {
      try {
        rtTexture.render();
        resolve(rtTexture);
      } catch (error) {
        reject(error instanceof Error ? error : new Error(String(error)));
      }
    });
  });
}
var KHR_materials_clearcoat_anisotropy = class {
  constructor(exporter) {
    this.name = NAME9;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._anisoTexturesMap = {};
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with the additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.coatRoughnessAnisotropy > 0) {
        const anisoTexture = await CreateMergedAnisotropyTexture2(babylonMaterial);
        if (anisoTexture) {
          additionalTextures.push(anisoTexture);
          this._anisoTexturesMap[babylonMaterial.id] = anisoTexture;
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      var _a;
      if (babylonMaterial instanceof OpenPBRMaterial) {
        if (babylonMaterial.coatRoughnessAnisotropy > 0) {
          node.extensions = node.extensions || {};
          const parentExt = node.extensions ? node.extensions["KHR_materials_clearcoat"] : null;
          if (!parentExt) {
            return resolve(node);
          }
          this._wasUsed = true;
          const roughnessTexture = babylonMaterial.coatRoughnessTexture;
          const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];
          if (!roughnessTexture && !mergedAnisoTexture) {
            let newBaseRoughness = babylonMaterial.coatRoughness;
            let newAnisotropyStrength = babylonMaterial.coatRoughnessAnisotropy;
            if (!babylonMaterial._useGltfStyleAnisotropy) {
              const newParams = OpenpbrAnisotropyStrengthToGltf2(babylonMaterial.coatRoughness, babylonMaterial.coatRoughnessAnisotropy);
              newBaseRoughness = newParams.newBaseRoughness;
              newAnisotropyStrength = newParams.newAnisotropyStrength;
            }
            if (node.pbrMetallicRoughness) {
              node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;
            }
            const anisotropyInfo2 = {
              clearcoatAnisotropyStrength: newAnisotropyStrength,
              clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle + Math.PI * 0.5,
              clearcoatAnisotropyTexture: void 0
            };
            parentExt.extensions = parentExt.extensions || {};
            parentExt.extensions[NAME9] = anisotropyInfo2;
            return resolve(node);
          }
          const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;
          const anisotropyInfo = {
            clearcoatAnisotropyStrength: babylonMaterial.coatRoughnessAnisotropy,
            clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle,
            clearcoatAnisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : void 0,
            extensions: {}
          };
          if (!babylonMaterial._useGltfStyleAnisotropy) {
            anisotropyInfo.extensions["EXT_materials_anisotropy_openpbr"] = {
              openPbrAnisotropyEnabled: true
            };
            (_a = this._exporter._glTF).extensionsUsed || (_a.extensionsUsed = []);
            if (this._exporter._glTF.extensionsUsed.indexOf("EXT_materials_anisotropy_openpbr") === -1) {
              this._exporter._glTF.extensionsUsed.push("EXT_materials_anisotropy_openpbr");
            }
          }
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
          parentExt.extensions = parentExt.extensions || {};
          parentExt.extensions[NAME9] = anisotropyInfo;
        }
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME9, (exporter) => new KHR_materials_clearcoat_anisotropy(exporter), 105);

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.js
var NAME10 = "KHR_materials_diffuse_transmission";
function GetTranslucencyIntensityTexture(context, babylonMaterial) {
  const subs = babylonMaterial.subSurface;
  let texture = null;
  if (subs.translucencyIntensityTexture) {
    texture = subs.translucencyIntensityTexture;
  } else if (subs.thicknessTexture && subs.useMaskFromThicknessTexture) {
    texture = subs.thicknessTexture;
  }
  if (texture && !subs.useGltfStyleTextures) {
    Logger.Warn(`${context}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${babylonMaterial.name}`, 1);
    return null;
  }
  return texture;
}
var KHR_materials_diffuse_transmission = class {
  constructor(exporter) {
    this.name = NAME10;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
      const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);
      if (translucencyIntensityTexture) {
        additionalTextures.push(translucencyIntensityTexture);
      }
      if (babylonMaterial.subSurface.translucencyColorTexture) {
        additionalTextures.push(babylonMaterial.subSurface.translucencyColorTexture);
      }
      return additionalTextures;
    }
    return additionalTextures;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    const subs = mat.subSurface;
    if (!subs.isTranslucencyEnabled) {
      return false;
    }
    return !mat.unlit && !subs.useAlbedoToTintTranslucency && subs.useGltfStyleTextures && subs.volumeIndexOfRefraction === 1 && subs.minimumThickness === 0 && subs.maximumThickness === 0;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise that resolves with the updated node
   */
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
        this._wasUsed = true;
        const subs = babylonMaterial.subSurface;
        const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);
        const diffuseTransmissionFactor = subs.translucencyIntensity == 0 ? void 0 : subs.translucencyIntensity;
        const diffuseTransmissionTexture = this._exporter._materialExporter.getTextureInfo(translucencyIntensityTexture) ?? void 0;
        const diffuseTransmissionColorFactor = !subs.translucencyColor || subs.translucencyColor.equalsFloats(1, 1, 1) ? void 0 : subs.translucencyColor.asArray();
        const diffuseTransmissionColorTexture = this._exporter._materialExporter.getTextureInfo(subs.translucencyColorTexture) ?? void 0;
        const diffuseTransmissionInfo = {
          diffuseTransmissionFactor,
          diffuseTransmissionTexture,
          diffuseTransmissionColorFactor,
          diffuseTransmissionColorTexture
        };
        if (diffuseTransmissionTexture || diffuseTransmissionColorTexture) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions = node.extensions || {};
        node.extensions[NAME10] = diffuseTransmissionInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME10, (exporter) => new KHR_materials_diffuse_transmission(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_dispersion.js
var NAME11 = "KHR_materials_dispersion";
var KHR_materials_dispersion = class {
  /** Constructor */
  constructor() {
    this.name = NAME11;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
  }
  /** Dispose */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    const subs = mat.subSurface;
    if (!subs.isRefractionEnabled && !subs.isDispersionEnabled) {
      return false;
    }
    return true;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise, resolves with the material
   */
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
        this._wasUsed = true;
        const subs = babylonMaterial.subSurface;
        const dispersion = subs.dispersion;
        const dispersionInfo = {
          dispersion
        };
        node.extensions = node.extensions || {};
        node.extensions[NAME11] = dispersionInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME11, () => new KHR_materials_dispersion());

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_emissive_strength.js
var NAME12 = "KHR_materials_emissive_strength";
var KHR_materials_emissive_strength = class {
  constructor() {
    this.name = NAME12;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
  }
  /** Dispose */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise, resolves with the material
   */
  async postExportMaterialAsync(context, node, babylonMaterial) {
    return await new Promise((resolve) => {
      if (!(babylonMaterial instanceof PBRMaterial)) {
        return resolve(node);
      }
      const emissiveColor = babylonMaterial.emissiveColor.scale(babylonMaterial.emissiveIntensity);
      const tempEmissiveStrength = Math.max(...emissiveColor.asArray());
      if (tempEmissiveStrength > 1) {
        node.emissiveFactor = emissiveColor.scale(1 / tempEmissiveStrength).asArray();
        this._wasUsed = true;
        const emissiveStrengthInfo = {
          emissiveStrength: tempEmissiveStrength
        };
        node.extensions || (node.extensions = {});
        node.extensions[NAME12] = emissiveStrengthInfo;
      } else {
        node.emissiveFactor = emissiveColor.asArray();
      }
      return resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME12, () => new KHR_materials_emissive_strength());

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_ior.js
var NAME13 = "KHR_materials_ior";
var KHR_materials_ior = class {
  constructor() {
    this.name = NAME13;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
  }
  /** Dispose */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    return mat.indexOfRefraction != void 0 && mat.indexOfRefraction != 1.5;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise, resolves with the material
   */
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
        this._wasUsed = true;
        const iorInfo = {
          ior: babylonMaterial.indexOfRefraction
        };
        node.extensions = node.extensions || {};
        node.extensions[NAME13] = iorInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME13, (exporter) => new KHR_materials_ior());

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_iridescence.js
var NAME14 = "KHR_materials_iridescence";
var KHR_materials_iridescence = class {
  constructor(exporter) {
    this.name = NAME14;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRBaseMaterial) {
      if (babylonMaterial.iridescence.isEnabled) {
        if (babylonMaterial.iridescence.texture) {
          additionalTextures.push(babylonMaterial.iridescence.texture);
        }
        if (babylonMaterial.iridescence.thicknessTexture && babylonMaterial.iridescence.thicknessTexture !== babylonMaterial.iridescence.texture) {
          additionalTextures.push(babylonMaterial.iridescence.thicknessTexture);
        }
        return additionalTextures;
      }
    } else if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.thinFilmWeight > 0) {
        if (babylonMaterial.thinFilmWeightTexture) {
          additionalTextures.push(babylonMaterial.thinFilmWeightTexture);
        }
        if (babylonMaterial.thinFilmThicknessTexture && babylonMaterial.thinFilmThicknessTexture !== babylonMaterial.thinFilmWeightTexture) {
          additionalTextures.push(babylonMaterial.thinFilmThicknessTexture);
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRBaseMaterial) {
        if (!babylonMaterial.iridescence.isEnabled) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const iridescenceTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.texture);
        const iridescenceThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.thicknessTexture);
        const iridescenceInfo = {
          iridescenceFactor: babylonMaterial.iridescence.intensity,
          iridescenceIor: babylonMaterial.iridescence.indexOfRefraction,
          iridescenceThicknessMinimum: babylonMaterial.iridescence.minimumThickness,
          iridescenceThicknessMaximum: babylonMaterial.iridescence.maximumThickness,
          iridescenceTexture: iridescenceTextureInfo ?? void 0,
          iridescenceThicknessTexture: iridescenceThicknessTextureInfo ?? void 0
        };
        if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME14] = iridescenceInfo;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        if (babylonMaterial.thinFilmWeight <= 0) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const thinFilmWeightTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.thinFilmWeightTexture);
        const thinFilmThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.thinFilmThicknessTexture);
        const iridescenceInfo = {
          iridescenceFactor: babylonMaterial.thinFilmWeight,
          iridescenceIor: babylonMaterial.thinFilmIor,
          iridescenceThicknessMinimum: babylonMaterial.thinFilmThicknessMin * 1e3,
          // Convert to nanometers for glTF
          iridescenceThicknessMaximum: babylonMaterial.thinFilmThickness * 1e3,
          // Convert to nanometers for glTF
          iridescenceTexture: thinFilmWeightTextureInfo ?? void 0,
          iridescenceThicknessTexture: thinFilmThicknessTextureInfo ?? void 0
        };
        if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME14] = iridescenceInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME14, (exporter) => new KHR_materials_iridescence(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_sheen.js
var NAME15 = "KHR_materials_sheen";
var KHR_materials_sheen = class {
  constructor(exporter) {
    this.name = NAME15;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    if (babylonMaterial instanceof PBRMaterial) {
      if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {
        return [babylonMaterial.sheen.texture];
      }
    }
    return [];
  }
  async postExportMaterialAsync(context, node, babylonMaterial) {
    return await new Promise((resolve) => {
      if (babylonMaterial instanceof PBRMaterial) {
        if (!babylonMaterial.sheen.isEnabled) {
          resolve(node);
          return;
        }
        this._wasUsed = true;
        if (node.extensions == null) {
          node.extensions = {};
        }
        const sheenInfo = {
          sheenColorFactor: babylonMaterial.sheen.color.asArray(),
          sheenRoughnessFactor: babylonMaterial.sheen.roughness ?? 0
        };
        if (sheenInfo.sheenColorTexture !== null || sheenInfo.sheenRoughnessTexture !== null) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        if (babylonMaterial.sheen.texture) {
          sheenInfo.sheenColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? void 0;
        }
        if (babylonMaterial.sheen.textureRoughness && !babylonMaterial.sheen.useRoughnessFromMainTexture) {
          sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.textureRoughness) ?? void 0;
        } else if (babylonMaterial.sheen.texture && babylonMaterial.sheen.useRoughnessFromMainTexture) {
          sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? void 0;
        }
        node.extensions[NAME15] = sheenInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME15, (exporter) => new KHR_materials_sheen(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_specular.js
var NAME16 = "KHR_materials_specular";
var KHR_materials_specular = class {
  constructor(exporter) {
    this.name = NAME16;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  /** Dispose */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with the additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRMaterial) {
      if (this._isExtensionEnabled(babylonMaterial)) {
        if (babylonMaterial.metallicReflectanceTexture) {
          additionalTextures.push(babylonMaterial.metallicReflectanceTexture);
        }
        if (babylonMaterial.reflectanceTexture) {
          additionalTextures.push(babylonMaterial.reflectanceTexture);
        }
        return additionalTextures;
      }
    }
    return additionalTextures;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    return mat.metallicF0Factor != void 0 && mat.metallicF0Factor != 1 || mat.metallicReflectanceColor != void 0 && !mat.metallicReflectanceColor.equalsFloats(1, 1, 1) || this._hasTexturesExtension(mat);
  }
  _hasTexturesExtension(mat) {
    return mat.metallicReflectanceTexture != null || mat.reflectanceTexture != null;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise, resolves with the material
   */
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      var _a;
      if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
        this._wasUsed = true;
        node.extensions = node.extensions || {};
        const metallicReflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.metallicReflectanceTexture) ?? void 0;
        const reflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.reflectanceTexture) ?? void 0;
        const metallicF0Factor = babylonMaterial.metallicF0Factor == 1 ? void 0 : babylonMaterial.metallicF0Factor;
        const metallicReflectanceColor = babylonMaterial.metallicReflectanceColor.equalsFloats(1, 1, 1) ? void 0 : babylonMaterial.metallicReflectanceColor.asArray();
        const specularInfo = {
          specularFactor: metallicF0Factor,
          specularTexture: metallicReflectanceTexture,
          specularColorFactor: metallicReflectanceColor,
          specularColorTexture: reflectanceTexture
        };
        if (this._hasTexturesExtension(babylonMaterial)) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME16] = specularInfo;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        node.extensions = node.extensions || {};
        const specularWeightTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.specularWeightTexture) ?? void 0;
        const specularColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.specularColorTexture) ?? void 0;
        const specularWeight = babylonMaterial.specularWeight == 1 ? void 0 : babylonMaterial.specularWeight;
        const specularColor = babylonMaterial.specularColor.equalsFloats(1, 1, 1) ? void 0 : babylonMaterial.specularColor.asArray();
        if (!specularColorTexture && !specularWeightTexture && specularWeight === void 0 && specularColor === void 0) {
          return resolve(node);
        }
        this._wasUsed = true;
        const specularEdgeColorInfo = {
          specularEdgeColorEnabled: true
        };
        const specularInfo = {
          specularFactor: specularWeight,
          specularTexture: specularWeightTexture,
          specularColorFactor: specularColor,
          specularColorTexture,
          extensions: {}
        };
        specularInfo.extensions["EXT_materials_specular_edge_color"] = specularEdgeColorInfo;
        (_a = this._exporter._glTF).extensionsUsed || (_a.extensionsUsed = []);
        if (this._exporter._glTF.extensionsUsed.indexOf("EXT_materials_specular_edge_color") === -1) {
          this._exporter._glTF.extensionsUsed.push("EXT_materials_specular_edge_color");
        }
        if (specularWeightTexture || specularColorTexture) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions[NAME16] = specularInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME16, (exporter) => new KHR_materials_specular(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_transmission.js
var NAME17 = "KHR_materials_transmission";
var KHR_materials_transmission = class {
  constructor(exporter) {
    this.name = NAME17;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  /** Dispose */
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRMaterial) {
      if (this._isExtensionEnabled(babylonMaterial)) {
        if (babylonMaterial.subSurface.thicknessTexture) {
          additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);
        }
        return additionalTextures;
      }
    }
    return additionalTextures;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    const subs = mat.subSurface;
    return subs.isRefractionEnabled && subs.refractionIntensity != void 0 && subs.refractionIntensity != 0 || this._hasTexturesExtension(mat);
  }
  _hasTexturesExtension(mat) {
    return mat.subSurface.refractionIntensityTexture != null;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns true if successful
   */
  async postExportMaterialAsync(context, node, babylonMaterial) {
    if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
      this._wasUsed = true;
      const subSurface = babylonMaterial.subSurface;
      const transmissionFactor = subSurface.refractionIntensity === 0 ? void 0 : subSurface.refractionIntensity;
      const volumeInfo = {
        transmissionFactor
      };
      if (this._hasTexturesExtension(babylonMaterial)) {
        this._exporter._materialNeedsUVsSet.add(babylonMaterial);
      }
      if (subSurface.refractionIntensityTexture) {
        if (subSurface.useGltfStyleTextures) {
          const transmissionTexture = await this._exporter._materialExporter.exportTextureAsync(subSurface.refractionIntensityTexture);
          if (transmissionTexture) {
            volumeInfo.transmissionTexture = transmissionTexture;
          }
        } else {
          Logger.Warn(`${context}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);
        }
      }
      node.extensions || (node.extensions = {});
      node.extensions[NAME17] = volumeInfo;
    }
    return node;
  }
};
GLTFExporter.RegisterExtension(NAME17, (exporter) => new KHR_materials_transmission(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_unlit.js
var NAME18 = "KHR_materials_unlit";
var KHR_materials_unlit = class {
  constructor() {
    this.name = NAME18;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  dispose() {
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      let unlitMaterial = false;
      if (babylonMaterial instanceof PBRMaterial) {
        unlitMaterial = babylonMaterial.unlit;
      } else if (babylonMaterial instanceof StandardMaterial) {
        unlitMaterial = babylonMaterial.disableLighting;
      }
      if (unlitMaterial) {
        this._wasUsed = true;
        if (node.extensions == null) {
          node.extensions = {};
        }
        node.extensions[NAME18] = {};
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME18, () => new KHR_materials_unlit());

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_volume.js
var NAME19 = "KHR_materials_volume";
var KHR_materials_volume = class {
  constructor(exporter) {
    this.name = NAME19;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  /**
   * After exporting a material, deal with additional textures
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns array of additional textures to export
   */
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRMaterial) {
      if (this._isExtensionEnabled(babylonMaterial)) {
        if (babylonMaterial.subSurface.thicknessTexture) {
          additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);
        }
        return additionalTextures;
      }
    }
    return additionalTextures;
  }
  _isExtensionEnabled(mat) {
    if (mat.unlit) {
      return false;
    }
    const subs = mat.subSurface;
    if (!subs.isRefractionEnabled && !subs.isTranslucencyEnabled) {
      return false;
    }
    return subs.maximumThickness != void 0 && subs.maximumThickness != 0 || subs.tintColorAtDistance != void 0 && subs.tintColorAtDistance != Number.POSITIVE_INFINITY || subs.tintColor != void 0 && subs.tintColor != Color3.White() || this._hasTexturesExtension(mat);
  }
  _hasTexturesExtension(mat) {
    return mat.subSurface.thicknessTexture != null;
  }
  /**
   * After exporting a material
   * @param context GLTF context of the material
   * @param node exported GLTF node
   * @param babylonMaterial corresponding babylon material
   * @returns promise that resolves with the updated node
   */
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {
        this._wasUsed = true;
        const subs = babylonMaterial.subSurface;
        const thicknessFactor = subs.maximumThickness == 0 ? void 0 : subs.maximumThickness;
        const thicknessTexture = this._exporter._materialExporter.getTextureInfo(subs.thicknessTexture) ?? void 0;
        const attenuationDistance = subs.tintColorAtDistance == Number.POSITIVE_INFINITY ? void 0 : subs.tintColorAtDistance;
        const attenuationColor = subs.tintColor.equalsFloats(1, 1, 1) ? void 0 : subs.tintColor.asArray();
        const volumeInfo = {
          thicknessFactor,
          thicknessTexture,
          attenuationDistance,
          attenuationColor
        };
        if (this._hasTexturesExtension(babylonMaterial)) {
          this._exporter._materialNeedsUVsSet.add(babylonMaterial);
        }
        node.extensions = node.extensions || {};
        node.extensions[NAME19] = volumeInfo;
      }
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME19, (exporter) => new KHR_materials_volume(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_materials_diffuse_roughness.js
var NAME20 = "KHR_materials_diffuse_roughness";
var KHR_materials_diffuse_roughness = class {
  constructor(exporter) {
    this.name = NAME20;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  async postExportMaterialAdditionalTexturesAsync(context, node, babylonMaterial) {
    const additionalTextures = [];
    if (babylonMaterial instanceof PBRBaseMaterial) {
      if (babylonMaterial._baseDiffuseRoughness) {
        if (babylonMaterial._baseDiffuseRoughnessTexture) {
          additionalTextures.push(babylonMaterial._baseDiffuseRoughnessTexture);
        }
        return additionalTextures;
      }
    } else if (babylonMaterial instanceof OpenPBRMaterial) {
      if (babylonMaterial.baseDiffuseRoughness) {
        if (babylonMaterial.baseDiffuseRoughnessTexture) {
          additionalTextures.push(babylonMaterial.baseDiffuseRoughnessTexture);
        }
        return additionalTextures;
      }
    }
    return [];
  }
  // eslint-disable-next-line no-restricted-syntax
  postExportMaterialAsync(context, node, babylonMaterial) {
    return new Promise((resolve) => {
      let diffuseRoughnessFactor = null;
      let diffuseRoughnessTexture = null;
      if (babylonMaterial instanceof PBRBaseMaterial) {
        diffuseRoughnessFactor = babylonMaterial._baseDiffuseRoughness;
        diffuseRoughnessTexture = babylonMaterial._baseDiffuseRoughnessTexture;
      } else if (babylonMaterial instanceof OpenPBRMaterial) {
        diffuseRoughnessFactor = babylonMaterial.baseDiffuseRoughness;
        diffuseRoughnessTexture = babylonMaterial.baseDiffuseRoughnessTexture;
      }
      if (!diffuseRoughnessFactor) {
        resolve(node);
        return;
      }
      this._wasUsed = true;
      node.extensions = node.extensions || {};
      const diffuseRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(diffuseRoughnessTexture);
      const diffuseRoughnessInfo = {
        diffuseRoughnessFactor,
        diffuseRoughnessTexture: diffuseRoughnessTextureInfo ?? void 0
      };
      if (diffuseRoughnessInfo.diffuseRoughnessTexture !== null) {
        this._exporter._materialNeedsUVsSet.add(babylonMaterial);
      }
      node.extensions[NAME20] = diffuseRoughnessInfo;
      resolve(node);
    });
  }
};
GLTFExporter.RegisterExtension(NAME20, (exporter) => new KHR_materials_diffuse_roughness(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_texture_transform.js
var NAME21 = "KHR_texture_transform";
function AdjustOffsetForRotationCenter(babylonTexture) {
  const { uOffset, vOffset, uRotationCenter, vRotationCenter, uScale, vScale, wAng } = babylonTexture;
  const cosAngle = Math.cos(wAng);
  const sinAngle = Math.sin(wAng);
  const scaledURotationCenter = uRotationCenter * uScale;
  const scaledVRotationCenter = vRotationCenter * vScale;
  const deltaU = scaledURotationCenter * (1 - cosAngle) + scaledVRotationCenter * sinAngle;
  const deltaV = scaledVRotationCenter * (1 - cosAngle) - scaledURotationCenter * sinAngle;
  return [uOffset + deltaU, vOffset + deltaV];
}
var KHR_texture_transform = class {
  constructor() {
    this.name = NAME21;
    this.enabled = true;
    this.required = false;
    this._wasUsed = false;
  }
  dispose() {
  }
  /** @internal */
  get wasUsed() {
    return this._wasUsed;
  }
  postExportTexture(context, textureInfo, babylonTexture) {
    const scene = babylonTexture.getScene();
    if (!scene) {
      Tools.Warn(`${context}: "scene" is not defined for Babylon texture ${babylonTexture.name}!`);
    }
    if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {
      Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);
      if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {
        return;
      }
    }
    const textureTransform = {};
    let transformIsRequired = false;
    if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {
      textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];
      transformIsRequired = true;
    }
    if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {
      textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];
      transformIsRequired = true;
    }
    if (babylonTexture.wAng !== 0) {
      if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {
        if (babylonTexture.homogeneousRotationInUVTransform && babylonTexture.uScale !== babylonTexture.vScale) {
          Tools.Warn(`${context}: Texture ${babylonTexture.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${NAME21}.`);
          return;
        }
        Tools.Warn(`${context}: Texture ${babylonTexture.name} with non-origin rotation center will be exported using an adjusted offset with ${NAME21}.`);
        textureTransform.offset = AdjustOffsetForRotationCenter(babylonTexture);
      }
      textureTransform.rotation = -babylonTexture.wAng;
      transformIsRequired = true;
    }
    if (babylonTexture.coordinatesIndex !== 0) {
      textureTransform.texCoord = babylonTexture.coordinatesIndex;
      transformIsRequired = true;
    }
    if (!transformIsRequired) {
      return;
    }
    this._wasUsed = true;
    if (!textureInfo.extensions) {
      textureInfo.extensions = {};
    }
    textureInfo.extensions[NAME21] = textureTransform;
  }
};
GLTFExporter.RegisterExtension(NAME21, () => new KHR_texture_transform());

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/KHR_texture_basisu.js
var NAME22 = "KHR_texture_basisu";
var KHR_texture_basisu = class {
  get wasUsed() {
    return this._wasUsed;
  }
  constructor(exporter) {
    this.name = NAME22;
    this.enabled = true;
    this.required = true;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  postExportTexture(_, textureInfo) {
    const texture = this._exporter._textures[textureInfo.index];
    const imageIndex = texture.source;
    if (imageIndex === void 0) {
      return;
    }
    const image = this._exporter._images[imageIndex];
    const sourceMimeType = image.mimeType || GetMimeType(image.uri);
    if (sourceMimeType !== "image/ktx2") {
      return;
    }
    texture.source = void 0;
    texture.extensions || (texture.extensions = {});
    texture.extensions[NAME22] = {
      source: imageIndex
    };
    this._wasUsed = true;
  }
};
GLTFExporter.RegisterExtension(NAME22, (exporter) => new KHR_texture_basisu(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/EXT_texture_webp.js
var NAME23 = "EXT_texture_webp";
var EXT_texture_webp = class {
  get wasUsed() {
    return this._wasUsed;
  }
  constructor(exporter) {
    this.name = NAME23;
    this.enabled = true;
    this.required = true;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  postExportTexture(_, textureInfo) {
    const texture = this._exporter._textures[textureInfo.index];
    const imageIndex = texture.source;
    if (imageIndex === void 0) {
      return;
    }
    const image = this._exporter._images[imageIndex];
    const sourceMimeType = image.mimeType || GetMimeType(image.uri);
    if (sourceMimeType !== "image/webp") {
      return;
    }
    texture.source = void 0;
    texture.extensions || (texture.extensions = {});
    texture.extensions[NAME23] = {
      source: imageIndex
    };
    this._wasUsed = true;
  }
};
GLTFExporter.RegisterExtension(NAME23, (exporter) => new EXT_texture_webp(exporter));

// node_modules/@babylonjs/serializers/glTF/2.0/Extensions/EXT_texture_avif.js
var NAME24 = "EXT_texture_avif";
var EXT_texture_avif = class {
  get wasUsed() {
    return this._wasUsed;
  }
  constructor(exporter) {
    this.name = NAME24;
    this.enabled = true;
    this.required = true;
    this._wasUsed = false;
    this._exporter = exporter;
  }
  dispose() {
  }
  postExportTexture(_, textureInfo) {
    const texture = this._exporter._textures[textureInfo.index];
    const imageIndex = texture.source;
    if (imageIndex === void 0) {
      return;
    }
    const image = this._exporter._images[imageIndex];
    const sourceMimeType = image.mimeType || GetMimeType(image.uri);
    if (sourceMimeType !== "image/avif") {
      return;
    }
    texture.source = void 0;
    texture.extensions || (texture.extensions = {});
    texture.extensions[NAME24] = {
      source: imageIndex
    };
    this._wasUsed = true;
  }
};
GLTFExporter.RegisterExtension(NAME24, (exporter) => new EXT_texture_avif(exporter));
export {
  EXT_mesh_gpu_instancing,
  EXT_texture_avif,
  EXT_texture_webp,
  GLTF2Export,
  GLTFData,
  KHR_draco_mesh_compression,
  KHR_lights_punctual,
  KHR_materials_anisotropy,
  KHR_materials_clearcoat,
  KHR_materials_clearcoat_anisotropy,
  KHR_materials_clearcoat_color,
  KHR_materials_clearcoat_darkening,
  KHR_materials_clearcoat_ior,
  KHR_materials_diffuse_roughness,
  KHR_materials_diffuse_transmission,
  KHR_materials_dispersion,
  KHR_materials_emissive_strength,
  KHR_materials_ior,
  KHR_materials_iridescence,
  KHR_materials_sheen,
  KHR_materials_specular,
  KHR_materials_transmission,
  KHR_materials_unlit,
  KHR_materials_volume,
  KHR_texture_basisu,
  KHR_texture_transform,
  _ConvertToGLTFPBRMetallicRoughness,
  _SolveMetallic,
  __IGLTFExporterExtension
};
//# sourceMappingURL=@babylonjs_serializers_glTF.js.map
