{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/Textures/rawTexture.ts", "../../../dev/core/src/Cameras/targetCamera.ts", "../../../dev/core/src/Maths/math.scalar.ts", "../../../dev/core/src/Morph/morphTarget.ts", "../../../dev/core/src/Misc/deepMerger.ts", "../../../dev/core/src/Meshes/thinInstanceMesh.ts", "../../../dev/core/src/Meshes/Compression/dracoCompressionWorker.ts", "../../../dev/core/src/Meshes/Compression/dracoCodec.ts"],
  "sourcesContent": ["import { Texture } from \"./texture\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport type { Nullable } from \"../../types\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\n\r\nimport type { Scene } from \"../../scene\";\r\n\r\n/**\r\n * Raw texture can help creating a texture directly from an array of data.\r\n * This can be super useful if you either get the data from an uncompressed source or\r\n * if you wish to create your texture pixel by pixel.\r\n */\r\nexport class RawTexture extends Texture {\r\n    private _waitingForData: boolean;\r\n    /**\r\n     * Instantiates a new RawTexture.\r\n     * Raw texture can help creating a texture directly from an array of data.\r\n     * This can be super useful if you either get the data from an uncompressed source or\r\n     * if you wish to create your texture pixel by pixel.\r\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\r\n     * @param width define the width of the texture\r\n     * @param height define the height of the texture\r\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps define whether mip maps should be generated or not\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.\r\n     */\r\n    constructor(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        /**\r\n         * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\r\n         */\r\n        public format: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags?: number,\r\n        useSRGBBuffer?: boolean,\r\n        waitDataToBeReady?: boolean\r\n    ) {\r\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\r\n\r\n        if (!this._engine) {\r\n            return;\r\n        }\r\n\r\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\r\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\r\n        }\r\n\r\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false);\r\n\r\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\r\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\r\n        this._waitingForData = !!waitDataToBeReady && !data;\r\n    }\r\n\r\n    /**\r\n     * Updates the texture underlying data.\r\n     * @param data Define the new data of the texture\r\n     */\r\n    public update(data: ArrayBufferView): void {\r\n        this._getEngine()!.updateRawTexture(this._texture, data, this._texture!.format, this._texture!.invertY, null, this._texture!.type, this._texture!._useSRGBBuffer);\r\n        this._waitingForData = false;\r\n    }\r\n\r\n    /**\r\n     * Clones the texture.\r\n     * @returns the cloned texture\r\n     */\r\n    public override clone(): Texture {\r\n        if (!this._texture) {\r\n            return super.clone();\r\n        }\r\n\r\n        const rawTexture = new RawTexture(\r\n            null,\r\n            this.getSize().width,\r\n            this.getSize().height,\r\n            this.format,\r\n            this.getScene(),\r\n            this._texture.generateMipMaps,\r\n            this._invertY,\r\n            this.samplingMode,\r\n            this._texture.type,\r\n            this._texture._creationFlags,\r\n            this._useSRGBBuffer\r\n        );\r\n\r\n        rawTexture._texture = this._texture;\r\n        this._texture.incrementReferences();\r\n\r\n        return rawTexture;\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        return super.isReady() && !this._waitingForData;\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance texture\r\n     */\r\n    public static CreateLuminanceTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a luminance alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the luminance alpha texture\r\n     */\r\n    public static CreateLuminanceAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates an alpha texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @returns the alpha texture\r\n     */\r\n    public static CreateAlphaTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGB texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGB alpha texture\r\n     */\r\n    public static CreateRGBTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBATexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        creationFlags: number = 0,\r\n        useSRGBBuffer: boolean = false,\r\n        waitDataToBeReady: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            creationFlags,\r\n            useSRGBBuffer,\r\n            waitDataToBeReady\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a RGBA storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\r\n     * @returns the RGBA texture\r\n     */\r\n    public static CreateRGBAStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        useSRGBBuffer: boolean = false\r\n    ): RawTexture {\r\n        return new RawTexture(\r\n            data,\r\n            width,\r\n            height,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            sceneOrEngine,\r\n            generateMipMaps,\r\n            invertY,\r\n            samplingMode,\r\n            type,\r\n            Constants.TEXTURE_CREATIONFLAG_STORAGE,\r\n            useSRGBBuffer\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a R texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    public static CreateRTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\r\n    }\r\n\r\n    /**\r\n     * Creates a R storage texture from some data.\r\n     * @param data Define the texture data\r\n     * @param width Define the width of the texture\r\n     * @param height Define the height of the texture\r\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\r\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\r\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\r\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\r\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\r\n     * @returns the R texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public static CreateRStorageTexture(\r\n        data: Nullable<ArrayBufferView>,\r\n        width: number,\r\n        height: number,\r\n        sceneOrEngine: Nullable<Scene | AbstractEngine>,\r\n        generateMipMaps: boolean = true,\r\n        invertY: boolean = false,\r\n        samplingMode: number = Texture.TRILINEAR_SAMPLINGMODE,\r\n        type: number = Constants.TEXTURETYPE_FLOAT\r\n    ): RawTexture {\r\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\r\n    }\r\n}\r\n", "import { serialize, serializeAsVector3, serializeAsMeshReference } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Camera } from \"./camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Quaternion, Matrix, Vector3, Vector2, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Axis } from \"../Maths/math.axis\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Node } from \"../node\";\r\n\r\nNode.AddNodeConstructor(\"TargetCamera\", (name, scene) => {\r\n    return () => new TargetCamera(name, Vector3.Zero(), scene);\r\n});\r\n\r\n// Temporary cache variables to avoid allocations.\r\nconst TmpMatrix = Matrix.Zero();\r\nconst TmpQuaternion = Quaternion.Identity();\r\n\r\n/**\r\n * A target camera takes a mesh or position as a target and continues to look at it while it moves.\r\n * This is the base of the follow, arc rotate cameras and Free camera\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n */\r\nexport class TargetCamera extends Camera {\r\n    private static _RigCamTransformMatrix = new Matrix();\r\n    private static _TargetTransformMatrix = new Matrix();\r\n    private static _TargetFocalPoint = new Vector3();\r\n\r\n    /**\r\n     * Define the current direction the camera is moving to\r\n     */\r\n    public cameraDirection = new Vector3(0, 0, 0);\r\n    /**\r\n     * Define the current rotation the camera is rotating to\r\n     */\r\n    public cameraRotation = new Vector2(0, 0);\r\n\r\n    /**\r\n     * When set, the up vector of the camera will be updated by the rotation of the camera\r\n     */\r\n    @serialize()\r\n    public updateUpVectorFromRotation = false;\r\n\r\n    /**\r\n     * Define the current rotation of the camera\r\n     */\r\n    @serializeAsVector3()\r\n    public rotation: Vector3;\r\n\r\n    /**\r\n     * Define the current rotation of the camera as a quaternion to prevent Gimbal lock\r\n     */\r\n    public rotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Define the current speed of the camera\r\n     */\r\n    @serialize()\r\n    public speed = 2.0;\r\n\r\n    /**\r\n     * Add constraint to the camera to prevent it to move freely in all directions and\r\n     * around all axis.\r\n     */\r\n    public noRotationConstraint = false;\r\n\r\n    /**\r\n     * Reverses mouselook direction to 'natural' panning as opposed to traditional direct\r\n     * panning\r\n     */\r\n    public invertRotation = false;\r\n\r\n    /**\r\n     * Speed multiplier for inverse camera panning\r\n     */\r\n    public inverseRotationSpeed = 0.2;\r\n\r\n    /**\r\n     * @internal\r\n     * @experimental\r\n     * Can be used to change clamping behavior for inertia. Hook into onBeforeRenderObservable to change the value per-frame\r\n     */\r\n    public _panningEpsilon = Epsilon;\r\n    /**\r\n     * @internal\r\n     * @experimental\r\n     * Can be used to change clamping behavior for inertia. Hook into onBeforeRenderObservable to change the value per-frame\r\n     */\r\n    public _rotationEpsilon = Epsilon;\r\n\r\n    /**\r\n     * Define the current target of the camera as an object or a position.\r\n     * Please note that locking a target will disable panning.\r\n     */\r\n    @serializeAsMeshReference(\"lockedTargetId\")\r\n    public lockedTarget: any = null;\r\n\r\n    protected readonly _currentTarget = Vector3.Zero();\r\n    protected _initialFocalDistance = 1;\r\n    protected readonly _viewMatrix = Matrix.Zero();\r\n\r\n    /** @internal */\r\n    public readonly _cameraTransformMatrix = Matrix.Zero();\r\n    /** @internal */\r\n    public readonly _cameraRotationMatrix = Matrix.Zero();\r\n\r\n    protected readonly _referencePoint: Vector3;\r\n    protected readonly _transformedReferencePoint = Vector3.Zero();\r\n\r\n    protected readonly _deferredPositionUpdate = new Vector3();\r\n    protected readonly _deferredRotationQuaternionUpdate = new Quaternion();\r\n    protected readonly _deferredRotationUpdate = new Vector3();\r\n    protected _deferredUpdated = false;\r\n    protected _deferOnly: boolean = false;\r\n\r\n    /** @internal */\r\n    public _reset: () => void;\r\n\r\n    /**\r\n     * Instantiates a target camera that takes a mesh or position as a target and continues to look at it while it moves.\r\n     * This is the base of the follow, arc rotate cameras and Free camera\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras\r\n     * @param name Defines the name of the camera in the scene\r\n     * @param position Defines the start position of the camera in the scene\r\n     * @param scene Defines the scene the camera belongs to\r\n     * @param setActiveOnSceneIfNoneActive Defines whether the camera should be marked as active if not other active cameras have been defined\r\n     */\r\n    constructor(name: string, position: Vector3, scene?: Scene, setActiveOnSceneIfNoneActive = true) {\r\n        super(name, position, scene, setActiveOnSceneIfNoneActive);\r\n\r\n        this._referencePoint = Vector3.Forward(this.getScene().useRightHandedSystem);\r\n\r\n        // Set the y component of the rotation to Math.PI in right-handed system for backwards compatibility.\r\n        this.rotation = new Vector3(0, this.getScene().useRightHandedSystem ? Math.PI : 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Gets the position in front of the camera at a given distance.\r\n     * @param distance The distance from the camera we want the position to be\r\n     * @returns the position\r\n     */\r\n    public getFrontPosition(distance: number): Vector3 {\r\n        this.getWorldMatrix();\r\n        const worldForward = TmpVectors.Vector3[0];\r\n        const localForward = TmpVectors.Vector3[1];\r\n        localForward.set(0, 0, this._scene.useRightHandedSystem ? -1.0 : 1.0);\r\n        this.getDirectionToRef(localForward, worldForward);\r\n        worldForward.scaleInPlace(distance);\r\n        return this.globalPosition.add(worldForward);\r\n    }\r\n\r\n    /** @internal */\r\n    public _getLockedTargetPosition(): Nullable<Vector3> {\r\n        if (!this.lockedTarget) {\r\n            return null;\r\n        }\r\n\r\n        if (this.lockedTarget.absolutePosition) {\r\n            const lockedTarget = this.lockedTarget as AbstractMesh;\r\n            const m = lockedTarget.computeWorldMatrix();\r\n            // in some cases the absolute position resets externally, but doesn't update since the matrix is cached.\r\n            m.getTranslationToRef(lockedTarget.absolutePosition);\r\n        }\r\n\r\n        return this.lockedTarget.absolutePosition || this.lockedTarget;\r\n    }\r\n\r\n    private _storedPosition: Vector3;\r\n    private _storedRotation: Vector3;\r\n    private _storedRotationQuaternion: Quaternion;\r\n\r\n    /**\r\n     * Store current camera state of the camera (fov, position, rotation, etc..)\r\n     * @returns the camera\r\n     */\r\n    public override storeState(): Camera {\r\n        this._storedPosition = this.position.clone();\r\n        this._storedRotation = this.rotation.clone();\r\n        if (this.rotationQuaternion) {\r\n            this._storedRotationQuaternion = this.rotationQuaternion.clone();\r\n        }\r\n\r\n        return super.storeState();\r\n    }\r\n\r\n    /**\r\n     * Restored camera state. You must call storeState() first\r\n     * @returns whether it was successful or not\r\n     * @internal\r\n     */\r\n    public override _restoreStateValues(): boolean {\r\n        if (!super._restoreStateValues()) {\r\n            return false;\r\n        }\r\n\r\n        this.position = this._storedPosition.clone();\r\n        this.rotation = this._storedRotation.clone();\r\n\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion = this._storedRotationQuaternion.clone();\r\n        }\r\n\r\n        this.cameraDirection.copyFromFloats(0, 0, 0);\r\n        this.cameraRotation.copyFromFloats(0, 0);\r\n\r\n        return true;\r\n    }\r\n\r\n    /** @internal */\r\n    public override _initCache() {\r\n        super._initCache();\r\n        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateCache(ignoreParentClass?: boolean): void {\r\n        if (!ignoreParentClass) {\r\n            super._updateCache();\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n        if (!lockedTargetPosition) {\r\n            this._cache.lockedTarget = null;\r\n        } else {\r\n            if (!this._cache.lockedTarget) {\r\n                this._cache.lockedTarget = lockedTargetPosition.clone();\r\n            } else {\r\n                this._cache.lockedTarget.copyFrom(lockedTargetPosition);\r\n            }\r\n        }\r\n\r\n        this._cache.rotation.copyFrom(this.rotation);\r\n        if (this.rotationQuaternion) {\r\n            this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n        }\r\n    }\r\n\r\n    // Synchronized\r\n    /** @internal */\r\n    public override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix()) {\r\n            return false;\r\n        }\r\n\r\n        const lockedTargetPosition = this._getLockedTargetPosition();\r\n\r\n        return (\r\n            (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) &&\r\n            (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))\r\n        );\r\n    }\r\n\r\n    // Methods\r\n    /** @internal */\r\n    public _computeLocalCameraSpeed(): number {\r\n        const engine = this.getEngine();\r\n        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100.0));\r\n    }\r\n\r\n    // Target\r\n\r\n    /**\r\n     * Defines the target the camera should look at.\r\n     * @param target Defines the new target as a Vector\r\n     */\r\n    public setTarget(target: Vector3): void {\r\n        this.upVector.normalize();\r\n\r\n        this._initialFocalDistance = target.subtract(this.position).length();\r\n\r\n        if (this.position.z === target.z) {\r\n            this.position.z += Epsilon;\r\n        }\r\n\r\n        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(this.position, target, Vector3.UpReadOnly, TmpMatrix);\r\n        }\r\n        TmpMatrix.invert();\r\n\r\n        const rotationQuaternion = this.rotationQuaternion || TmpQuaternion;\r\n        Quaternion.FromRotationMatrixToRef(TmpMatrix, rotationQuaternion);\r\n\r\n        rotationQuaternion.toEulerAnglesToRef(this.rotation);\r\n\r\n        // Explicitly set z to 0 to match previous behavior.\r\n        this.rotation.z = 0;\r\n    }\r\n\r\n    /**\r\n     * Defines the target point of the camera.\r\n     * The camera looks towards it form the radius distance.\r\n     */\r\n    public get target(): Vector3 {\r\n        return this.getTarget();\r\n    }\r\n    public set target(value: Vector3) {\r\n        this.setTarget(value);\r\n    }\r\n\r\n    /**\r\n     * Return the current target position of the camera. This value is expressed in local space.\r\n     * @returns the target position\r\n     */\r\n    public getTarget(): Vector3 {\r\n        return this._currentTarget;\r\n    }\r\n\r\n    /** @internal */\r\n    public _decideIfNeedsToMove(): boolean {\r\n        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;\r\n    }\r\n\r\n    /** @internal */\r\n    public _updatePosition(): void {\r\n        if (this.parent) {\r\n            this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);\r\n            this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);\r\n            if (!this._deferOnly) {\r\n                this.position.copyFrom(this._deferredPositionUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n            return;\r\n        }\r\n        this._deferredPositionUpdate.addInPlace(this.cameraDirection);\r\n        if (!this._deferOnly) {\r\n            this.position.copyFrom(this._deferredPositionUpdate);\r\n        } else {\r\n            this._deferredUpdated = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public override _checkInputs(): void {\r\n        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1.0;\r\n        const needToMove = this._decideIfNeedsToMove();\r\n        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;\r\n\r\n        this._deferredUpdated = false;\r\n        this._deferredRotationUpdate.copyFrom(this.rotation);\r\n        this._deferredPositionUpdate.copyFrom(this.position);\r\n        if (this.rotationQuaternion) {\r\n            this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);\r\n        }\r\n\r\n        // Move\r\n        if (needToMove) {\r\n            this._updatePosition();\r\n        }\r\n\r\n        // Rotate\r\n        if (needToRotate) {\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);\r\n            }\r\n\r\n            this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;\r\n            this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;\r\n\r\n            // Apply constraints\r\n            if (!this.noRotationConstraint) {\r\n                const limit = 1.570796;\r\n\r\n                if (this._deferredRotationUpdate.x > limit) {\r\n                    this._deferredRotationUpdate.x = limit;\r\n                }\r\n                if (this._deferredRotationUpdate.x < -limit) {\r\n                    this._deferredRotationUpdate.x = -limit;\r\n                }\r\n            }\r\n\r\n            if (!this._deferOnly) {\r\n                this.rotation.copyFrom(this._deferredRotationUpdate);\r\n            } else {\r\n                this._deferredUpdated = true;\r\n            }\r\n\r\n            //rotate, if quaternion is set and rotation was used\r\n            if (this.rotationQuaternion) {\r\n                const len = this._deferredRotationUpdate.lengthSquared();\r\n                if (len) {\r\n                    Quaternion.RotationYawPitchRollToRef(\r\n                        this._deferredRotationUpdate.y,\r\n                        this._deferredRotationUpdate.x,\r\n                        this._deferredRotationUpdate.z,\r\n                        this._deferredRotationQuaternionUpdate\r\n                    );\r\n                    if (!this._deferOnly) {\r\n                        this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);\r\n                    } else {\r\n                        this._deferredUpdated = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        const inertialPanningLimit = this.speed * this._panningEpsilon;\r\n        const inertialRotationLimit = this.speed * this._rotationEpsilon;\r\n        // Inertia\r\n        if (needToMove) {\r\n            if (Math.abs(this.cameraDirection.x) < inertialPanningLimit) {\r\n                this.cameraDirection.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.y) < inertialPanningLimit) {\r\n                this.cameraDirection.y = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraDirection.z) < inertialPanningLimit) {\r\n                this.cameraDirection.z = 0;\r\n            }\r\n\r\n            this.cameraDirection.scaleInPlace(this.inertia);\r\n        }\r\n        if (needToRotate) {\r\n            if (Math.abs(this.cameraRotation.x) < inertialRotationLimit) {\r\n                this.cameraRotation.x = 0;\r\n            }\r\n\r\n            if (Math.abs(this.cameraRotation.y) < inertialRotationLimit) {\r\n                this.cameraRotation.y = 0;\r\n            }\r\n            this.cameraRotation.scaleInPlace(this.inertia);\r\n        }\r\n\r\n        super._checkInputs();\r\n    }\r\n\r\n    protected _updateCameraRotationMatrix() {\r\n        if (this.rotationQuaternion) {\r\n            this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);\r\n        } else {\r\n            Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the up vector to apply the rotation of the camera (So if you changed the camera rotation.z this will let you update the up vector as well)\r\n     * @returns the current camera\r\n     */\r\n    private _rotateUpVectorWithCameraRotationMatrix(): TargetCamera {\r\n        Vector3.TransformNormalToRef(Vector3.UpReadOnly, this._cameraRotationMatrix, this.upVector);\r\n        return this;\r\n    }\r\n\r\n    private _cachedRotationZ = 0;\r\n    private _cachedQuaternionRotationZ = 0;\r\n    /** @internal */\r\n    public override _getViewMatrix(): Matrix {\r\n        if (this.lockedTarget) {\r\n            this.setTarget(this._getLockedTargetPosition()!);\r\n        }\r\n\r\n        // Compute\r\n        this._updateCameraRotationMatrix();\r\n\r\n        // Apply the changed rotation to the upVector\r\n        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedQuaternionRotationZ = this.rotationQuaternion.z;\r\n        } else if (this._cachedRotationZ !== this.rotation.z) {\r\n            this._rotateUpVectorWithCameraRotationMatrix();\r\n            this._cachedRotationZ = this.rotation.z;\r\n        }\r\n\r\n        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);\r\n\r\n        // Computing target and final matrix\r\n        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);\r\n        if (this.updateUpVectorFromRotation) {\r\n            if (this.rotationQuaternion) {\r\n                Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);\r\n            } else {\r\n                Quaternion.FromEulerVectorToRef(this.rotation, TmpQuaternion);\r\n                Axis.Y.rotateByQuaternionToRef(TmpQuaternion, this.upVector);\r\n            }\r\n        }\r\n        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    protected _computeViewMatrix(position: Vector3, target: Vector3, up: Vector3): void {\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);\r\n        }\r\n\r\n        if (this.parent) {\r\n            const parentWorldMatrix = this.parent.getWorldMatrix();\r\n            this._viewMatrix.invert();\r\n            this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);\r\n            this._viewMatrix.getTranslationToRef(this._globalPosition);\r\n            this._viewMatrix.invert();\r\n\r\n            this._markSyncedWithParent();\r\n        } else {\r\n            this._globalPosition.copyFrom(position);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public override createRigCamera(name: string, cameraIndex: number): Nullable<Camera> {\r\n        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {\r\n            const rigCamera = new TargetCamera(name, this.position.clone(), this.getScene());\r\n            rigCamera.isRigCamera = true;\r\n            rigCamera.rigParent = this;\r\n            if (this.cameraRigMode === Camera.RIG_MODE_VR) {\r\n                if (!this.rotationQuaternion) {\r\n                    this.rotationQuaternion = new Quaternion();\r\n                }\r\n                rigCamera._cameraRigParams = {};\r\n                rigCamera.rotationQuaternion = new Quaternion();\r\n            }\r\n\r\n            rigCamera.mode = this.mode;\r\n            rigCamera.orthoLeft = this.orthoLeft;\r\n            rigCamera.orthoRight = this.orthoRight;\r\n            rigCamera.orthoTop = this.orthoTop;\r\n            rigCamera.orthoBottom = this.orthoBottom;\r\n\r\n            return rigCamera;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _updateRigCameras() {\r\n        const camLeft = <TargetCamera>this._rigCameras[0];\r\n        const camRight = <TargetCamera>this._rigCameras[1];\r\n\r\n        this.computeWorldMatrix();\r\n\r\n        switch (this.cameraRigMode) {\r\n            case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:\r\n            case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {\r\n                //provisionnaly using _cameraRigParams.stereoHalfAngle instead of calculations based on _cameraRigParams.interaxialDistance:\r\n                const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;\r\n                const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);\r\n                this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);\r\n                break;\r\n            }\r\n            case Camera.RIG_MODE_VR:\r\n                if (camLeft.rotationQuaternion) {\r\n                    camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                    camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);\r\n                } else {\r\n                    camLeft.rotation.copyFrom(this.rotation);\r\n                    camRight.rotation.copyFrom(this.rotation);\r\n                }\r\n                camLeft.position.copyFrom(this.position);\r\n                camRight.position.copyFrom(this.position);\r\n\r\n                break;\r\n        }\r\n        super._updateRigCameras();\r\n    }\r\n\r\n    private _getRigCamPositionAndTarget(halfSpace: number, rigCamera: TargetCamera) {\r\n        const target = this.getTarget();\r\n        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);\r\n\r\n        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);\r\n        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);\r\n\r\n        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);\r\n        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);\r\n\r\n        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);\r\n        rigCamera.setTarget(newFocalTarget);\r\n    }\r\n\r\n    /**\r\n     * Gets the current object class name.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"TargetCamera\";\r\n    }\r\n}\r\n", "/* eslint-disable @typescript-eslint/naming-convention */\r\nimport * as functions from \"./math.scalar.functions\";\r\n\r\nconst HCF: (a: number, b: number) => number = functions.HighestCommonFactor;\r\n\r\n/**\r\n * Scalar computation library\r\n */\r\nexport const Scalar = {\r\n    ...functions,\r\n\r\n    /**\r\n     * Two pi constants convenient for computation.\r\n     */\r\n    TwoPi: Math.PI * 2,\r\n\r\n    /**\r\n     * Returns -1 if value is negative and +1 is value is positive.\r\n     * @param value the value\r\n     * @returns the value itself if it's equal to zero.\r\n     */\r\n    Sign: Math.sign,\r\n\r\n    /**\r\n     * the log2 of value.\r\n     * @param value the value to compute log2 of\r\n     * @returns the log2 of value.\r\n     */\r\n    Log2: Math.log2,\r\n\r\n    /**\r\n     * Returns the highest common factor of two integers.\r\n     * @param a first parameter\r\n     * @param b second parameter\r\n     * @returns HCF of a and b\r\n     */\r\n    HCF,\r\n};\r\n/* eslint-enable @typescript-eslint/naming-convention */\r\n", "import type { IAnimatable } from \"../Animations/animatable.interface\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"../Buffers/buffer\";\r\nimport type { AnimationPropertiesOverride } from \"../Animations/animationPropertiesOverride\";\r\nimport { serialize } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { GetClass } from \"../Misc/typeStore\";\r\n\r\nimport type { Animation } from \"../Animations/animation\";\r\n\r\n/**\r\n * Defines a target to use with MorphTargetManager\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTarget implements IAnimatable {\r\n    /**\r\n     * Gets or sets the list of animations\r\n     */\r\n    public animations: Animation[] = [];\r\n\r\n    private _scene: Nullable<Scene>;\r\n    private _positions: Nullable<FloatArray> = null;\r\n    private _normals: Nullable<FloatArray> = null;\r\n    private _tangents: Nullable<FloatArray> = null;\r\n    private _uvs: Nullable<FloatArray> = null;\r\n    private _uv2s: Nullable<FloatArray> = null;\r\n    private _colors: Nullable<FloatArray> = null;\r\n    private _influence: number;\r\n    private _uniqueId = 0;\r\n\r\n    /**\r\n     * Observable raised when the influence changes\r\n     */\r\n    public onInfluenceChanged = new Observable<boolean>();\r\n\r\n    /** @internal */\r\n    public _onDataLayoutChanged = new Observable<void>();\r\n\r\n    /**\r\n     * Gets or sets the influence of this target (ie. its weight in the overall morphing)\r\n     */\r\n    public get influence(): number {\r\n        return this._influence;\r\n    }\r\n\r\n    public set influence(influence: number) {\r\n        if (this._influence === influence) {\r\n            return;\r\n        }\r\n\r\n        const previous = this._influence;\r\n        this._influence = influence;\r\n\r\n        if (this.onInfluenceChanged.hasObservers()) {\r\n            this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the id of the morph Target\r\n     */\r\n    @serialize()\r\n    public id: string;\r\n\r\n    private _animationPropertiesOverride: Nullable<AnimationPropertiesOverride> = null;\r\n\r\n    /**\r\n     * Gets or sets the animation properties override\r\n     */\r\n    public get animationPropertiesOverride(): Nullable<AnimationPropertiesOverride> {\r\n        if (!this._animationPropertiesOverride && this._scene) {\r\n            return this._scene.animationPropertiesOverride;\r\n        }\r\n        return this._animationPropertiesOverride;\r\n    }\r\n\r\n    public set animationPropertiesOverride(value: Nullable<AnimationPropertiesOverride>) {\r\n        this._animationPropertiesOverride = value;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTarget\r\n     * @param name defines the name of the target\r\n     * @param influence defines the influence to use\r\n     * @param scene defines the scene the morphtarget belongs to\r\n     */\r\n    public constructor(\r\n        /** defines the name of the target */\r\n        public name: string,\r\n        influence = 0,\r\n        scene: Nullable<Scene> = null\r\n    ) {\r\n        this.id = name;\r\n        this._scene = scene || EngineStore.LastCreatedScene;\r\n        this.influence = influence;\r\n\r\n        if (this._scene) {\r\n            this._uniqueId = this._scene.getUniqueId();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains position data\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return !!this._positions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains normal data\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return !!this._normals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains tangent data\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return !!this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates data\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return !!this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean defining if the target contains texture coordinates 2 data\r\n     */\r\n    public get hasUV2s(): boolean {\r\n        return !!this._uv2s;\r\n    }\r\n\r\n    public get hasColors(): boolean {\r\n        return !!this._colors;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices stored in this target\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._positions\r\n            ? this._positions.length / 3\r\n            : this._normals\r\n              ? this._normals.length / 3\r\n              : this._tangents\r\n                ? this._tangents.length / 3\r\n                : this._uvs\r\n                  ? this._uvs.length / 2\r\n                  : this._uv2s\r\n                    ? this._uv2s.length / 2\r\n                    : this._colors\r\n                      ? this._colors.length / 4\r\n                      : 0;\r\n    }\r\n\r\n    /**\r\n     * Affects position data to this target\r\n     * @param data defines the position data to use\r\n     */\r\n    public setPositions(data: Nullable<FloatArray>) {\r\n        const hadPositions = this.hasPositions;\r\n\r\n        this._positions = data;\r\n\r\n        if (hadPositions !== this.hasPositions) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the position data stored in this target\r\n     * @returns a FloatArray containing the position data (or null if not present)\r\n     */\r\n    public getPositions(): Nullable<FloatArray> {\r\n        return this._positions;\r\n    }\r\n\r\n    /**\r\n     * Affects normal data to this target\r\n     * @param data defines the normal data to use\r\n     */\r\n    public setNormals(data: Nullable<FloatArray>) {\r\n        const hadNormals = this.hasNormals;\r\n\r\n        this._normals = data;\r\n\r\n        if (hadNormals !== this.hasNormals) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the normal data stored in this target\r\n     * @returns a FloatArray containing the normal data (or null if not present)\r\n     */\r\n    public getNormals(): Nullable<FloatArray> {\r\n        return this._normals;\r\n    }\r\n\r\n    /**\r\n     * Affects tangent data to this target\r\n     * @param data defines the tangent data to use\r\n     */\r\n    public setTangents(data: Nullable<FloatArray>) {\r\n        const hadTangents = this.hasTangents;\r\n\r\n        this._tangents = data;\r\n\r\n        if (hadTangents !== this.hasTangents) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the tangent data stored in this target\r\n     * @returns a FloatArray containing the tangent data (or null if not present)\r\n     */\r\n    public getTangents(): Nullable<FloatArray> {\r\n        return this._tangents;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates data to this target\r\n     * @param data defines the texture coordinates data to use\r\n     */\r\n    public setUVs(data: Nullable<FloatArray>) {\r\n        const hadUVs = this.hasUVs;\r\n\r\n        this._uvs = data;\r\n\r\n        if (hadUVs !== this.hasUVs) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates data (or null if not present)\r\n     */\r\n    public getUVs(): Nullable<FloatArray> {\r\n        return this._uvs;\r\n    }\r\n\r\n    /**\r\n     * Affects texture coordinates 2 data to this target\r\n     * @param data defines the texture coordinates 2 data to use\r\n     */\r\n    public setUV2s(data: Nullable<FloatArray>) {\r\n        const hadUV2s = this.hasUV2s;\r\n\r\n        this._uv2s = data;\r\n\r\n        if (hadUV2s !== this.hasUV2s) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the texture coordinates 2 data stored in this target\r\n     * @returns a FloatArray containing the texture coordinates 2 data (or null if not present)\r\n     */\r\n    public getUV2s(): Nullable<FloatArray> {\r\n        return this._uv2s;\r\n    }\r\n\r\n    /**\r\n     * Affects color data to this target\r\n     * @param data defines the color data to use\r\n     */\r\n    public setColors(data: Nullable<FloatArray>) {\r\n        const hadColors = this.hasColors;\r\n\r\n        this._colors = data;\r\n\r\n        if (hadColors !== this.hasColors) {\r\n            this._onDataLayoutChanged.notifyObservers(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the color data stored in this target\r\n     * @returns a FloatArray containing the color data (or null if not present)\r\n     */\r\n    public getColors(): Nullable<FloatArray> {\r\n        return this._colors;\r\n    }\r\n\r\n    /**\r\n     * Clone the current target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public clone(): MorphTarget {\r\n        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);\r\n\r\n        newOne._positions = this._positions;\r\n        newOne._normals = this._normals;\r\n        newOne._tangents = this._tangents;\r\n        newOne._uvs = this._uvs;\r\n        newOne._uv2s = this._uv2s;\r\n        newOne._colors = this._colors;\r\n\r\n        return newOne;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current target into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.name = this.name;\r\n        serializationObject.influence = this.influence;\r\n\r\n        serializationObject.positions = Array.prototype.slice.call(this.getPositions());\r\n        if (this.id != null) {\r\n            serializationObject.id = this.id;\r\n        }\r\n        if (this.hasNormals) {\r\n            serializationObject.normals = Array.prototype.slice.call(this.getNormals());\r\n        }\r\n        if (this.hasTangents) {\r\n            serializationObject.tangents = Array.prototype.slice.call(this.getTangents());\r\n        }\r\n        if (this.hasUVs) {\r\n            serializationObject.uvs = Array.prototype.slice.call(this.getUVs());\r\n        }\r\n        if (this.hasUV2s) {\r\n            serializationObject.uv2s = Array.prototype.slice.call(this.getUV2s());\r\n        }\r\n        if (this.hasColors) {\r\n            serializationObject.colors = Array.prototype.slice.call(this.getColors());\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(this, serializationObject);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Returns the string \"MorphTarget\"\r\n     * @returns \"MorphTarget\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"MorphTarget\";\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new target from serialized data\r\n     * @param serializationObject defines the serialized data to use\r\n     * @param scene defines the hosting scene\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static Parse(serializationObject: any, scene?: Scene): MorphTarget {\r\n        const result = new MorphTarget(serializationObject.name, serializationObject.influence);\r\n\r\n        result.setPositions(serializationObject.positions);\r\n\r\n        if (serializationObject.id != null) {\r\n            result.id = serializationObject.id;\r\n        }\r\n        if (serializationObject.normals) {\r\n            result.setNormals(serializationObject.normals);\r\n        }\r\n        if (serializationObject.tangents) {\r\n            result.setTangents(serializationObject.tangents);\r\n        }\r\n        if (serializationObject.uvs) {\r\n            result.setUVs(serializationObject.uvs);\r\n        }\r\n        if (serializationObject.uv2s) {\r\n            result.setUV2s(serializationObject.uv2s);\r\n        }\r\n        if (serializationObject.colors) {\r\n            result.setColors(serializationObject.colors);\r\n        }\r\n\r\n        // Animations\r\n        if (serializationObject.animations) {\r\n            for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {\r\n                const parsedAnimation = serializationObject.animations[animationIndex];\r\n                const internalClass = GetClass(\"BABYLON.Animation\");\r\n                if (internalClass) {\r\n                    result.animations.push(internalClass.Parse(parsedAnimation));\r\n                }\r\n            }\r\n\r\n            if (serializationObject.autoAnimate && scene) {\r\n                scene.beginAnimation(\r\n                    result,\r\n                    serializationObject.autoAnimateFrom,\r\n                    serializationObject.autoAnimateTo,\r\n                    serializationObject.autoAnimateLoop,\r\n                    serializationObject.autoAnimateSpeed || 1.0\r\n                );\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Creates a MorphTarget from mesh data\r\n     * @param mesh defines the source mesh\r\n     * @param name defines the name to use for the new target\r\n     * @param influence defines the influence to attach to the target\r\n     * @returns a new MorphTarget\r\n     */\r\n    public static FromMesh(mesh: AbstractMesh, name?: string, influence?: number): MorphTarget {\r\n        if (!name) {\r\n            name = mesh.name;\r\n        }\r\n\r\n        const result = new MorphTarget(name, influence, mesh.getScene());\r\n\r\n        result.setPositions(<FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind));\r\n\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            result.setNormals(<FloatArray>mesh.getVerticesData(VertexBuffer.NormalKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n            result.setTangents(<FloatArray>mesh.getVerticesData(VertexBuffer.TangentKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\r\n            result.setUVs(<FloatArray>mesh.getVerticesData(VertexBuffer.UVKind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\r\n            result.setUV2s(<FloatArray>mesh.getVerticesData(VertexBuffer.UV2Kind));\r\n        }\r\n        if (mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\r\n            result.setColors(<FloatArray>mesh.getVerticesData(VertexBuffer.ColorKind));\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n", "// https://stackoverflow.com/a/48218209\r\n/**\r\n * Merges a series of objects into a single object, deeply.\r\n * @param objects The objects to merge (objects later in the list take precedence).\r\n * @returns The merged object.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function deepMerge<T extends object>(...objects: T[]): T {\r\n    const isRecord = (obj: unknown): obj is Record<string, unknown> => !!obj && typeof obj === \"object\";\r\n\r\n    return objects.reduce<Record<string, unknown>>((prev, obj) => {\r\n        const keys = Object.keys(obj);\r\n        for (const key of keys) {\r\n            const pVal = prev[key];\r\n            const oVal = (obj as Record<string, unknown>)[key];\r\n\r\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\r\n                prev[key] = pVal.concat(...oVal);\r\n            } else if (isRecord(pVal) && isRecord(oVal)) {\r\n                prev[key] = deepMerge(pVal, oVal);\r\n            } else {\r\n                prev[key] = oVal;\r\n            }\r\n        }\r\n\r\n        return prev;\r\n    }, {}) as T;\r\n}\r\n", "import type { Nullable, DeepImmutableObject } from \"../types\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\r\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\n\r\ndeclare module \"./mesh\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Mesh {\r\n        /**\r\n         * Gets or sets a boolean defining if we want picking to pick thin instances as well\r\n         */\r\n        thinInstanceEnablePicking: boolean;\r\n\r\n        /**\r\n         * Indicates that a buffer created as static should be recreated if the buffer is updated (by calling thinInstanceSetMatrixAt or thinInstanceSetAttributeAt, for eg.)\r\n         * If this flag is false (the default behavior), a buffer created as \"static\" won't show any update done to it, and will stay the same as it was created.\r\n         * Note however that recreating a buffer each time there's a change will have some performance cost, that's why it is set to false by default.\r\n         * You should set this flag to true only if your static buffers should change infrequently. If they change frequently, you should create your buffers as \"dynamic\" instead.\r\n         */\r\n        thinInstanceAllowAutomaticStaticBufferRecreation: boolean;\r\n\r\n        /**\r\n         * Creates a new thin instance\r\n         * @param matrix the matrix or array of matrices (position, rotation, scale) of the thin instance(s) to create\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number. If you pass an array of matrices, other instance indexes are index+1, index+2, etc\r\n         */\r\n        thinInstanceAdd(matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh?: boolean): number;\r\n\r\n        /**\r\n         * Adds the transformation (matrix) of the current mesh as a thin instance\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         * @returns the thin instance index number\r\n         */\r\n        thinInstanceAddSelf(refresh?: boolean): number;\r\n\r\n        /**\r\n         * Registers a custom attribute to be used with thin instances\r\n         * @param kind name of the attribute\r\n         * @param stride size in floats of the attribute\r\n         */\r\n        thinInstanceRegisterAttribute(kind: string, stride: number): void;\r\n\r\n        /**\r\n         * Sets the matrix of a thin instance\r\n         * @param index index of the thin instance\r\n         * @param matrix matrix to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetMatrixAt(index: number, matrix: DeepImmutableObject<Matrix>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Sets the value of a custom attribute for a thin instance\r\n         * @param kind name of the attribute\r\n         * @param index index of the thin instance\r\n         * @param value value to set\r\n         * @param refresh true to refresh the underlying gpu buffer (default: true). If you do multiple calls to this method in a row, set refresh to true only for the last call to save performance\r\n         */\r\n        thinInstanceSetAttributeAt(kind: string, index: number, value: Array<number>, refresh?: boolean): void;\r\n\r\n        /**\r\n         * Gets / sets the number of thin instances to display. Note that you can't set a number higher than what the underlying buffer can handle.\r\n         */\r\n        thinInstanceCount: number;\r\n\r\n        /**\r\n         * Sets a buffer to be used with thin instances. This method is a faster way to setup multiple instances than calling thinInstanceAdd repeatedly\r\n         * @param kind name of the attribute. Use \"matrix\" to setup the buffer of matrices\r\n         * @param buffer buffer to set\r\n         * @param stride size in floats of each value of the buffer\r\n         * @param staticBuffer indicates that the buffer is static, so that you won't change it after it is set (better performances - true by default)\r\n         */\r\n        thinInstanceSetBuffer(kind: string, buffer: Nullable<Float32Array>, stride?: number, staticBuffer?: boolean): void;\r\n\r\n        /**\r\n         * Gets the list of world matrices\r\n         * @returns an array containing all the world matrices from the thin instances\r\n         */\r\n        thinInstanceGetWorldMatrices(): Matrix[];\r\n\r\n        /**\r\n         * Synchronize the gpu buffers with a thin instance buffer. Call this method if you update later on the buffers passed to thinInstanceSetBuffer\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         */\r\n        thinInstanceBufferUpdated(kind: string): void;\r\n\r\n        /**\r\n         * Applies a partial update to a buffer directly on the GPU\r\n         * Note that the buffer located on the CPU is NOT updated! It's up to you to update it (or not) with the same data you pass to this method\r\n         * @param kind name of the attribute to update. Use \"matrix\" to update the buffer of matrices\r\n         * @param data the data to set in the GPU buffer\r\n         * @param offset the offset in the GPU buffer where to update the data\r\n         */\r\n        thinInstancePartialBufferUpdate(kind: string, data: Float32Array, offset: number): void;\r\n\r\n        /**\r\n         * Refreshes the bounding info, taking into account all the thin instances defined\r\n         * @param forceRefreshParentInfo true to force recomputing the mesh bounding info and use it to compute the aggregated bounding info\r\n         * @param applySkeleton defines whether to apply the skeleton before computing the bounding info\r\n         * @param applyMorph  defines whether to apply the morph target before computing the bounding info\r\n         */\r\n        thinInstanceRefreshBoundingInfo(forceRefreshParentInfo?: boolean, applySkeleton?: boolean, applyMorph?: boolean): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceInitializeUserStorage(): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceUpdateBufferSize(kind: string, numInstances?: number): void;\r\n\r\n        /** @internal */\r\n        _thinInstanceCreateMatrixBuffer(kind: string, buffer: Nullable<Float32Array>, staticBuffer: boolean): Buffer;\r\n\r\n        /** @internal */\r\n        _thinInstanceRecreateBuffer(kind: string, staticBuffer?: boolean): void;\r\n\r\n        /** @internal */\r\n        _userThinInstanceBuffersStorage: {\r\n            data: { [key: string]: Float32Array };\r\n            sizes: { [key: string]: number };\r\n            vertexBuffers: { [key: string]: Nullable<VertexBuffer> };\r\n            strides: { [key: string]: number };\r\n        };\r\n    }\r\n}\r\n\r\nMesh.prototype.thinInstanceAdd = function (matrix: DeepImmutableObject<Matrix> | Array<DeepImmutableObject<Matrix>>, refresh: boolean = true): number {\r\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\r\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\r\n        return -1;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\r\n\r\n    const index = this._thinInstanceDataStorage.instancesCount;\r\n\r\n    if (Array.isArray(matrix)) {\r\n        for (let i = 0; i < matrix.length; ++i) {\r\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\r\n        }\r\n    } else {\r\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nMesh.prototype.thinInstanceAddSelf = function (refresh: boolean = true): number {\r\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\r\n};\r\n\r\nMesh.prototype.thinInstanceRegisterAttribute = function (kind: string, stride: number): void {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    this.removeVerticesData(kind);\r\n\r\n    this._thinInstanceInitializeUserStorage();\r\n\r\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\r\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\r\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\r\n\r\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n};\r\n\r\nMesh.prototype.thinInstanceSetMatrixAt = function (index: number, matrix: DeepImmutableObject<Matrix>, refresh: boolean = true): boolean {\r\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    matrix.copyToArray(matrixData, index * 16);\r\n\r\n    if (this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix as Matrix;\r\n    }\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(\"matrix\");\r\n\r\n        if (!this.doNotSyncBoundingInfo) {\r\n            this.thinInstanceRefreshBoundingInfo(false);\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetAttributeAt = function (kind: string, index: number, value: Array<number>, refresh: boolean = true): boolean {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\r\n        return false;\r\n    }\r\n\r\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\r\n\r\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\r\n\r\n    if (refresh) {\r\n        this.thinInstanceBufferUpdated(kind);\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\r\n    get: function (this: Mesh) {\r\n        return this._thinInstanceDataStorage.instancesCount;\r\n    },\r\n    set: function (this: Mesh, value: number) {\r\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\r\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\r\n\r\n        if (value <= numMaxInstances) {\r\n            this._thinInstanceDataStorage.instancesCount = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind: string, buffer: Float32Array, staticBuffer: boolean = true): Buffer {\r\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\r\n\r\n    for (let i = 0; i < 4; i++) {\r\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\r\n    }\r\n\r\n    return matrixBuffer;\r\n};\r\n\r\nMesh.prototype.thinInstanceSetBuffer = function (kind: string, buffer: Nullable<Float32Array>, stride: number = 0, staticBuffer: boolean = true): void {\r\n    stride = stride || 16;\r\n\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\r\n        this._thinInstanceDataStorage.matrixData = buffer;\r\n        this._thinInstanceDataStorage.worldMatrices = null;\r\n\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\r\n\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                this.thinInstanceRefreshBoundingInfo(false);\r\n            }\r\n        } else {\r\n            this._thinInstanceDataStorage.instancesCount = 0;\r\n            if (!this.doNotSyncBoundingInfo) {\r\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\r\n                this.refreshBoundingInfo();\r\n            }\r\n        }\r\n    } else if (kind === \"previousMatrix\") {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\r\n        if (buffer !== null) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\r\n        }\r\n    } else {\r\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\r\n        // hot switching kind here to preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (buffer === null) {\r\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\r\n                this.removeVerticesData(kind);\r\n                delete this._userThinInstanceBuffersStorage.data[kind];\r\n                delete this._userThinInstanceBuffersStorage.strides[kind];\r\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\r\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\r\n            }\r\n        } else {\r\n            this._thinInstanceInitializeUserStorage();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\r\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceBufferUpdated = function (kind: string): void {\r\n    if (kind === \"matrix\") {\r\n        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (\r\n            this.thinInstanceAllowAutomaticStaticBufferRecreation &&\r\n            this._thinInstanceDataStorage.previousMatrixBuffer &&\r\n            !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()\r\n        ) {\r\n            this._thinInstanceRecreateBuffer(kind);\r\n        }\r\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData!, 0, this._thinInstanceDataStorage.instancesCount);\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.isUpdatable()) {\r\n                this._thinInstanceRecreateBuffer(kind);\r\n            }\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind: string, data: Float32Array, offset: number): void {\r\n    if (kind === \"matrix\") {\r\n        if (this._thinInstanceDataStorage.matrixBuffer) {\r\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\r\n        }\r\n    } else {\r\n        // preserve backward compatibility\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]!.updateDirectly(data, offset);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype.thinInstanceGetWorldMatrices = function (): Matrix[] {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return [];\r\n    }\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (!this._thinInstanceDataStorage.worldMatrices) {\r\n        this._thinInstanceDataStorage.worldMatrices = [] as Matrix[];\r\n\r\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\r\n        }\r\n    }\r\n\r\n    return this._thinInstanceDataStorage.worldMatrices;\r\n};\r\n\r\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo: boolean = false, applySkeleton: boolean = false, applyMorph: boolean = false) {\r\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\r\n        return;\r\n    }\r\n\r\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\r\n\r\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\r\n        vectors.length = 0;\r\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\r\n        const boundingInfo = this.getBoundingInfo();\r\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\r\n    }\r\n\r\n    const boundingInfo = this.getBoundingInfo();\r\n    const matrixData = this._thinInstanceDataStorage.matrixData;\r\n\r\n    if (vectors.length === 0) {\r\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\r\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\r\n        }\r\n    }\r\n\r\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\r\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\r\n\r\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\r\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\r\n\r\n        for (let v = 0; v < vectors.length; ++v) {\r\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\r\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\r\n        }\r\n    }\r\n\r\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\r\n\r\n    this._updateBoundingInfo();\r\n};\r\n\r\nMesh.prototype._thinInstanceRecreateBuffer = function (kind: string, staticBuffer: boolean = true) {\r\n    if (kind === \"matrix\") {\r\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", this._thinInstanceDataStorage.matrixData, staticBuffer);\r\n    } else if (kind === \"previousMatrix\") {\r\n        if (this._scene.needsPreviousWorldMatrices) {\r\n            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\r\n                \"previousWorld\",\r\n                this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData,\r\n                staticBuffer\r\n            );\r\n        }\r\n    } else {\r\n        if (kind === VertexBuffer.ColorKind) {\r\n            kind = VertexBuffer.ColorInstanceKind;\r\n        }\r\n\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(\r\n            this.getEngine(),\r\n            this._userThinInstanceBuffersStorage.data[kind],\r\n            kind,\r\n            !staticBuffer,\r\n            false,\r\n            this._userThinInstanceBuffersStorage.strides[kind],\r\n            true\r\n        );\r\n        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind: string, numInstances: number = 1) {\r\n    // preserve backward compatibility\r\n    if (kind === VertexBuffer.ColorKind) {\r\n        kind = VertexBuffer.ColorInstanceKind;\r\n    }\r\n\r\n    const kindIsMatrix = kind === \"matrix\";\r\n\r\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\r\n        return;\r\n    }\r\n\r\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\r\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\r\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\r\n\r\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\r\n\r\n    let newSize = currentSize;\r\n\r\n    while (newSize < bufferSize) {\r\n        newSize *= 2;\r\n    }\r\n\r\n    if (!data || currentSize != newSize) {\r\n        if (!data) {\r\n            data = new Float32Array(newSize);\r\n        } else {\r\n            const newData = new Float32Array(newSize);\r\n            newData.set(data, 0);\r\n            data = newData;\r\n        }\r\n\r\n        if (kindIsMatrix) {\r\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\r\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\r\n            this._thinInstanceDataStorage.matrixData = data;\r\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\r\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\r\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\r\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\r\n            }\r\n        } else {\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\r\n\r\n            this._userThinInstanceBuffersStorage.data[kind] = data;\r\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\r\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\r\n\r\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]!);\r\n        }\r\n    }\r\n};\r\n\r\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\r\n    if (!this._userThinInstanceBuffersStorage) {\r\n        this._userThinInstanceBuffersStorage = {\r\n            data: {},\r\n            sizes: {},\r\n            vertexBuffers: {},\r\n            strides: {},\r\n        };\r\n    }\r\n};\r\n\r\nMesh.prototype._disposeThinInstanceSpecificData = function () {\r\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\r\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.matrixBuffer = null;\r\n    }\r\n    if (this._thinInstanceDataStorage?.previousMatrixBuffer) {\r\n        this._thinInstanceDataStorage.previousMatrixBuffer.dispose();\r\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\r\n    }\r\n};\r\n", "import type { Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport type { EncoderMessage, IDracoAttributeData, IDracoEncodedMeshData, IDracoEncoderOptions } from \"./dracoEncoder.types\";\r\nimport type { DecoderMessage } from \"./dracoDecoder.types\";\r\nimport type { DecoderBuffer, Decoder, Mesh, PointCloud, Status, DecoderModule, EncoderModule, MeshBuilder, Encoder, DracoInt8Array } from \"draco3dgltf\";\r\nimport { DracoDecoderModule } from \"draco3dgltf\";\r\nimport type { VertexDataTypedArray } from \"core/Buffers/bufferUtils\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoDecoderModule: DracoDecoderModule;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let DracoEncoderModule: (props: { wasmBinary?: ArrayBuffer }) => Promise<EncoderModule>;\r\n\r\ninterface IInitDoneMessage {\r\n    id: \"initDone\";\r\n}\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: IInitDoneMessage | DecoderMessage | EncoderMessage, transfer?: ArrayBufferLike[]): void;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function EncodeMesh(\r\n    module: unknown /** EncoderModule */,\r\n    attributes: Array<IDracoAttributeData>,\r\n    indices: Nullable<Uint16Array | Uint32Array>,\r\n    options: IDracoEncoderOptions\r\n): Nullable<IDracoEncodedMeshData> {\r\n    const encoderModule = module as EncoderModule;\r\n    let encoder: Nullable<Encoder> = null;\r\n    let meshBuilder: Nullable<MeshBuilder> = null;\r\n    let mesh: Nullable<Mesh> = null;\r\n    let encodedNativeBuffer: Nullable<DracoInt8Array> = null;\r\n    const attributeIDs: Record<string, number> = {}; // Babylon kind -> Draco unique id\r\n\r\n    // Double-check that at least a position attribute is provided\r\n    const positionAttribute = attributes.find((a) => a.dracoName === \"POSITION\");\r\n    if (!positionAttribute) {\r\n        throw new Error(\"Position attribute is required for Draco encoding\");\r\n    }\r\n\r\n    // If no indices are provided, assume mesh is unindexed. Let's generate them, since Draco meshes require them.\r\n    // TODO: This may be the POINT_CLOUD case, but need to investigate. Should work for now-- just less efficient.\r\n    if (!indices) {\r\n        // Assume position attribute is the largest attribute.\r\n        const positionVerticesCount = positionAttribute.data.length / positionAttribute.size;\r\n        indices = new (positionVerticesCount > 65535 ? Uint32Array : Uint16Array)(positionVerticesCount);\r\n        for (let i = 0; i < positionVerticesCount; i++) {\r\n            indices[i] = i;\r\n        }\r\n    }\r\n\r\n    try {\r\n        encoder = new encoderModule.Encoder();\r\n        meshBuilder = new encoderModule.MeshBuilder();\r\n        mesh = new encoderModule.Mesh();\r\n\r\n        // Add the faces\r\n        meshBuilder.AddFacesToMesh(mesh, indices.length / 3, indices);\r\n\r\n        const addAttributeMap = new Map<\r\n            Function,\r\n            (builder: MeshBuilder, mesh: Mesh, attr: any, count: number, size: number, data: Exclude<VertexDataTypedArray, Uint8ClampedArray>) => number\r\n        >([\r\n            [Float32Array, (mb, m, a, c, s, d) => mb.AddFloatAttribute(m, a, c, s, d)],\r\n            [Uint32Array, (mb, m, a, c, s, d) => mb.AddUInt32Attribute(m, a, c, s, d)],\r\n            [Uint16Array, (mb, m, a, c, s, d) => mb.AddUInt16Attribute(m, a, c, s, d)],\r\n            [Uint8Array, (mb, m, a, c, s, d) => mb.AddUInt8Attribute(m, a, c, s, d)],\r\n            [Int32Array, (mb, m, a, c, s, d) => mb.AddInt32Attribute(m, a, c, s, d)],\r\n            [Int16Array, (mb, m, a, c, s, d) => mb.AddInt16Attribute(m, a, c, s, d)],\r\n            [Int8Array, (mb, m, a, c, s, d) => mb.AddInt8Attribute(m, a, c, s, d)],\r\n        ]);\r\n\r\n        // Add the attributes\r\n        for (const attribute of attributes) {\r\n            if (attribute.data instanceof Uint8ClampedArray) {\r\n                attribute.data = new Uint8Array(attribute.data); // Draco does not support Uint8ClampedArray\r\n            }\r\n            const addAttribute = addAttributeMap.get(attribute.data.constructor)!;\r\n            const verticesCount = attribute.data.length / attribute.size;\r\n            attributeIDs[attribute.kind] = addAttribute(meshBuilder, mesh, encoderModule[attribute.dracoName], verticesCount, attribute.size, attribute.data);\r\n            if (options.quantizationBits && options.quantizationBits[attribute.dracoName]) {\r\n                encoder.SetAttributeQuantization(encoderModule[attribute.dracoName], options.quantizationBits[attribute.dracoName]);\r\n            }\r\n        }\r\n\r\n        // Set the options\r\n        if (options.method) {\r\n            encoder.SetEncodingMethod(encoderModule[options.method]);\r\n        }\r\n        if (options.encodeSpeed !== undefined && options.decodeSpeed !== undefined) {\r\n            encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);\r\n        }\r\n\r\n        // Encode to native buffer\r\n        encodedNativeBuffer = new encoderModule.DracoInt8Array();\r\n        const encodedLength = encoder.EncodeMeshToDracoBuffer(mesh, encodedNativeBuffer);\r\n        if (encodedLength <= 0) {\r\n            throw new Error(\"Draco encoding failed.\");\r\n        }\r\n\r\n        // Copy the native buffer data to worker heap\r\n        const encodedData = new Int8Array(encodedLength);\r\n        for (let i = 0; i < encodedLength; i++) {\r\n            encodedData[i] = encodedNativeBuffer.GetValue(i);\r\n        }\r\n\r\n        return { data: encodedData, attributeIds: attributeIDs };\r\n    } finally {\r\n        if (mesh) {\r\n            encoderModule.destroy(mesh);\r\n        }\r\n        if (meshBuilder) {\r\n            encoderModule.destroy(meshBuilder);\r\n        }\r\n        if (encoder) {\r\n            encoderModule.destroy(encoder);\r\n        }\r\n        if (encodedNativeBuffer) {\r\n            encoderModule.destroy(encodedNativeBuffer);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function EncoderWorkerFunction(): void {\r\n    let encoderPromise: PromiseLike<EncoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initEncoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                encoderPromise = DracoEncoderModule(initEncoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"encodeMesh\": {\r\n                if (!encoderPromise) {\r\n                    throw new Error(\"Draco encoder module is not available\");\r\n                }\r\n                // eslint-disable-next-line github/no-then\r\n                encoderPromise.then((encoder) => {\r\n                    const result = EncodeMesh(encoder, message.attributes, message.indices, message.options);\r\n                    postMessage({ id: \"encodeMeshDone\", encodedMeshData: result }, result ? [result.data.buffer] : undefined);\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function DecodeMesh(\r\n    module: unknown /** DecoderModule */,\r\n    data: Int8Array,\r\n    attributeIDs: Record<string, number> | undefined,\r\n    onIndicesData: (indices: Uint16Array | Uint32Array) => void,\r\n    onAttributeData: (kind: string, data: ArrayBufferView, size: number, offset: number, stride: number, normalized: boolean) => void\r\n): number {\r\n    const decoderModule = module as DecoderModule;\r\n    let decoder: Nullable<Decoder> = null;\r\n    let buffer: Nullable<DecoderBuffer> = null;\r\n    let geometry: Nullable<Mesh | PointCloud> = null;\r\n\r\n    try {\r\n        decoder = new decoderModule.Decoder();\r\n\r\n        buffer = new decoderModule.DecoderBuffer();\r\n        buffer.Init(data, data.byteLength);\r\n\r\n        let status: Status;\r\n        const type = decoder.GetEncodedGeometryType(buffer);\r\n        switch (type) {\r\n            case decoderModule.TRIANGULAR_MESH: {\r\n                const mesh = new decoderModule.Mesh();\r\n                status = decoder.DecodeBufferToMesh(buffer, mesh);\r\n                if (!status.ok() || mesh.ptr === 0) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                const numFaces = mesh.num_faces();\r\n                const numIndices = numFaces * 3;\r\n                const byteLength = numIndices * 4;\r\n\r\n                const ptr = decoderModule._malloc(byteLength);\r\n                try {\r\n                    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);\r\n                    const indices = new Uint32Array(numIndices);\r\n                    indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));\r\n                    onIndicesData(indices);\r\n                } finally {\r\n                    decoderModule._free(ptr);\r\n                }\r\n\r\n                geometry = mesh;\r\n                break;\r\n            }\r\n            case decoderModule.POINT_CLOUD: {\r\n                const pointCloud = new decoderModule.PointCloud();\r\n                status = decoder.DecodeBufferToPointCloud(buffer, pointCloud);\r\n                if (!status.ok() || !pointCloud.ptr) {\r\n                    throw new Error(status.error_msg());\r\n                }\r\n\r\n                geometry = pointCloud;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid geometry type ${type}`);\r\n            }\r\n        }\r\n\r\n        const numPoints = geometry.num_points();\r\n\r\n        const processAttribute = (decoder: Decoder, geometry: Mesh | PointCloud, kind: string, attribute: any /** Attribute */) => {\r\n            const dataType = attribute.data_type();\r\n            const numComponents = attribute.num_components();\r\n            const normalized = attribute.normalized();\r\n            const byteStride = attribute.byte_stride();\r\n            const byteOffset = attribute.byte_offset();\r\n\r\n            const dataTypeInfo: Record<number, { typedArrayConstructor: TypedArrayConstructor; heap: TypedArray }> = {\r\n                [decoderModule.DT_FLOAT32]: { typedArrayConstructor: Float32Array, heap: decoderModule.HEAPF32 },\r\n                [decoderModule.DT_INT8]: { typedArrayConstructor: Int8Array, heap: decoderModule.HEAP8 },\r\n                [decoderModule.DT_INT16]: { typedArrayConstructor: Int16Array, heap: decoderModule.HEAP16 },\r\n                [decoderModule.DT_INT32]: { typedArrayConstructor: Int32Array, heap: decoderModule.HEAP32 },\r\n                [decoderModule.DT_UINT8]: { typedArrayConstructor: Uint8Array, heap: decoderModule.HEAPU8 },\r\n                [decoderModule.DT_UINT16]: { typedArrayConstructor: Uint16Array, heap: decoderModule.HEAPU16 },\r\n                [decoderModule.DT_UINT32]: { typedArrayConstructor: Uint32Array, heap: decoderModule.HEAPU32 },\r\n            };\r\n\r\n            const info = dataTypeInfo[dataType];\r\n            if (!info) {\r\n                throw new Error(`Invalid data type ${dataType}`);\r\n            }\r\n\r\n            const numValues = numPoints * numComponents;\r\n            const byteLength = numValues * info.typedArrayConstructor.BYTES_PER_ELEMENT;\r\n\r\n            const ptr = decoderModule._malloc(byteLength);\r\n            try {\r\n                decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, dataType, byteLength, ptr);\r\n                const data = new info.typedArrayConstructor(info.heap.buffer, ptr, numValues);\r\n                onAttributeData(kind, data.slice(), numComponents, byteOffset, byteStride, normalized);\r\n            } finally {\r\n                decoderModule._free(ptr);\r\n            }\r\n        };\r\n\r\n        if (attributeIDs) {\r\n            for (const kind in attributeIDs) {\r\n                const id = attributeIDs[kind];\r\n                const attribute = decoder.GetAttributeByUniqueId(geometry, id);\r\n                processAttribute(decoder, geometry, kind, attribute);\r\n            }\r\n        } else {\r\n            const dracoAttributeTypes: Record<string, number> = {\r\n                position: decoderModule.POSITION,\r\n                normal: decoderModule.NORMAL,\r\n                color: decoderModule.COLOR,\r\n                uv: decoderModule.TEX_COORD,\r\n            };\r\n\r\n            for (const kind in dracoAttributeTypes) {\r\n                const id = decoder.GetAttributeId(geometry, dracoAttributeTypes[kind]);\r\n                if (id !== -1) {\r\n                    const attribute = decoder.GetAttribute(geometry, id);\r\n                    processAttribute(decoder, geometry, kind, attribute);\r\n                }\r\n            }\r\n        }\r\n\r\n        return numPoints;\r\n    } finally {\r\n        if (geometry) {\r\n            decoderModule.destroy(geometry);\r\n        }\r\n\r\n        if (buffer) {\r\n            decoderModule.destroy(buffer);\r\n        }\r\n\r\n        if (decoder) {\r\n            decoderModule.destroy(decoder);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n * To be used if a developer wants to create their own worker instance and inject it instead of using the default worker.\r\n */\r\nexport function DecoderWorkerFunction(): void {\r\n    let decoderPromise: PromiseLike<DecoderModule> | undefined;\r\n\r\n    onmessage = (event) => {\r\n        const message = event.data;\r\n        switch (message.id) {\r\n            case \"init\": {\r\n                // if URL is provided then load the script. Otherwise expect the script to be loaded already\r\n                if (message.url) {\r\n                    importScripts(message.url);\r\n                }\r\n                const initDecoderObject = message.wasmBinary ? { wasmBinary: message.wasmBinary } : {};\r\n                decoderPromise = DracoDecoderModule(initDecoderObject);\r\n                postMessage({ id: \"initDone\" });\r\n                break;\r\n            }\r\n            case \"decodeMesh\": {\r\n                if (!decoderPromise) {\r\n                    throw new Error(\"Draco decoder module is not available\");\r\n                }\r\n                // eslint-disable-next-line github/no-then\r\n                decoderPromise.then((decoder) => {\r\n                    const numPoints = DecodeMesh(\r\n                        decoder,\r\n                        message.dataView,\r\n                        message.attributes,\r\n                        (indices) => {\r\n                            postMessage({ id: \"indices\", data: indices }, [indices.buffer]);\r\n                        },\r\n                        (kind, data, size, offset, stride, normalized) => {\r\n                            postMessage({ id: \"attribute\", kind, data, size, byteOffset: offset, byteStride: stride, normalized }, [data.buffer]);\r\n                        }\r\n                    );\r\n                    postMessage({ id: \"decodeMeshDone\", totalVertices: numPoints });\r\n                });\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// For backwards compatibility\r\nexport { DecoderWorkerFunction as workerFunction };\r\n\r\n/**\r\n * Initializes a worker that was created for the draco agent pool\r\n * @param worker  The worker to initialize\r\n * @param wasmBinary The wasm binary to load into the worker\r\n * @param moduleUrl The url to the draco decoder module (optional)\r\n * @returns A promise that resolves when the worker is initialized\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport async function initializeWebWorker(worker: Worker, wasmBinary?: ArrayBuffer, moduleUrl?: string): Promise<Worker> {\r\n    return await new Promise<Worker>((resolve, reject) => {\r\n        const onError = (error: ErrorEvent) => {\r\n            worker.removeEventListener(\"error\", onError);\r\n            worker.removeEventListener(\"message\", onMessage);\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(error);\r\n        };\r\n\r\n        const onMessage = (event: MessageEvent<IInitDoneMessage>) => {\r\n            if (event.data.id === \"initDone\") {\r\n                worker.removeEventListener(\"error\", onError);\r\n                worker.removeEventListener(\"message\", onMessage);\r\n                resolve(worker);\r\n            }\r\n        };\r\n\r\n        worker.addEventListener(\"error\", onError);\r\n        worker.addEventListener(\"message\", onMessage);\r\n\r\n        // Load with either JS-only or WASM version\r\n        if (!wasmBinary) {\r\n            worker.postMessage({\r\n                id: \"init\",\r\n                url: moduleUrl,\r\n            });\r\n        } else {\r\n            // clone the array buffer to make it transferable\r\n            const clone = wasmBinary.slice(0);\r\n            worker.postMessage(\r\n                {\r\n                    id: \"init\",\r\n                    url: moduleUrl,\r\n                    wasmBinary: clone,\r\n                },\r\n                [clone]\r\n            );\r\n        }\r\n        // note: no transfer list as the ArrayBuffer is shared across main thread and pool workers\r\n    });\r\n}\r\n", "import { Tools } from \"../../Misc/tools\";\r\nimport { AutoReleaseWorkerPool } from \"../../Misc/workerPool\";\r\nimport type { WorkerPool } from \"../../Misc/workerPool\";\r\nimport type { IDisposable } from \"../../scene\";\r\nimport { initializeWebWorker } from \"./dracoCompressionWorker\";\r\n\r\n/**\r\n * Configuration for using a Draco codec.\r\n */\r\nexport interface IDracoCodecConfiguration {\r\n    /**\r\n     * The url to the WebAssembly module.\r\n     */\r\n    wasmUrl?: string;\r\n\r\n    /**\r\n     * The url to the WebAssembly binary.\r\n     */\r\n    wasmBinaryUrl?: string;\r\n\r\n    /**\r\n     * The url to the fallback JavaScript module.\r\n     */\r\n    fallbackUrl?: string;\r\n\r\n    /**\r\n     * The number of workers for async operations. Specify `0` to disable web workers and run synchronously in the current context.\r\n     */\r\n    numWorkers?: number;\r\n\r\n    /**\r\n     * Optional worker pool to use for async encoding/decoding.\r\n     * If provided, the worker pool will be used as is: no Draco scripts will be loaded, and numWorkers will be ignored.\r\n     */\r\n    workerPool?: WorkerPool;\r\n\r\n    /**\r\n     * Optional ArrayBuffer of the WebAssembly binary.\r\n     * If provided it will be used instead of loading the binary from wasmBinaryUrl.\r\n     */\r\n    wasmBinary?: ArrayBuffer;\r\n\r\n    /**\r\n     * The codec module if already available.\r\n     */\r\n    jsModule?: unknown /* DracoDecoderModule | DracoEncoderModule */;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _GetDefaultNumWorkers(): number {\r\n    if (typeof navigator !== \"object\" || !navigator.hardwareConcurrency) {\r\n        return 1;\r\n    }\r\n\r\n    // Use 50% of the available logical processors but capped at 4.\r\n    return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _IsConfigurationAvailable(config: IDracoCodecConfiguration): boolean {\r\n    return !!((config.wasmUrl && (config.wasmBinary || config.wasmBinaryUrl) && typeof WebAssembly === \"object\") || config.fallbackUrl);\r\n    // TODO: Account for jsModule\r\n}\r\n\r\n/**\r\n * Base class for a Draco codec.\r\n * @internal\r\n */\r\nexport abstract class DracoCodec implements IDisposable {\r\n    protected _workerPoolPromise?: Promise<WorkerPool>;\r\n    protected _modulePromise?: Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Checks if the default codec JS module is in scope.\r\n     */\r\n    protected abstract _isModuleAvailable(): boolean;\r\n\r\n    /**\r\n     * Creates the JS Module for the corresponding wasm.\r\n     */\r\n    protected abstract _createModuleAsync(\r\n        wasmBinary?: ArrayBuffer,\r\n        jsModule?: unknown /** DracoDecoderModule | DracoEncoderModule */\r\n    ): Promise<{ module: unknown /** DecoderModule | EncoderModule */ }>;\r\n\r\n    /**\r\n     * Returns the worker content.\r\n     */\r\n    protected abstract _getWorkerContent(): string;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param configuration The configuration for the DracoCodec instance.\r\n     */\r\n    constructor(configuration: IDracoCodecConfiguration) {\r\n        // check if the codec binary and worker pool was injected\r\n        // Note - it is expected that the developer checked if WebWorker, WebAssembly and the URL object are available\r\n        if (configuration.workerPool) {\r\n            // Set the promise accordingly\r\n            this._workerPoolPromise = Promise.resolve(configuration.workerPool);\r\n            return;\r\n        }\r\n\r\n        // to avoid making big changes to the code here, if wasmBinary is provided use it in the wasmBinaryPromise\r\n        const wasmBinaryProvided = configuration.wasmBinary;\r\n        const numberOfWorkers = configuration.numWorkers ?? _GetDefaultNumWorkers();\r\n        const useWorkers = numberOfWorkers && typeof Worker === \"function\" && typeof URL === \"function\";\r\n        const urlNeeded = useWorkers || !configuration.jsModule;\r\n        // code maintained here for back-compat with no changes\r\n\r\n        const codecInfo: { url: string | undefined; wasmBinaryPromise: Promise<ArrayBuffer | undefined> } =\r\n            configuration.wasmUrl && configuration.wasmBinaryUrl && typeof WebAssembly === \"object\"\r\n                ? {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.wasmUrl, true) : \"\",\r\n                      wasmBinaryPromise: wasmBinaryProvided\r\n                          ? Promise.resolve(wasmBinaryProvided)\r\n                          : Tools.LoadFileAsync(Tools.GetBabylonScriptURL(configuration.wasmBinaryUrl, true)),\r\n                  }\r\n                : {\r\n                      url: urlNeeded ? Tools.GetBabylonScriptURL(configuration.fallbackUrl!) : \"\",\r\n                      wasmBinaryPromise: Promise.resolve(undefined),\r\n                  };\r\n        // If using workers, initialize a worker pool with either the wasm or url?\r\n        if (useWorkers) {\r\n            // eslint-disable-next-line github/no-then\r\n            this._workerPoolPromise = codecInfo.wasmBinaryPromise.then((wasmBinary) => {\r\n                const workerContent = this._getWorkerContent();\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n\r\n                // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n                return new AutoReleaseWorkerPool(numberOfWorkers, () => {\r\n                    const worker = new Worker(workerBlobUrl);\r\n                    return initializeWebWorker(worker, wasmBinary, codecInfo.url);\r\n                });\r\n            });\r\n        } else {\r\n            // eslint-disable-next-line github/no-then\r\n            this._modulePromise = codecInfo.wasmBinaryPromise.then(async (wasmBinary) => {\r\n                if (!this._isModuleAvailable()) {\r\n                    if (!configuration.jsModule) {\r\n                        if (!codecInfo.url) {\r\n                            throw new Error(\"Draco codec module is not available\");\r\n                        }\r\n                        await Tools.LoadBabylonScriptAsync(codecInfo.url);\r\n                    }\r\n                }\r\n                return await this._createModuleAsync(wasmBinary as ArrayBuffer, configuration.jsModule);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when ready. Call this manually to ensure the draco codec is ready before use.\r\n     * @returns a promise that resolves when ready\r\n     */\r\n    public async whenReadyAsync(): Promise<void> {\r\n        if (this._workerPoolPromise) {\r\n            await this._workerPoolPromise;\r\n            return;\r\n        }\r\n\r\n        if (this._modulePromise) {\r\n            await this._modulePromise;\r\n            return;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop all async operations and release resources.\r\n     */\r\n    public dispose(): void {\r\n        if (this._workerPoolPromise) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._workerPoolPromise.then((workerPool) => {\r\n                workerPool.dispose();\r\n            });\r\n        }\r\n\r\n        delete this._workerPoolPromise;\r\n        delete this._modulePromise;\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["boundingInfo", "decoder", "geometry", "data"]
}
