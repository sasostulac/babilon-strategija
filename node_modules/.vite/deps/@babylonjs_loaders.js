import {
  AddObjectAccessorToKey,
  AnimationPropertyInfo,
  GetMappingForKey,
  GetPathToObjectConverter,
  SetInterpolationForKey,
  TransformNodeAnimationPropertyInfo,
  WeightAnimationPropertyInfo,
  getQuaternion,
  getVector3,
  getWeights
} from "./chunk-B5RKMJWP.js";
import {
  OpenPBRMaterialLoadingAdapter
} from "./chunk-D5SMSPSH.js";
import {
  PBRMaterialLoadingAdapter
} from "./chunk-Z47UYLY5.js";
import {
  FlowGraphGLTFDataProvider
} from "./chunk-QVJHTO46.js";
import {
  AnimationEvent,
  DataReader,
  Deferred,
  DracoDecoder,
  FreeCamera,
  GaussianSplattingMesh,
  HemisphericLight,
  Lazy,
  MeshoptCompression,
  MorphTargetManager,
  ParseFlowGraphAsync,
  PointLight,
  PointsCloudSystem,
  RawCubeTexture,
  RectAreaLight,
  Skeleton,
  Sound,
  WeightedSound,
  addToBlockFactory
} from "./chunk-2NZ3PI6Y.js";
import {
  SpotLight
} from "./chunk-POYKRZF7.js";
import "./chunk-RUR5ABGF.js";
import "./chunk-OHITSUAX.js";
import "./chunk-K352EZKD.js";
import "./chunk-Y2NF7IYK.js";
import {
  FlowGraphCoordinator
} from "./chunk-66E4XH6O.js";
import "./chunk-2TY2RX26.js";
import "./chunk-3F6WI3CQ.js";
import "./chunk-IP2DQ76V.js";
import "./chunk-SLACJA6J.js";
import "./chunk-YQMXD425.js";
import "./chunk-Y46XVAPS.js";
import {
  getAnimationTypeByFlowGraphType
} from "./chunk-ET3Y5ZV4.js";
import {
  Bone
} from "./chunk-CRKUXQ7L.js";
import "./chunk-AZMWNXZR.js";
import "./chunk-GA37H3AK.js";
import "./chunk-4NYMFOYY.js";
import "./chunk-WS5BRGHT.js";
import "./chunk-EHARRLPW.js";
import "./chunk-5GCMVDQS.js";
import "./chunk-Z7ROD62A.js";
import "./chunk-IYFMIC75.js";
import "./chunk-BXC7G5RX.js";
import "./chunk-GPOCEXB4.js";
import "./chunk-RS3BFJMM.js";
import "./chunk-WJPABBOL.js";
import "./chunk-P42GBQCR.js";
import "./chunk-7SVSTJQN.js";
import "./chunk-POQ5JRS2.js";
import "./chunk-AFZ2CWYE.js";
import "./chunk-AJQHHBGD.js";
import "./chunk-SUH5XADF.js";
import {
  MorphTarget,
  Scalar,
  deepMerge
} from "./chunk-JHEX2SWQ.js";
import {
  Animation
} from "./chunk-TSMTS3RY.js";
import "./chunk-QCIHLJPD.js";
import "./chunk-3FSMXJUD.js";
import "./chunk-TNSJACA6.js";
import "./chunk-PDWIPFS6.js";
import "./chunk-R3FZPVAK.js";
import "./chunk-SMISYRRS.js";
import "./chunk-6MAH6HWI.js";
import "./chunk-4IHNUQVM.js";
import "./chunk-R7FSI55E.js";
import "./chunk-IG22W5Z3.js";
import "./chunk-VUZBMCLA.js";
import "./chunk-MAWGFN3Q.js";
import {
  ShaderMaterial
} from "./chunk-OLUA2UG4.js";
import {
  Constants
} from "./chunk-4ZZTRAG2.js";
import {
  PBRMaterial
} from "./chunk-V3LGLGDY.js";
import "./chunk-I3TMUHRM.js";
import "./chunk-OXJQIT7Z.js";
import "./chunk-I5VRO6IR.js";
import "./chunk-QE4LR6WB.js";
import "./chunk-PMTD2I4J.js";
import {
  MTLFileLoader,
  OBJFileLoader,
  SolidParser
} from "./chunk-XAVN6F72.js";
import {
  AssetContainer,
  RegisterSceneLoaderPlugin
} from "./chunk-GTV4JERF.js";
import "./chunk-PF7TCB4E.js";
import {
  AbstractMesh,
  Geometry,
  Mesh,
  MultiMaterial,
  StandardMaterial,
  TransformNode,
  VertexData
} from "./chunk-JPDS7OIY.js";
import "./chunk-CXGX3PZM.js";
import {
  Material,
  SubMesh
} from "./chunk-43CLNRDT.js";
import "./chunk-A4ZWE3KB.js";
import {
  BoundingInfo,
  Camera,
  DirectionalLight
} from "./chunk-VEFBIZWV.js";
import {
  Light
} from "./chunk-DILINRTI.js";
import "./chunk-VJOELCDK.js";
import "./chunk-UCQRX3RS.js";
import "./chunk-5L7L3C5R.js";
import "./chunk-WKXRXUEO.js";
import "./chunk-HGHYVV6G.js";
import "./chunk-T2KPYHB2.js";
import "./chunk-GFXF2AHA.js";
import "./chunk-TOAF46MT.js";
import "./chunk-6W4IL5BZ.js";
import "./chunk-GJUHN7CQ.js";
import "./chunk-TXNJXLHN.js";
import "./chunk-ZDMLZ54Z.js";
import "./chunk-4YTIJHCE.js";
import "./chunk-HZV6LONH.js";
import "./chunk-LMU2RTUR.js";
import "./chunk-XZQW7V5M.js";
import "./chunk-4G5IUL4P.js";
import "./chunk-GTGQLCHH.js";
import "./chunk-OQDLFVF3.js";
import "./chunk-RWNDBSCB.js";
import "./chunk-727VTLHD.js";
import "./chunk-XY4T45S3.js";
import "./chunk-FSW2QHX7.js";
import "./chunk-DDBXBNWX.js";
import {
  RenderTargetTexture,
  SphericalHarmonics,
  SphericalPolynomial
} from "./chunk-A4D5JG2T.js";
import "./chunk-BEJPWP7R.js";
import "./chunk-XJITC4RP.js";
import "./chunk-WAGTS43G.js";
import "./chunk-LJSODA3L.js";
import {
  Texture
} from "./chunk-RLP7VL7I.js";
import "./chunk-KEOAMMZ7.js";
import "./chunk-URVCX2UN.js";
import {
  Color3,
  Color4
} from "./chunk-5HS37WJT.js";
import {
  Matrix,
  Quaternion,
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-H4PB4IWT.js";
import "./chunk-JKI5MLKH.js";
import "./chunk-E3DHVNB4.js";
import "./chunk-M7IZCQVV.js";
import {
  Buffer,
  GetTypedArrayConstructor,
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  Tools
} from "./chunk-V4HVSPHY.js";
import {
  DecodeBase64UrlToBinary,
  ErrorCodes,
  GetMimeType,
  IsBase64DataUrl,
  LoadFileError,
  RuntimeError
} from "./chunk-XHCADOMZ.js";
import "./chunk-2ZEUD233.js";
import {
  RandomGUID
} from "./chunk-IW7YW5OA.js";
import "./chunk-S7NDMBDF.js";
import "./chunk-I2PO3XEU.js";
import "./chunk-I4NFOKIT.js";
import {
  Effect
} from "./chunk-5OVANEI2.js";
import "./chunk-OWCZTH5B.js";
import "./chunk-AZNEH5GV.js";
import "./chunk-WWEEGZBW.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";
import "./chunk-QCCD6NMF.js";
import "./chunk-4U4OQIRL.js";
import "./chunk-FX6MN5HL.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/@babylonjs/loaders/BVH/bvhLoader.js
var _XPosition = "Xposition";
var _YPosition = "Yposition";
var _ZPosition = "Zposition";
var _XRotation = "Xrotation";
var _YRotation = "Yrotation";
var _ZRotation = "Zrotation";
var _HierarchyNode = "HIERARCHY";
var _MotionNode = "MOTION";
var LoaderContext = class {
  constructor(skeleton) {
    this.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE;
    this.list = [];
    this.root = CreateBVHNode();
    this.numFrames = 0;
    this.frameRate = 0;
    this.skeleton = skeleton;
  }
};
function CreateBVHNode() {
  return {
    name: "",
    type: "",
    offset: new Vector3(),
    channels: [],
    children: [],
    frames: [],
    parent: null
  };
}
function CreateBVHKeyFrame() {
  return {
    frame: 0,
    position: new Vector3(),
    rotation: new Quaternion()
  };
}
function BoneOffset(node) {
  const x = node.offset.x;
  const y = node.offset.y;
  const z = node.offset.z;
  return Matrix.Translation(x, y, z);
}
function CreateAnimations(node, context) {
  if (node.frames.length === 0) {
    return [];
  }
  const animations = [];
  const hasPosition = node.channels.some((c) => c === _XPosition || c === _YPosition || c === _ZPosition);
  const hasRotation = node.channels.some((c) => c === _XRotation || c === _YRotation || c === _ZRotation);
  const posAnim = new Animation(`${node.name}_pos`, "position", context.frameRate, Animation.ANIMATIONTYPE_VECTOR3, context.loopMode);
  const rotAnim = new Animation(`${node.name}_rot`, "rotationQuaternion", context.frameRate, Animation.ANIMATIONTYPE_QUATERNION, context.loopMode);
  const posKeys = [];
  const rotKeys = [];
  for (let i = 0; i < node.frames.length; i++) {
    const frame = node.frames[i];
    if (hasPosition && frame.position) {
      posKeys.push({
        frame: frame.frame,
        value: frame.position.clone()
      });
    }
    if (hasRotation) {
      rotKeys.push({
        frame: frame.frame,
        value: frame.rotation.clone()
      });
    }
  }
  if (posKeys.length > 0) {
    posAnim.setKeys(posKeys);
    animations.push(posAnim);
  }
  if (rotKeys.length > 0) {
    rotAnim.setKeys(rotKeys);
    animations.push(rotAnim);
  }
  return animations;
}
function ConvertNode(node, parent, context) {
  const matrix = BoneOffset(node);
  const bone = new Bone(node.name, context.skeleton, parent, matrix);
  const animations = CreateAnimations(node, context);
  for (const animation of animations) {
    if (animation.getKeys() && animation.getKeys().length > 0) {
      bone.animations.push(animation);
    }
  }
  for (const child of node.children) {
    ConvertNode(child, bone, context);
  }
}
function ReadFrameData(data, frameNumber, bone, tokenIndex) {
  if (bone.type === "ENDSITE") {
    return;
  }
  const keyframe = CreateBVHKeyFrame();
  keyframe.frame = frameNumber;
  keyframe.position = new Vector3();
  keyframe.rotation = new Quaternion();
  bone.frames.push(keyframe);
  let combinedRotation = Matrix.Identity();
  for (let i = 0; i < bone.channels.length; ++i) {
    const channel = bone.channels[i];
    const value = data[tokenIndex.i++];
    if (!value) {
      continue;
    }
    const parsedValue = parseFloat(value.trim());
    if (channel.endsWith("position")) {
      switch (channel) {
        case _XPosition:
          keyframe.position.x = parsedValue;
          break;
        case _YPosition:
          keyframe.position.y = parsedValue;
          break;
        case _ZPosition:
          keyframe.position.z = parsedValue;
          break;
      }
    } else if (channel.endsWith("rotation")) {
      const angle = Tools.ToRadians(parsedValue);
      let rotationMatrix;
      switch (channel) {
        case _XRotation:
          rotationMatrix = Matrix.RotationX(angle);
          break;
        case _YRotation:
          rotationMatrix = Matrix.RotationY(angle);
          break;
        case _ZRotation:
          rotationMatrix = Matrix.RotationZ(angle);
          break;
      }
      combinedRotation = rotationMatrix.multiply(combinedRotation);
    }
  }
  Quaternion.FromRotationMatrixToRef(combinedRotation, keyframe.rotation);
  for (const child of bone.children) {
    ReadFrameData(data, frameNumber, child, tokenIndex);
  }
}
function ReadNode(lines, firstLine, parent, context) {
  const node = CreateBVHNode();
  node.parent = parent;
  context.list.push(node);
  let tokens = firstLine.trim().split(/\s+/);
  if (tokens[0].toUpperCase() === "END" && tokens[1].toUpperCase() === "SITE") {
    node.type = "ENDSITE";
    node.name = "ENDSITE";
  } else {
    node.name = tokens[1];
    node.type = tokens[0].toUpperCase();
  }
  if (lines.shift()?.trim() != "{") {
    throw new Error("Expected opening { after type & name");
  }
  const tokensSplit = lines.shift()?.trim().split(/\s+/);
  if (!tokensSplit) {
    throw new Error("Unexpected end of file: missing OFFSET");
  }
  tokens = tokensSplit;
  if (tokens[0].toUpperCase() != "OFFSET") {
    throw new Error("Expected OFFSET, but got: " + tokens[0]);
  }
  if (tokens.length != 4) {
    throw new Error("OFFSET: Invalid number of values");
  }
  const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
  if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {
    throw new Error("OFFSET: Invalid values");
  }
  node.offset = offset;
  if (node.type != "ENDSITE") {
    tokens = lines.shift()?.trim().split(/\s+/);
    if (!tokens) {
      throw new Error("Unexpected end of file: missing CHANNELS");
    }
    if (tokens[0].toUpperCase() != "CHANNELS") {
      throw new Error("Expected CHANNELS definition");
    }
    const numChannels = parseInt(tokens[1]);
    node.channels = tokens.splice(2, numChannels);
    node.children = [];
  }
  while (lines.length > 0) {
    const line = lines.shift()?.trim();
    if (line === "}") {
      return node;
    } else if (line) {
      node.children.push(ReadNode(lines, line, node, context));
    }
  }
  throw new Error("Unexpected end of file: missing closing brace");
}
function ReadBvh(text, scene, assetContainer, loadingOptions) {
  const lines = text.split("\n");
  const { loopMode } = loadingOptions;
  scene._blockEntityCollection = !!assetContainer;
  const skeleton = new Skeleton("", "", scene);
  skeleton._parentContainer = assetContainer;
  scene._blockEntityCollection = false;
  const context = new LoaderContext(skeleton);
  context.loopMode = loopMode;
  const firstLine = lines.shift();
  if (!firstLine || firstLine.trim().toUpperCase() !== _HierarchyNode) {
    throw new Error("HIERARCHY expected");
  }
  const nodeLine = lines.shift();
  if (!nodeLine) {
    throw new Error("Unexpected end of file after HIERARCHY");
  }
  const root = ReadNode(lines, nodeLine.trim(), null, context);
  const motionLine = lines.shift();
  if (!motionLine || motionLine.trim().toUpperCase() !== _MotionNode) {
    throw new Error("MOTION expected");
  }
  const framesLine = lines.shift();
  if (!framesLine) {
    throw new Error("Unexpected end of file before frame count");
  }
  const framesTokens = framesLine.trim().split(/[\s]+/);
  if (framesTokens.length < 2) {
    throw new Error("Invalid frame count line");
  }
  const numFrames = parseInt(framesTokens[1]);
  if (isNaN(numFrames)) {
    throw new Error("Failed to read number of frames.");
  }
  context.numFrames = numFrames;
  const frameTimeLine = lines.shift();
  if (!frameTimeLine) {
    throw new Error("Unexpected end of file before frame time");
  }
  const frameTimeTokens = frameTimeLine.trim().split(/[\s]+/);
  if (frameTimeTokens.length < 3) {
    throw new Error("Invalid frame time line");
  }
  const frameTime = parseFloat(frameTimeTokens[2]);
  if (isNaN(frameTime)) {
    throw new Error("Failed to read frame time.");
  }
  if (frameTime <= 0) {
    throw new Error("Failed to read frame time. Invalid value " + frameTime);
  }
  context.frameRate = 1 / frameTime;
  for (let i = 0; i < numFrames; ++i) {
    const frameLine = lines.shift();
    if (!frameLine) {
      continue;
    }
    const tokens = frameLine.trim().split(/[\s]+/) || [];
    ReadFrameData(tokens, i, root, { i: 0 });
  }
  context.root = root;
  ConvertNode(context.root, null, context);
  context.skeleton.returnToRest();
  return context.skeleton;
}

// node_modules/@babylonjs/loaders/BVH/bvhFileLoader.metadata.js
var BVHFileLoaderMetadata = {
  name: "bvh",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".bvh": { isBinary: false }
  }
};

// node_modules/@babylonjs/loaders/BVH/bvhFileLoader.js
var BVHFileLoader = class _BVHFileLoader {
  /**
   * Creates loader for bvh motion files
   * @param loadingOptions - Options for the bvh loader
   */
  constructor(loadingOptions) {
    this.name = BVHFileLoaderMetadata.name;
    this.extensions = BVHFileLoaderMetadata.extensions;
    this._loadingOptions = { ..._BVHFileLoader._DefaultLoadingOptions, ...loadingOptions ?? {} };
  }
  static get _DefaultLoadingOptions() {
    return {
      loopMode: Animation.ANIMATIONLOOPMODE_CYCLE
    };
  }
  /** @internal */
  createPlugin(options) {
    return new _BVHFileLoader(options[BVHFileLoaderMetadata.name]);
  }
  /**
   * If the data string can be loaded directly.
   * @param data - direct load data
   * @returns if the data can be loaded directly
   */
  canDirectLoad(data) {
    return this.isBvhHeader(data);
  }
  isBvhHeader(text) {
    return text.split("\n")[0] == "HIERARCHY";
  }
  isNotBvhHeader(text) {
    return !this.isBvhHeader(text);
  }
  /**
   * Imports  from the loaded gaussian splatting data and adds them to the scene
   * @param _meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param data the bvh data to load
   * @returns a promise containing the loaded skeletons and animations
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  importMeshAsync(_meshesNames, scene, data) {
    if (typeof data !== "string") {
      return Promise.reject("BVH loader expects string data.");
    }
    if (this.isNotBvhHeader(data)) {
      return Promise.reject("BVH loader expects HIERARCHY header.");
    }
    try {
      const skeleton = ReadBvh(data, scene, null, this._loadingOptions);
      return Promise.resolve({
        meshes: [],
        particleSystems: [],
        skeletons: [skeleton],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: [],
        spriteManagers: []
      });
    } catch (e) {
      return Promise.reject(e);
    }
  }
  /**
   * Imports all objects from the loaded bvh data and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data the bvh data to load
   * @returns a promise which completes when objects have been loaded to the scene
   */
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  loadAsync(scene, data) {
    if (typeof data !== "string") {
      return Promise.reject("BVH loader expects string data.");
    }
    if (this.isNotBvhHeader(data)) {
      return Promise.reject("BVH loader expects HIERARCHY header.");
    }
    return this.importMeshAsync(null, scene, data).then(() => {
    });
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @returns The loaded asset container
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  loadAssetContainerAsync(scene, data) {
    if (typeof data !== "string") {
      return Promise.reject("BVH loader expects string data.");
    }
    if (this.isNotBvhHeader(data)) {
      return Promise.reject("BVH loader expects HIERARCHY header.");
    }
    const assetContainer = new AssetContainer(scene);
    try {
      const skeleton = ReadBvh(data, scene, assetContainer, this._loadingOptions);
      assetContainer.skeletons.push(skeleton);
      return Promise.resolve(assetContainer);
    } catch (e) {
      return Promise.reject(e);
    }
  }
};
RegisterSceneLoaderPlugin(new BVHFileLoader());

// node_modules/@babylonjs/loaders/glTF/glTFValidation.js
function ValidateAsync(data, rootUrl, fileName, getExternalResource) {
  const options = {
    externalResourceFunction: getExternalResource
  };
  if (fileName) {
    options.uri = rootUrl === "file:" ? fileName : rootUrl + fileName;
  }
  return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);
}
function WorkerFunc() {
  const pendingExternalResources = [];
  onmessage = (message) => {
    const data = message.data;
    switch (data.id) {
      case "init": {
        importScripts(data.url);
        break;
      }
      case "validate": {
        ValidateAsync(data.data, data.rootUrl, data.fileName, (uri) => new Promise((resolve, reject) => {
          const index = pendingExternalResources.length;
          pendingExternalResources.push({ resolve, reject });
          postMessage({ id: "getExternalResource", index, uri });
        })).then((value) => {
          postMessage({ id: "validate.resolve", value });
        }, (reason) => {
          postMessage({ id: "validate.reject", reason });
        });
        break;
      }
      case "getExternalResource.resolve": {
        pendingExternalResources[data.index].resolve(data.value);
        break;
      }
      case "getExternalResource.reject": {
        pendingExternalResources[data.index].reject(data.reason);
        break;
      }
    }
  };
}
var GLTFValidation = class {
  /**
   * Validate a glTF asset using the glTF-Validator.
   * @param data The JSON of a glTF or the array buffer of a binary glTF
   * @param rootUrl The root url for the glTF
   * @param fileName The file name for the glTF
   * @param getExternalResource The callback to get external resources for the glTF validator
   * @returns A promise that resolves with the glTF validation results once complete
   */
  static ValidateAsync(data, rootUrl, fileName, getExternalResource) {
    if (typeof Worker === "function") {
      return new Promise((resolve, reject) => {
        const workerContent = `${ValidateAsync}(${WorkerFunc})()`;
        const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
        const worker = new Worker(workerBlobUrl);
        const onError = (error) => {
          worker.removeEventListener("error", onError);
          worker.removeEventListener("message", onMessage);
          reject(error);
        };
        const onMessage = (message) => {
          const data2 = message.data;
          switch (data2.id) {
            case "getExternalResource": {
              getExternalResource(data2.uri).then((value) => {
                worker.postMessage({ id: "getExternalResource.resolve", index: data2.index, value }, [value.buffer]);
              }, (reason) => {
                worker.postMessage({ id: "getExternalResource.reject", index: data2.index, reason });
              });
              break;
            }
            case "validate.resolve": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              resolve(data2.value);
              worker.terminate();
              break;
            }
            case "validate.reject": {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              reject(data2.reason);
              worker.terminate();
            }
          }
        };
        worker.addEventListener("error", onError);
        worker.addEventListener("message", onMessage);
        worker.postMessage({ id: "init", url: Tools.GetBabylonScriptURL(this.Configuration.url) });
        if (ArrayBuffer.isView(data)) {
          const slicedData = data.slice();
          worker.postMessage({ id: "validate", data: slicedData, rootUrl, fileName }, [slicedData.buffer]);
        } else {
          worker.postMessage({ id: "validate", data, rootUrl, fileName });
        }
      });
    } else {
      if (!this._LoadScriptPromise) {
        this._LoadScriptPromise = Tools.LoadBabylonScriptAsync(this.Configuration.url);
      }
      return this._LoadScriptPromise.then(() => {
        return ValidateAsync(data, rootUrl, fileName, getExternalResource);
      });
    }
  }
};
GLTFValidation.Configuration = {
  url: `${Tools._DefaultCdnUrl}/gltf_validator.js`
};

// node_modules/@babylonjs/loaders/glTF/glTFFileLoader.metadata.js
var GLTFMagicBase64Encoded = "Z2xURg";
var GLTFFileLoaderMetadata = {
  name: "gltf",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".gltf": { isBinary: false, mimeType: "model/gltf+json" },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".glb": { isBinary: true, mimeType: "model/gltf-binary" }
  },
  canDirectLoad(data) {
    return data.indexOf("asset") !== -1 && data.indexOf("version") !== -1 || data.startsWith("data:base64," + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
    data.startsWith("data:;base64," + GLTFMagicBase64Encoded) || data.startsWith("data:application/octet-stream;base64," + GLTFMagicBase64Encoded) || data.startsWith("data:model/gltf-binary;base64," + GLTFMagicBase64Encoded);
  }
};

// node_modules/@babylonjs/loaders/glTF/glTFFileLoader.js
function readAsync(arrayBuffer, byteOffset, byteLength) {
  try {
    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
  } catch (e) {
    return Promise.reject(e);
  }
}
function readViewAsync(arrayBufferView, byteOffset, byteLength) {
  try {
    if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {
      throw new RangeError("Offset is out of range.");
    }
    if (byteOffset + byteLength > arrayBufferView.byteLength) {
      throw new RangeError("Length is out of range.");
    }
    return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));
  } catch (e) {
    return Promise.reject(e);
  }
}
var GLTFLoaderCoordinateSystemMode;
(function(GLTFLoaderCoordinateSystemMode2) {
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["AUTO"] = 0] = "AUTO";
  GLTFLoaderCoordinateSystemMode2[GLTFLoaderCoordinateSystemMode2["FORCE_RIGHT_HANDED"] = 1] = "FORCE_RIGHT_HANDED";
})(GLTFLoaderCoordinateSystemMode || (GLTFLoaderCoordinateSystemMode = {}));
var GLTFLoaderAnimationStartMode;
(function(GLTFLoaderAnimationStartMode2) {
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["NONE"] = 0] = "NONE";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["FIRST"] = 1] = "FIRST";
  GLTFLoaderAnimationStartMode2[GLTFLoaderAnimationStartMode2["ALL"] = 2] = "ALL";
})(GLTFLoaderAnimationStartMode || (GLTFLoaderAnimationStartMode = {}));
var GLTFLoaderState;
(function(GLTFLoaderState2) {
  GLTFLoaderState2[GLTFLoaderState2["LOADING"] = 0] = "LOADING";
  GLTFLoaderState2[GLTFLoaderState2["READY"] = 1] = "READY";
  GLTFLoaderState2[GLTFLoaderState2["COMPLETE"] = 2] = "COMPLETE";
})(GLTFLoaderState || (GLTFLoaderState = {}));
var GLTFLoaderBaseOptions = class {
  constructor() {
    this.alwaysComputeBoundingBox = false;
    this.alwaysComputeSkeletonRootNode = false;
    this.animationStartMode = GLTFLoaderAnimationStartMode.FIRST;
    this.compileMaterials = false;
    this.compileShadowGenerators = false;
    this.coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;
    this.createInstances = true;
    this.loadAllMaterials = false;
    this.loadMorphTargets = true;
    this.loadNodeAnimations = true;
    this.loadOnlyMaterials = false;
    this.loadSkins = true;
    this.skipMaterials = false;
    this.targetFps = 60;
    this.transparencyAsCoverage = false;
    this.useClipPlane = false;
    this.useGltfTextureNames = false;
    this.useRangeRequests = false;
    this.useSRGBBuffers = true;
    this.validate = false;
    this.useOpenPBR = false;
  }
};
var GLTFLoaderDefaultOptions = new GLTFLoaderBaseOptions();
var GLTFLoaderOptions = class extends GLTFLoaderBaseOptions {
  constructor() {
    super(...arguments);
    this.extensionOptions = {};
    this.preprocessUrlAsync = (url) => Promise.resolve(url);
  }
  // eslint-disable-next-line babylonjs/available
  copyFrom(options) {
    if (options) {
      this.alwaysComputeBoundingBox = options.alwaysComputeBoundingBox ?? this.alwaysComputeBoundingBox;
      this.alwaysComputeSkeletonRootNode = options.alwaysComputeSkeletonRootNode ?? this.alwaysComputeSkeletonRootNode;
      this.animationStartMode = options.animationStartMode ?? this.animationStartMode;
      this.capturePerformanceCounters = options.capturePerformanceCounters ?? this.capturePerformanceCounters;
      this.compileMaterials = options.compileMaterials ?? this.compileMaterials;
      this.compileShadowGenerators = options.compileShadowGenerators ?? this.compileShadowGenerators;
      this.coordinateSystemMode = options.coordinateSystemMode ?? this.coordinateSystemMode;
      this.createInstances = options.createInstances ?? this.createInstances;
      this.customRootNode = options.customRootNode;
      this.extensionOptions = options.extensionOptions ?? this.extensionOptions;
      this.loadAllMaterials = options.loadAllMaterials ?? this.loadAllMaterials;
      this.loadMorphTargets = options.loadMorphTargets ?? this.loadMorphTargets;
      this.loadNodeAnimations = options.loadNodeAnimations ?? this.loadNodeAnimations;
      this.loadOnlyMaterials = options.loadOnlyMaterials ?? this.loadOnlyMaterials;
      this.loadSkins = options.loadSkins ?? this.loadSkins;
      this.loggingEnabled = options.loggingEnabled ?? this.loggingEnabled;
      this.onCameraLoaded = options.onCameraLoaded;
      this.onMaterialLoaded = options.onMaterialLoaded;
      this.onMeshLoaded = options.onMeshLoaded;
      this.onParsed = options.onParsed;
      this.onSkinLoaded = options.onSkinLoaded;
      this.onTextureLoaded = options.onTextureLoaded;
      this.onValidated = options.onValidated;
      this.preprocessUrlAsync = options.preprocessUrlAsync ?? this.preprocessUrlAsync;
      this.skipMaterials = options.skipMaterials ?? this.skipMaterials;
      this.targetFps = options.targetFps ?? this.targetFps;
      this.transparencyAsCoverage = options.transparencyAsCoverage ?? this.transparencyAsCoverage;
      this.useClipPlane = options.useClipPlane ?? this.useClipPlane;
      this.useGltfTextureNames = options.useGltfTextureNames ?? this.useGltfTextureNames;
      this.useOpenPBR = options.useOpenPBR ?? this.useOpenPBR;
      this.useRangeRequests = options.useRangeRequests ?? this.useRangeRequests;
      this.useSRGBBuffers = options.useSRGBBuffers ?? this.useSRGBBuffers;
      this.validate = options.validate ?? this.validate;
    }
  }
};
var GLTFFileLoader = class _GLTFFileLoader extends GLTFLoaderOptions {
  /**
   * Creates a new glTF file loader.
   * @param options The options for the loader
   */
  constructor(options) {
    super();
    this.onParsedObservable = new Observable();
    this.onMeshLoadedObservable = new Observable();
    this.onSkinLoadedObservable = new Observable();
    this.onTextureLoadedObservable = new Observable();
    this.onMaterialLoadedObservable = new Observable();
    this.onCameraLoadedObservable = new Observable();
    this.onCompleteObservable = new Observable();
    this.onErrorObservable = new Observable();
    this.onDisposeObservable = new Observable();
    this.onExtensionLoadedObservable = new Observable();
    this.onValidatedObservable = new Observable();
    this._loader = null;
    this._state = null;
    this._requests = new Array();
    this.name = GLTFFileLoaderMetadata.name;
    this.extensions = GLTFFileLoaderMetadata.extensions;
    this.onLoaderStateChangedObservable = new Observable();
    this._logIndentLevel = 0;
    this._loggingEnabled = false;
    this._log = this._logDisabled;
    this._capturePerformanceCounters = false;
    this._startPerformanceCounter = this._startPerformanceCounterDisabled;
    this._endPerformanceCounter = this._endPerformanceCounterDisabled;
    this.copyFrom(Object.assign({ ...GLTFLoaderDefaultOptions }, options));
  }
  /**
   * Raised when the asset has been parsed
   */
  set onParsed(callback) {
    if (this._onParsedObserver) {
      this.onParsedObservable.remove(this._onParsedObserver);
    }
    if (callback) {
      this._onParsedObserver = this.onParsedObservable.add(callback);
    }
  }
  /**
   * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.
   * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)
   */
  set onMeshLoaded(callback) {
    if (this._onMeshLoadedObserver) {
      this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);
    }
    if (callback) {
      this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);
    }
  }
  /**
   * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh
   */
  set onSkinLoaded(callback) {
    if (this._onSkinLoadedObserver) {
      this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);
    }
    if (callback) {
      this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((data) => callback(data.node, data.skinnedNode));
    }
  }
  /**
   * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.
   */
  set onTextureLoaded(callback) {
    if (this._onTextureLoadedObserver) {
      this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);
    }
    if (callback) {
      this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);
    }
  }
  /**
   * Callback raised when the loader creates a material after parsing the glTF properties of the material.
   */
  set onMaterialLoaded(callback) {
    if (this._onMaterialLoadedObserver) {
      this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);
    }
    if (callback) {
      this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);
    }
  }
  /**
   * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.
   */
  set onCameraLoaded(callback) {
    if (this._onCameraLoadedObserver) {
      this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);
    }
    if (callback) {
      this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);
    }
  }
  /**
   * Callback raised when the asset is completely loaded, immediately before the loader is disposed.
   * For assets with LODs, raised when all of the LODs are complete.
   * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.
   */
  set onComplete(callback) {
    if (this._onCompleteObserver) {
      this.onCompleteObservable.remove(this._onCompleteObserver);
    }
    this._onCompleteObserver = this.onCompleteObservable.add(callback);
  }
  /**
   * Callback raised when an error occurs.
   */
  set onError(callback) {
    if (this._onErrorObserver) {
      this.onErrorObservable.remove(this._onErrorObserver);
    }
    this._onErrorObserver = this.onErrorObservable.add(callback);
  }
  /**
   * Callback raised after the loader is disposed.
   */
  set onDispose(callback) {
    if (this._onDisposeObserver) {
      this.onDisposeObservable.remove(this._onDisposeObserver);
    }
    this._onDisposeObserver = this.onDisposeObservable.add(callback);
  }
  /**
   * Callback raised after a loader extension is created.
   */
  set onExtensionLoaded(callback) {
    if (this._onExtensionLoadedObserver) {
      this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);
    }
    this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);
  }
  /**
   * Defines if the loader logging is enabled.
   */
  get loggingEnabled() {
    return this._loggingEnabled;
  }
  set loggingEnabled(value) {
    if (this._loggingEnabled === value) {
      return;
    }
    this._loggingEnabled = value;
    if (this._loggingEnabled) {
      this._log = this._logEnabled;
    } else {
      this._log = this._logDisabled;
    }
  }
  /**
   * Defines if the loader should capture performance counters.
   */
  get capturePerformanceCounters() {
    return this._capturePerformanceCounters;
  }
  set capturePerformanceCounters(value) {
    if (this._capturePerformanceCounters === value) {
      return;
    }
    this._capturePerformanceCounters = value;
    if (this._capturePerformanceCounters) {
      this._startPerformanceCounter = this._startPerformanceCounterEnabled;
      this._endPerformanceCounter = this._endPerformanceCounterEnabled;
    } else {
      this._startPerformanceCounter = this._startPerformanceCounterDisabled;
      this._endPerformanceCounter = this._endPerformanceCounterDisabled;
    }
  }
  /**
   * Callback raised after the asset is validated.
   */
  set onValidated(callback) {
    if (this._onValidatedObserver) {
      this.onValidatedObservable.remove(this._onValidatedObserver);
    }
    this._onValidatedObserver = this.onValidatedObservable.add(callback);
  }
  /**
   * Disposes the loader, releases resources during load, and cancels any outstanding requests.
   */
  dispose() {
    if (this._loader) {
      this._loader.dispose();
      this._loader = null;
    }
    for (const request of this._requests) {
      request.abort();
    }
    this._requests.length = 0;
    delete this._progressCallback;
    this.preprocessUrlAsync = (url) => Promise.resolve(url);
    this.onMeshLoadedObservable.clear();
    this.onSkinLoadedObservable.clear();
    this.onTextureLoadedObservable.clear();
    this.onMaterialLoadedObservable.clear();
    this.onCameraLoadedObservable.clear();
    this.onCompleteObservable.clear();
    this.onExtensionLoadedObservable.clear();
    this.onDisposeObservable.notifyObservers(void 0);
    this.onDisposeObservable.clear();
  }
  /**
   * @internal
   */
  loadFile(scene, fileOrUrl, rootUrl, onSuccess, onProgress, useArrayBuffer, onError, name2) {
    if (ArrayBuffer.isView(fileOrUrl)) {
      this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name2);
      return null;
    }
    this._progressCallback = onProgress;
    const fileName = fileOrUrl.name || Tools.GetFilename(fileOrUrl);
    if (useArrayBuffer) {
      if (this.useRangeRequests) {
        if (this.validate) {
          Logger.Warn("glTF validation is not supported when range requests are enabled");
        }
        const fileRequest = {
          abort: () => {
          },
          onCompleteObservable: new Observable()
        };
        const dataBuffer = {
          readAsync: (byteOffset, byteLength) => {
            return new Promise((resolve, reject) => {
              this._loadFile(scene, fileOrUrl, (data) => {
                resolve(new Uint8Array(data));
              }, true, (error) => {
                reject(error);
              }, (webRequest) => {
                webRequest.setRequestHeader("Range", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);
              });
            });
          },
          byteLength: 0
        };
        this._unpackBinaryAsync(new DataReader(dataBuffer)).then((loaderData) => {
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          onSuccess(loaderData);
        }, onError ? (error) => onError(void 0, error) : void 0);
        return fileRequest;
      }
      return this._loadFile(scene, fileOrUrl, (data) => {
        this._validate(scene, new Uint8Array(data, 0, data.byteLength), rootUrl, fileName);
        this._unpackBinaryAsync(new DataReader({
          readAsync: (byteOffset, byteLength) => readAsync(data, byteOffset, byteLength),
          byteLength: data.byteLength
        })).then((loaderData) => {
          onSuccess(loaderData);
        }, onError ? (error) => onError(void 0, error) : void 0);
      }, true, onError);
    } else {
      return this._loadFile(scene, fileOrUrl, (data) => {
        try {
          this._validate(scene, data, rootUrl, fileName);
          onSuccess({ json: this._parseJson(data) });
        } catch {
          if (onError) {
            onError();
          }
        }
      }, false, onError);
    }
  }
  _loadBinary(scene, data, rootUrl, onSuccess, onError, fileName) {
    this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);
    this._unpackBinaryAsync(new DataReader({
      readAsync: (byteOffset, byteLength) => readViewAsync(data, byteOffset, byteLength),
      byteLength: data.byteLength
    })).then((loaderData) => {
      onSuccess(loaderData);
    }, onError ? (error) => onError(void 0, error) : void 0);
  }
  /**
   * @internal
   */
  importMeshAsync(meshesNames, scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);
    });
  }
  /**
   * @internal
   */
  loadAsync(scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);
    });
  }
  /**
   * @internal
   */
  loadAssetContainerAsync(scene, data, rootUrl, onProgress, fileName) {
    return Promise.resolve().then(() => {
      this.onParsedObservable.notifyObservers(data);
      this.onParsedObservable.clear();
      this._log(`Loading ${fileName || ""}`);
      this._loader = this._getLoader(data);
      const container = new AssetContainer(scene);
      const materials = [];
      this.onMaterialLoadedObservable.add((material) => {
        materials.push(material);
      });
      const textures = [];
      this.onTextureLoadedObservable.add((texture) => {
        textures.push(texture);
      });
      const cameras = [];
      this.onCameraLoadedObservable.add((camera) => {
        cameras.push(camera);
      });
      const morphTargetManagers = [];
      this.onMeshLoadedObservable.add((mesh) => {
        if (mesh.morphTargetManager) {
          morphTargetManagers.push(mesh.morphTargetManager);
        }
      });
      return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {
        Array.prototype.push.apply(container.geometries, result.geometries);
        Array.prototype.push.apply(container.meshes, result.meshes);
        Array.prototype.push.apply(container.particleSystems, result.particleSystems);
        Array.prototype.push.apply(container.skeletons, result.skeletons);
        Array.prototype.push.apply(container.animationGroups, result.animationGroups);
        Array.prototype.push.apply(container.materials, materials);
        Array.prototype.push.apply(container.textures, textures);
        Array.prototype.push.apply(container.lights, result.lights);
        Array.prototype.push.apply(container.transformNodes, result.transformNodes);
        Array.prototype.push.apply(container.cameras, cameras);
        Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);
        return container;
      });
    });
  }
  /**
   * @internal
   */
  canDirectLoad(data) {
    return GLTFFileLoaderMetadata.canDirectLoad(data);
  }
  /**
   * @internal
   */
  directLoad(scene, data) {
    if (data.startsWith("base64," + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.
    data.startsWith(";base64," + GLTFMagicBase64Encoded) || data.startsWith("application/octet-stream;base64," + GLTFMagicBase64Encoded) || data.startsWith("model/gltf-binary;base64," + GLTFMagicBase64Encoded)) {
      const arrayBuffer = DecodeBase64UrlToBinary(data);
      this._validate(scene, new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));
      return this._unpackBinaryAsync(new DataReader({
        readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),
        byteLength: arrayBuffer.byteLength
      }));
    }
    this._validate(scene, data);
    return Promise.resolve({ json: this._parseJson(data) });
  }
  /** @internal */
  createPlugin(options) {
    return new _GLTFFileLoader(options[GLTFFileLoaderMetadata.name]);
  }
  /**
   * The loader state or null if the loader is not active.
   */
  get loaderState() {
    return this._state;
  }
  /**
   * Returns a promise that resolves when the asset is completely loaded.
   * @returns a promise that resolves when the asset is completely loaded.
   */
  whenCompleteAsync() {
    return new Promise((resolve, reject) => {
      this.onCompleteObservable.addOnce(() => {
        resolve();
      });
      this.onErrorObservable.addOnce((reason) => {
        reject(reason);
      });
    });
  }
  /**
   * @internal
   */
  _setState(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.onLoaderStateChangedObservable.notifyObservers(this._state);
    this._log(GLTFLoaderState[this._state]);
  }
  /**
   * @internal
   */
  _loadFile(scene, fileOrUrl, onSuccess, useArrayBuffer, onError, onOpened) {
    const request = scene._loadFile(fileOrUrl, onSuccess, (event) => {
      this._onProgress(event, request);
    }, true, useArrayBuffer, onError, onOpened);
    request.onCompleteObservable.add(() => {
      request._lengthComputable = true;
      request._total = request._loaded;
    });
    this._requests.push(request);
    return request;
  }
  _onProgress(event, request) {
    if (!this._progressCallback) {
      return;
    }
    request._lengthComputable = event.lengthComputable;
    request._loaded = event.loaded;
    request._total = event.total;
    let lengthComputable = true;
    let loaded = 0;
    let total = 0;
    for (const request2 of this._requests) {
      if (request2._lengthComputable === void 0 || request2._loaded === void 0 || request2._total === void 0) {
        return;
      }
      lengthComputable = lengthComputable && request2._lengthComputable;
      loaded += request2._loaded;
      total += request2._total;
    }
    this._progressCallback({
      lengthComputable,
      loaded,
      total: lengthComputable ? total : 0
    });
  }
  _validate(scene, data, rootUrl = "", fileName = "") {
    if (!this.validate) {
      return;
    }
    this._startPerformanceCounter("Validate JSON");
    GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {
      return this.preprocessUrlAsync(rootUrl + uri).then((url) => {
        return scene._loadFileAsync(url, void 0, true, true).then((data2) => {
          return new Uint8Array(data2, 0, data2.byteLength);
        });
      });
    }).then((result) => {
      this._endPerformanceCounter("Validate JSON");
      this.onValidatedObservable.notifyObservers(result);
      this.onValidatedObservable.clear();
    }, (reason) => {
      this._endPerformanceCounter("Validate JSON");
      Tools.Warn(`Failed to validate: ${reason.message}`);
      this.onValidatedObservable.clear();
    });
  }
  _getLoader(loaderData) {
    const asset = loaderData.json.asset || {};
    this._log(`Asset version: ${asset.version}`);
    asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);
    asset.generator && this._log(`Asset generator: ${asset.generator}`);
    const version = _GLTFFileLoader._parseVersion(asset.version);
    if (!version) {
      throw new Error("Invalid version: " + asset.version);
    }
    if (asset.minVersion !== void 0) {
      const minVersion = _GLTFFileLoader._parseVersion(asset.minVersion);
      if (!minVersion) {
        throw new Error("Invalid minimum version: " + asset.minVersion);
      }
      if (_GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {
        throw new Error("Incompatible minimum version: " + asset.minVersion);
      }
    }
    const createLoaders = {
      1: _GLTFFileLoader._CreateGLTF1Loader,
      2: _GLTFFileLoader._CreateGLTF2Loader
    };
    const createLoader = createLoaders[version.major];
    if (!createLoader) {
      throw new Error("Unsupported version: " + asset.version);
    }
    return createLoader(this);
  }
  _parseJson(json) {
    this._startPerformanceCounter("Parse JSON");
    this._log(`JSON length: ${json.length}`);
    const parsed = JSON.parse(json);
    this._endPerformanceCounter("Parse JSON");
    return parsed;
  }
  _unpackBinaryAsync(dataReader) {
    this._startPerformanceCounter("Unpack Binary");
    return dataReader.loadAsync(20).then(() => {
      const Binary = {
        Magic: 1179937895
      };
      const magic = dataReader.readUint32();
      if (magic !== Binary.Magic) {
        throw new RuntimeError("Unexpected magic: " + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);
      }
      const version = dataReader.readUint32();
      if (this.loggingEnabled) {
        this._log(`Binary version: ${version}`);
      }
      const length = dataReader.readUint32();
      if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {
        Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);
      }
      let unpacked;
      switch (version) {
        case 1: {
          unpacked = this._unpackBinaryV1Async(dataReader, length);
          break;
        }
        case 2: {
          unpacked = this._unpackBinaryV2Async(dataReader, length);
          break;
        }
        default: {
          throw new Error("Unsupported version: " + version);
        }
      }
      this._endPerformanceCounter("Unpack Binary");
      return unpacked;
    });
  }
  _unpackBinaryV1Async(dataReader, length) {
    const ContentFormat = {
      JSON: 0
    };
    const contentLength = dataReader.readUint32();
    const contentFormat = dataReader.readUint32();
    if (contentFormat !== ContentFormat.JSON) {
      throw new Error(`Unexpected content format: ${contentFormat}`);
    }
    const bodyLength = length - dataReader.byteOffset;
    const data = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };
    if (bodyLength !== 0) {
      const startByteOffset = dataReader.byteOffset;
      data.bin = {
        readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),
        byteLength: bodyLength
      };
    }
    return Promise.resolve(data);
  }
  _unpackBinaryV2Async(dataReader, length) {
    const ChunkFormat = {
      JSON: 1313821514,
      BIN: 5130562
    };
    const chunkLength = dataReader.readUint32();
    const chunkFormat = dataReader.readUint32();
    if (chunkFormat !== ChunkFormat.JSON) {
      throw new Error("First chunk format is not JSON");
    }
    if (dataReader.byteOffset + chunkLength === length) {
      return dataReader.loadAsync(chunkLength).then(() => {
        return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };
      });
    }
    return dataReader.loadAsync(chunkLength + 8).then(() => {
      const data = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };
      const readAsync2 = () => {
        const chunkLength2 = dataReader.readUint32();
        const chunkFormat2 = dataReader.readUint32();
        switch (chunkFormat2) {
          case ChunkFormat.JSON: {
            throw new Error("Unexpected JSON chunk");
          }
          case ChunkFormat.BIN: {
            const startByteOffset = dataReader.byteOffset;
            data.bin = {
              readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),
              byteLength: chunkLength2
            };
            dataReader.skipBytes(chunkLength2);
            break;
          }
          default: {
            dataReader.skipBytes(chunkLength2);
            break;
          }
        }
        if (dataReader.byteOffset !== length) {
          return dataReader.loadAsync(8).then(readAsync2);
        }
        return Promise.resolve(data);
      };
      return readAsync2();
    });
  }
  static _parseVersion(version) {
    if (version === "1.0" || version === "1.0.1") {
      return {
        major: 1,
        minor: 0
      };
    }
    const match = (version + "").match(/^(\d+)\.(\d+)/);
    if (!match) {
      return null;
    }
    return {
      major: parseInt(match[1]),
      minor: parseInt(match[2])
    };
  }
  static _compareVersion(a, b) {
    if (a.major > b.major) {
      return 1;
    }
    if (a.major < b.major) {
      return -1;
    }
    if (a.minor > b.minor) {
      return 1;
    }
    if (a.minor < b.minor) {
      return -1;
    }
    return 0;
  }
  /**
   * @internal
   */
  _logOpen(message) {
    this._log(message);
    this._logIndentLevel++;
  }
  /** @internal */
  _logClose() {
    --this._logIndentLevel;
  }
  _logEnabled(message) {
    const spaces = _GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);
    Logger.Log(`${spaces}${message}`);
  }
  _logDisabled(message) {
  }
  _startPerformanceCounterEnabled(counterName) {
    Tools.StartPerformanceCounter(counterName);
  }
  _startPerformanceCounterDisabled(counterName) {
  }
  _endPerformanceCounterEnabled(counterName) {
    Tools.EndPerformanceCounter(counterName);
  }
  _endPerformanceCounterDisabled(counterName) {
  }
};
GLTFFileLoader.IncrementalLoading = true;
GLTFFileLoader.HomogeneousCoordinates = false;
GLTFFileLoader._logSpaces = "                                ";
RegisterSceneLoaderPlugin(new GLTFFileLoader());

// node_modules/@babylonjs/loaders/glTF/1.0/index.js
var __exports = {};
__export(__exports, {
  EBlendingFunction: () => EBlendingFunction,
  EComponentType: () => EComponentType,
  ECullingType: () => ECullingType,
  EParameterType: () => EParameterType,
  EShaderType: () => EShaderType,
  ETextureFilterType: () => ETextureFilterType,
  ETextureFormat: () => ETextureFormat,
  ETextureWrapMode: () => ETextureWrapMode,
  GLTFBinaryExtension: () => GLTFBinaryExtension,
  GLTFLoader: () => GLTFLoader,
  GLTFLoaderBase: () => GLTFLoaderBase,
  GLTFLoaderExtension: () => GLTFLoaderExtension,
  GLTFMaterialsCommonExtension: () => GLTFMaterialsCommonExtension,
  GLTFUtils: () => GLTFUtils
});

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderInterfaces.js
var EComponentType;
(function(EComponentType2) {
  EComponentType2[EComponentType2["BYTE"] = 5120] = "BYTE";
  EComponentType2[EComponentType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EComponentType2[EComponentType2["SHORT"] = 5122] = "SHORT";
  EComponentType2[EComponentType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EComponentType2[EComponentType2["FLOAT"] = 5126] = "FLOAT";
})(EComponentType || (EComponentType = {}));
var EShaderType;
(function(EShaderType2) {
  EShaderType2[EShaderType2["FRAGMENT"] = 35632] = "FRAGMENT";
  EShaderType2[EShaderType2["VERTEX"] = 35633] = "VERTEX";
})(EShaderType || (EShaderType = {}));
var EParameterType;
(function(EParameterType2) {
  EParameterType2[EParameterType2["BYTE"] = 5120] = "BYTE";
  EParameterType2[EParameterType2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
  EParameterType2[EParameterType2["SHORT"] = 5122] = "SHORT";
  EParameterType2[EParameterType2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
  EParameterType2[EParameterType2["INT"] = 5124] = "INT";
  EParameterType2[EParameterType2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
  EParameterType2[EParameterType2["FLOAT"] = 5126] = "FLOAT";
  EParameterType2[EParameterType2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
  EParameterType2[EParameterType2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
  EParameterType2[EParameterType2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
  EParameterType2[EParameterType2["INT_VEC2"] = 35667] = "INT_VEC2";
  EParameterType2[EParameterType2["INT_VEC3"] = 35668] = "INT_VEC3";
  EParameterType2[EParameterType2["INT_VEC4"] = 35669] = "INT_VEC4";
  EParameterType2[EParameterType2["BOOL"] = 35670] = "BOOL";
  EParameterType2[EParameterType2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
  EParameterType2[EParameterType2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
  EParameterType2[EParameterType2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
  EParameterType2[EParameterType2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
  EParameterType2[EParameterType2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
  EParameterType2[EParameterType2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
  EParameterType2[EParameterType2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
})(EParameterType || (EParameterType = {}));
var ETextureWrapMode;
(function(ETextureWrapMode2) {
  ETextureWrapMode2[ETextureWrapMode2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
  ETextureWrapMode2[ETextureWrapMode2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
  ETextureWrapMode2[ETextureWrapMode2["REPEAT"] = 10497] = "REPEAT";
})(ETextureWrapMode || (ETextureWrapMode = {}));
var ETextureFilterType;
(function(ETextureFilterType2) {
  ETextureFilterType2[ETextureFilterType2["NEAREST"] = 9728] = "NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR"] = 9728] = "LINEAR";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
  ETextureFilterType2[ETextureFilterType2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
  ETextureFilterType2[ETextureFilterType2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(ETextureFilterType || (ETextureFilterType = {}));
var ETextureFormat;
(function(ETextureFormat2) {
  ETextureFormat2[ETextureFormat2["ALPHA"] = 6406] = "ALPHA";
  ETextureFormat2[ETextureFormat2["RGB"] = 6407] = "RGB";
  ETextureFormat2[ETextureFormat2["RGBA"] = 6408] = "RGBA";
  ETextureFormat2[ETextureFormat2["LUMINANCE"] = 6409] = "LUMINANCE";
  ETextureFormat2[ETextureFormat2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
})(ETextureFormat || (ETextureFormat = {}));
var ECullingType;
(function(ECullingType2) {
  ECullingType2[ECullingType2["FRONT"] = 1028] = "FRONT";
  ECullingType2[ECullingType2["BACK"] = 1029] = "BACK";
  ECullingType2[ECullingType2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
})(ECullingType || (ECullingType = {}));
var EBlendingFunction;
(function(EBlendingFunction2) {
  EBlendingFunction2[EBlendingFunction2["ZERO"] = 0] = "ZERO";
  EBlendingFunction2[EBlendingFunction2["ONE"] = 1] = "ONE";
  EBlendingFunction2[EBlendingFunction2["SRC_COLOR"] = 768] = "SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
  EBlendingFunction2[EBlendingFunction2["DST_COLOR"] = 774] = "DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
  EBlendingFunction2[EBlendingFunction2["DST_ALPHA"] = 772] = "DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
  EBlendingFunction2[EBlendingFunction2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
  EBlendingFunction2[EBlendingFunction2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
})(EBlendingFunction || (EBlendingFunction = {}));

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoaderUtils.js
var GLTFUtils = class _GLTFUtils {
  /**
   * Sets the given "parameter" matrix
   * @param scene the Scene object
   * @param source the source node where to pick the matrix
   * @param parameter the GLTF technique parameter
   * @param uniformName the name of the shader's uniform
   * @param shaderMaterial the shader material
   */
  static SetMatrix(scene, source, parameter, uniformName, shaderMaterial) {
    let mat = null;
    if (parameter.semantic === "MODEL") {
      mat = source.getWorldMatrix();
    } else if (parameter.semantic === "PROJECTION") {
      mat = scene.getProjectionMatrix();
    } else if (parameter.semantic === "VIEW") {
      mat = scene.getViewMatrix();
    } else if (parameter.semantic === "MODELVIEWINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().multiply(scene.getViewMatrix()).invert());
    } else if (parameter.semantic === "MODELVIEW") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix());
    } else if (parameter.semantic === "MODELVIEWPROJECTION") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix());
    } else if (parameter.semantic === "MODELINVERSE") {
      mat = source.getWorldMatrix().invert();
    } else if (parameter.semantic === "VIEWINVERSE") {
      mat = scene.getViewMatrix().invert();
    } else if (parameter.semantic === "PROJECTIONINVERSE") {
      mat = scene.getProjectionMatrix().invert();
    } else if (parameter.semantic === "MODELVIEWINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getViewMatrix()).invert();
    } else if (parameter.semantic === "MODELVIEWPROJECTIONINVERSE") {
      mat = source.getWorldMatrix().multiply(scene.getTransformMatrix()).invert();
    } else if (parameter.semantic === "MODELINVERSETRANSPOSE") {
      mat = Matrix.Transpose(source.getWorldMatrix().invert());
    }
    if (mat) {
      switch (parameter.type) {
        case EParameterType.FLOAT_MAT2:
          shaderMaterial.setMatrix2x2(uniformName, Matrix.GetAsMatrix2x2(mat));
          break;
        case EParameterType.FLOAT_MAT3:
          shaderMaterial.setMatrix3x3(uniformName, Matrix.GetAsMatrix3x3(mat));
          break;
        case EParameterType.FLOAT_MAT4:
          shaderMaterial.setMatrix(uniformName, mat);
          break;
        default:
          break;
      }
    }
  }
  /**
   * Sets the given "parameter" matrix
   * @param shaderMaterial the shader material
   * @param uniform the name of the shader's uniform
   * @param value the value of the uniform
   * @param type the uniform's type (EParameterType FLOAT, VEC2, VEC3 or VEC4)
   * @returns true if set, else false
   */
  static SetUniform(shaderMaterial, uniform, value, type) {
    switch (type) {
      case EParameterType.FLOAT:
        shaderMaterial.setFloat(uniform, value);
        return true;
      case EParameterType.FLOAT_VEC2:
        shaderMaterial.setVector2(uniform, Vector2.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC3:
        shaderMaterial.setVector3(uniform, Vector3.FromArray(value));
        return true;
      case EParameterType.FLOAT_VEC4:
        shaderMaterial.setVector4(uniform, Vector4.FromArray(value));
        return true;
      default:
        return false;
    }
  }
  /**
   * Returns the wrap mode of the texture
   * @param mode the mode value
   * @returns the wrap mode (TEXTURE_WRAP_ADDRESSMODE, MIRROR_ADDRESSMODE or CLAMP_ADDRESSMODE)
   */
  static GetWrapMode(mode) {
    switch (mode) {
      case ETextureWrapMode.CLAMP_TO_EDGE:
        return Texture.CLAMP_ADDRESSMODE;
      case ETextureWrapMode.MIRRORED_REPEAT:
        return Texture.MIRROR_ADDRESSMODE;
      case ETextureWrapMode.REPEAT:
        return Texture.WRAP_ADDRESSMODE;
      default:
        return Texture.WRAP_ADDRESSMODE;
    }
  }
  /**
   * Returns the byte stride giving an accessor
   * @param accessor the GLTF accessor objet
   * @returns the byte stride
   */
  static GetByteStrideFromType(accessor) {
    const type = accessor.type;
    switch (type) {
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
      default:
        return 1;
    }
  }
  /**
   * Returns the texture filter mode giving a mode value
   * @param mode the filter mode value
   * @returns the filter mode (TODO - needs to be a type?)
   */
  static GetTextureFilterMode(mode) {
    switch (mode) {
      case ETextureFilterType.LINEAR:
      case ETextureFilterType.LINEAR_MIPMAP_NEAREST:
      case ETextureFilterType.LINEAR_MIPMAP_LINEAR:
        return Texture.TRILINEAR_SAMPLINGMODE;
      case ETextureFilterType.NEAREST:
      case ETextureFilterType.NEAREST_MIPMAP_NEAREST:
        return Texture.NEAREST_SAMPLINGMODE;
      default:
        return Texture.BILINEAR_SAMPLINGMODE;
    }
  }
  static GetBufferFromBufferView(gltfRuntime, bufferView, byteOffset, byteLength, componentType) {
    byteOffset = bufferView.byteOffset + byteOffset;
    const loadedBufferView = gltfRuntime.loadedBufferViews[bufferView.buffer];
    if (byteOffset + byteLength > loadedBufferView.byteLength) {
      throw new Error("Buffer access is out of range");
    }
    const buffer = loadedBufferView.buffer;
    byteOffset += loadedBufferView.byteOffset;
    switch (componentType) {
      case EComponentType.BYTE:
        return new Int8Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_BYTE:
        return new Uint8Array(buffer, byteOffset, byteLength);
      case EComponentType.SHORT:
        return new Int16Array(buffer, byteOffset, byteLength);
      case EComponentType.UNSIGNED_SHORT:
        return new Uint16Array(buffer, byteOffset, byteLength);
      default:
        return new Float32Array(buffer, byteOffset, byteLength);
    }
  }
  /**
   * Returns a buffer from its accessor
   * @param gltfRuntime the GLTF runtime
   * @param accessor the GLTF accessor
   * @returns an array buffer view
   */
  static GetBufferFromAccessor(gltfRuntime, accessor) {
    const bufferView = gltfRuntime.bufferViews[accessor.bufferView];
    const byteLength = accessor.count * _GLTFUtils.GetByteStrideFromType(accessor);
    return _GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, accessor.byteOffset, byteLength, accessor.componentType);
  }
  /**
   * Decodes a buffer view into a string
   * @param view the buffer view
   * @returns a string
   */
  static DecodeBufferToText(view) {
    let result = "";
    const length = view.byteLength;
    for (let i = 0; i < length; ++i) {
      result += String.fromCharCode(view[i]);
    }
    return result;
  }
  /**
   * Returns the default material of gltf. Related to
   * https://github.com/KhronosGroup/glTF/tree/master/specification/1.0#appendix-a-default-material
   * @param scene the Babylon.js scene
   * @returns the default Babylon material
   */
  static GetDefaultMaterial(scene) {
    if (!_GLTFUtils._DefaultMaterial) {
      Effect.ShadersStore["GLTFDefaultMaterialVertexShader"] = [
        "precision highp float;",
        "",
        "uniform mat4 worldView;",
        "uniform mat4 projection;",
        "",
        "attribute vec3 position;",
        "",
        "void main(void)",
        "{",
        "    gl_Position = projection * worldView * vec4(position, 1.0);",
        "}"
      ].join("\n");
      Effect.ShadersStore["GLTFDefaultMaterialPixelShader"] = [
        "precision highp float;",
        "",
        "uniform vec4 u_emission;",
        "",
        "void main(void)",
        "{",
        "    gl_FragColor = u_emission;",
        "}"
      ].join("\n");
      const shaderPath = {
        vertex: "GLTFDefaultMaterial",
        fragment: "GLTFDefaultMaterial"
      };
      const options = {
        attributes: ["position"],
        uniforms: ["worldView", "projection", "u_emission"],
        samplers: new Array(),
        needAlphaBlending: false
      };
      _GLTFUtils._DefaultMaterial = new ShaderMaterial("GLTFDefaultMaterial", scene, shaderPath, options);
      _GLTFUtils._DefaultMaterial.setColor4("u_emission", new Color4(0.5, 0.5, 0.5, 1));
    }
    return _GLTFUtils._DefaultMaterial;
  }
};
GLTFUtils._DefaultMaterial = null;

// node_modules/@babylonjs/loaders/glTF/1.0/glTFLoader.js
var ETokenType;
(function(ETokenType2) {
  ETokenType2[ETokenType2["IDENTIFIER"] = 1] = "IDENTIFIER";
  ETokenType2[ETokenType2["UNKNOWN"] = 2] = "UNKNOWN";
  ETokenType2[ETokenType2["END_OF_INPUT"] = 3] = "END_OF_INPUT";
})(ETokenType || (ETokenType = {}));
var Tokenizer = class {
  constructor(toParse) {
    this._pos = 0;
    this.currentToken = ETokenType.UNKNOWN;
    this.currentIdentifier = "";
    this.currentString = "";
    this.isLetterOrDigitPattern = /^[a-zA-Z0-9]+$/;
    this._toParse = toParse;
    this._maxPos = toParse.length;
  }
  getNextToken() {
    if (this.isEnd()) {
      return ETokenType.END_OF_INPUT;
    }
    this.currentString = this.read();
    this.currentToken = ETokenType.UNKNOWN;
    if (this.currentString === "_" || this.isLetterOrDigitPattern.test(this.currentString)) {
      this.currentToken = ETokenType.IDENTIFIER;
      this.currentIdentifier = this.currentString;
      while (!this.isEnd() && (this.isLetterOrDigitPattern.test(this.currentString = this.peek()) || this.currentString === "_")) {
        this.currentIdentifier += this.currentString;
        this.forward();
      }
    }
    return this.currentToken;
  }
  peek() {
    return this._toParse[this._pos];
  }
  read() {
    return this._toParse[this._pos++];
  }
  forward() {
    this._pos++;
  }
  isEnd() {
    return this._pos >= this._maxPos;
  }
};
var glTFTransforms = ["MODEL", "VIEW", "PROJECTION", "MODELVIEW", "MODELVIEWPROJECTION", "JOINTMATRIX"];
var BabylonTransforms = ["world", "view", "projection", "worldView", "worldViewProjection", "mBones"];
var glTFAnimationPaths = ["translation", "rotation", "scale"];
var BabylonAnimationPaths = ["position", "rotationQuaternion", "scaling"];
var ParseBuffers = (parsedBuffers, gltfRuntime) => {
  for (const buf in parsedBuffers) {
    const parsedBuffer = parsedBuffers[buf];
    gltfRuntime.buffers[buf] = parsedBuffer;
    gltfRuntime.buffersCount++;
  }
};
var ParseShaders = (parsedShaders, gltfRuntime) => {
  for (const sha in parsedShaders) {
    const parsedShader = parsedShaders[sha];
    gltfRuntime.shaders[sha] = parsedShader;
    gltfRuntime.shaderscount++;
  }
};
var ParseObject = (parsedObjects, runtimeProperty, gltfRuntime) => {
  for (const object in parsedObjects) {
    const parsedObject = parsedObjects[object];
    gltfRuntime[runtimeProperty][object] = parsedObject;
  }
};
var NormalizeUVs = (buffer) => {
  if (!buffer) {
    return;
  }
  for (let i = 0; i < buffer.length / 2; i++) {
    buffer[i * 2 + 1] = 1 - buffer[i * 2 + 1];
  }
};
var GetAttribute = (attributeParameter) => {
  if (attributeParameter.semantic === "NORMAL") {
    return "normal";
  } else if (attributeParameter.semantic === "POSITION") {
    return "position";
  } else if (attributeParameter.semantic === "JOINT") {
    return "matricesIndices";
  } else if (attributeParameter.semantic === "WEIGHT") {
    return "matricesWeights";
  } else if (attributeParameter.semantic === "COLOR") {
    return "color";
  } else if (attributeParameter.semantic && attributeParameter.semantic.indexOf("TEXCOORD_") !== -1) {
    const channel = Number(attributeParameter.semantic.split("_")[1]);
    return "uv" + (channel === 0 ? "" : channel + 1);
  }
  return null;
};
var LoadAnimations = (gltfRuntime) => {
  for (const anim in gltfRuntime.animations) {
    const animation = gltfRuntime.animations[anim];
    if (!animation.channels || !animation.samplers) {
      continue;
    }
    let lastAnimation = null;
    for (let i = 0; i < animation.channels.length; i++) {
      const channel = animation.channels[i];
      const sampler = animation.samplers[channel.sampler];
      if (!sampler) {
        continue;
      }
      let inputData = null;
      let outputData = null;
      if (animation.parameters) {
        inputData = animation.parameters[sampler.input];
        outputData = animation.parameters[sampler.output];
      } else {
        inputData = sampler.input;
        outputData = sampler.output;
      }
      const bufferInput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[inputData]);
      const bufferOutput = GLTFUtils.GetBufferFromAccessor(gltfRuntime, gltfRuntime.accessors[outputData]);
      const targetId = channel.target.id;
      let targetNode = gltfRuntime.scene.getNodeById(targetId);
      if (targetNode === null) {
        targetNode = gltfRuntime.scene.getNodeByName(targetId);
      }
      if (targetNode === null) {
        Tools.Warn("Creating animation named " + anim + ". But cannot find node named " + targetId + " to attach to");
        continue;
      }
      const isBone = targetNode instanceof Bone;
      let targetPath = channel.target.path;
      const targetPathIndex = glTFAnimationPaths.indexOf(targetPath);
      if (targetPathIndex !== -1) {
        targetPath = BabylonAnimationPaths[targetPathIndex];
      }
      let animationType = Animation.ANIMATIONTYPE_MATRIX;
      if (!isBone) {
        if (targetPath === "rotationQuaternion") {
          animationType = Animation.ANIMATIONTYPE_QUATERNION;
          targetNode.rotationQuaternion = new Quaternion();
        } else {
          animationType = Animation.ANIMATIONTYPE_VECTOR3;
        }
      }
      let babylonAnimation = null;
      const keys = [];
      let arrayOffset = 0;
      let modifyKey = false;
      if (isBone && lastAnimation && lastAnimation.getKeys().length === bufferInput.length) {
        babylonAnimation = lastAnimation;
        modifyKey = true;
      }
      if (!modifyKey) {
        gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
        babylonAnimation = new Animation(anim, isBone ? "_matrix" : targetPath, 1, animationType, Animation.ANIMATIONLOOPMODE_CYCLE);
        gltfRuntime.scene._blockEntityCollection = false;
      }
      for (let j = 0; j < bufferInput.length; j++) {
        let value = null;
        if (targetPath === "rotationQuaternion") {
          value = Quaternion.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2], bufferOutput[arrayOffset + 3]]);
          arrayOffset += 4;
        } else {
          value = Vector3.FromArray([bufferOutput[arrayOffset], bufferOutput[arrayOffset + 1], bufferOutput[arrayOffset + 2]]);
          arrayOffset += 3;
        }
        if (isBone) {
          const bone = targetNode;
          let translation = Vector3.Zero();
          let rotationQuaternion = new Quaternion();
          let scaling = Vector3.Zero();
          let mat = bone.getBaseMatrix();
          if (modifyKey && lastAnimation) {
            mat = lastAnimation.getKeys()[j].value;
          }
          mat.decompose(scaling, rotationQuaternion, translation);
          if (targetPath === "position") {
            translation = value;
          } else if (targetPath === "rotationQuaternion") {
            rotationQuaternion = value;
          } else {
            scaling = value;
          }
          value = Matrix.Compose(scaling, rotationQuaternion, translation);
        }
        if (!modifyKey) {
          keys.push({
            frame: bufferInput[j],
            value
          });
        } else if (lastAnimation) {
          lastAnimation.getKeys()[j].value = value;
        }
      }
      if (!modifyKey && babylonAnimation) {
        babylonAnimation.setKeys(keys);
        targetNode.animations.push(babylonAnimation);
      }
      lastAnimation = babylonAnimation;
      gltfRuntime.scene.stopAnimation(targetNode);
      gltfRuntime.scene.beginAnimation(targetNode, 0, bufferInput[bufferInput.length - 1], true, 1);
    }
  }
};
var ConfigureBoneTransformation = (node) => {
  let mat = null;
  if (node.translation || node.rotation || node.scale) {
    const scale = Vector3.FromArray(node.scale || [1, 1, 1]);
    const rotation = Quaternion.FromArray(node.rotation || [0, 0, 0, 1]);
    const position = Vector3.FromArray(node.translation || [0, 0, 0]);
    mat = Matrix.Compose(scale, rotation, position);
  } else {
    mat = Matrix.FromArray(node.matrix);
  }
  return mat;
};
var GetParentBone = (gltfRuntime, skins, jointName, newSkeleton) => {
  for (let i = 0; i < newSkeleton.bones.length; i++) {
    if (newSkeleton.bones[i].name === jointName) {
      return newSkeleton.bones[i];
    }
  }
  const nodes = gltfRuntime.nodes;
  for (const nde in nodes) {
    const node = nodes[nde];
    if (!node.jointName) {
      continue;
    }
    const children = node.children;
    for (let i = 0; i < children.length; i++) {
      const child = gltfRuntime.nodes[children[i]];
      if (!child.jointName) {
        continue;
      }
      if (child.jointName === jointName) {
        const mat = ConfigureBoneTransformation(node);
        const bone = new Bone(node.name || "", newSkeleton, GetParentBone(gltfRuntime, skins, node.jointName, newSkeleton), mat);
        bone.id = nde;
        return bone;
      }
    }
  }
  return null;
};
var GetNodeToRoot = (nodesToRoot, id) => {
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    for (let j = 0; j < nodeToRoot.node.children.length; j++) {
      const child = nodeToRoot.node.children[j];
      if (child === id) {
        return nodeToRoot.bone;
      }
    }
  }
  return null;
};
var GetJointNode = (gltfRuntime, jointName) => {
  const nodes = gltfRuntime.nodes;
  let node = nodes[jointName];
  if (node) {
    return {
      node,
      id: jointName
    };
  }
  for (const nde in nodes) {
    node = nodes[nde];
    if (node.jointName === jointName) {
      return {
        node,
        id: nde
      };
    }
  }
  return null;
};
var NodeIsInJoints = (skins, id) => {
  for (let i = 0; i < skins.jointNames.length; i++) {
    if (skins.jointNames[i] === id) {
      return true;
    }
  }
  return false;
};
var GetNodesToRoot = (gltfRuntime, newSkeleton, skins, nodesToRoot) => {
  for (const nde in gltfRuntime.nodes) {
    const node = gltfRuntime.nodes[nde];
    const id = nde;
    if (!node.jointName || NodeIsInJoints(skins, node.jointName)) {
      continue;
    }
    const mat = ConfigureBoneTransformation(node);
    const bone = new Bone(node.name || "", newSkeleton, null, mat);
    bone.id = id;
    nodesToRoot.push({ bone, node, id });
  }
  for (let i = 0; i < nodesToRoot.length; i++) {
    const nodeToRoot = nodesToRoot[i];
    const children = nodeToRoot.node.children;
    for (let j = 0; j < children.length; j++) {
      let child = null;
      for (let k = 0; k < nodesToRoot.length; k++) {
        if (nodesToRoot[k].id === children[j]) {
          child = nodesToRoot[k];
          break;
        }
      }
      if (child) {
        child.bone._parent = nodeToRoot.bone;
        nodeToRoot.bone.children.push(child.bone);
      }
    }
  }
};
var ImportSkeleton = (gltfRuntime, skins, mesh, newSkeleton) => {
  if (!newSkeleton) {
    newSkeleton = new Skeleton(skins.name || "", "", gltfRuntime.scene);
  }
  if (!skins.babylonSkeleton) {
    return newSkeleton;
  }
  const nodesToRoot = [];
  const nodesToRootToAdd = [];
  GetNodesToRoot(gltfRuntime, newSkeleton, skins, nodesToRoot);
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    const node = jointNode.node;
    if (!node) {
      Tools.Warn("Joint named " + skins.jointNames[i] + " does not exist");
      continue;
    }
    const id = jointNode.id;
    const existingBone = gltfRuntime.scene.getBoneById(id);
    if (existingBone) {
      newSkeleton.bones.push(existingBone);
      continue;
    }
    let foundBone = false;
    let parentBone = null;
    for (let j = 0; j < i; j++) {
      const jointNode2 = GetJointNode(gltfRuntime, skins.jointNames[j]);
      if (!jointNode2) {
        continue;
      }
      const joint = jointNode2.node;
      if (!joint) {
        Tools.Warn("Joint named " + skins.jointNames[j] + " does not exist when looking for parent");
        continue;
      }
      const children = joint.children;
      if (!children) {
        continue;
      }
      foundBone = false;
      for (let k = 0; k < children.length; k++) {
        if (children[k] === id) {
          parentBone = GetParentBone(gltfRuntime, skins, skins.jointNames[j], newSkeleton);
          foundBone = true;
          break;
        }
      }
      if (foundBone) {
        break;
      }
    }
    const mat = ConfigureBoneTransformation(node);
    if (!parentBone && nodesToRoot.length > 0) {
      parentBone = GetNodeToRoot(nodesToRoot, id);
      if (parentBone) {
        if (nodesToRootToAdd.indexOf(parentBone) === -1) {
          nodesToRootToAdd.push(parentBone);
        }
      }
    }
    const bone = new Bone(node.jointName || "", newSkeleton, parentBone, mat);
    bone.id = id;
  }
  const bones = newSkeleton.bones;
  newSkeleton.bones = [];
  for (let i = 0; i < skins.jointNames.length; i++) {
    const jointNode = GetJointNode(gltfRuntime, skins.jointNames[i]);
    if (!jointNode) {
      continue;
    }
    for (let j = 0; j < bones.length; j++) {
      if (bones[j].id === jointNode.id) {
        newSkeleton.bones.push(bones[j]);
        break;
      }
    }
  }
  newSkeleton.prepare();
  for (let i = 0; i < nodesToRootToAdd.length; i++) {
    newSkeleton.bones.push(nodesToRootToAdd[i]);
  }
  return newSkeleton;
};
var ImportMesh = (gltfRuntime, node, meshes, id, newMesh) => {
  if (!newMesh) {
    gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
    newMesh = new Mesh(node.name || "", gltfRuntime.scene);
    newMesh._parentContainer = gltfRuntime.assetContainer;
    gltfRuntime.scene._blockEntityCollection = false;
    newMesh.id = id;
  }
  if (!node.babylonNode) {
    return newMesh;
  }
  const subMaterials = [];
  let vertexData = null;
  const verticesStarts = [];
  const verticesCounts = [];
  const indexStarts = [];
  const indexCounts = [];
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      const tempVertexData = new VertexData();
      const primitive = mesh.primitives[i];
      if (primitive.mode !== 4) {
      }
      const attributes = primitive.attributes;
      let accessor = null;
      let buffer = null;
      for (const semantic in attributes) {
        accessor = gltfRuntime.accessors[attributes[semantic]];
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        if (semantic === "NORMAL") {
          tempVertexData.normals = new Float32Array(buffer.length);
          tempVertexData.normals.set(buffer);
        } else if (semantic === "POSITION") {
          if (GLTFFileLoader.HomogeneousCoordinates) {
            tempVertexData.positions = new Float32Array(buffer.length - buffer.length / 4);
            for (let j = 0; j < buffer.length; j += 4) {
              tempVertexData.positions[j] = buffer[j];
              tempVertexData.positions[j + 1] = buffer[j + 1];
              tempVertexData.positions[j + 2] = buffer[j + 2];
            }
          } else {
            tempVertexData.positions = new Float32Array(buffer.length);
            tempVertexData.positions.set(buffer);
          }
          verticesCounts.push(tempVertexData.positions.length);
        } else if (semantic.indexOf("TEXCOORD_") !== -1) {
          const channel = Number(semantic.split("_")[1]);
          const uvKind = VertexBuffer.UVKind + (channel === 0 ? "" : channel + 1);
          const uvs = new Float32Array(buffer.length);
          uvs.set(buffer);
          NormalizeUVs(uvs);
          tempVertexData.set(uvs, uvKind);
        } else if (semantic === "JOINT") {
          tempVertexData.matricesIndices = new Float32Array(buffer.length);
          tempVertexData.matricesIndices.set(buffer);
        } else if (semantic === "WEIGHT") {
          tempVertexData.matricesWeights = new Float32Array(buffer.length);
          tempVertexData.matricesWeights.set(buffer);
        } else if (semantic === "COLOR") {
          tempVertexData.colors = new Float32Array(buffer.length);
          tempVertexData.colors.set(buffer);
        }
      }
      accessor = gltfRuntime.accessors[primitive.indices];
      if (accessor) {
        buffer = GLTFUtils.GetBufferFromAccessor(gltfRuntime, accessor);
        tempVertexData.indices = new Int32Array(buffer.length);
        tempVertexData.indices.set(buffer);
        indexCounts.push(tempVertexData.indices.length);
      } else {
        const indices = [];
        for (let j = 0; j < tempVertexData.positions.length / 3; j++) {
          indices.push(j);
        }
        tempVertexData.indices = new Int32Array(indices);
        indexCounts.push(tempVertexData.indices.length);
      }
      if (!vertexData) {
        vertexData = tempVertexData;
      } else {
        vertexData.merge(tempVertexData);
      }
      const material2 = gltfRuntime.scene.getMaterialById(primitive.material);
      subMaterials.push(material2 === null ? GLTFUtils.GetDefaultMaterial(gltfRuntime.scene) : material2);
      verticesStarts.push(verticesStarts.length === 0 ? 0 : verticesStarts[verticesStarts.length - 1] + verticesCounts[verticesCounts.length - 2]);
      indexStarts.push(indexStarts.length === 0 ? 0 : indexStarts[indexStarts.length - 1] + indexCounts[indexCounts.length - 2]);
    }
  }
  let material;
  gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
  if (subMaterials.length > 1) {
    material = new MultiMaterial("multimat" + id, gltfRuntime.scene);
    material.subMaterials = subMaterials;
  } else {
    material = new StandardMaterial("multimat" + id, gltfRuntime.scene);
  }
  if (subMaterials.length === 1) {
    material = subMaterials[0];
  }
  material._parentContainer = gltfRuntime.assetContainer;
  if (!newMesh.material) {
    newMesh.material = material;
  }
  new Geometry(id, gltfRuntime.scene, vertexData, false, newMesh);
  newMesh.computeWorldMatrix(true);
  gltfRuntime.scene._blockEntityCollection = false;
  newMesh.subMeshes = [];
  let index = 0;
  for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
    const meshId = meshes[meshIndex];
    const mesh = gltfRuntime.meshes[meshId];
    if (!mesh) {
      continue;
    }
    for (let i = 0; i < mesh.primitives.length; i++) {
      if (mesh.primitives[i].mode !== 4) {
      }
      SubMesh.AddToMesh(index, verticesStarts[index], verticesCounts[index], indexStarts[index], indexCounts[index], newMesh, newMesh, true);
      index++;
    }
  }
  return newMesh;
};
var ConfigureNode = (newNode, position, rotation, scaling) => {
  if (newNode.position) {
    newNode.position = position;
  }
  if (newNode.rotationQuaternion || newNode.rotation) {
    newNode.rotationQuaternion = rotation;
  }
  if (newNode.scaling) {
    newNode.scaling = scaling;
  }
};
var ConfigureNodeFromMatrix = (newNode, node) => {
  if (node.matrix) {
    const position = new Vector3(0, 0, 0);
    const rotation = new Quaternion();
    const scaling = new Vector3(0, 0, 0);
    const mat = Matrix.FromArray(node.matrix);
    mat.decompose(scaling, rotation, position);
    ConfigureNode(newNode, position, rotation, scaling);
  } else if (node.translation && node.rotation && node.scale) {
    ConfigureNode(newNode, Vector3.FromArray(node.translation), Quaternion.FromArray(node.rotation), Vector3.FromArray(node.scale));
  }
  newNode.computeWorldMatrix(true);
};
var ImportNode = (gltfRuntime, node, id) => {
  let lastNode = null;
  if (gltfRuntime.importOnlyMeshes && (node.skin || node.meshes)) {
    if (gltfRuntime.importMeshesNames && gltfRuntime.importMeshesNames.length > 0 && gltfRuntime.importMeshesNames.indexOf(node.name || "") === -1) {
      return null;
    }
  }
  if (node.skin) {
    if (node.meshes) {
      const skin = gltfRuntime.skins[node.skin];
      const newMesh = ImportMesh(gltfRuntime, node, node.meshes, id, node.babylonNode);
      newMesh.skeleton = gltfRuntime.scene.getLastSkeletonById(node.skin);
      if (newMesh.skeleton === null) {
        newMesh.skeleton = ImportSkeleton(gltfRuntime, skin, newMesh, skin.babylonSkeleton);
        if (!skin.babylonSkeleton) {
          skin.babylonSkeleton = newMesh.skeleton;
        }
      }
      lastNode = newMesh;
    }
  } else if (node.meshes) {
    const newMesh = ImportMesh(gltfRuntime, node, node.mesh ? [node.mesh] : node.meshes, id, node.babylonNode);
    lastNode = newMesh;
  } else if (node.light && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const light = gltfRuntime.lights[node.light];
    if (light) {
      if (light.type === "ambient") {
        const ambienLight = light[light.type];
        const hemiLight = new HemisphericLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        hemiLight.name = node.name || "";
        if (ambienLight.color) {
          hemiLight.diffuse = Color3.FromArray(ambienLight.color);
        }
        lastNode = hemiLight;
      } else if (light.type === "directional") {
        const directionalLight = light[light.type];
        const dirLight = new DirectionalLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        dirLight.name = node.name || "";
        if (directionalLight.color) {
          dirLight.diffuse = Color3.FromArray(directionalLight.color);
        }
        lastNode = dirLight;
      } else if (light.type === "point") {
        const pointLight = light[light.type];
        const ptLight = new PointLight(node.light, Vector3.Zero(), gltfRuntime.scene);
        ptLight.name = node.name || "";
        if (pointLight.color) {
          ptLight.diffuse = Color3.FromArray(pointLight.color);
        }
        lastNode = ptLight;
      } else if (light.type === "spot") {
        const spotLight = light[light.type];
        const spLight = new SpotLight(node.light, Vector3.Zero(), Vector3.Zero(), 0, 0, gltfRuntime.scene);
        spLight.name = node.name || "";
        if (spotLight.color) {
          spLight.diffuse = Color3.FromArray(spotLight.color);
        }
        if (spotLight.fallOfAngle) {
          spLight.angle = spotLight.fallOfAngle;
        }
        if (spotLight.fallOffExponent) {
          spLight.exponent = spotLight.fallOffExponent;
        }
        lastNode = spLight;
      }
    }
  } else if (node.camera && !node.babylonNode && !gltfRuntime.importOnlyMeshes) {
    const camera = gltfRuntime.cameras[node.camera];
    if (camera) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      if (camera.type === "orthographic") {
        const orthoCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        orthoCamera.name = node.name || "";
        orthoCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        orthoCamera.attachControl();
        lastNode = orthoCamera;
        orthoCamera._parentContainer = gltfRuntime.assetContainer;
      } else if (camera.type === "perspective") {
        const perspectiveCamera = camera[camera.type];
        const persCamera = new FreeCamera(node.camera, Vector3.Zero(), gltfRuntime.scene, false);
        persCamera.name = node.name || "";
        persCamera.attachControl();
        if (!perspectiveCamera.aspectRatio) {
          perspectiveCamera.aspectRatio = gltfRuntime.scene.getEngine().getRenderWidth() / gltfRuntime.scene.getEngine().getRenderHeight();
        }
        if (perspectiveCamera.znear && perspectiveCamera.zfar) {
          persCamera.maxZ = perspectiveCamera.zfar;
          persCamera.minZ = perspectiveCamera.znear;
        }
        lastNode = persCamera;
        persCamera._parentContainer = gltfRuntime.assetContainer;
      }
      gltfRuntime.scene._blockEntityCollection = false;
    }
  }
  if (!node.jointName) {
    if (node.babylonNode) {
      return node.babylonNode;
    } else if (lastNode === null) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const dummy = new Mesh(node.name || "", gltfRuntime.scene);
      dummy._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      node.babylonNode = dummy;
      lastNode = dummy;
    }
  }
  if (lastNode !== null) {
    if (node.matrix && lastNode instanceof Mesh) {
      ConfigureNodeFromMatrix(lastNode, node);
    } else {
      const translation = node.translation || [0, 0, 0];
      const rotation = node.rotation || [0, 0, 0, 1];
      const scale = node.scale || [1, 1, 1];
      ConfigureNode(lastNode, Vector3.FromArray(translation), Quaternion.FromArray(rotation), Vector3.FromArray(scale));
    }
    lastNode.updateCache(true);
    node.babylonNode = lastNode;
  }
  return lastNode;
};
var TraverseNodes = (gltfRuntime, id, parent, meshIncluded = false) => {
  const node = gltfRuntime.nodes[id];
  let newNode = null;
  if (gltfRuntime.importOnlyMeshes && !meshIncluded && gltfRuntime.importMeshesNames) {
    if (gltfRuntime.importMeshesNames.indexOf(node.name || "") !== -1 || gltfRuntime.importMeshesNames.length === 0) {
      meshIncluded = true;
    } else {
      meshIncluded = false;
    }
  } else {
    meshIncluded = true;
  }
  if (!node.jointName && meshIncluded) {
    newNode = ImportNode(gltfRuntime, node, id);
    if (newNode !== null) {
      newNode.id = id;
      newNode.parent = parent;
    }
  }
  if (node.children) {
    for (let i = 0; i < node.children.length; i++) {
      TraverseNodes(gltfRuntime, node.children[i], newNode, meshIncluded);
    }
  }
};
var PostLoad = (gltfRuntime) => {
  let currentScene = gltfRuntime.currentScene;
  if (currentScene) {
    for (let i = 0; i < currentScene.nodes.length; i++) {
      TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
    }
  } else {
    for (const thing in gltfRuntime.scenes) {
      currentScene = gltfRuntime.scenes[thing];
      for (let i = 0; i < currentScene.nodes.length; i++) {
        TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    }
  }
  LoadAnimations(gltfRuntime);
  for (let i = 0; i < gltfRuntime.scene.skeletons.length; i++) {
    const skeleton = gltfRuntime.scene.skeletons[i];
    gltfRuntime.scene.beginAnimation(skeleton, 0, Number.MAX_VALUE, true, 1);
  }
};
var OnBindShaderMaterial = (mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess) => {
  const materialValues = material.values || technique.parameters;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    if (type === EParameterType.FLOAT_MAT2 || type === EParameterType.FLOAT_MAT3 || type === EParameterType.FLOAT_MAT4) {
      if (uniform.semantic && !uniform.source && !uniform.node) {
        GLTFUtils.SetMatrix(gltfRuntime.scene, mesh, uniform, unif, shaderMaterial.getEffect());
      } else if (uniform.semantic && (uniform.source || uniform.node)) {
        let source = gltfRuntime.scene.getNodeByName(uniform.source || uniform.node || "");
        if (source === null) {
          source = gltfRuntime.scene.getNodeById(uniform.source || uniform.node || "");
        }
        if (source === null) {
          continue;
        }
        GLTFUtils.SetMatrix(gltfRuntime.scene, source, uniform, unif, shaderMaterial.getEffect());
      }
    } else {
      const value = materialValues[technique.uniforms[unif]];
      if (!value) {
        continue;
      }
      if (type === EParameterType.SAMPLER_2D) {
        const texture = gltfRuntime.textures[material.values ? value : uniform.value].babylonTexture;
        if (texture === null || texture === void 0) {
          continue;
        }
        shaderMaterial.getEffect().setTexture(unif, texture);
      } else {
        GLTFUtils.SetUniform(shaderMaterial.getEffect(), unif, value, type);
      }
    }
  }
  onSuccess(shaderMaterial);
};
var PrepareShaderMaterialUniforms = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms) => {
  const materialValues = material.values || technique.parameters;
  const techniqueUniforms = technique.uniforms;
  for (const unif in unTreatedUniforms) {
    const uniform = unTreatedUniforms[unif];
    const type = uniform.type;
    let value = materialValues[techniqueUniforms[unif]];
    if (value === void 0) {
      value = uniform.value;
    }
    if (!value) {
      continue;
    }
    const onLoadTexture = (uniformName) => {
      return (texture) => {
        if (uniform.value && uniformName) {
          shaderMaterial.setTexture(uniformName, texture);
          delete unTreatedUniforms[uniformName];
        }
      };
    };
    if (type === EParameterType.SAMPLER_2D) {
      GLTFLoaderExtension.LoadTextureAsync(gltfRuntime, material.values ? value : uniform.value, onLoadTexture(unif), () => onLoadTexture(null));
    } else {
      if (uniform.value && GLTFUtils.SetUniform(shaderMaterial, unif, material.values ? value : uniform.value, type)) {
        delete unTreatedUniforms[unif];
      }
    }
  }
};
var OnShaderCompileError = (program, shaderMaterial, onError) => {
  return (effect, error) => {
    shaderMaterial.dispose(true);
    onError("Cannot compile program named " + program.name + ". Error: " + error + ". Default material will be applied");
  };
};
var OnShaderCompileSuccess = (gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess) => {
  return (_) => {
    PrepareShaderMaterialUniforms(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms);
    shaderMaterial.onBind = (mesh) => {
      OnBindShaderMaterial(mesh, gltfRuntime, unTreatedUniforms, shaderMaterial, technique, material, onSuccess);
    };
  };
};
var ParseShaderUniforms = (tokenizer, technique, unTreatedUniforms) => {
  for (const unif in technique.uniforms) {
    const uniform = technique.uniforms[unif];
    const uniformParameter = technique.parameters[uniform];
    if (tokenizer.currentIdentifier === unif) {
      if (uniformParameter.semantic && !uniformParameter.source && !uniformParameter.node) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          delete unTreatedUniforms[unif];
          return BabylonTransforms[transformIndex];
        }
      }
    }
  }
  return tokenizer.currentIdentifier;
};
var ImportMaterials = (gltfRuntime) => {
  for (const mat in gltfRuntime.materials) {
    GLTFLoaderExtension.LoadMaterialAsync(gltfRuntime, mat, () => {
    }, () => {
    });
  }
};
var GLTFLoaderBase = class {
  static CreateRuntime(parsedData, scene, rootUrl) {
    const gltfRuntime = {
      extensions: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      meshes: {},
      lights: {},
      cameras: {},
      nodes: {},
      images: {},
      textures: {},
      shaders: {},
      programs: {},
      samplers: {},
      techniques: {},
      materials: {},
      animations: {},
      skins: {},
      extensionsUsed: [],
      scenes: {},
      buffersCount: 0,
      shaderscount: 0,
      scene,
      rootUrl,
      loadedBufferCount: 0,
      loadedBufferViews: {},
      loadedShaderCount: 0,
      importOnlyMeshes: false,
      dummyNodes: [],
      assetContainer: null
    };
    if (parsedData.extensions) {
      ParseObject(parsedData.extensions, "extensions", gltfRuntime);
    }
    if (parsedData.extensionsUsed) {
      ParseObject(parsedData.extensionsUsed, "extensionsUsed", gltfRuntime);
    }
    if (parsedData.buffers) {
      ParseBuffers(parsedData.buffers, gltfRuntime);
    }
    if (parsedData.bufferViews) {
      ParseObject(parsedData.bufferViews, "bufferViews", gltfRuntime);
    }
    if (parsedData.accessors) {
      ParseObject(parsedData.accessors, "accessors", gltfRuntime);
    }
    if (parsedData.meshes) {
      ParseObject(parsedData.meshes, "meshes", gltfRuntime);
    }
    if (parsedData.lights) {
      ParseObject(parsedData.lights, "lights", gltfRuntime);
    }
    if (parsedData.cameras) {
      ParseObject(parsedData.cameras, "cameras", gltfRuntime);
    }
    if (parsedData.nodes) {
      ParseObject(parsedData.nodes, "nodes", gltfRuntime);
    }
    if (parsedData.images) {
      ParseObject(parsedData.images, "images", gltfRuntime);
    }
    if (parsedData.textures) {
      ParseObject(parsedData.textures, "textures", gltfRuntime);
    }
    if (parsedData.shaders) {
      ParseShaders(parsedData.shaders, gltfRuntime);
    }
    if (parsedData.programs) {
      ParseObject(parsedData.programs, "programs", gltfRuntime);
    }
    if (parsedData.samplers) {
      ParseObject(parsedData.samplers, "samplers", gltfRuntime);
    }
    if (parsedData.techniques) {
      ParseObject(parsedData.techniques, "techniques", gltfRuntime);
    }
    if (parsedData.materials) {
      ParseObject(parsedData.materials, "materials", gltfRuntime);
    }
    if (parsedData.animations) {
      ParseObject(parsedData.animations, "animations", gltfRuntime);
    }
    if (parsedData.skins) {
      ParseObject(parsedData.skins, "skins", gltfRuntime);
    }
    if (parsedData.scenes) {
      gltfRuntime.scenes = parsedData.scenes;
    }
    if (parsedData.scene && parsedData.scenes) {
      gltfRuntime.currentScene = parsedData.scenes[parsedData.scene];
    }
    return gltfRuntime;
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    const buffer = gltfRuntime.buffers[id];
    if (Tools.IsBase64(buffer.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(buffer.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + buffer.uri, (data) => onSuccess(new Uint8Array(data)), onProgress, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    const texture = gltfRuntime.textures[id];
    if (!texture || !texture.source) {
      onError("");
      return;
    }
    if (texture.babylonTexture) {
      onSuccess(null);
      return;
    }
    const source = gltfRuntime.images[texture.source];
    if (Tools.IsBase64(source.uri)) {
      setTimeout(() => onSuccess(new Uint8Array(Tools.DecodeBase64(source.uri))));
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + source.uri, (data) => onSuccess(new Uint8Array(data)), void 0, void 0, true, (request) => {
        if (request) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static CreateTextureAsync(gltfRuntime, id, buffer, onSuccess) {
    const texture = gltfRuntime.textures[id];
    if (texture.babylonTexture) {
      onSuccess(texture.babylonTexture);
      return;
    }
    const sampler = gltfRuntime.samplers[texture.sampler];
    const createMipMaps = sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.NEAREST_MIPMAP_LINEAR || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_NEAREST || sampler.minFilter === ETextureFilterType.LINEAR_MIPMAP_LINEAR;
    const samplingMode = Texture.BILINEAR_SAMPLINGMODE;
    const blob = buffer == null ? new Blob() : new Blob([buffer]);
    const blobURL = URL.createObjectURL(blob);
    const revokeBlobURL = () => URL.revokeObjectURL(blobURL);
    const newTexture = new Texture(blobURL, gltfRuntime.scene, !createMipMaps, true, samplingMode, revokeBlobURL, revokeBlobURL);
    if (sampler.wrapS !== void 0) {
      newTexture.wrapU = GLTFUtils.GetWrapMode(sampler.wrapS);
    }
    if (sampler.wrapT !== void 0) {
      newTexture.wrapV = GLTFUtils.GetWrapMode(sampler.wrapT);
    }
    newTexture.name = id;
    texture.babylonTexture = newTexture;
    onSuccess(newTexture);
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    const shader = gltfRuntime.shaders[id];
    if (Tools.IsBase64(shader.uri)) {
      const shaderString = atob(shader.uri.split(",")[1]);
      if (onSuccess) {
        onSuccess(shaderString);
      }
    } else {
      Tools.LoadFile(gltfRuntime.rootUrl + shader.uri, onSuccess, void 0, void 0, false, (request) => {
        if (request && onError) {
          onError(request.status + " " + request.statusText);
        }
      });
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material.technique) {
      if (onError) {
        onError("No technique found.");
      }
      return;
    }
    const technique = gltfRuntime.techniques[material.technique];
    if (!technique) {
      gltfRuntime.scene._blockEntityCollection = !!gltfRuntime.assetContainer;
      const defaultMaterial = new StandardMaterial(id, gltfRuntime.scene);
      defaultMaterial._parentContainer = gltfRuntime.assetContainer;
      gltfRuntime.scene._blockEntityCollection = false;
      defaultMaterial.diffuseColor = new Color3(0.5, 0.5, 0.5);
      defaultMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
      onSuccess(defaultMaterial);
      return;
    }
    const program = gltfRuntime.programs[technique.program];
    const states = technique.states;
    const vertexShader = Effect.ShadersStore[program.vertexShader + "VertexShader"];
    const pixelShader = Effect.ShadersStore[program.fragmentShader + "PixelShader"];
    let newVertexShader = "";
    let newPixelShader = "";
    const vertexTokenizer = new Tokenizer(vertexShader);
    const pixelTokenizer = new Tokenizer(pixelShader);
    const unTreatedUniforms = {};
    const uniforms = [];
    const attributes = [];
    const samplers = [];
    for (const unif in technique.uniforms) {
      const uniform = technique.uniforms[unif];
      const uniformParameter = technique.parameters[uniform];
      unTreatedUniforms[unif] = uniformParameter;
      if (uniformParameter.semantic && !uniformParameter.node && !uniformParameter.source) {
        const transformIndex = glTFTransforms.indexOf(uniformParameter.semantic);
        if (transformIndex !== -1) {
          uniforms.push(BabylonTransforms[transformIndex]);
          delete unTreatedUniforms[unif];
        } else {
          uniforms.push(unif);
        }
      } else if (uniformParameter.type === EParameterType.SAMPLER_2D) {
        samplers.push(unif);
      } else {
        uniforms.push(unif);
      }
    }
    for (const attr in technique.attributes) {
      const attribute = technique.attributes[attr];
      const attributeParameter = technique.parameters[attribute];
      if (attributeParameter.semantic) {
        const name2 = GetAttribute(attributeParameter);
        if (name2) {
          attributes.push(name2);
        }
      }
    }
    while (!vertexTokenizer.isEnd() && vertexTokenizer.getNextToken()) {
      const tokenType = vertexTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newVertexShader += vertexTokenizer.currentString;
        continue;
      }
      let foundAttribute = false;
      for (const attr in technique.attributes) {
        const attribute = technique.attributes[attr];
        const attributeParameter = technique.parameters[attribute];
        if (vertexTokenizer.currentIdentifier === attr && attributeParameter.semantic) {
          newVertexShader += GetAttribute(attributeParameter);
          foundAttribute = true;
          break;
        }
      }
      if (foundAttribute) {
        continue;
      }
      newVertexShader += ParseShaderUniforms(vertexTokenizer, technique, unTreatedUniforms);
    }
    while (!pixelTokenizer.isEnd() && pixelTokenizer.getNextToken()) {
      const tokenType = pixelTokenizer.currentToken;
      if (tokenType !== ETokenType.IDENTIFIER) {
        newPixelShader += pixelTokenizer.currentString;
        continue;
      }
      newPixelShader += ParseShaderUniforms(pixelTokenizer, technique, unTreatedUniforms);
    }
    const shaderPath = {
      vertex: program.vertexShader + id,
      fragment: program.fragmentShader + id
    };
    const options = {
      attributes,
      uniforms,
      samplers,
      needAlphaBlending: states && states.enable && states.enable.indexOf(3042) !== -1
    };
    Effect.ShadersStore[program.vertexShader + id + "VertexShader"] = newVertexShader;
    Effect.ShadersStore[program.fragmentShader + id + "PixelShader"] = newPixelShader;
    const shaderMaterial = new ShaderMaterial(id, gltfRuntime.scene, shaderPath, options);
    shaderMaterial.onError = OnShaderCompileError(program, shaderMaterial, onError);
    shaderMaterial.onCompiled = OnShaderCompileSuccess(gltfRuntime, shaderMaterial, technique, material, unTreatedUniforms, onSuccess);
    shaderMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (states && states.functions) {
      const functions = states.functions;
      if (functions.cullFace && functions.cullFace[0] !== ECullingType.BACK) {
        shaderMaterial.backFaceCulling = false;
      }
      const blendFunc = functions.blendFuncSeparate;
      if (blendFunc) {
        if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_ALPHA && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_COMBINE;
        } else if (blendFunc[0] === EBlendingFunction.ONE && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ONEONE;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE && blendFunc[2] === EBlendingFunction.ZERO && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_ADD;
        } else if (blendFunc[0] === EBlendingFunction.ZERO && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_SUBTRACT;
        } else if (blendFunc[0] === EBlendingFunction.DST_COLOR && blendFunc[1] === EBlendingFunction.ZERO && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MULTIPLY;
        } else if (blendFunc[0] === EBlendingFunction.SRC_ALPHA && blendFunc[1] === EBlendingFunction.ONE_MINUS_SRC_COLOR && blendFunc[2] === EBlendingFunction.ONE && blendFunc[3] === EBlendingFunction.ONE) {
          shaderMaterial.alphaMode = Constants.ALPHA_MAXIMIZED;
        }
      }
    }
  }
};
var GLTFLoader = class _GLTFLoader {
  static RegisterExtension(extension) {
    if (_GLTFLoader.Extensions[extension.name]) {
      Tools.Error('Tool with the same name "' + extension.name + '" already exists');
      return;
    }
    _GLTFLoader.Extensions[extension.name] = extension;
  }
  dispose() {
  }
  // eslint-disable-next-line no-restricted-syntax
  _importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      gltfRuntime.assetContainer = assetContainer;
      gltfRuntime.importOnlyMeshes = true;
      if (meshesNames === "") {
        gltfRuntime.importMeshesNames = [];
      } else if (typeof meshesNames === "string") {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else if (meshesNames && !(meshesNames instanceof Array)) {
        gltfRuntime.importMeshesNames = [meshesNames];
      } else {
        gltfRuntime.importMeshesNames = [];
        Tools.Warn("Argument meshesNames must be of type string or string[]");
      }
      this._createNodes(gltfRuntime);
      const meshes = [];
      const skeletons = [];
      for (const nde in gltfRuntime.nodes) {
        const node = gltfRuntime.nodes[nde];
        if (node.babylonNode instanceof AbstractMesh) {
          meshes.push(node.babylonNode);
        }
      }
      for (const skl in gltfRuntime.skins) {
        const skin = gltfRuntime.skins[skl];
        if (skin.babylonSkeleton instanceof Skeleton) {
          skeletons.push(skin.babylonSkeleton);
        }
      }
      this._loadBuffersAsync(gltfRuntime, () => {
        this._loadShadersAsync(gltfRuntime, () => {
          ImportMaterials(gltfRuntime);
          PostLoad(gltfRuntime);
          if (!GLTFFileLoader.IncrementalLoading && onSuccess) {
            onSuccess(meshes, skeletons);
          }
        });
      });
      if (GLTFFileLoader.IncrementalLoading && onSuccess) {
        onSuccess(meshes, skeletons);
      }
    }, onError);
    return true;
  }
  /**
   * Imports one or more meshes from a loaded gltf file and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param assetContainer defines the asset container to use (can be null)
   * @param data gltf data containing information of the meshes in a loaded file
   * @param rootUrl root url to load from
   * @param onProgress event that fires when loading progress has occured
   * @returns a promise containg the loaded meshes, particles, skeletons and animations
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  importMeshAsync(meshesNames, scene, assetContainer, data, rootUrl, onProgress) {
    return new Promise((resolve, reject) => {
      this._importMeshAsync(meshesNames, scene, data, rootUrl, assetContainer, (meshes, skeletons) => {
        resolve({
          meshes,
          particleSystems: [],
          skeletons,
          animationGroups: [],
          lights: [],
          transformNodes: [],
          geometries: [],
          spriteManagers: []
        });
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadAsync(scene, data, rootUrl, onSuccess, onProgress, onError) {
    scene.useRightHandedSystem = true;
    GLTFLoaderExtension.LoadRuntimeAsync(scene, data, rootUrl, (gltfRuntime) => {
      GLTFLoaderExtension.LoadRuntimeExtensionsAsync(gltfRuntime, () => {
        this._createNodes(gltfRuntime);
        this._loadBuffersAsync(gltfRuntime, () => {
          this._loadShadersAsync(gltfRuntime, () => {
            ImportMaterials(gltfRuntime);
            PostLoad(gltfRuntime);
            if (!GLTFFileLoader.IncrementalLoading) {
              onSuccess();
            }
          });
        });
        if (GLTFFileLoader.IncrementalLoading) {
          onSuccess();
        }
      }, onError);
    }, onError);
  }
  /**
   * Imports all objects from a loaded gltf file and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data gltf data containing information of the meshes in a loaded file
   * @param rootUrl root url to load from
   * @param onProgress event that fires when loading progress has occured
   * @returns a promise which completes when objects have been loaded to the scene
   */
  async loadAsync(scene, data, rootUrl, onProgress) {
    return await new Promise((resolve, reject) => {
      this._loadAsync(scene, data, rootUrl, () => {
        resolve();
      }, onProgress, (message) => {
        reject(new Error(message));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadShadersAsync(gltfRuntime, onload) {
    let hasShaders = false;
    const processShader = (sha, shader) => {
      GLTFLoaderExtension.LoadShaderStringAsync(gltfRuntime, sha, (shaderString) => {
        if (shaderString instanceof ArrayBuffer) {
          return;
        }
        gltfRuntime.loadedShaderCount++;
        if (shaderString) {
          Effect.ShadersStore[sha + (shader.type === EShaderType.VERTEX ? "VertexShader" : "PixelShader")] = shaderString;
        }
        if (gltfRuntime.loadedShaderCount === gltfRuntime.shaderscount) {
          onload();
        }
      }, () => {
        Tools.Error("Error when loading shader program named " + sha + " located at " + shader.uri);
      });
    };
    for (const sha in gltfRuntime.shaders) {
      hasShaders = true;
      const shader = gltfRuntime.shaders[sha];
      if (shader) {
        processShader.bind(this, sha, shader)();
      } else {
        Tools.Error("No shader named: " + sha);
      }
    }
    if (!hasShaders) {
      onload();
    }
  }
  // eslint-disable-next-line no-restricted-syntax
  _loadBuffersAsync(gltfRuntime, onLoad) {
    let hasBuffers = false;
    const processBuffer = (buf, buffer) => {
      GLTFLoaderExtension.LoadBufferAsync(gltfRuntime, buf, (bufferView) => {
        gltfRuntime.loadedBufferCount++;
        if (bufferView) {
          if (bufferView.byteLength != gltfRuntime.buffers[buf].byteLength) {
            Tools.Error("Buffer named " + buf + " is length " + bufferView.byteLength + ". Expected: " + buffer.byteLength);
          }
          gltfRuntime.loadedBufferViews[buf] = bufferView;
        }
        if (gltfRuntime.loadedBufferCount === gltfRuntime.buffersCount) {
          onLoad();
        }
      }, () => {
        Tools.Error("Error when loading buffer named " + buf + " located at " + buffer.uri);
      });
    };
    for (const buf in gltfRuntime.buffers) {
      hasBuffers = true;
      const buffer = gltfRuntime.buffers[buf];
      if (buffer) {
        processBuffer.bind(this, buf, buffer)();
      } else {
        Tools.Error("No buffer named: " + buf);
      }
    }
    if (!hasBuffers) {
      onLoad();
    }
  }
  _createNodes(gltfRuntime) {
    let currentScene = gltfRuntime.currentScene;
    if (currentScene) {
      for (let i = 0; i < currentScene.nodes.length; i++) {
        TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
      }
    } else {
      for (const thing in gltfRuntime.scenes) {
        currentScene = gltfRuntime.scenes[thing];
        for (let i = 0; i < currentScene.nodes.length; i++) {
          TraverseNodes(gltfRuntime, currentScene.nodes[i], null);
        }
      }
    }
  }
};
GLTFLoader.Extensions = {};
var GLTFLoaderExtension = class _GLTFLoaderExtension {
  constructor(name2) {
    this._name = name2;
  }
  get name() {
    return this._name;
  }
  /**
   * Defines an override for loading the runtime
   * Return true to stop further extensions from loading the runtime
   * @param scene
   * @param data
   * @param rootUrl
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading the runtime
   */
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an onverride for creating gltf runtime
   * Return true to stop further extensions from creating the runtime
   * @param gltfRuntime
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from creating the runtime
   */
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading buffers
   * Return true to stop further extensions from loading this buffer
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @param onProgress
   * @returns true to stop further extensions from loading this buffer
   */
  // eslint-disable-next-line no-restricted-syntax
  // eslint-disable-next-line no-restricted-syntax
  loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    return false;
  }
  /**
   * Defines an override for loading texture buffers
   * Return true to stop further extensions from loading this texture data
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this texture data
   */
  // eslint-disable-next-line no-restricted-syntax
  loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for creating textures
   * Return true to stop further extensions from loading this texture
   * @param gltfRuntime
   * @param id
   * @param buffer
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this texture
   */
  // eslint-disable-next-line no-restricted-syntax
  createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading shader strings
   * Return true to stop further extensions from loading this shader data
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this shader data
   */
  // eslint-disable-next-line no-restricted-syntax
  loadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  /**
   * Defines an override for loading materials
   * Return true to stop further extensions from loading this material
   * @param gltfRuntime
   * @param id
   * @param onSuccess
   * @param onError
   * @returns true to stop further extensions from loading this material
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    return false;
  }
  // ---------
  // Utilities
  // ---------
  // eslint-disable-next-line no-restricted-syntax
  static LoadRuntimeAsync(scene, data, rootUrl, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeAsync(scene, data, rootUrl, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        if (!onSuccess) {
          return;
        }
        onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadRuntimeExtensionsAsync(gltfRuntime, onSuccess, onError);
    }, () => {
      setTimeout(() => {
        onSuccess();
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    }, () => {
      GLTFLoaderBase.LoadBufferAsync(gltfRuntime, id, onSuccess, onError, onProgress);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadTextureAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      if (buffer) {
        _GLTFLoaderExtension._CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
      }
    }, onError);
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadShaderStringAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static LoadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadMaterialAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static _LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.loadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, onSuccess, onError);
    });
  }
  // eslint-disable-next-line no-restricted-syntax
  static _CreateTextureAsync(gltfRuntime, id, buffer, onSuccess, onError) {
    _GLTFLoaderExtension._ApplyExtensions((loaderExtension) => {
      return loaderExtension.createTextureAsync(gltfRuntime, id, buffer, onSuccess, onError);
    }, () => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, onSuccess);
    });
  }
  static _ApplyExtensions(func, defaultFunc) {
    for (const extensionName in GLTFLoader.Extensions) {
      const loaderExtension = GLTFLoader.Extensions[extensionName];
      if (func(loaderExtension)) {
        return;
      }
    }
    defaultFunc();
  }
};
GLTFFileLoader._CreateGLTF1Loader = () => new GLTFLoader();

// node_modules/@babylonjs/loaders/glTF/1.0/glTFBinaryExtension.js
var BinaryExtensionBufferName = "binary_glTF";
var GLTFBinaryExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_binary_glTF");
  }
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeAsync(scene, data, rootUrl, onSuccess) {
    const extensionsUsed = data.json.extensionsUsed;
    if (!extensionsUsed || extensionsUsed.indexOf(this.name) === -1 || !data.bin) {
      return false;
    }
    this._bin = data.bin;
    onSuccess(GLTFLoaderBase.CreateRuntime(data.json, scene, rootUrl));
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadBufferAsync(gltfRuntime, id, onSuccess, onError) {
    if (gltfRuntime.extensionsUsed.indexOf(this.name) === -1) {
      return false;
    }
    if (id !== BinaryExtensionBufferName) {
      return false;
    }
    this._bin.readAsync(0, this._bin.byteLength).then(onSuccess, (error) => onError(error.message));
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadTextureBufferAsync(gltfRuntime, id, onSuccess) {
    const texture = gltfRuntime.textures[id];
    const source = gltfRuntime.images[texture.source];
    if (!source.extensions || !(this.name in source.extensions)) {
      return false;
    }
    const sourceExt = source.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[sourceExt.bufferView];
    const buffer = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    onSuccess(buffer);
    return true;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadShaderStringAsync(gltfRuntime, id, onSuccess) {
    const shader = gltfRuntime.shaders[id];
    if (!shader.extensions || !(this.name in shader.extensions)) {
      return false;
    }
    const binaryExtensionShader = shader.extensions[this.name];
    const bufferView = gltfRuntime.bufferViews[binaryExtensionShader.bufferView];
    const shaderBytes = GLTFUtils.GetBufferFromBufferView(gltfRuntime, bufferView, 0, bufferView.byteLength, EComponentType.UNSIGNED_BYTE);
    setTimeout(() => {
      const shaderString = GLTFUtils.DecodeBufferToText(shaderBytes);
      onSuccess(shaderString);
    });
    return true;
  }
};
GLTFLoader.RegisterExtension(new GLTFBinaryExtension());

// node_modules/@babylonjs/loaders/glTF/1.0/glTFMaterialsCommonExtension.js
var GLTFMaterialsCommonExtension = class extends GLTFLoaderExtension {
  constructor() {
    super("KHR_materials_common");
  }
  // eslint-disable-next-line no-restricted-syntax
  loadRuntimeExtensionsAsync(gltfRuntime) {
    if (!gltfRuntime.extensions) {
      return false;
    }
    const extension = gltfRuntime.extensions[this.name];
    if (!extension) {
      return false;
    }
    const lights = extension.lights;
    if (lights) {
      for (const thing in lights) {
        const light = lights[thing];
        switch (light.type) {
          case "ambient": {
            const ambientLight = new HemisphericLight(light.name, new Vector3(0, 1, 0), gltfRuntime.scene);
            const ambient = light.ambient;
            if (ambient) {
              ambientLight.diffuse = Color3.FromArray(ambient.color || [1, 1, 1]);
            }
            break;
          }
          case "point": {
            const pointLight = new PointLight(light.name, new Vector3(10, 10, 10), gltfRuntime.scene);
            const point = light.point;
            if (point) {
              pointLight.diffuse = Color3.FromArray(point.color || [1, 1, 1]);
            }
            break;
          }
          case "directional": {
            const dirLight = new DirectionalLight(light.name, new Vector3(0, -1, 0), gltfRuntime.scene);
            const directional = light.directional;
            if (directional) {
              dirLight.diffuse = Color3.FromArray(directional.color || [1, 1, 1]);
            }
            break;
          }
          case "spot": {
            const spot = light.spot;
            if (spot) {
              const spotLight = new SpotLight(light.name, new Vector3(0, 10, 0), new Vector3(0, -1, 0), spot.fallOffAngle || Math.PI, spot.fallOffExponent || 0, gltfRuntime.scene);
              spotLight.diffuse = Color3.FromArray(spot.color || [1, 1, 1]);
            }
            break;
          }
          default:
            Tools.Warn('GLTF Material Common extension: light type "' + light.type + " not supported");
            break;
        }
      }
    }
    return false;
  }
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialAsync(gltfRuntime, id, onSuccess, onError) {
    const material = gltfRuntime.materials[id];
    if (!material || !material.extensions) {
      return false;
    }
    const extension = material.extensions[this.name];
    if (!extension) {
      return false;
    }
    const standardMaterial = new StandardMaterial(id, gltfRuntime.scene);
    standardMaterial.sideOrientation = Material.CounterClockWiseSideOrientation;
    if (extension.technique === "CONSTANT") {
      standardMaterial.disableLighting = true;
    }
    standardMaterial.backFaceCulling = extension.doubleSided === void 0 ? false : !extension.doubleSided;
    standardMaterial.alpha = extension.values.transparency === void 0 ? 1 : extension.values.transparency;
    standardMaterial.specularPower = extension.values.shininess === void 0 ? 0 : extension.values.shininess;
    if (typeof extension.values.ambient === "string") {
      this._loadTexture(gltfRuntime, extension.values.ambient, standardMaterial, "ambientTexture", onError);
    } else {
      standardMaterial.ambientColor = Color3.FromArray(extension.values.ambient || [0, 0, 0]);
    }
    if (typeof extension.values.diffuse === "string") {
      this._loadTexture(gltfRuntime, extension.values.diffuse, standardMaterial, "diffuseTexture", onError);
    } else {
      standardMaterial.diffuseColor = Color3.FromArray(extension.values.diffuse || [0, 0, 0]);
    }
    if (typeof extension.values.emission === "string") {
      this._loadTexture(gltfRuntime, extension.values.emission, standardMaterial, "emissiveTexture", onError);
    } else {
      standardMaterial.emissiveColor = Color3.FromArray(extension.values.emission || [0, 0, 0]);
    }
    if (typeof extension.values.specular === "string") {
      this._loadTexture(gltfRuntime, extension.values.specular, standardMaterial, "specularTexture", onError);
    } else {
      standardMaterial.specularColor = Color3.FromArray(extension.values.specular || [0, 0, 0]);
    }
    return true;
  }
  _loadTexture(gltfRuntime, id, material, propertyPath, onError) {
    GLTFLoaderBase.LoadTextureBufferAsync(gltfRuntime, id, (buffer) => {
      GLTFLoaderBase.CreateTextureAsync(gltfRuntime, id, buffer, (texture) => material[propertyPath] = texture);
    }, onError);
  }
};
GLTFLoader.RegisterExtension(new GLTFMaterialsCommonExtension());

// node_modules/@babylonjs/loaders/glTF/2.0/index.js
var __exports2 = {};
__export(__exports2, {
  AddObjectAccessorToKey: () => AddObjectAccessorToKey,
  AnimationPropertyInfo: () => AnimationPropertyInfo,
  ArrayItem: () => ArrayItem,
  EXT_lights_area: () => EXT_lights_area,
  EXT_lights_ies: () => EXT_lights_ies,
  EXT_lights_image_based: () => EXT_lights_image_based,
  EXT_mesh_gpu_instancing: () => EXT_mesh_gpu_instancing,
  EXT_meshopt_compression: () => EXT_meshopt_compression,
  EXT_texture_avif: () => EXT_texture_avif,
  EXT_texture_webp: () => EXT_texture_webp,
  ExtrasAsMetadata: () => ExtrasAsMetadata,
  FlowGraphGLTFDataProvider: () => FlowGraphGLTFDataProvider,
  GLTFFileLoader: () => GLTFFileLoader,
  GLTFLoader: () => GLTFLoader2,
  GetMappingForKey: () => GetMappingForKey,
  GetPathToObjectConverter: () => GetPathToObjectConverter,
  InteractivityGraphToFlowGraphParser: () => InteractivityGraphToFlowGraphParser,
  KHR_animation_pointer: () => KHR_animation_pointer,
  KHR_draco_mesh_compression: () => KHR_draco_mesh_compression,
  KHR_interactivity: () => KHR_interactivity,
  KHR_lights: () => KHR_lights,
  KHR_materials_anisotropy: () => KHR_materials_anisotropy,
  KHR_materials_clearcoat: () => KHR_materials_clearcoat,
  KHR_materials_diffuse_roughness: () => KHR_materials_diffuse_roughness,
  KHR_materials_diffuse_transmission: () => KHR_materials_diffuse_transmission,
  KHR_materials_dispersion: () => KHR_materials_dispersion,
  KHR_materials_emissive_strength: () => KHR_materials_emissive_strength,
  KHR_materials_ior: () => KHR_materials_ior,
  KHR_materials_iridescence: () => KHR_materials_iridescence,
  KHR_materials_pbrSpecularGlossiness: () => KHR_materials_pbrSpecularGlossiness,
  KHR_materials_sheen: () => KHR_materials_sheen,
  KHR_materials_specular: () => KHR_materials_specular,
  KHR_materials_transmission: () => KHR_materials_transmission,
  KHR_materials_unlit: () => KHR_materials_unlit,
  KHR_materials_variants: () => KHR_materials_variants,
  KHR_materials_volume: () => KHR_materials_volume,
  KHR_mesh_quantization: () => KHR_mesh_quantization,
  KHR_node_hoverability: () => KHR_node_hoverability,
  KHR_node_selectability: () => KHR_node_selectability,
  KHR_node_visibility: () => KHR_node_visibility,
  KHR_texture_basisu: () => KHR_texture_basisu,
  KHR_texture_transform: () => KHR_texture_transform,
  KHR_xmp_json_ld: () => KHR_xmp_json_ld,
  LoadBoundingInfoFromPositionAccessor: () => LoadBoundingInfoFromPositionAccessor,
  MSFT_audio_emitter: () => MSFT_audio_emitter,
  MSFT_lod: () => MSFT_lod,
  MSFT_minecraftMesh: () => MSFT_minecraftMesh,
  MSFT_sRGBFactors: () => MSFT_sRGBFactors,
  OpenPBRMaterialLoadingAdapter: () => OpenPBRMaterialLoadingAdapter,
  PBRMaterialLoadingAdapter: () => PBRMaterialLoadingAdapter,
  SetInterpolationForKey: () => SetInterpolationForKey,
  TransformNodeAnimationPropertyInfo: () => TransformNodeAnimationPropertyInfo,
  WeightAnimationPropertyInfo: () => WeightAnimationPropertyInfo,
  _AddInteractivityObjectModel: () => _AddInteractivityObjectModel,
  addNewInteractivityFlowGraphMapping: () => addNewInteractivityFlowGraphMapping,
  getAllSupportedNativeNodeTypes: () => getAllSupportedNativeNodeTypes,
  getMappingForDeclaration: () => getMappingForDeclaration,
  getMappingForFullOperationName: () => getMappingForFullOperationName,
  getQuaternion: () => getQuaternion,
  getVector3: () => getVector3,
  getWeights: () => getWeights,
  gltfTypeToBabylonType: () => gltfTypeToBabylonType,
  registerGLTFExtension: () => registerGLTFExtension,
  registeredGLTFExtensions: () => registeredGLTFExtensions,
  unregisterGLTFExtension: () => unregisterGLTFExtension
});

// node_modules/@babylonjs/loaders/glTF/2.0/glTFLoaderExtensionRegistry.js
var RegisteredGLTFExtensions = /* @__PURE__ */ new Map();
var registeredGLTFExtensions = RegisteredGLTFExtensions;
function registerGLTFExtension(name2, isGLTFExtension, factory) {
  if (unregisterGLTFExtension(name2)) {
    Logger.Warn(`Extension with the name '${name2}' already exists`);
  }
  RegisteredGLTFExtensions.set(name2, {
    isGLTFExtension,
    factory
  });
}
function unregisterGLTFExtension(name2) {
  return RegisteredGLTFExtensions.delete(name2);
}

// node_modules/@babylonjs/loaders/glTF/2.0/glTFLoader.js
var LazyAnimationGroupModulePromise = new Lazy(() => import("./animationGroup-IZJHJZBS.js"));
var LazyLoaderAnimationModulePromise = new Lazy(() => import("./glTFLoaderAnimation-ETQRXGDF.js"));
var ArrayItem = class {
  /**
   * Gets an item from the given array.
   * @param context The context when loading the asset
   * @param array The array to get the item from
   * @param index The index to the array
   * @returns The array item
   */
  static Get(context, array, index) {
    if (!array || index == void 0 || !array[index]) {
      throw new Error(`${context}: Failed to find index (${index})`);
    }
    return array[index];
  }
  /**
   * Gets an item from the given array or returns null if not available.
   * @param array The array to get the item from
   * @param index The index to the array
   * @returns The array item or null
   */
  static TryGet(array, index) {
    if (!array || index == void 0 || !array[index]) {
      return null;
    }
    return array[index];
  }
  /**
   * Assign an `index` field to each item of the given array.
   * @param array The array of items
   */
  static Assign(array) {
    if (array) {
      for (let index = 0; index < array.length; index++) {
        array[index].index = index;
      }
    }
  }
};
function LoadBoundingInfoFromPositionAccessor(accessor) {
  if (accessor.min && accessor.max) {
    const minArray = accessor.min;
    const maxArray = accessor.max;
    const minVector = TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);
    const maxVector = TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);
    if (accessor.normalized && accessor.componentType !== 5126) {
      let divider = 1;
      switch (accessor.componentType) {
        case 5120:
          divider = 127;
          break;
        case 5121:
          divider = 255;
          break;
        case 5122:
          divider = 32767;
          break;
        case 5123:
          divider = 65535;
          break;
      }
      const oneOverDivider = 1 / divider;
      minVector.scaleInPlace(oneOverDivider);
      maxVector.scaleInPlace(oneOverDivider);
    }
    return new BoundingInfo(minVector, maxVector);
  }
  return null;
}
var GLTFLoader2 = class _GLTFLoader {
  /**
   * Registers a loader extension.
   * @param name The name of the loader extension.
   * @param factory The factory function that creates the loader extension.
   * @deprecated Please use registerGLTFExtension instead.
   */
  static RegisterExtension(name2, factory) {
    registerGLTFExtension(name2, false, factory);
  }
  /**
   * Unregisters a loader extension.
   * @param name The name of the loader extension.
   * @returns A boolean indicating whether the extension has been unregistered
   * @deprecated Please use unregisterGLTFExtension instead.
   */
  static UnregisterExtension(name2) {
    return unregisterGLTFExtension(name2);
  }
  /**
   * The object that represents the glTF JSON.
   */
  get gltf() {
    if (!this._gltf) {
      throw new Error("glTF JSON is not available");
    }
    return this._gltf;
  }
  /**
   * The BIN chunk of a binary glTF.
   */
  get bin() {
    return this._bin;
  }
  /**
   * The parent file loader.
   */
  get parent() {
    return this._parent;
  }
  /**
   * The Babylon scene when loading the asset.
   */
  get babylonScene() {
    if (!this._babylonScene) {
      throw new Error("Scene is not available");
    }
    return this._babylonScene;
  }
  /**
   * The root Babylon node when loading the asset.
   */
  get rootBabylonMesh() {
    return this._rootBabylonMesh;
  }
  /**
   * The root url when loading the asset.
   */
  get rootUrl() {
    return this._rootUrl;
  }
  /**
   * @internal
   */
  constructor(parent) {
    this._completePromises = new Array();
    this._assetContainer = null;
    this._babylonLights = [];
    this._disableInstancedMesh = 0;
    this._allMaterialsDirtyRequired = false;
    this._skipStartAnimationStep = false;
    this._extensions = new Array();
    this._disposed = false;
    this._rootUrl = null;
    this._fileName = null;
    this._uniqueRootUrl = null;
    this._bin = null;
    this._rootBabylonMesh = null;
    this._defaultBabylonMaterialData = {};
    this._postSceneLoadActions = new Array();
    this._materialAdapterCache = /* @__PURE__ */ new WeakMap();
    this._pbrMaterialImpl = null;
    this._parent = parent;
  }
  /**
   * Creates or gets a cached material loading adapter with dynamic imports
   * @param material The material to adapt
   * @returns Promise that resolves to the appropriate adapter
   * @internal
   */
  _getOrCreateMaterialAdapter(material) {
    let adapter = this._materialAdapterCache.get(material);
    if (!adapter) {
      if (this._pbrMaterialImpl) {
        adapter = new this._pbrMaterialImpl.adapterClass(material);
      } else {
        throw new Error(`Appropriate material adapter class not found`);
      }
      this._materialAdapterCache.set(material, adapter);
    }
    return adapter;
  }
  /** @internal */
  dispose() {
    if (this._disposed) {
      return;
    }
    this._disposed = true;
    this._completePromises.length = 0;
    this._extensions.forEach((extension) => extension.dispose && extension.dispose());
    this._extensions.length = 0;
    this._gltf = null;
    this._bin = null;
    this._babylonScene = null;
    this._rootBabylonMesh = null;
    this._defaultBabylonMaterialData = {};
    this._postSceneLoadActions.length = 0;
    this._parent.dispose();
  }
  /**
   * @internal
   */
  async importMeshAsync(meshesNames, scene, container, data, rootUrl, onProgress, fileName = "") {
    return await Promise.resolve().then(async () => {
      this._babylonScene = scene;
      this._assetContainer = container;
      this._loadData(data);
      let nodes = null;
      if (meshesNames) {
        const nodeMap = {};
        if (this._gltf.nodes) {
          for (const node of this._gltf.nodes) {
            if (node.name) {
              nodeMap[node.name] = node.index;
            }
          }
        }
        const names = meshesNames instanceof Array ? meshesNames : [meshesNames];
        nodes = names.map((name2) => {
          const node = nodeMap[name2];
          if (node === void 0) {
            throw new Error(`Failed to find node '${name2}'`);
          }
          return node;
        });
      }
      return await this._loadAsync(rootUrl, fileName, nodes, () => {
        return {
          meshes: this._getMeshes(),
          particleSystems: [],
          skeletons: this._getSkeletons(),
          animationGroups: this._getAnimationGroups(),
          lights: this._babylonLights,
          transformNodes: this._getTransformNodes(),
          geometries: this._getGeometries(),
          spriteManagers: []
        };
      });
    });
  }
  /**
   * @internal
   */
  async loadAsync(scene, data, rootUrl, onProgress, fileName = "") {
    this._babylonScene = scene;
    this._loadData(data);
    return await this._loadAsync(rootUrl, fileName, null, () => void 0);
  }
  async _loadAsync(rootUrl, fileName, nodes, resultFunc) {
    return await Promise.resolve().then(async () => {
      this._rootUrl = rootUrl;
      this._uniqueRootUrl = !rootUrl.startsWith("file:") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;
      this._fileName = fileName;
      this._allMaterialsDirtyRequired = false;
      await this._loadExtensionsAsync();
      if (!this.parent.skipMaterials && this._pbrMaterialImpl == null) {
        if (this.parent.useOpenPBR || this.isExtensionUsed("KHR_materials_openpbr")) {
          this._pbrMaterialImpl = {
            materialClass: (await import("./openPbrMaterial-EEDJHBQK.js")).OpenPBRMaterial,
            adapterClass: (await import("./openpbrMaterialLoadingAdapter-HLKNGKWJ.js")).OpenPBRMaterialLoadingAdapter
          };
        } else {
          this._pbrMaterialImpl = {
            materialClass: (await import("./pbrMaterial-7SGG5AJQ.js")).PBRMaterial,
            adapterClass: (await import("./pbrMaterialLoadingAdapter-HJGXCVSN.js")).PBRMaterialLoadingAdapter
          };
        }
      }
      const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;
      const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;
      this._parent._startPerformanceCounter(loadingToReadyCounterName);
      this._parent._startPerformanceCounter(loadingToCompleteCounterName);
      this._parent._setState(GLTFLoaderState.LOADING);
      this._extensionsOnLoading();
      const promises = new Array();
      const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;
      this._babylonScene.blockMaterialDirtyMechanism = true;
      if (!this.parent.loadOnlyMaterials) {
        if (nodes) {
          promises.push(this.loadSceneAsync("/nodes", { nodes, index: -1 }));
        } else if (this._gltf.scene != void 0 || this._gltf.scenes && this._gltf.scenes[0]) {
          const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);
          promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));
        }
      }
      if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {
        for (let m = 0; m < this._gltf.materials.length; ++m) {
          const material = this._gltf.materials[m];
          const context = "/materials/" + m;
          const babylonDrawMode = Material.TriangleFillMode;
          promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {
          }));
        }
      }
      if (this._allMaterialsDirtyRequired) {
        this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;
      } else {
        this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);
      }
      if (this._parent.compileMaterials) {
        promises.push(this._compileMaterialsAsync());
      }
      if (this._parent.compileShadowGenerators) {
        promises.push(this._compileShadowGeneratorsAsync());
      }
      const resultPromise = Promise.all(promises).then(() => {
        if (this._rootBabylonMesh && this._rootBabylonMesh !== this._parent.customRootNode) {
          this._rootBabylonMesh.setEnabled(true);
        }
        for (const material of this._babylonScene.materials) {
          const mat = material;
          if (mat.maxSimultaneousLights !== void 0) {
            mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, this._babylonScene.lights.length);
          }
        }
        this._extensionsOnReady();
        this._parent._setState(GLTFLoaderState.READY);
        if (!this._skipStartAnimationStep) {
          this._startAnimations();
        }
        return resultFunc();
      });
      return await resultPromise.then((result) => {
        this._parent._endPerformanceCounter(loadingToReadyCounterName);
        Tools.SetImmediate(() => {
          if (!this._disposed) {
            Promise.all(this._completePromises).then(() => {
              this._parent._endPerformanceCounter(loadingToCompleteCounterName);
              this._parent._setState(GLTFLoaderState.COMPLETE);
              this._parent.onCompleteObservable.notifyObservers(void 0);
              this._parent.onCompleteObservable.clear();
              this.dispose();
            }, (error) => {
              this._parent.onErrorObservable.notifyObservers(error);
              this._parent.onErrorObservable.clear();
              this.dispose();
            });
          }
        });
        return result;
      });
    }).catch((error) => {
      if (!this._disposed) {
        this._parent.onErrorObservable.notifyObservers(error);
        this._parent.onErrorObservable.clear();
        this.dispose();
      }
      throw error;
    });
  }
  _loadData(data) {
    this._gltf = data.json;
    this._setupData();
    if (data.bin) {
      const buffers = this._gltf.buffers;
      if (buffers && buffers[0] && !buffers[0].uri) {
        const binaryBuffer = buffers[0];
        if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {
          Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);
        }
        this._bin = data.bin;
      } else {
        Logger.Warn("Unexpected BIN chunk");
      }
    }
  }
  _setupData() {
    ArrayItem.Assign(this._gltf.accessors);
    ArrayItem.Assign(this._gltf.animations);
    ArrayItem.Assign(this._gltf.buffers);
    ArrayItem.Assign(this._gltf.bufferViews);
    ArrayItem.Assign(this._gltf.cameras);
    ArrayItem.Assign(this._gltf.images);
    ArrayItem.Assign(this._gltf.materials);
    ArrayItem.Assign(this._gltf.meshes);
    ArrayItem.Assign(this._gltf.nodes);
    ArrayItem.Assign(this._gltf.samplers);
    ArrayItem.Assign(this._gltf.scenes);
    ArrayItem.Assign(this._gltf.skins);
    ArrayItem.Assign(this._gltf.textures);
    if (this._gltf.nodes) {
      const nodeParents = {};
      for (const node of this._gltf.nodes) {
        if (node.children) {
          for (const index of node.children) {
            nodeParents[index] = node.index;
          }
        }
      }
      const rootNode = this._createRootNode();
      for (const node of this._gltf.nodes) {
        const parentIndex = nodeParents[node.index];
        node.parent = parentIndex === void 0 ? rootNode : this._gltf.nodes[parentIndex];
      }
    }
  }
  async _loadExtensionsAsync() {
    const extensionPromises = [];
    registeredGLTFExtensions.forEach((registeredExtension, name2) => {
      if (this.parent.extensionOptions[name2]?.enabled === false) {
        if (registeredExtension.isGLTFExtension && this.isExtensionUsed(name2)) {
          Logger.Warn(`Extension ${name2} is used but has been explicitly disabled.`);
        }
      } else if (!registeredExtension.isGLTFExtension || this.isExtensionUsed(name2)) {
        extensionPromises.push((async () => {
          const extension = await registeredExtension.factory(this);
          if (extension.name !== name2) {
            Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name2}`);
          }
          this._parent.onExtensionLoadedObservable.notifyObservers(extension);
          return extension;
        })());
      }
    });
    this._extensions.push(...await Promise.all(extensionPromises));
    this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));
    this._parent.onExtensionLoadedObservable.clear();
    if (this._gltf.extensionsRequired) {
      for (const name2 of this._gltf.extensionsRequired) {
        const available = this._extensions.some((extension) => extension.name === name2 && extension.enabled);
        if (!available) {
          if (this.parent.extensionOptions[name2]?.enabled === false) {
            throw new Error(`Required extension ${name2} is disabled`);
          }
          throw new Error(`Required extension ${name2} is not available`);
        }
      }
    }
  }
  _createRootNode() {
    if (this._parent.customRootNode !== void 0) {
      this._rootBabylonMesh = this._parent.customRootNode;
      return {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        _babylonTransformNode: this._rootBabylonMesh === null ? void 0 : this._rootBabylonMesh,
        index: -1
      };
    }
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const rootMesh = new Mesh("__root__", this._babylonScene);
    this._rootBabylonMesh = rootMesh;
    this._rootBabylonMesh._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    this._rootBabylonMesh.setEnabled(false);
    const rootNode = {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _babylonTransformNode: this._rootBabylonMesh,
      index: -1
    };
    switch (this._parent.coordinateSystemMode) {
      case GLTFLoaderCoordinateSystemMode.AUTO: {
        if (!this._babylonScene.useRightHandedSystem) {
          rootNode.rotation = [0, 1, 0, 0];
          rootNode.scale = [1, 1, -1];
          _GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);
        }
        break;
      }
      case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {
        this._babylonScene.useRightHandedSystem = true;
        break;
      }
      default: {
        throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);
      }
    }
    this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);
    return rootNode;
  }
  /**
   * Loads a glTF scene.
   * @param context The context when loading the asset
   * @param scene The glTF scene property
   * @returns A promise that resolves when the load is complete
   */
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  loadSceneAsync(context, scene) {
    const extensionPromise = this._extensionsLoadSceneAsync(context, scene);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    this.logOpen(`${context} ${scene.name || ""}`);
    if (scene.nodes) {
      for (const index of scene.nodes) {
        const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);
        promises.push(this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {
          babylonMesh.parent = this._rootBabylonMesh;
        }));
      }
    }
    for (const action of this._postSceneLoadActions) {
      action();
    }
    promises.push(this._loadAnimationsAsync());
    this.logClose();
    return Promise.all(promises).then(() => {
    });
  }
  _forEachPrimitive(node, callback) {
    if (node._primitiveBabylonMeshes) {
      for (const babylonMesh of node._primitiveBabylonMeshes) {
        callback(babylonMesh);
      }
    }
  }
  _getGeometries() {
    const geometries = [];
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        this._forEachPrimitive(node, (babylonMesh) => {
          const geometry = babylonMesh.geometry;
          if (geometry && geometries.indexOf(geometry) === -1) {
            geometries.push(geometry);
          }
        });
      }
    }
    return geometries;
  }
  _getMeshes() {
    const meshes = [];
    if (this._rootBabylonMesh instanceof AbstractMesh) {
      meshes.push(this._rootBabylonMesh);
    }
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        this._forEachPrimitive(node, (babylonMesh) => {
          meshes.push(babylonMesh);
        });
      }
    }
    return meshes;
  }
  _getTransformNodes() {
    const transformNodes = [];
    const nodes = this._gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === "TransformNode") {
          transformNodes.push(node._babylonTransformNode);
        }
        if (node._babylonTransformNodeForSkin) {
          transformNodes.push(node._babylonTransformNodeForSkin);
        }
      }
    }
    return transformNodes;
  }
  _getSkeletons() {
    const skeletons = [];
    const skins = this._gltf.skins;
    if (skins) {
      for (const skin of skins) {
        if (skin._data) {
          skeletons.push(skin._data.babylonSkeleton);
        }
      }
    }
    return skeletons;
  }
  _getAnimationGroups() {
    const animationGroups = [];
    const animations = this._gltf.animations;
    if (animations) {
      for (const animation of animations) {
        if (animation._babylonAnimationGroup) {
          animationGroups.push(animation._babylonAnimationGroup);
        }
      }
    }
    return animationGroups;
  }
  _startAnimations() {
    switch (this._parent.animationStartMode) {
      case GLTFLoaderAnimationStartMode.NONE: {
        break;
      }
      case GLTFLoaderAnimationStartMode.FIRST: {
        const babylonAnimationGroups = this._getAnimationGroups();
        if (babylonAnimationGroups.length !== 0) {
          babylonAnimationGroups[0].start(true);
        }
        break;
      }
      case GLTFLoaderAnimationStartMode.ALL: {
        const babylonAnimationGroups = this._getAnimationGroups();
        for (const babylonAnimationGroup of babylonAnimationGroups) {
          babylonAnimationGroup.start(true);
        }
        break;
      }
      default: {
        Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);
        return;
      }
    }
  }
  /**
   * Loads a glTF node.
   * @param context The context when loading the asset
   * @param node The glTF node property
   * @param assign A function called synchronously after parsing the glTF properties
   * @returns A promise that resolves with the loaded Babylon mesh when the load is complete
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  loadNodeAsync(context, node, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (node._babylonTransformNode) {
      throw new Error(`${context}: Invalid recursive node hierarchy`);
    }
    const promises = new Array();
    this.logOpen(`${context} ${node.name || ""}`);
    const loadNode = (babylonTransformNode) => {
      _GLTFLoader.AddPointerMetadata(babylonTransformNode, context);
      _GLTFLoader._LoadTransform(node, babylonTransformNode);
      if (node.camera != void 0) {
        const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);
        promises.push(this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {
          babylonCamera.parent = babylonTransformNode;
          if (!this._babylonScene.useRightHandedSystem) {
            babylonTransformNode.scaling.x = -1;
          }
        }));
      }
      if (node.children) {
        for (const index of node.children) {
          const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);
          promises.push(this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {
            childBabylonMesh.parent = babylonTransformNode;
          }));
        }
      }
      assign(babylonTransformNode);
    };
    const hasMesh = node.mesh != void 0;
    const hasSkin = this._parent.loadSkins && node.skin != void 0;
    if (!hasMesh || hasSkin) {
      const nodeName = node.name || `node${node.index}`;
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      const transformNode = new TransformNode(nodeName, this._babylonScene);
      transformNode._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      if (node.mesh == void 0) {
        node._babylonTransformNode = transformNode;
      } else {
        node._babylonTransformNodeForSkin = transformNode;
      }
      loadNode(transformNode);
    }
    if (hasMesh) {
      if (hasSkin) {
        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);
        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {
          const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin;
          babylonTransformNode.metadata = deepMerge(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});
          const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);
          promises.push(this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {
            this._forEachPrimitive(node, (babylonMesh) => {
              babylonMesh.skeleton = babylonSkeleton;
            });
            this._postSceneLoadActions.push(() => {
              if (skin.skeleton != void 0) {
                const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent;
                if (node.index === parentNode.index) {
                  babylonTransformNode.parent = babylonTransformNodeForSkin.parent;
                } else {
                  babylonTransformNode.parent = parentNode._babylonTransformNode;
                }
              } else {
                babylonTransformNode.parent = this._rootBabylonMesh;
              }
              this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });
            });
          }));
        }));
      } else {
        const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);
        promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));
      }
    }
    this.logClose();
    return Promise.all(promises).then(() => {
      this._forEachPrimitive(node, (babylonMesh) => {
        const asMesh = babylonMesh;
        if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {
          babylonMesh._updateBoundingInfo();
        } else {
          babylonMesh.refreshBoundingInfo(true, true);
        }
      });
      return node._babylonTransformNode;
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadMeshAsync(context, node, mesh, assign) {
    const primitives = mesh.primitives;
    if (!primitives || !primitives.length) {
      throw new Error(`${context}: Primitives are missing`);
    }
    if (primitives[0].index == void 0) {
      ArrayItem.Assign(primitives);
    }
    const promises = new Array();
    this.logOpen(`${context} ${mesh.name || ""}`);
    const name2 = node.name || `node${node.index}`;
    if (primitives.length === 1) {
      const primitive = mesh.primitives[0];
      promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name2, node, mesh, primitive, (babylonMesh) => {
        node._babylonTransformNode = babylonMesh;
        node._primitiveBabylonMeshes = [babylonMesh];
      }));
    } else {
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      node._babylonTransformNode = new TransformNode(name2, this._babylonScene);
      node._babylonTransformNode._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      node._primitiveBabylonMeshes = [];
      for (const primitive of primitives) {
        promises.push(this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name2}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {
          babylonMesh.parent = node._babylonTransformNode;
          node._primitiveBabylonMeshes.push(babylonMesh);
        }));
      }
    }
    assign(node._babylonTransformNode);
    this.logClose();
    return Promise.all(promises).then(() => {
      return node._babylonTransformNode;
    });
  }
  /**
   * @internal Define this method to modify the default behavior when loading data for mesh primitives.
   * @param context The context when loading the asset
   * @param name The mesh name when loading the asset
   * @param node The glTF node when loading the asset
   * @param mesh The glTF mesh when loading the asset
   * @param primitive The glTF mesh primitive property
   * @param assign A function called synchronously after parsing the glTF properties
   * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign) {
    const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context}`);
    const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == void 0 && !mesh.primitives[0].targets;
    let babylonAbstractMesh;
    let promise;
    if (shouldInstance && primitive._instanceData) {
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name2);
      babylonAbstractMesh._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      promise = primitive._instanceData.promise;
    } else {
      const promises = new Array();
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      const babylonMesh = new Mesh(name2, this._babylonScene);
      babylonMesh._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      babylonMesh.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      this._createMorphTargets(context, node, mesh, primitive, babylonMesh);
      promises.push(this._loadVertexDataAsync(context, primitive, babylonMesh).then(async (babylonGeometry) => {
        return await this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {
          if (this._disposed) {
            return;
          }
          this._babylonScene._blockEntityCollection = !!this._assetContainer;
          babylonGeometry.applyToMesh(babylonMesh);
          babylonGeometry._parentContainer = this._assetContainer;
          this._babylonScene._blockEntityCollection = false;
        });
      }));
      if (!this.parent.skipMaterials) {
        const babylonDrawMode = _GLTFLoader._GetDrawMode(context, primitive.mode);
        if (primitive.material == void 0) {
          let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];
          if (!babylonMaterial) {
            babylonMaterial = this._createDefaultMaterial("__GLTFLoader._default", babylonDrawMode);
            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
            this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;
          }
          babylonMesh.material = babylonMaterial;
        } else {
          const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);
          promises.push(this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {
            babylonMesh.material = babylonMaterial;
          }));
        }
      }
      promise = Promise.all(promises);
      if (shouldInstance) {
        primitive._instanceData = {
          babylonSourceMesh: babylonMesh,
          promise
        };
      }
      babylonAbstractMesh = babylonMesh;
    }
    _GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);
    this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);
    assign(babylonAbstractMesh);
    this.logClose();
    return promise.then(() => {
      return babylonAbstractMesh;
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadVertexDataAsync(context, primitive, babylonMesh) {
    const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);
    if (extensionPromise) {
      return extensionPromise;
    }
    const attributes = primitive.attributes;
    if (!attributes) {
      throw new Error(`${context}: Attributes are missing`);
    }
    const promises = new Array();
    const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);
    if (primitive.indices == void 0) {
      babylonMesh.isUnIndexed = true;
    } else {
      const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);
      promises.push(this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {
        babylonGeometry.setIndices(data);
      }));
    }
    const loadAttribute = (name2, kind, callback) => {
      if (attributes[name2] == void 0) {
        return;
      }
      babylonMesh._delayInfo = babylonMesh._delayInfo || [];
      if (babylonMesh._delayInfo.indexOf(kind) === -1) {
        babylonMesh._delayInfo.push(kind);
      }
      const accessor = ArrayItem.Get(`${context}/attributes/${name2}`, this._gltf.accessors, attributes[name2]);
      promises.push(this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {
        if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {
          const babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor);
          if (babylonBoundingInfo) {
            babylonGeometry._boundingInfo = babylonBoundingInfo;
            babylonGeometry.useBoundingInfoFromGeometry = true;
          }
        }
        babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);
      }));
      if (kind == VertexBuffer.MatricesIndicesExtraKind) {
        babylonMesh.numBoneInfluencers = 8;
      }
      if (callback) {
        callback(accessor);
      }
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind);
    loadAttribute("NORMAL", VertexBuffer.NormalKind);
    loadAttribute("TANGENT", VertexBuffer.TangentKind);
    loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
    loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
    loadAttribute("TEXCOORD_2", VertexBuffer.UV3Kind);
    loadAttribute("TEXCOORD_3", VertexBuffer.UV4Kind);
    loadAttribute("TEXCOORD_4", VertexBuffer.UV5Kind);
    loadAttribute("TEXCOORD_5", VertexBuffer.UV6Kind);
    loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
    loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
    loadAttribute("JOINTS_1", VertexBuffer.MatricesIndicesExtraKind);
    loadAttribute("WEIGHTS_1", VertexBuffer.MatricesWeightsExtraKind);
    loadAttribute("COLOR_0", VertexBuffer.ColorKind, (accessor) => {
      if (accessor.type === "VEC4") {
        babylonMesh.hasVertexAlpha = true;
      }
    });
    return Promise.all(promises).then(() => {
      return babylonGeometry;
    });
  }
  _createMorphTargets(context, node, mesh, primitive, babylonMesh) {
    if (!primitive.targets || !this._parent.loadMorphTargets) {
      return;
    }
    if (node._numMorphTargets == void 0) {
      node._numMorphTargets = primitive.targets.length;
    } else if (primitive.targets.length !== node._numMorphTargets) {
      throw new Error(`${context}: Primitives do not have the same number of targets`);
    }
    const targetNames = mesh.extras ? mesh.extras.targetNames : null;
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    babylonMesh.morphTargetManager = new MorphTargetManager(this._babylonScene);
    babylonMesh.morphTargetManager._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    babylonMesh.morphTargetManager.areUpdatesFrozen = true;
    for (let index = 0; index < primitive.targets.length; index++) {
      const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;
      const name2 = targetNames ? targetNames[index] : `morphTarget${index}`;
      babylonMesh.morphTargetManager.addTarget(new MorphTarget(name2, weight, babylonMesh.getScene()));
    }
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry) {
    if (!primitive.targets || !this._parent.loadMorphTargets) {
      return Promise.resolve();
    }
    const promises = new Array();
    const morphTargetManager = babylonMesh.morphTargetManager;
    for (let index = 0; index < morphTargetManager.numTargets; index++) {
      const babylonMorphTarget = morphTargetManager.getTarget(index);
      promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));
    }
    return Promise.all(promises).then(() => {
      morphTargetManager.areUpdatesFrozen = false;
    });
  }
  async _loadMorphTargetVertexDataAsync(context, babylonGeometry, attributes, babylonMorphTarget) {
    const promises = new Array();
    const loadAttribute = (attribute, kind, setData) => {
      if (attributes[attribute] == void 0) {
        return;
      }
      const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);
      if (!babylonVertexBuffer) {
        return;
      }
      const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);
      promises.push(this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {
        setData(babylonVertexBuffer, data);
      }));
    };
    loadAttribute("POSITION", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {
      const positions = new Float32Array(data.length);
      babylonVertexBuffer.forEach(data.length, (value, index) => {
        positions[index] = data[index] + value;
      });
      babylonMorphTarget.setPositions(positions);
    });
    loadAttribute("NORMAL", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {
      const normals = new Float32Array(data.length);
      babylonVertexBuffer.forEach(normals.length, (value, index) => {
        normals[index] = data[index] + value;
      });
      babylonMorphTarget.setNormals(normals);
    });
    loadAttribute("TANGENT", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {
      const tangents = new Float32Array(data.length / 3 * 4);
      let dataIndex = 0;
      babylonVertexBuffer.forEach(data.length / 3 * 4, (value, index) => {
        if ((index + 1) % 4 !== 0) {
          tangents[dataIndex] = data[dataIndex] + value;
          dataIndex++;
        }
      });
      babylonMorphTarget.setTangents(tangents);
    });
    loadAttribute("TEXCOORD_0", VertexBuffer.UVKind, (babylonVertexBuffer, data) => {
      const uvs = new Float32Array(data.length);
      babylonVertexBuffer.forEach(data.length, (value, index) => {
        uvs[index] = data[index] + value;
      });
      babylonMorphTarget.setUVs(uvs);
    });
    loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind, (babylonVertexBuffer, data) => {
      const uvs = new Float32Array(data.length);
      babylonVertexBuffer.forEach(data.length, (value, index) => {
        uvs[index] = data[index] + value;
      });
      babylonMorphTarget.setUV2s(uvs);
    });
    loadAttribute("COLOR_0", VertexBuffer.ColorKind, (babylonVertexBuffer, data) => {
      let colors = null;
      const componentSize = babylonVertexBuffer.getSize();
      if (componentSize === 3) {
        colors = new Float32Array(data.length / 3 * 4);
        babylonVertexBuffer.forEach(data.length, (value, index) => {
          const pixid = Math.floor(index / 3);
          const channel = index % 3;
          colors[4 * pixid + channel] = data[3 * pixid + channel] + value;
        });
        for (let i = 0; i < data.length / 3; ++i) {
          colors[4 * i + 3] = 1;
        }
      } else if (componentSize === 4) {
        colors = new Float32Array(data.length);
        babylonVertexBuffer.forEach(data.length, (value, index) => {
          colors[index] = data[index] + value;
        });
      } else {
        throw new Error(`${context}: Invalid number of components (${componentSize}) for COLOR_0 attribute`);
      }
      babylonMorphTarget.setColors(colors);
    });
    return await Promise.all(promises).then(() => {
    });
  }
  static _LoadTransform(node, babylonNode) {
    if (node.skin != void 0) {
      return;
    }
    let position = Vector3.Zero();
    let rotation = Quaternion.Identity();
    let scaling = Vector3.One();
    if (node.matrix) {
      const matrix = Matrix.FromArray(node.matrix);
      matrix.decompose(scaling, rotation, position);
    } else {
      if (node.translation) {
        position = Vector3.FromArray(node.translation);
      }
      if (node.rotation) {
        rotation = Quaternion.FromArray(node.rotation);
      }
      if (node.scale) {
        scaling = Vector3.FromArray(node.scale);
      }
    }
    babylonNode.position = position;
    babylonNode.rotationQuaternion = rotation;
    babylonNode.scaling = scaling;
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadSkinAsync(context, node, skin, assign) {
    if (!this._parent.loadSkins) {
      return Promise.resolve();
    }
    const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (skin._data) {
      assign(skin._data.babylonSkeleton);
      return skin._data.promise;
    }
    const skeletonId = `skeleton${skin.index}`;
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);
    babylonSkeleton._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    this._loadBones(context, skin, babylonSkeleton);
    const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {
      this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);
    });
    skin._data = {
      babylonSkeleton,
      promise
    };
    assign(babylonSkeleton);
    return promise;
  }
  _loadBones(context, skin, babylonSkeleton) {
    if (skin.skeleton == void 0 || this._parent.alwaysComputeSkeletonRootNode) {
      const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);
      if (rootNode) {
        if (skin.skeleton === void 0) {
          skin.skeleton = rootNode.index;
        } else {
          const isParent = (a, b) => {
            for (; b.parent; b = b.parent) {
              if (b.parent === a) {
                return true;
              }
            }
            return false;
          };
          const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);
          if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {
            Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);
            skin.skeleton = rootNode.index;
          }
        }
      } else {
        Logger.Warn(`${context}: Failed to find common root`);
      }
    }
    const babylonBones = {};
    for (const index of skin.joints) {
      const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);
      this._loadBone(node, skin, babylonSkeleton, babylonBones);
    }
  }
  _findSkeletonRootNode(context, joints) {
    if (joints.length === 0) {
      return null;
    }
    const paths = {};
    for (const index of joints) {
      const path = [];
      let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);
      while (node.index !== -1) {
        path.unshift(node);
        node = node.parent;
      }
      paths[index] = path;
    }
    let rootNode = null;
    for (let i = 0; ; ++i) {
      let path = paths[joints[0]];
      if (i >= path.length) {
        return rootNode;
      }
      const node = path[i];
      for (let j = 1; j < joints.length; ++j) {
        path = paths[joints[j]];
        if (i >= path.length || node !== path[i]) {
          return rootNode;
        }
      }
      rootNode = node;
    }
  }
  _loadBone(node, skin, babylonSkeleton, babylonBones) {
    node._isJoint = true;
    let babylonBone = babylonBones[node.index];
    if (babylonBone) {
      return babylonBone;
    }
    let parentBabylonBone = null;
    if (node.index !== skin.skeleton) {
      if (node.parent && node.parent.index !== -1) {
        parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);
      } else if (skin.skeleton !== void 0) {
        Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);
      }
    }
    const boneIndex = skin.joints.indexOf(node.index);
    babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);
    babylonBones[node.index] = babylonBone;
    this._postSceneLoadActions.push(() => {
      babylonBone.linkTransformNode(node._babylonTransformNode);
    });
    return babylonBone;
  }
  _loadSkinInverseBindMatricesDataAsync(context, skin) {
    if (skin.inverseBindMatrices == void 0) {
      return Promise.resolve(null);
    }
    const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);
    return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);
  }
  _updateBoneMatrices(babylonSkeleton, inverseBindMatricesData) {
    for (const babylonBone of babylonSkeleton.bones) {
      const baseMatrix = Matrix.Identity();
      const boneIndex = babylonBone._index;
      if (inverseBindMatricesData && boneIndex !== -1) {
        Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);
        baseMatrix.invertToRef(baseMatrix);
      }
      const babylonParentBone = babylonBone.getParent();
      if (babylonParentBone) {
        baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);
      }
      babylonBone.updateMatrix(baseMatrix, false, false);
      babylonBone._updateAbsoluteBindMatrices(void 0, false);
    }
  }
  _getNodeMatrix(node) {
    return node.matrix ? Matrix.FromArray(node.matrix) : Matrix.Compose(node.scale ? Vector3.FromArray(node.scale) : Vector3.One(), node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(), node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero());
  }
  /**
   * Loads a glTF camera.
   * @param context The context when loading the asset
   * @param camera The glTF camera property
   * @param assign A function called synchronously after parsing the glTF properties
   * @returns A promise that resolves with the loaded Babylon camera when the load is complete
   */
  loadCameraAsync(context, camera, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    this.logOpen(`${context} ${camera.name || ""}`);
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);
    babylonCamera._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    camera._babylonCamera = babylonCamera;
    babylonCamera.setTarget(new Vector3(0, 0, -1));
    switch (camera.type) {
      case "perspective": {
        const perspective = camera.perspective;
        if (!perspective) {
          throw new Error(`${context}: Camera perspective properties are missing`);
        }
        babylonCamera.fov = perspective.yfov;
        babylonCamera.minZ = perspective.znear;
        babylonCamera.maxZ = perspective.zfar || 0;
        break;
      }
      case "orthographic": {
        if (!camera.orthographic) {
          throw new Error(`${context}: Camera orthographic properties are missing`);
        }
        babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;
        babylonCamera.orthoLeft = -camera.orthographic.xmag;
        babylonCamera.orthoRight = camera.orthographic.xmag;
        babylonCamera.orthoBottom = -camera.orthographic.ymag;
        babylonCamera.orthoTop = camera.orthographic.ymag;
        babylonCamera.minZ = camera.orthographic.znear;
        babylonCamera.maxZ = camera.orthographic.zfar;
        break;
      }
      default: {
        throw new Error(`${context}: Invalid camera type (${camera.type})`);
      }
    }
    _GLTFLoader.AddPointerMetadata(babylonCamera, context);
    this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);
    assign(babylonCamera);
    this.logClose();
    return Promise.all(promises).then(() => {
      return babylonCamera;
    });
  }
  _loadAnimationsAsync() {
    this._parent._startPerformanceCounter("Load animations");
    const animations = this._gltf.animations;
    if (!animations) {
      return Promise.resolve();
    }
    const promises = new Array();
    for (let index = 0; index < animations.length; index++) {
      const animation = animations[index];
      promises.push(this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {
        if (animationGroup.targetedAnimations.length === 0) {
          animationGroup.dispose();
        }
      }));
    }
    return Promise.all(promises).then(() => {
      this._parent._endPerformanceCounter("Load animations");
    });
  }
  /**
   * Loads a glTF animation.
   * @param context The context when loading the asset
   * @param animation The glTF animation property
   * @returns A promise that resolves with the loaded Babylon animation group when the load is complete
   */
  loadAnimationAsync(context, animation) {
    this._parent._startPerformanceCounter("Load animation");
    const promise = this._extensionsLoadAnimationAsync(context, animation);
    if (promise) {
      return promise;
    }
    return LazyAnimationGroupModulePromise.value.then(({ AnimationGroup }) => {
      this._babylonScene._blockEntityCollection = !!this._assetContainer;
      const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);
      babylonAnimationGroup._parentContainer = this._assetContainer;
      this._babylonScene._blockEntityCollection = false;
      animation._babylonAnimationGroup = babylonAnimationGroup;
      const promises = new Array();
      ArrayItem.Assign(animation.channels);
      ArrayItem.Assign(animation.samplers);
      for (const channel of animation.channels) {
        promises.push(this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {
          babylonTarget.animations = babylonTarget.animations || [];
          babylonTarget.animations.push(babylonAnimation);
          babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);
        }));
      }
      this._parent._endPerformanceCounter("Load animation");
      return Promise.all(promises).then(() => {
        babylonAnimationGroup.normalize(0);
        return babylonAnimationGroup;
      });
    });
  }
  /**
   * @hidden
   * Loads a glTF animation channel.
   * @param context The context when loading the asset
   * @param animationContext The context of the animation when loading the asset
   * @param animation The glTF animation property
   * @param channel The glTF animation channel property
   * @param onLoad Called for each animation loaded
   * @returns A void promise that resolves when the load is complete
   */
  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);
    if (promise) {
      return promise;
    }
    if (channel.target.node == void 0) {
      return Promise.resolve();
    }
    const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);
    const channelTargetPath = channel.target.path;
    const pathIsWeights = channelTargetPath === "weights";
    if (pathIsWeights && !targetNode._numMorphTargets || !pathIsWeights && !targetNode._babylonTransformNode) {
      return Promise.resolve();
    }
    if (!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint) {
      return Promise.resolve();
    }
    return LazyLoaderAnimationModulePromise.value.then(() => {
      let properties;
      switch (channelTargetPath) {
        case "translation": {
          properties = GetMappingForKey("/nodes/{}/translation")?.interpolation;
          break;
        }
        case "rotation": {
          properties = GetMappingForKey("/nodes/{}/rotation")?.interpolation;
          break;
        }
        case "scale": {
          properties = GetMappingForKey("/nodes/{}/scale")?.interpolation;
          break;
        }
        case "weights": {
          properties = GetMappingForKey("/nodes/{}/weights")?.interpolation;
          break;
        }
        default: {
          throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);
        }
      }
      if (!properties) {
        throw new Error(`${context}/target/path: Could not find interpolation properties for target path (${channel.target.path})`);
      }
      const targetInfo = {
        object: targetNode,
        info: properties
      };
      return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);
    });
  }
  /**
   * @hidden
   * Loads a glTF animation channel.
   * @param context The context when loading the asset
   * @param animationContext The context of the animation when loading the asset
   * @param animation The glTF animation property
   * @param channel The glTF animation channel property
   * @param targetInfo The glTF target and properties
   * @param onLoad Called for each animation loaded
   * @returns A void promise that resolves when the load is complete
   */
  _loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad) {
    const fps = this.parent.targetFps;
    const invfps = 1 / fps;
    const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);
    return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {
      let numAnimations = 0;
      const target = targetInfo.object;
      const propertyInfos = targetInfo.info;
      for (const propertyInfo of propertyInfos) {
        const stride = propertyInfo.getStride(target);
        const input = data.input;
        const output = data.output;
        const keys = new Array(input.length);
        let outputOffset = 0;
        switch (data.interpolation) {
          case "STEP": {
            for (let index = 0; index < input.length; index++) {
              const value = propertyInfo.getValue(target, output, outputOffset, 1);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                value,
                interpolation: 1
              };
            }
            break;
          }
          case "CUBICSPLINE": {
            for (let index = 0; index < input.length; index++) {
              const inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
              outputOffset += stride;
              const value = propertyInfo.getValue(target, output, outputOffset, 1);
              outputOffset += stride;
              const outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                inTangent,
                value,
                outTangent
              };
            }
            break;
          }
          case "LINEAR": {
            for (let index = 0; index < input.length; index++) {
              const value = propertyInfo.getValue(target, output, outputOffset, 1);
              outputOffset += stride;
              keys[index] = {
                frame: input[index] * fps,
                value
              };
            }
            break;
          }
        }
        if (outputOffset > 0) {
          const name2 = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;
          const babylonAnimations = propertyInfo.buildAnimations(target, name2, fps, keys);
          for (const babylonAnimation of babylonAnimations) {
            numAnimations++;
            onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);
          }
        }
      }
    });
  }
  _loadAnimationSamplerAsync(context, sampler) {
    if (sampler._data) {
      return sampler._data;
    }
    const interpolation = sampler.interpolation || "LINEAR";
    switch (interpolation) {
      case "STEP":
      case "LINEAR":
      case "CUBICSPLINE": {
        break;
      }
      default: {
        throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);
      }
    }
    const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);
    const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);
    sampler._data = Promise.all([
      this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),
      this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor)
    ]).then(([inputData, outputData]) => {
      return {
        input: inputData,
        interpolation,
        output: outputData
      };
    });
    return sampler._data;
  }
  /**
   * Loads a glTF buffer.
   * @param context The context when loading the asset
   * @param buffer The glTF buffer property
   * @param byteOffset The byte offset to use
   * @param byteLength The byte length to use
   * @returns A promise that resolves with the loaded data when the load is complete
   */
  loadBufferAsync(context, buffer, byteOffset, byteLength) {
    const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!buffer._data) {
      if (buffer.uri) {
        buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);
      } else {
        if (!this._bin) {
          throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);
        }
        buffer._data = this._bin.readAsync(0, buffer.byteLength);
      }
    }
    return buffer._data.then((data) => {
      try {
        return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      } catch (e) {
        throw new Error(`${context}: ${e.message}`);
      }
    });
  }
  /**
   * Loads a glTF buffer view.
   * @param context The context when loading the asset
   * @param bufferView The glTF buffer view property
   * @returns A promise that resolves with the loaded data when the load is complete
   */
  loadBufferViewAsync(context, bufferView) {
    const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (bufferView._data) {
      return bufferView._data;
    }
    const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);
    bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);
    return bufferView._data;
  }
  _loadAccessorAsync(context, accessor, constructor) {
    if (accessor._data) {
      return accessor._data;
    }
    const numComponents = _GLTFLoader._GetNumComponents(context, accessor.type);
    const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);
    const length = numComponents * accessor.count;
    if (accessor.bufferView == void 0) {
      accessor._data = Promise.resolve(new constructor(length));
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
        if (accessor.componentType === 5126 && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {
          return _GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);
        } else {
          const typedArray = new constructor(length);
          VertexBuffer.ForEach(data, accessor.byteOffset || 0, bufferView.byteStride || byteStride, numComponents, accessor.componentType, typedArray.length, accessor.normalized || false, (value, index) => {
            typedArray[index] = value;
          });
          return typedArray;
        }
      });
    }
    if (accessor.sparse) {
      const sparse = accessor.sparse;
      accessor._data = accessor._data.then((data) => {
        const typedArray = data;
        const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);
        const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);
        return Promise.all([
          this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),
          this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView)
        ]).then(([indicesData, valuesData]) => {
          const indices = _GLTFLoader._GetTypedArray(`${context}/sparse/indices`, sparse.indices.componentType, indicesData, sparse.indices.byteOffset, sparse.count);
          const sparseLength = numComponents * sparse.count;
          let values;
          if (accessor.componentType === 5126 && !accessor.normalized) {
            values = _GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);
          } else {
            const sparseData = _GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);
            values = new constructor(sparseLength);
            VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {
              values[index] = value;
            });
          }
          let valuesIndex = 0;
          for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {
            let dataIndex = indices[indicesIndex] * numComponents;
            for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {
              typedArray[dataIndex++] = values[valuesIndex++];
            }
          }
          return typedArray;
        });
      });
    }
    return accessor._data;
  }
  /**
   * @internal
   */
  _loadFloatAccessorAsync(context, accessor) {
    return this._loadAccessorAsync(context, accessor, Float32Array);
  }
  /**
   * @internal
   */
  _loadIndicesAccessorAsync(context, accessor) {
    if (accessor.type !== "SCALAR") {
      throw new Error(`${context}/type: Invalid value ${accessor.type}`);
    }
    if (accessor.componentType !== 5121 && accessor.componentType !== 5123 && accessor.componentType !== 5125) {
      throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);
    }
    if (accessor._data) {
      return accessor._data;
    }
    if (accessor.sparse) {
      const constructor = _GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);
      accessor._data = this._loadAccessorAsync(context, accessor, constructor);
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
        return _GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);
      });
    }
    return accessor._data;
  }
  /**
   * @internal
   */
  _loadVertexBufferViewAsync(bufferView) {
    if (bufferView._babylonBuffer) {
      return bufferView._babylonBuffer;
    }
    const engine = this._babylonScene.getEngine();
    bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {
      return new Buffer(engine, data, false);
    });
    return bufferView._babylonBuffer;
  }
  /**
   * @internal
   */
  _loadVertexAccessorAsync(context, accessor, kind) {
    if (accessor._babylonVertexBuffer?.[kind]) {
      return accessor._babylonVertexBuffer[kind];
    }
    if (!accessor._babylonVertexBuffer) {
      accessor._babylonVertexBuffer = {};
    }
    const engine = this._babylonScene.getEngine();
    if (accessor.sparse || accessor.bufferView == void 0) {
      accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {
        return new VertexBuffer(engine, data, kind, false);
      });
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);
      accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {
        const numComponents = _GLTFLoader._GetNumComponents(context, accessor.type);
        return new VertexBuffer(engine, babylonBuffer, kind, false, void 0, bufferView.byteStride, void 0, accessor.byteOffset, numComponents, accessor.componentType, accessor.normalized, true, void 0, true);
      });
    }
    return accessor._babylonVertexBuffer[kind];
  }
  _loadMaterialMetallicRoughnessPropertiesAsync(context, properties, babylonMaterial) {
    const promises = new Array();
    const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);
    if (properties) {
      if (properties.baseColorFactor) {
        adapter.baseColor = Color3.FromArray(properties.baseColorFactor);
        adapter.geometryOpacity = properties.baseColorFactor[3];
      } else {
        adapter.baseColor = Color3.White();
      }
      adapter.baseMetalness = properties.metallicFactor == void 0 ? 1 : properties.metallicFactor;
      adapter.specularRoughness = properties.roughnessFactor == void 0 ? 1 : properties.roughnessFactor;
      if (properties.baseColorTexture) {
        promises.push(this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Base Color)`;
          adapter.baseColorTexture = texture;
        }));
      }
      if (properties.metallicRoughnessTexture) {
        properties.metallicRoughnessTexture.nonColorData = true;
        promises.push(this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Metallic Roughness)`;
          adapter.baseMetalnessTexture = texture;
          adapter.specularRoughnessTexture = texture;
        }));
        adapter.useRoughnessFromMetallicTextureGreen = true;
        adapter.useMetallicFromMetallicTextureBlue = true;
      }
    }
    return Promise.all(promises).then(() => {
    });
  }
  /**
   * @internal
   */
  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    material._data = material._data || {};
    let babylonData = material._data[babylonDrawMode];
    if (!babylonData) {
      this.logOpen(`${context} ${material.name || ""}`);
      const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);
      babylonData = {
        babylonMaterial,
        babylonMeshes: [],
        promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial)
      };
      material._data[babylonDrawMode] = babylonData;
      _GLTFLoader.AddPointerMetadata(babylonMaterial, context);
      this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);
      this.logClose();
    }
    if (babylonMesh) {
      babylonData.babylonMeshes.push(babylonMesh);
      babylonMesh.onDisposeObservable.addOnce(() => {
        const index = babylonData.babylonMeshes.indexOf(babylonMesh);
        if (index !== -1) {
          babylonData.babylonMeshes.splice(index, 1);
        }
      });
    }
    assign(babylonData.babylonMaterial);
    return babylonData.promise.then(() => {
      return babylonData.babylonMaterial;
    });
  }
  _createDefaultMaterial(name2, babylonDrawMode) {
    if (!this._pbrMaterialImpl) {
      throw new Error("PBR Material class not loaded");
    }
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const babylonMaterial = new this._pbrMaterialImpl.materialClass(name2, this._babylonScene);
    babylonMaterial._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    babylonMaterial.fillMode = babylonDrawMode;
    babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;
    const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);
    adapter.transparencyAsAlphaCoverage = this._parent.transparencyAsCoverage;
    adapter.baseMetalness = 1;
    adapter.specularRoughness = 1;
    return babylonMaterial;
  }
  /**
   * Creates a Babylon material from a glTF material.
   * @param context The context when loading the asset
   * @param material The glTF material property
   * @param babylonDrawMode The draw mode for the Babylon material
   * @returns The Babylon material
   */
  createMaterial(context, material, babylonDrawMode) {
    const extensionMaterial = this._extensionsCreateMaterial(context, material, babylonDrawMode);
    if (extensionMaterial) {
      return extensionMaterial;
    }
    const name2 = material.name || `material${material.index}`;
    const babylonMaterial = this._createDefaultMaterial(name2, babylonDrawMode);
    return babylonMaterial;
  }
  /**
   * Loads properties from a glTF material into a Babylon material.
   * @param context The context when loading the asset
   * @param material The glTF material property
   * @param babylonMaterial The Babylon material
   * @returns A promise that resolves when the load is complete
   */
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);
    if (extensionPromise) {
      return extensionPromise;
    }
    const promises = new Array();
    promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
    if (material.pbrMetallicRoughness) {
      promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));
    }
    this.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(() => {
    });
  }
  /**
   * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.
   * @param context The context when loading the asset
   * @param material The glTF material property
   * @param babylonMaterial The Babylon material
   * @returns A promise that resolves when the load is complete
   */
  loadMaterialBasePropertiesAsync(context, material, babylonMaterial) {
    const promises = new Array();
    const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);
    adapter.emissionColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);
    if (material.doubleSided) {
      adapter.backFaceCulling = false;
      adapter.twoSidedLighting = true;
    }
    if (material.normalTexture) {
      material.normalTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Normal)`;
        adapter.geometryNormalTexture = texture;
        if (material.normalTexture?.scale != void 0) {
          texture.level = material.normalTexture.scale;
        }
      }));
      adapter.setNormalMapInversions(!this._babylonScene.useRightHandedSystem, this._babylonScene.useRightHandedSystem);
    }
    let aoTexture;
    let aoStrength = 1;
    let emissionTexture;
    if (material.occlusionTexture) {
      material.occlusionTexture.nonColorData = true;
      promises.push(this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Occlusion)`;
        aoTexture = texture;
      }));
      if (material.occlusionTexture.strength != void 0) {
        aoStrength = material.occlusionTexture.strength;
      }
    }
    if (material.emissiveTexture) {
      promises.push(this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Emissive)`;
        emissionTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
      if (aoTexture) {
        adapter.ambientOcclusionTexture = aoTexture;
        adapter.ambientOcclusionTextureStrength = aoStrength;
      }
      if (emissionTexture) {
        adapter.emissionColorTexture = emissionTexture;
      }
    });
  }
  /**
   * Loads the alpha properties from a glTF material into a Babylon material.
   * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.
   * @param context The context when loading the asset
   * @param material The glTF material property
   * @param babylonMaterial The Babylon material
   */
  loadMaterialAlphaProperties(context, material, babylonMaterial) {
    if (!this._pbrMaterialImpl) {
      throw new Error(`${context}: Material type not supported`);
    }
    const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);
    const baseColorTexture = adapter.baseColorTexture;
    const alphaMode = material.alphaMode || "OPAQUE";
    switch (alphaMode) {
      case "OPAQUE": {
        babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;
        babylonMaterial.alpha = 1;
        break;
      }
      case "MASK": {
        babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHATEST;
        adapter.alphaCutOff = material.alphaCutoff == void 0 ? 0.5 : material.alphaCutoff;
        if (baseColorTexture) {
          baseColorTexture.hasAlpha = true;
        }
        break;
      }
      case "BLEND": {
        babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHABLEND;
        if (baseColorTexture) {
          baseColorTexture.hasAlpha = true;
          adapter.useAlphaFromBaseColorTexture = true;
        }
        break;
      }
      default: {
        throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);
      }
    }
  }
  /**
   * Loads a glTF texture info.
   * @param context The context when loading the asset
   * @param textureInfo The glTF texture info property
   * @param assign A function called synchronously after parsing the glTF properties
   * @returns A promise that resolves with the loaded Babylon texture when the load is complete
   */
  loadTextureInfoAsync(context, textureInfo, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context}`);
    if (textureInfo.texCoord >= 6) {
      throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);
    }
    const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);
    texture._textureInfo = textureInfo;
    const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {
      babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;
      _GLTFLoader.AddPointerMetadata(babylonTexture, context);
      this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);
      assign(babylonTexture);
    });
    this.logClose();
    return promise;
  }
  /**
   * @internal
   */
  _loadTextureAsync(context, texture, assign = () => {
  }) {
    const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);
    if (extensionPromise) {
      return extensionPromise;
    }
    this.logOpen(`${context} ${texture.name || ""}`);
    const sampler = texture.sampler == void 0 ? _GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);
    const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);
    const promise = this._createTextureAsync(context, sampler, image, assign, void 0, !texture._textureInfo.nonColorData);
    this.logClose();
    return promise;
  }
  /**
   * @internal
   */
  _createTextureAsync(context, sampler, image, assign = () => {
  }, textureLoaderOptions, useSRGBBuffer) {
    const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);
    const promises = new Array();
    const deferred = new Deferred();
    this._babylonScene._blockEntityCollection = !!this._assetContainer;
    const textureCreationOptions = {
      noMipmap: samplerData.noMipMaps,
      invertY: false,
      samplingMode: samplerData.samplingMode,
      onLoad: () => {
        if (!this._disposed) {
          deferred.resolve();
        }
      },
      onError: (message, exception) => {
        if (!this._disposed) {
          deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || "Failed to load texture"}`));
        }
      },
      mimeType: image.mimeType ?? GetMimeType(image.uri ?? ""),
      loaderOptions: textureLoaderOptions,
      useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers
    };
    const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);
    babylonTexture._parentContainer = this._assetContainer;
    this._babylonScene._blockEntityCollection = false;
    promises.push(deferred.promise);
    promises.push(this.loadImageAsync(`/images/${image.index}`, image).then((data) => {
      const name2 = image.uri || `${this._fileName}#image${image.index}`;
      const dataUrl = `data:${this._uniqueRootUrl}${name2}`;
      babylonTexture.updateURL(dataUrl, data);
      const internalTexture = babylonTexture.getInternalTexture();
      if (internalTexture) {
        internalTexture.label = image.name;
      }
    }));
    babylonTexture.wrapU = samplerData.wrapU;
    babylonTexture.wrapV = samplerData.wrapV;
    assign(babylonTexture);
    if (this._parent.useGltfTextureNames) {
      babylonTexture.name = image.name || image.uri || `image${image.index}`;
    }
    return Promise.all(promises).then(() => {
      return babylonTexture;
    });
  }
  _loadSampler(context, sampler) {
    if (!sampler._data) {
      sampler._data = {
        noMipMaps: sampler.minFilter === 9728 || sampler.minFilter === 9729,
        samplingMode: _GLTFLoader._GetTextureSamplingMode(context, sampler),
        wrapU: _GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),
        wrapV: _GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT)
      };
    }
    return sampler._data;
  }
  /**
   * Loads a glTF image.
   * @param context The context when loading the asset
   * @param image The glTF image property
   * @returns A promise that resolves with the loaded data when the load is complete
   */
  loadImageAsync(context, image) {
    if (!image._data) {
      this.logOpen(`${context} ${image.name || ""}`);
      if (image.uri) {
        image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);
      } else {
        const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);
        image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);
      }
      this.logClose();
    }
    return image._data;
  }
  /**
   * Loads a glTF uri.
   * @param context The context when loading the asset
   * @param property The glTF property associated with the uri
   * @param uri The base64 or relative uri
   * @returns A promise that resolves with the loaded data when the load is complete
   */
  loadUriAsync(context, property, uri) {
    const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);
    if (extensionPromise) {
      return extensionPromise;
    }
    if (!_GLTFLoader._ValidateUri(uri)) {
      throw new Error(`${context}: '${uri}' is invalid`);
    }
    if (IsBase64DataUrl(uri)) {
      const data = new Uint8Array(DecodeBase64UrlToBinary(uri));
      this.log(`${context}: Decoded ${uri.substring(0, 64)}... (${data.length} bytes)`);
      return Promise.resolve(data);
    }
    this.log(`${context}: Loading ${uri}`);
    return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {
      return new Promise((resolve, reject) => {
        this._parent._loadFile(this._babylonScene, url, (data) => {
          if (!this._disposed) {
            this.log(`${context}: Loaded ${uri} (${data.byteLength} bytes)`);
            resolve(new Uint8Array(data));
          }
        }, true, (request) => {
          reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? ": " + request.status + " " + request.statusText : ""}`, request));
        });
      });
    });
  }
  /**
   * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.
   * @param babylonObject the Babylon object with _internalMetadata
   * @param pointer the JSON pointer
   */
  static AddPointerMetadata(babylonObject, pointer) {
    babylonObject.metadata = babylonObject.metadata || {};
    const metadata = babylonObject._internalMetadata = babylonObject._internalMetadata || {};
    const gltf = metadata.gltf = metadata.gltf || {};
    const pointers = gltf.pointers = gltf.pointers || [];
    pointers.push(pointer);
  }
  static _GetTextureWrapMode(context, mode) {
    mode = mode == void 0 ? 10497 : mode;
    switch (mode) {
      case 33071:
        return Texture.CLAMP_ADDRESSMODE;
      case 33648:
        return Texture.MIRROR_ADDRESSMODE;
      case 10497:
        return Texture.WRAP_ADDRESSMODE;
      default:
        Logger.Warn(`${context}: Invalid value (${mode})`);
        return Texture.WRAP_ADDRESSMODE;
    }
  }
  static _GetTextureSamplingMode(context, sampler) {
    const magFilter = sampler.magFilter == void 0 ? 9729 : sampler.magFilter;
    const minFilter = sampler.minFilter == void 0 ? 9987 : sampler.minFilter;
    if (magFilter === 9729) {
      switch (minFilter) {
        case 9728:
          return Texture.LINEAR_NEAREST;
        case 9729:
          return Texture.LINEAR_LINEAR;
        case 9984:
          return Texture.LINEAR_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.LINEAR_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.LINEAR_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.LINEAR_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);
          return Texture.LINEAR_LINEAR_MIPLINEAR;
      }
    } else {
      if (magFilter !== 9728) {
        Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);
      }
      switch (minFilter) {
        case 9728:
          return Texture.NEAREST_NEAREST;
        case 9729:
          return Texture.NEAREST_LINEAR;
        case 9984:
          return Texture.NEAREST_NEAREST_MIPNEAREST;
        case 9985:
          return Texture.NEAREST_LINEAR_MIPNEAREST;
        case 9986:
          return Texture.NEAREST_NEAREST_MIPLINEAR;
        case 9987:
          return Texture.NEAREST_LINEAR_MIPLINEAR;
        default:
          Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);
          return Texture.NEAREST_NEAREST_MIPNEAREST;
      }
    }
  }
  static _GetTypedArrayConstructor(context, componentType) {
    try {
      return GetTypedArrayConstructor(componentType);
    } catch (e) {
      throw new Error(`${context}: ${e.message}`);
    }
  }
  static _GetTypedArray(context, componentType, bufferView, byteOffset, length) {
    const buffer = bufferView.buffer;
    byteOffset = bufferView.byteOffset + (byteOffset || 0);
    const constructor = _GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);
    const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);
    if (byteOffset % componentTypeLength !== 0) {
      Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);
      return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);
    }
    return new constructor(buffer, byteOffset, length);
  }
  static _GetNumComponents(context, type) {
    switch (type) {
      case "SCALAR":
        return 1;
      case "VEC2":
        return 2;
      case "VEC3":
        return 3;
      case "VEC4":
        return 4;
      case "MAT2":
        return 4;
      case "MAT3":
        return 9;
      case "MAT4":
        return 16;
    }
    throw new Error(`${context}: Invalid type (${type})`);
  }
  static _ValidateUri(uri) {
    return Tools.IsBase64(uri) || uri.indexOf("..") === -1;
  }
  /**
   * @internal
   */
  static _GetDrawMode(context, mode) {
    if (mode == void 0) {
      mode = 4;
    }
    switch (mode) {
      case 0:
        return Material.PointListDrawMode;
      case 1:
        return Material.LineListDrawMode;
      case 2:
        return Material.LineLoopDrawMode;
      case 3:
        return Material.LineStripDrawMode;
      case 4:
        return Material.TriangleFillMode;
      case 5:
        return Material.TriangleStripDrawMode;
      case 6:
        return Material.TriangleFanDrawMode;
    }
    throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);
  }
  _compileMaterialsAsync() {
    this._parent._startPerformanceCounter("Compile materials");
    const promises = new Array();
    if (this._gltf.materials) {
      for (const material of this._gltf.materials) {
        if (material._data) {
          for (const babylonDrawMode in material._data) {
            const babylonData = material._data[babylonDrawMode];
            for (const babylonMesh of babylonData.babylonMeshes) {
              babylonMesh.computeWorldMatrix(true);
              const babylonMaterial = babylonData.babylonMaterial;
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));
              promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));
              if (this._parent.useClipPlane) {
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));
                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));
              }
            }
          }
        }
      }
    }
    return Promise.all(promises).then(() => {
      this._parent._endPerformanceCounter("Compile materials");
    });
  }
  _compileShadowGeneratorsAsync() {
    this._parent._startPerformanceCounter("Compile shadow generators");
    const promises = new Array();
    const lights = this._babylonScene.lights;
    for (const light of lights) {
      const generator = light.getShadowGenerator();
      if (generator) {
        promises.push(generator.forceCompilationAsync());
      }
    }
    return Promise.all(promises).then(() => {
      this._parent._endPerformanceCounter("Compile shadow generators");
    });
  }
  _forEachExtensions(action) {
    for (const extension of this._extensions) {
      if (extension.enabled) {
        action(extension);
      }
    }
  }
  _applyExtensions(property, functionName, actionAsync) {
    for (const extension of this._extensions) {
      if (extension.enabled) {
        const id = `${extension.name}.${functionName}`;
        const loaderProperty = property;
        loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};
        const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;
        if (!activeLoaderExtensionFunctions[id]) {
          activeLoaderExtensionFunctions[id] = true;
          try {
            const result = actionAsync(extension);
            if (result) {
              return result;
            }
          } finally {
            delete activeLoaderExtensionFunctions[id];
          }
        }
      }
    }
    return null;
  }
  _extensionsOnLoading() {
    this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());
  }
  _extensionsOnReady() {
    this._forEachExtensions((extension) => extension.onReady && extension.onReady());
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadSceneAsync(context, scene) {
    return this._applyExtensions(scene, "loadScene", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadNodeAsync(context, node, assign) {
    return this._applyExtensions(node, "loadNode", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadCameraAsync(context, camera, assign) {
    return this._applyExtensions(camera, "loadCamera", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadVertexDataAsync(context, primitive, babylonMesh) {
    return this._applyExtensions(primitive, "loadVertexData", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign) {
    return this._applyExtensions(primitive, "loadMeshPrimitive", (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {
    return this._applyExtensions(material, "loadMaterial", (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign));
  }
  _extensionsCreateMaterial(context, material, babylonDrawMode) {
    return this._applyExtensions(material, "createMaterial", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return this._applyExtensions(material, "loadMaterialProperties", (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadTextureInfoAsync(context, textureInfo, assign) {
    return this._applyExtensions(textureInfo, "loadTextureInfo", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadTextureAsync(context, texture, assign) {
    return this._applyExtensions(texture, "loadTexture", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadAnimationAsync(context, animation) {
    return this._applyExtensions(animation, "loadAnimation", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    return this._applyExtensions(animation, "loadAnimationChannel", (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadSkinAsync(context, node, skin) {
    return this._applyExtensions(skin, "loadSkin", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadUriAsync(context, property, uri) {
    return this._applyExtensions(property, "loadUri", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadBufferViewAsync(context, bufferView) {
    return this._applyExtensions(bufferView, "loadBufferView", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));
  }
  // eslint-disable-next-line no-restricted-syntax
  _extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength) {
    return this._applyExtensions(buffer, "loadBuffer", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));
  }
  /**
   * Helper method called by a loader extension to load an glTF extension.
   * @param context The context when loading the asset
   * @param property The glTF property to load the extension from
   * @param extensionName The name of the extension to load
   * @param actionAsync The action to run
   * @returns The promise returned by actionAsync or null if the extension does not exist
   */
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention
  static LoadExtensionAsync(context, property, extensionName, actionAsync) {
    if (!property.extensions) {
      return null;
    }
    const extensions = property.extensions;
    const extension = extensions[extensionName];
    if (!extension) {
      return null;
    }
    return actionAsync(`${context}/extensions/${extensionName}`, extension);
  }
  /**
   * Helper method called by a loader extension to load a glTF extra.
   * @param context The context when loading the asset
   * @param property The glTF property to load the extra from
   * @param extensionName The name of the extension to load
   * @param actionAsync The action to run
   * @returns The promise returned by actionAsync or null if the extra does not exist
   */
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention
  static LoadExtraAsync(context, property, extensionName, actionAsync) {
    if (!property.extras) {
      return null;
    }
    const extras = property.extras;
    const extra = extras[extensionName];
    if (!extra) {
      return null;
    }
    return actionAsync(`${context}/extras/${extensionName}`, extra);
  }
  /**
   * Checks for presence of an extension.
   * @param name The name of the extension to check
   * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`
   */
  isExtensionUsed(name2) {
    return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name2) !== -1;
  }
  /**
   * Increments the indentation level and logs a message.
   * @param message The message to log
   */
  logOpen(message) {
    this._parent._logOpen(message);
  }
  /**
   * Decrements the indentation level.
   */
  logClose() {
    this._parent._logClose();
  }
  /**
   * Logs a message
   * @param message The message to log
   */
  log(message) {
    this._parent._log(message);
  }
  /**
   * Starts a performance counter.
   * @param counterName The name of the performance counter
   */
  startPerformanceCounter(counterName) {
    this._parent._startPerformanceCounter(counterName);
  }
  /**
   * Ends a performance counter.
   * @param counterName The name of the performance counter
   */
  endPerformanceCounter(counterName) {
    this._parent._endPerformanceCounter(counterName);
  }
};
GLTFLoader2.DefaultSampler = { index: -1 };
GLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader2(parent);

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_area.js
var NAME = "EXT_lights_area";
var EXT_lights_area = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
      ArrayItem.Assign(this._lights);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      this._loader._allMaterialsDirtyRequired = true;
      return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {
        let babylonLight;
        const light = ArrayItem.Get(extensionContext, this._lights, extension.light);
        const name2 = light.name || babylonMesh.name;
        this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;
        switch (light.shape) {
          case "rect": {
            const width = light.width !== void 0 ? light.width : 1;
            const height = light.height !== void 0 ? light.height : 1;
            const babylonRectAreaLight = new RectAreaLight(name2, Vector3.Zero(), width, height, this._loader.babylonScene);
            babylonLight = babylonRectAreaLight;
            break;
          }
          case "disk": {
            const radius = light.radius !== void 0 ? light.radius : 0.5;
            const size = radius * 2;
            const babylonRectAreaLight = new RectAreaLight(name2, Vector3.Zero(), size, size, this._loader.babylonScene);
            babylonLight = babylonRectAreaLight;
            break;
          }
          default: {
            this._loader.babylonScene._blockEntityCollection = false;
            throw new Error(`${extensionContext}: Invalid area light shape (${light.shape})`);
          }
        }
        babylonLight._parentContainer = this._loader._assetContainer;
        this._loader.babylonScene._blockEntityCollection = false;
        light._babylonLight = babylonLight;
        babylonLight.falloffType = Light.FALLOFF_GLTF;
        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();
        babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
        const lightParentNode = new TransformNode(`${name2}_orientation`, this._loader.babylonScene);
        lightParentNode.rotationQuaternion = Quaternion.RotationAxis(Vector3.Up(), Math.PI);
        lightParentNode.parent = babylonMesh;
        babylonLight.parent = lightParentNode;
        this._loader._babylonLights.push(babylonLight);
        GLTFLoader2.AddPointerMetadata(babylonLight, extensionContext);
        assign(babylonMesh);
      });
    });
  }
};
unregisterGLTFExtension(NAME);
registerGLTFExtension(NAME, true, (loader) => new EXT_lights_area(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_image_based.js
var NAME2 = "EXT_lights_image_based";
var EXT_lights_image_based = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME2;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME2);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadSceneAsync(context, scene) {
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {
      this._loader._allMaterialsDirtyRequired = true;
      const promises = new Array();
      promises.push(this._loader.loadSceneAsync(context, scene));
      this._loader.logOpen(`${extensionContext}`);
      const light = ArrayItem.Get(`${extensionContext}/light`, this._lights, extension.light);
      promises.push(
        // eslint-disable-next-line github/no-then
        this._loadLightAsync(`/extensions/${this.name}/lights/${extension.light}`, light).then((texture) => {
          this._loader.babylonScene.environmentTexture = texture;
        })
      );
      this._loader.logClose();
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadLightAsync(context, light) {
    if (!light._loaded) {
      const promises = new Array();
      this._loader.logOpen(`${context}`);
      const imageData = new Array(light.specularImages.length);
      for (let mipmap = 0; mipmap < light.specularImages.length; mipmap++) {
        const faces = light.specularImages[mipmap];
        imageData[mipmap] = new Array(faces.length);
        for (let face = 0; face < faces.length; face++) {
          const specularImageContext = `${context}/specularImages/${mipmap}/${face}`;
          this._loader.logOpen(`${specularImageContext}`);
          const index = faces[face];
          const image = ArrayItem.Get(specularImageContext, this._loader.gltf.images, index);
          promises.push(
            // eslint-disable-next-line github/no-then
            this._loader.loadImageAsync(`/images/${index}`, image).then((data) => {
              imageData[mipmap][face] = data;
            })
          );
          this._loader.logClose();
        }
      }
      this._loader.logClose();
      light._loaded = Promise.all(promises).then(async () => {
        const babylonTexture = new RawCubeTexture(this._loader.babylonScene, null, light.specularImageSize);
        babylonTexture.name = light.name || "environment";
        light._babylonTexture = babylonTexture;
        if (light.intensity != void 0) {
          babylonTexture.level = light.intensity;
        }
        if (light.rotation) {
          let rotation = Quaternion.FromArray(light.rotation);
          if (!this._loader.babylonScene.useRightHandedSystem) {
            rotation = Quaternion.Inverse(rotation);
          }
          Matrix.FromQuaternionToRef(rotation, babylonTexture.getReflectionTextureMatrix());
        }
        if (!light.irradianceCoefficients) {
          throw new Error(`${context}: Irradiance coefficients are missing`);
        }
        const sphericalHarmonics = SphericalHarmonics.FromArray(light.irradianceCoefficients);
        sphericalHarmonics.scaleInPlace(light.intensity);
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        const sphericalPolynomial = SphericalPolynomial.FromHarmonics(sphericalHarmonics);
        const lodGenerationScale = (imageData.length - 1) / Math.log2(light.specularImageSize);
        return await babylonTexture.updateRGBDAsync(imageData, sphericalPolynomial, lodGenerationScale);
      });
    }
    return light._loaded.then(() => {
      return light._babylonTexture;
    });
  }
};
unregisterGLTFExtension(NAME2);
registerGLTFExtension(NAME2, true, (loader) => new EXT_lights_image_based(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.js
var NAME3 = "EXT_mesh_gpu_instancing";
var EXT_mesh_gpu_instancing = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME3;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME3);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      this._loader._disableInstancedMesh++;
      const promise = this._loader.loadNodeAsync(`/nodes/${node.index}`, node, assign);
      this._loader._disableInstancedMesh--;
      if (!node._primitiveBabylonMeshes) {
        return await promise;
      }
      const promises = new Array();
      let instanceCount = 0;
      const loadAttribute = (attribute) => {
        if (extension.attributes[attribute] == void 0) {
          promises.push(Promise.resolve(null));
          return;
        }
        const accessor = ArrayItem.Get(`${extensionContext}/attributes/${attribute}`, this._loader.gltf.accessors, extension.attributes[attribute]);
        promises.push(this._loader._loadFloatAccessorAsync(`/accessors/${accessor.bufferView}`, accessor));
        if (instanceCount === 0) {
          instanceCount = accessor.count;
        } else if (instanceCount !== accessor.count) {
          throw new Error(`${extensionContext}/attributes: Instance buffer accessors do not have the same count.`);
        }
      };
      loadAttribute("TRANSLATION");
      loadAttribute("ROTATION");
      loadAttribute("SCALE");
      loadAttribute("_COLOR_0");
      return await promise.then(async (babylonTransformNode) => {
        const [translationBuffer, rotationBuffer, scaleBuffer, colorBuffer] = await Promise.all(promises);
        const matrices = new Float32Array(instanceCount * 16);
        TmpVectors.Vector3[0].copyFromFloats(0, 0, 0);
        TmpVectors.Quaternion[0].copyFromFloats(0, 0, 0, 1);
        TmpVectors.Vector3[1].copyFromFloats(1, 1, 1);
        for (let i = 0; i < instanceCount; ++i) {
          translationBuffer && Vector3.FromArrayToRef(translationBuffer, i * 3, TmpVectors.Vector3[0]);
          rotationBuffer && Quaternion.FromArrayToRef(rotationBuffer, i * 4, TmpVectors.Quaternion[0]);
          scaleBuffer && Vector3.FromArrayToRef(scaleBuffer, i * 3, TmpVectors.Vector3[1]);
          Matrix.ComposeToRef(TmpVectors.Vector3[1], TmpVectors.Quaternion[0], TmpVectors.Vector3[0], TmpVectors.Matrix[0]);
          TmpVectors.Matrix[0].copyToArray(matrices, i * 16);
        }
        for (const babylonMesh of node._primitiveBabylonMeshes) {
          babylonMesh.thinInstanceSetBuffer("matrix", matrices, 16, true);
          if (colorBuffer) {
            if (colorBuffer.length === instanceCount * 3) {
              babylonMesh.thinInstanceSetBuffer("color", colorBuffer, 3, true);
            } else if (colorBuffer.length === instanceCount * 4) {
              babylonMesh.thinInstanceSetBuffer("color", colorBuffer, 4, true);
            } else {
              Logger.Warn("Unexpected size of _COLOR_0 attribute for mesh " + babylonMesh.name);
            }
          }
        }
        return babylonTransformNode;
      });
    });
  }
};
unregisterGLTFExtension(NAME3);
registerGLTFExtension(NAME3, true, (loader) => new EXT_mesh_gpu_instancing(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_meshopt_compression.js
var NAME4 = "EXT_meshopt_compression";
var EXT_meshopt_compression = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME4;
    this.enabled = loader.isExtensionUsed(NAME4);
    this._loader = loader;
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadBufferViewAsync(context, bufferView) {
    return GLTFLoader2.LoadExtensionAsync(context, bufferView, this.name, async (extensionContext, extension) => {
      const bufferViewMeshopt = bufferView;
      if (bufferViewMeshopt._meshOptData) {
        return await bufferViewMeshopt._meshOptData;
      }
      const buffer = ArrayItem.Get(`${context}/buffer`, this._loader.gltf.buffers, extension.buffer);
      bufferViewMeshopt._meshOptData = this._loader.loadBufferAsync(`/buffers/${buffer.index}`, buffer, extension.byteOffset || 0, extension.byteLength).then(async (buffer2) => {
        return await MeshoptCompression.Default.decodeGltfBufferAsync(buffer2, extension.count, extension.byteStride, extension.mode, extension.filter);
      });
      return await bufferViewMeshopt._meshOptData;
    });
  }
};
unregisterGLTFExtension(NAME4);
registerGLTFExtension(NAME4, true, (loader) => new EXT_meshopt_compression(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_texture_webp.js
var NAME5 = "EXT_texture_webp";
var EXT_texture_webp = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME5;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME5);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadTextureAsync(context, texture, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, async (extensionContext, extension) => {
      const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);
      const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);
      return await this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {
        assign(babylonTexture);
      }, void 0, !texture._textureInfo.nonColorData);
    });
  }
};
unregisterGLTFExtension(NAME5);
registerGLTFExtension(NAME5, true, (loader) => new EXT_texture_webp(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_texture_avif.js
var NAME6 = "EXT_texture_avif";
var EXT_texture_avif = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME6;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME6);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadTextureAsync(context, texture, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, async (extensionContext, extension) => {
      const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);
      const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);
      return await this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {
        assign(babylonTexture);
      }, void 0, !texture._textureInfo.nonColorData);
    });
  }
};
unregisterGLTFExtension(NAME6);
registerGLTFExtension(NAME6, true, (loader) => new EXT_texture_avif(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/EXT_lights_ies.js
var NAME7 = "EXT_lights_ies";
var EXT_lights_ies = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME7;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME7);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
      ArrayItem.Assign(this._lights);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      this._loader._allMaterialsDirtyRequired = true;
      let babylonSpotLight;
      let light;
      const transformNode = await this._loader.loadNodeAsync(context, node, (babylonMesh) => {
        light = ArrayItem.Get(extensionContext, this._lights, extension.light);
        const name2 = light.name || babylonMesh.name;
        this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;
        babylonSpotLight = new SpotLight(name2, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);
        babylonSpotLight.angle = Math.PI / 2;
        babylonSpotLight.innerAngle = 0;
        babylonSpotLight._parentContainer = this._loader._assetContainer;
        this._loader.babylonScene._blockEntityCollection = false;
        light._babylonLight = babylonSpotLight;
        babylonSpotLight.falloffType = Light.FALLOFF_GLTF;
        babylonSpotLight.diffuse = extension.color ? Color3.FromArray(extension.color) : Color3.White();
        babylonSpotLight.intensity = extension.multiplier || 1;
        babylonSpotLight.range = Number.MAX_VALUE;
        babylonSpotLight.parent = babylonMesh;
        this._loader._babylonLights.push(babylonSpotLight);
        GLTFLoader2.AddPointerMetadata(babylonSpotLight, extensionContext);
        assign(babylonMesh);
      });
      let bufferData;
      if (light.uri) {
        bufferData = await this._loader.loadUriAsync(context, light, light.uri);
      } else {
        const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, light.bufferView);
        bufferData = await this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);
      }
      babylonSpotLight.iesProfileTexture = new Texture(name + "_iesProfile", this._loader.babylonScene, true, false, void 0, null, null, bufferData, true, void 0, void 0, void 0, void 0, ".ies");
      return transformNode;
    });
  }
};
unregisterGLTFExtension(NAME7);
registerGLTFExtension(NAME7, true, (loader) => new EXT_lights_ies(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_draco_mesh_compression.js
var NAME8 = "KHR_draco_mesh_compression";
var KHR_draco_mesh_compression = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME8;
    this.useNormalizedFlagFromAccessor = true;
    this._loader = loader;
    this.enabled = DracoDecoder.DefaultAvailable && this._loader.isExtensionUsed(NAME8);
  }
  /** @internal */
  dispose() {
    delete this.dracoDecoder;
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadVertexDataAsync(context, primitive, babylonMesh) {
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {
      if (primitive.mode != void 0) {
        if (primitive.mode !== 4 && primitive.mode !== 5) {
          throw new Error(`${context}: Unsupported mode ${primitive.mode}`);
        }
      }
      const attributes = {};
      const normalized = {};
      const loadAttribute = (name2, kind) => {
        const uniqueId = extension.attributes[name2];
        if (uniqueId == void 0) {
          return;
        }
        babylonMesh._delayInfo = babylonMesh._delayInfo || [];
        if (babylonMesh._delayInfo.indexOf(kind) === -1) {
          babylonMesh._delayInfo.push(kind);
        }
        attributes[kind] = uniqueId;
        if (this.useNormalizedFlagFromAccessor) {
          const accessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes[name2]);
          if (accessor) {
            normalized[kind] = accessor.normalized || false;
          }
        }
      };
      loadAttribute("POSITION", VertexBuffer.PositionKind);
      loadAttribute("NORMAL", VertexBuffer.NormalKind);
      loadAttribute("TANGENT", VertexBuffer.TangentKind);
      loadAttribute("TEXCOORD_0", VertexBuffer.UVKind);
      loadAttribute("TEXCOORD_1", VertexBuffer.UV2Kind);
      loadAttribute("TEXCOORD_2", VertexBuffer.UV3Kind);
      loadAttribute("TEXCOORD_3", VertexBuffer.UV4Kind);
      loadAttribute("TEXCOORD_4", VertexBuffer.UV5Kind);
      loadAttribute("TEXCOORD_5", VertexBuffer.UV6Kind);
      loadAttribute("JOINTS_0", VertexBuffer.MatricesIndicesKind);
      loadAttribute("WEIGHTS_0", VertexBuffer.MatricesWeightsKind);
      loadAttribute("COLOR_0", VertexBuffer.ColorKind);
      const bufferView = ArrayItem.Get(extensionContext, this._loader.gltf.bufferViews, extension.bufferView);
      if (!bufferView._dracoBabylonGeometry) {
        bufferView._dracoBabylonGeometry = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then(async (data) => {
          const dracoDecoder = this.dracoDecoder || DracoDecoder.Default;
          const positionAccessor = ArrayItem.TryGet(this._loader.gltf.accessors, primitive.attributes["POSITION"]);
          const babylonBoundingInfo = !this._loader.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton && positionAccessor ? LoadBoundingInfoFromPositionAccessor(positionAccessor) : null;
          return await dracoDecoder._decodeMeshToGeometryForGltfAsync(babylonMesh.name, this._loader.babylonScene, data, attributes, normalized, babylonBoundingInfo).catch((error) => {
            throw new Error(`${context}: ${error.message}`);
          });
        });
      }
      return await bufferView._dracoBabylonGeometry;
    });
  }
};
unregisterGLTFExtension(NAME8);
registerGLTFExtension(NAME8, true, (loader) => new KHR_draco_mesh_compression(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_lights_punctual.js
var NAME9 = "KHR_lights_punctual";
var KHR_lights = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME9;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME9);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    delete this._lights;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._lights = extension.lights;
      ArrayItem.Assign(this._lights);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      this._loader._allMaterialsDirtyRequired = true;
      return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {
        let babylonLight;
        const light = ArrayItem.Get(extensionContext, this._lights, extension.light);
        const name2 = light.name || babylonMesh.name;
        this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;
        switch (light.type) {
          case "directional": {
            const babylonDirectionalLight = new DirectionalLight(name2, Vector3.Backward(), this._loader.babylonScene);
            babylonDirectionalLight.position.setAll(0);
            babylonLight = babylonDirectionalLight;
            break;
          }
          case "point": {
            babylonLight = new PointLight(name2, Vector3.Zero(), this._loader.babylonScene);
            break;
          }
          case "spot": {
            const babylonSpotLight = new SpotLight(name2, Vector3.Zero(), Vector3.Backward(), 0, 1, this._loader.babylonScene);
            babylonSpotLight.angle = (light.spot && light.spot.outerConeAngle || Math.PI / 4) * 2;
            babylonSpotLight.innerAngle = (light.spot && light.spot.innerConeAngle || 0) * 2;
            babylonLight = babylonSpotLight;
            break;
          }
          default: {
            this._loader.babylonScene._blockEntityCollection = false;
            throw new Error(`${extensionContext}: Invalid light type (${light.type})`);
          }
        }
        babylonLight._parentContainer = this._loader._assetContainer;
        this._loader.babylonScene._blockEntityCollection = false;
        light._babylonLight = babylonLight;
        babylonLight.falloffType = Light.FALLOFF_GLTF;
        babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();
        babylonLight.intensity = light.intensity == void 0 ? 1 : light.intensity;
        babylonLight.range = light.range == void 0 ? Number.MAX_VALUE : light.range;
        babylonLight.parent = babylonMesh;
        this._loader._babylonLights.push(babylonLight);
        GLTFLoader2.AddPointerMetadata(babylonLight, extensionContext);
        assign(babylonMesh);
      });
    });
  }
};
unregisterGLTFExtension(NAME9);
registerGLTFExtension(NAME9, true, (loader) => new KHR_lights(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_pbrSpecularGlossiness.js
var NAME10 = "KHR_materials_pbrSpecularGlossiness";
var KHR_materials_pbrSpecularGlossiness = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME10;
    this.order = 200;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME10);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSpecularGlossinessPropertiesAsync(extensionContext, extension, babylonMaterial));
      this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadSpecularGlossinessPropertiesAsync(context, properties, babylonMaterial) {
    if (!(babylonMaterial instanceof PBRMaterial)) {
      throw new Error(`${context}: Material type not supported`);
    }
    const promises = new Array();
    babylonMaterial.metallic = null;
    babylonMaterial.roughness = null;
    if (properties.diffuseFactor) {
      babylonMaterial.albedoColor = Color3.FromArray(properties.diffuseFactor);
      babylonMaterial.alpha = properties.diffuseFactor[3];
    } else {
      babylonMaterial.albedoColor = Color3.White();
    }
    babylonMaterial.reflectivityColor = properties.specularFactor ? Color3.FromArray(properties.specularFactor) : Color3.White();
    babylonMaterial.microSurface = properties.glossinessFactor == void 0 ? 1 : properties.glossinessFactor;
    if (properties.diffuseTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTexture`, properties.diffuseTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Diffuse)`;
        babylonMaterial.albedoTexture = texture;
      }));
    }
    if (properties.specularGlossinessTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularGlossinessTexture`, properties.specularGlossinessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular Glossiness)`;
        babylonMaterial.reflectivityTexture = texture;
        babylonMaterial.reflectivityTexture.hasAlpha = true;
      }));
      babylonMaterial.useMicroSurfaceFromReflectivityMapAlpha = true;
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME10);
registerGLTFExtension(NAME10, true, (loader) => new KHR_materials_pbrSpecularGlossiness(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_unlit.js
var NAME11 = "KHR_materials_unlit";
var KHR_materials_unlit = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME11;
    this.order = 210;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME11);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async () => {
      return await this._loadUnlitPropertiesAsync(context, material, babylonMaterial);
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadUnlitPropertiesAsync(context, material, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    const properties = material.pbrMetallicRoughness;
    if (properties) {
      if (properties.baseColorFactor) {
        adapter.baseColor = Color3.FromArray(properties.baseColorFactor);
        adapter.geometryOpacity = properties.baseColorFactor[3];
      }
      if (properties.baseColorTexture) {
        promises.push(this._loader.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {
          texture.name = `${babylonMaterial.name} (Base Color)`;
          adapter.baseColorTexture = texture;
        }));
      }
    }
    adapter.isUnlit = true;
    if (material.doubleSided) {
      adapter.backFaceCulling = false;
      adapter.twoSidedLighting = true;
    }
    this._loader.loadMaterialAlphaProperties(context, material, babylonMaterial);
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME11);
registerGLTFExtension(NAME11, true, (loader) => new KHR_materials_unlit(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_clearcoat.js
var NAME12 = "KHR_materials_clearcoat";
var KHR_materials_clearcoat = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME12;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME12);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadClearCoatPropertiesAsync(extensionContext, extension, babylonMaterial));
      const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
      if (extension.extensions && extension.extensions.KHR_materials_clearcoat_darkening) {
        const darkeningExtension = extension.extensions.KHR_materials_clearcoat_darkening;
        promises.push(this._loadClearCoatDarkeningPropertiesAsync(extensionContext, darkeningExtension, babylonMaterial));
      }
      if (extension.extensions && extension.extensions.KHR_materials_clearcoat_ior) {
        const iorExtension = extension.extensions.KHR_materials_clearcoat_ior;
        let ior = 1.5;
        if (iorExtension.clearcoatIor !== void 0) {
          ior = iorExtension.clearcoatIor;
        }
        adapter.coatIor = ior;
      }
      if (extension.extensions && extension.extensions.KHR_materials_clearcoat_anisotropy) {
        const anisotropyExtension = extension.extensions.KHR_materials_clearcoat_anisotropy;
        promises.push(this._loadClearCoatAnisotropyPropertiesAsync(extensionContext, anisotropyExtension, babylonMaterial));
      }
      if (extension.extensions && extension.extensions.KHR_materials_clearcoat_color) {
        const colorExtension = extension.extensions.KHR_materials_clearcoat_color;
        promises.push(this._loadClearCoatColorPropertiesAsync(extensionContext, colorExtension, babylonMaterial));
      }
      await Promise.all(promises);
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadClearCoatPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.configureCoat();
    adapter.coatWeight = properties.clearcoatFactor !== void 0 ? properties.clearcoatFactor : 0;
    adapter.coatRoughness = properties.clearcoatRoughnessFactor !== void 0 ? properties.clearcoatRoughnessFactor : 0;
    if (properties.clearcoatTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatTexture`, properties.clearcoatTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat)`;
        adapter.coatWeightTexture = texture;
      }));
    }
    if (properties.clearcoatRoughnessTexture) {
      properties.clearcoatRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatRoughnessTexture`, properties.clearcoatRoughnessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Roughness)`;
        adapter.coatRoughnessTexture = texture;
      }));
    }
    if (properties.clearcoatNormalTexture) {
      properties.clearcoatNormalTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatNormalTexture`, properties.clearcoatNormalTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Normal)`;
        adapter.geometryCoatNormalTexture = texture;
        if (properties.clearcoatNormalTexture?.scale != void 0) {
          adapter.geometryCoatNormalTextureScale = properties.clearcoatNormalTexture.scale;
        }
      }));
      adapter.setNormalMapInversions(!babylonMaterial.getScene().useRightHandedSystem, babylonMaterial.getScene().useRightHandedSystem);
    }
    return Promise.all(promises).then(() => {
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadClearCoatDarkeningPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.coatDarkening = properties.clearcoatDarkeningFactor !== void 0 ? properties.clearcoatDarkeningFactor : 1;
    if (properties.clearcoatDarkeningTexture) {
      properties.clearcoatDarkeningTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatDarkeningTexture`, properties.clearcoatDarkeningTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Darkening)`;
        adapter.coatDarkeningTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadClearCoatColorPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    const colorFactor = Color3.White();
    if (properties.clearcoatColorFactor !== void 0) {
      colorFactor.fromArray(properties.clearcoatColorFactor);
    }
    adapter.coatColor = colorFactor;
    if (properties.clearcoatColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatColorTexture`, properties.clearcoatColorTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (ClearCoat Color)`;
        adapter.coatColorTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadClearCoatAnisotropyPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    const clearcoatAnisotropyWeight = properties.clearcoatAnisotropyStrength ?? 0;
    const clearcoatAnisotropyAngle = properties.clearcoatAnisotropyRotation ?? 0;
    adapter.coatRoughnessAnisotropy = clearcoatAnisotropyWeight;
    adapter.geometryCoatTangentAngle = clearcoatAnisotropyAngle;
    const extensions = properties.extensions ?? {};
    if (!extensions.EXT_materials_anisotropy_openpbr || !extensions.EXT_materials_anisotropy_openpbr.openPbrAnisotropyEnabled) {
      adapter.configureGltfStyleAnisotropy(true);
    }
    if (properties.clearcoatAnisotropyTexture) {
      properties.clearcoatAnisotropyTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/clearcoatAnisotropyTexture`, properties.clearcoatAnisotropyTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Clearcoat Anisotropy)`;
        adapter.geometryCoatTangentTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME12);
registerGLTFExtension(NAME12, true, (loader) => new KHR_materials_clearcoat(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_iridescence.js
var NAME13 = "KHR_materials_iridescence";
var KHR_materials_iridescence = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME13;
    this.order = 195;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME13);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadIridescencePropertiesAsync(extensionContext, extension, babylonMaterial));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadIridescencePropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.thinFilmWeight = properties.iridescenceFactor ?? 0;
    adapter.thinFilmIor = properties.iridescenceIor ?? properties.iridescenceIOR ?? 1.3;
    adapter.thinFilmThicknessMinimum = properties.iridescenceThicknessMinimum ?? 100;
    adapter.thinFilmThicknessMaximum = properties.iridescenceThicknessMaximum ?? 400;
    if (properties.iridescenceTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceTexture`, properties.iridescenceTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Iridescence)`;
        adapter.thinFilmWeightTexture = texture;
      }));
    }
    if (properties.iridescenceThicknessTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/iridescenceThicknessTexture`, properties.iridescenceThicknessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Iridescence Thickness)`;
        adapter.thinFilmThicknessTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME13);
registerGLTFExtension(NAME13, true, (loader) => new KHR_materials_iridescence(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_anisotropy.js
var NAME14 = "KHR_materials_anisotropy";
var KHR_materials_anisotropy = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME14;
    this.order = 195;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME14);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadAnisotropyPropertiesAsync(extensionContext, extension, babylonMaterial));
      await Promise.all(promises);
    });
  }
  async _loadAnisotropyPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    const anisotropyWeight = properties.anisotropyStrength ?? 0;
    const anisotropyAngle = properties.anisotropyRotation ?? 0;
    adapter.specularRoughnessAnisotropy = anisotropyWeight;
    adapter.geometryTangentAngle = anisotropyAngle;
    const extensions = properties.extensions ?? {};
    if (!extensions.EXT_materials_anisotropy_openpbr || !extensions.EXT_materials_anisotropy_openpbr.openPbrAnisotropyEnabled) {
      adapter.configureGltfStyleAnisotropy(true);
    }
    if (properties.anisotropyTexture) {
      properties.anisotropyTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/anisotropyTexture`, properties.anisotropyTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Anisotropy Intensity)`;
        adapter.geometryTangentTexture = texture;
      }));
    }
    await Promise.all(promises);
  }
};
unregisterGLTFExtension(NAME14);
registerGLTFExtension(NAME14, true, (loader) => new KHR_materials_anisotropy(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_emissive_strength.js
var NAME15 = "KHR_materials_emissive_strength";
var KHR_materials_emissive_strength = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME15;
    this.order = 170;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME15);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      await this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
      this._loadEmissiveProperties(extensionContext, extension, babylonMaterial);
      return await Promise.resolve();
    });
  }
  _loadEmissiveProperties(context, properties, babylonMaterial) {
    if (properties.emissiveStrength !== void 0) {
      const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
      adapter.emissionLuminance = properties.emissiveStrength;
    }
  }
};
unregisterGLTFExtension(NAME15);
registerGLTFExtension(NAME15, true, (loader) => new KHR_materials_emissive_strength(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_sheen.js
var NAME16 = "KHR_materials_sheen";
var KHR_materials_sheen = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME16;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME16);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSheenPropertiesAsync(extensionContext, extension, babylonMaterial));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadSheenPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.configureFuzz();
    const sheenColor = properties.sheenColorFactor !== void 0 ? Color3.FromArray(properties.sheenColorFactor) : Color3.Black();
    const sheenRoughness = properties.sheenRoughnessFactor !== void 0 ? properties.sheenRoughnessFactor : 0;
    adapter.fuzzWeight = 1;
    adapter.fuzzColor = sheenColor;
    adapter.fuzzRoughness = sheenRoughness;
    if (properties.sheenColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenColorTexture`, properties.sheenColorTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Sheen Color)`;
        adapter.fuzzColorTexture = texture;
      }));
    }
    if (properties.sheenRoughnessTexture) {
      properties.sheenRoughnessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/sheenRoughnessTexture`, properties.sheenRoughnessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Sheen Roughness)`;
        adapter.fuzzRoughnessTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME16);
registerGLTFExtension(NAME16, true, (loader) => new KHR_materials_sheen(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_specular.js
var NAME17 = "KHR_materials_specular";
var KHR_materials_specular = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME17;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME17);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadSpecularPropertiesAsync(extensionContext, extension, babylonMaterial));
      const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
      if (extension.extensions && extension.extensions.EXT_materials_specular_edge_color) {
        const specularEdgeColorExtension = extension.extensions.EXT_materials_specular_edge_color;
        if (specularEdgeColorExtension.specularEdgeColorEnabled) {
          adapter.enableSpecularEdgeColor(true);
        }
      }
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadSpecularPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.specularWeight = properties.specularFactor ?? 1;
    adapter.specularColor = properties.specularColorFactor !== void 0 ? Color3.FromArray(properties.specularColorFactor) : new Color3(1, 1, 1);
    if (properties.specularTexture) {
      properties.specularTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularTexture`, properties.specularTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular)`;
        adapter.specularWeightTexture = texture;
      }));
    }
    if (properties.specularColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/specularColorTexture`, properties.specularColorTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Specular Color)`;
        adapter.specularColorTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME17);
registerGLTFExtension(NAME17, true, (loader) => new KHR_materials_specular(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_ior.js
var NAME18 = "KHR_materials_ior";
var KHR_materials_ior = class _KHR_materials_ior {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME18;
    this.order = 180;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME18);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadIorPropertiesAsync(extensionContext, extension, babylonMaterial));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadIorPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const indexOfRefraction = properties.ior !== void 0 ? properties.ior : _KHR_materials_ior._DEFAULT_IOR;
    adapter.specularIor = indexOfRefraction;
    return Promise.resolve();
  }
};
KHR_materials_ior._DEFAULT_IOR = 1.5;
unregisterGLTFExtension(NAME18);
registerGLTFExtension(NAME18, true, (loader) => new KHR_materials_ior(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_variants.js
var NAME19 = "KHR_materials_variants";
var KHR_materials_variants = class _KHR_materials_variants {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME19;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME19) && !this._loader.parent.skipMaterials;
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * Gets the list of available variant names for this asset.
   * @param rootNode The glTF root node
   * @returns the list of all the variant names for this model
   */
  static GetAvailableVariants(rootNode) {
    const extensionMetadata = this._GetExtensionMetadata(rootNode);
    if (!extensionMetadata) {
      return [];
    }
    return Object.keys(extensionMetadata.variants);
  }
  /**
   * Gets the list of available variant names for this asset.
   * @param rootNode The glTF root node
   * @returns the list of all the variant names for this model
   */
  getAvailableVariants(rootNode) {
    return _KHR_materials_variants.GetAvailableVariants(rootNode);
  }
  /**
   * Select a variant given a variant name or a list of variant names.
   * @param rootNode The glTF root node
   * @param variantName The variant name(s) to select.
   */
  static SelectVariant(rootNode, variantName) {
    const extensionMetadata = this._GetExtensionMetadata(rootNode);
    if (!extensionMetadata) {
      throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME19} extension`);
    }
    const select = (variantName2) => {
      const entries = extensionMetadata.variants[variantName2];
      if (entries) {
        for (const entry of entries) {
          entry.mesh.material = entry.material;
        }
      }
    };
    if (variantName instanceof Array) {
      for (const name2 of variantName) {
        select(name2);
      }
    } else {
      select(variantName);
    }
    extensionMetadata.lastSelected = variantName;
  }
  /**
   * Select a variant given a variant name or a list of variant names.
   * @param rootNode The glTF root node
   * @param variantName The variant name(s) to select.
   */
  selectVariant(rootNode, variantName) {
    _KHR_materials_variants.SelectVariant(rootNode, variantName);
  }
  /**
   * Reset back to the original before selecting a variant.
   * @param rootNode The glTF root node
   */
  static Reset(rootNode) {
    const extensionMetadata = this._GetExtensionMetadata(rootNode);
    if (!extensionMetadata) {
      throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME19} extension`);
    }
    for (const entry of extensionMetadata.original) {
      entry.mesh.material = entry.material;
    }
    extensionMetadata.lastSelected = null;
  }
  /**
   * Reset back to the original before selecting a variant.
   * @param rootNode The glTF root node
   */
  reset(rootNode) {
    _KHR_materials_variants.Reset(rootNode);
  }
  /**
   * Gets the last selected variant name(s) or null if original.
   * @param rootNode The glTF root node
   * @returns The selected variant name(s).
   */
  static GetLastSelectedVariant(rootNode) {
    const extensionMetadata = this._GetExtensionMetadata(rootNode);
    if (!extensionMetadata) {
      throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME19} extension`);
    }
    return extensionMetadata.lastSelected;
  }
  /**
   * Gets the last selected variant name(s) or null if original.
   * @param rootNode The glTF root node
   * @returns The selected variant name(s).
   */
  getLastSelectedVariant(rootNode) {
    return _KHR_materials_variants.GetLastSelectedVariant(rootNode);
  }
  static _GetExtensionMetadata(rootNode) {
    return rootNode?._internalMetadata?.gltf?.[NAME19] || null;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._variants = extension.variants;
    }
  }
  /** @internal */
  onReady() {
    const rootNode = this._loader.rootBabylonMesh;
    if (rootNode) {
      const options = this._loader.parent.extensionOptions[NAME19];
      if (options?.defaultVariant) {
        _KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);
      }
      options?.onLoaded?.({
        get variants() {
          return _KHR_materials_variants.GetAvailableVariants(rootNode);
        },
        get selectedVariant() {
          const lastSelectedVariant = _KHR_materials_variants.GetLastSelectedVariant(rootNode);
          if (!lastSelectedVariant) {
            return _KHR_materials_variants.GetAvailableVariants(rootNode)[0];
          }
          if (Array.isArray(lastSelectedVariant)) {
            return lastSelectedVariant[0];
          }
          return lastSelectedVariant;
        },
        set selectedVariant(variantName) {
          _KHR_materials_variants.SelectVariant(rootNode, variantName);
        }
      });
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, primitive, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader._loadMeshPrimitiveAsync(context, name2, node, mesh, primitive, (babylonMesh) => {
        assign(babylonMesh);
        if (babylonMesh instanceof Mesh) {
          const babylonDrawMode = GLTFLoader2._GetDrawMode(context, primitive.mode);
          const root = this._loader.rootBabylonMesh;
          const metadata = root ? root._internalMetadata = root._internalMetadata || {} : {};
          const gltf = metadata.gltf = metadata.gltf || {};
          const extensionMetadata = gltf[NAME19] = gltf[NAME19] || { lastSelected: null, original: [], variants: {} };
          extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });
          for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {
            const mapping = extension.mappings[mappingIndex];
            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);
            promises.push(this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {
              for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {
                const variantIndex = mapping.variants[mappingVariantIndex];
                const variant = ArrayItem.Get(`/extensions/${NAME19}/variants/${variantIndex}`, this._variants, variantIndex);
                extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];
                extensionMetadata.variants[variant.name].push({
                  mesh: babylonMesh,
                  material: babylonMaterial
                });
                babylonMesh.onClonedObservable.add((newOne) => {
                  const newMesh = newOne;
                  let metadata2 = null;
                  let newRoot = newMesh;
                  do {
                    newRoot = newRoot.parent;
                    if (!newRoot) {
                      return;
                    }
                    metadata2 = _KHR_materials_variants._GetExtensionMetadata(newRoot);
                  } while (metadata2 === null);
                  if (root && metadata2 === _KHR_materials_variants._GetExtensionMetadata(root)) {
                    newRoot._internalMetadata = {};
                    for (const key in root._internalMetadata) {
                      newRoot._internalMetadata[key] = root._internalMetadata[key];
                    }
                    newRoot._internalMetadata.gltf = [];
                    for (const key in root._internalMetadata.gltf) {
                      newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];
                    }
                    newRoot._internalMetadata.gltf[NAME19] = { lastSelected: null, original: [], variants: {} };
                    for (const original of metadata2.original) {
                      newRoot._internalMetadata.gltf[NAME19].original.push({
                        mesh: original.mesh,
                        material: original.material
                      });
                    }
                    for (const key in metadata2.variants) {
                      if (Object.prototype.hasOwnProperty.call(metadata2.variants, key)) {
                        newRoot._internalMetadata.gltf[NAME19].variants[key] = [];
                        for (const variantEntry of metadata2.variants[key]) {
                          newRoot._internalMetadata.gltf[NAME19].variants[key].push({
                            mesh: variantEntry.mesh,
                            material: variantEntry.material
                          });
                        }
                      }
                    }
                    metadata2 = newRoot._internalMetadata.gltf[NAME19];
                  }
                  for (const target of metadata2.original) {
                    if (target.mesh === babylonMesh) {
                      target.mesh = newMesh;
                    }
                  }
                  for (const target of metadata2.variants[variant.name]) {
                    if (target.mesh === babylonMesh) {
                      target.mesh = newMesh;
                    }
                  }
                });
              }
            }));
          }
        }
      }));
      return await Promise.all(promises).then(([babylonMesh]) => {
        return babylonMesh;
      });
    });
  }
};
unregisterGLTFExtension(NAME19);
registerGLTFExtension(NAME19, true, (loader) => new KHR_materials_variants(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_transmission.js
var TransmissionHelper = class _TransmissionHelper {
  /**
   * Creates the default options for the helper.
   * @returns the default options
   */
  static _GetDefaultOptions() {
    return {
      renderSize: 1024,
      samples: 4,
      lodGenerationScale: 1,
      lodGenerationOffset: -4,
      renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,
      generateMipmaps: true
    };
  }
  /**
   * constructor
   * @param options Defines the options we want to customize the helper
   * @param scene The scene to add the material to
   */
  constructor(options, scene) {
    this._opaqueRenderTarget = null;
    this._opaqueMeshesCache = [];
    this._transparentMeshesCache = [];
    this._materialObservers = {};
    this._options = {
      ..._TransmissionHelper._GetDefaultOptions(),
      ...options
    };
    this._scene = scene;
    this._scene._transmissionHelper = this;
    this.onErrorObservable = new Observable();
    this._scene.onDisposeObservable.addOnce(() => {
      this.dispose();
    });
    this._parseScene();
    this._setupRenderTargets();
  }
  /**
   * Updates the background according to the new options
   * @param options
   */
  updateOptions(options) {
    const newValues = Object.keys(options).filter((key) => this._options[key] !== options[key]);
    if (!newValues.length) {
      return;
    }
    const newOptions = {
      ...this._options,
      ...options
    };
    const oldOptions = this._options;
    this._options = newOptions;
    if (newOptions.renderSize !== oldOptions.renderSize || newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType || newOptions.generateMipmaps !== oldOptions.generateMipmaps || !this._opaqueRenderTarget) {
      this._setupRenderTargets();
    } else {
      this._opaqueRenderTarget.samples = newOptions.samples;
      this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;
      this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;
    }
  }
  /**
   * @returns the opaque render target texture or null if not available.
   */
  getOpaqueTarget() {
    return this._opaqueRenderTarget;
  }
  _shouldRenderAsTransmission(material) {
    return material?.subSurface?.isRefractionEnabled ? true : false;
  }
  _addMesh(mesh) {
    this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));
    Tools.SetImmediate(() => {
      if (this._shouldRenderAsTransmission(mesh.material)) {
        mesh.material.refractionTexture = this._opaqueRenderTarget;
        if (this._transparentMeshesCache.indexOf(mesh) === -1) {
          this._transparentMeshesCache.push(mesh);
        }
      } else {
        if (this._opaqueMeshesCache.indexOf(mesh) === -1) {
          this._opaqueMeshesCache.push(mesh);
        }
      }
    });
  }
  _removeMesh(mesh) {
    mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);
    delete this._materialObservers[mesh.uniqueId];
    let idx = this._transparentMeshesCache.indexOf(mesh);
    if (idx !== -1) {
      this._transparentMeshesCache.splice(idx, 1);
    }
    idx = this._opaqueMeshesCache.indexOf(mesh);
    if (idx !== -1) {
      this._opaqueMeshesCache.splice(idx, 1);
    }
  }
  _parseScene() {
    this._scene.meshes.forEach(this._addMesh.bind(this));
    this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));
    this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));
  }
  // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.
  _onMeshMaterialChanged(mesh) {
    const transparentIdx = this._transparentMeshesCache.indexOf(mesh);
    const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);
    const useTransmission = this._shouldRenderAsTransmission(mesh.material);
    if (useTransmission) {
      if (mesh.material) {
        const subSurface = mesh.material.subSurface;
        if (subSurface) {
          subSurface.refractionTexture = this._opaqueRenderTarget;
        }
      }
      if (opaqueIdx !== -1) {
        this._opaqueMeshesCache.splice(opaqueIdx, 1);
        this._transparentMeshesCache.push(mesh);
      } else if (transparentIdx === -1) {
        this._transparentMeshesCache.push(mesh);
      }
    } else {
      if (transparentIdx !== -1) {
        this._transparentMeshesCache.splice(transparentIdx, 1);
        this._opaqueMeshesCache.push(mesh);
      } else if (opaqueIdx === -1) {
        this._opaqueMeshesCache.push(mesh);
      }
    }
  }
  /**
   * @internal
   * Check if the opaque render target has not been disposed and can still be used.
   * @returns
   */
  _isRenderTargetValid() {
    return this._opaqueRenderTarget?.getInternalTexture() !== null;
  }
  /**
   * @internal
   * Setup the render targets according to the specified options.
   */
  _setupRenderTargets() {
    if (this._opaqueRenderTarget) {
      this._opaqueRenderTarget.dispose();
    }
    this._opaqueRenderTarget = new RenderTargetTexture("opaqueSceneTexture", this._options.renderSize, this._scene, this._options.generateMipmaps, void 0, this._options.renderTargetTextureType);
    this._opaqueRenderTarget.ignoreCameraViewport = true;
    this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;
    this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();
    this._opaqueRenderTarget.gammaSpace = false;
    this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;
    this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;
    this._opaqueRenderTarget.samples = this._options.samples;
    this._opaqueRenderTarget.renderSprites = true;
    this._opaqueRenderTarget.renderParticles = true;
    this._opaqueRenderTarget.disableImageProcessing = true;
    let saveSceneEnvIntensity;
    this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {
      saveSceneEnvIntensity = this._scene.environmentIntensity;
      this._scene.environmentIntensity = 1;
      if (!this._options.clearColor) {
        this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);
      } else {
        opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);
      }
    });
    this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {
      this._scene.environmentIntensity = saveSceneEnvIntensity;
    });
    for (const mesh of this._transparentMeshesCache) {
      if (this._shouldRenderAsTransmission(mesh.material)) {
        mesh.material.refractionTexture = this._opaqueRenderTarget;
      }
    }
  }
  /**
   * Dispose all the elements created by the Helper.
   */
  dispose() {
    this._scene._transmissionHelper = void 0;
    if (this._opaqueRenderTarget) {
      this._opaqueRenderTarget.dispose();
      this._opaqueRenderTarget = null;
    }
    this._transparentMeshesCache = [];
    this._opaqueMeshesCache = [];
  }
};
var NAME20 = "KHR_materials_transmission";
var KHR_materials_transmission = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME20;
    this.order = 175;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME20);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _loadTransparentPropertiesAsync(context, material, babylonMaterial, extension) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const transmissionWeight = extension.transmissionFactor !== void 0 ? extension.transmissionFactor : 0;
    if (transmissionWeight === 0) {
      return Promise.resolve();
    }
    adapter.configureTransmission();
    adapter.transmissionWeight = transmissionWeight;
    if (transmissionWeight > 0) {
      const scene = babylonMaterial.getScene();
      if (!scene._transmissionHelper) {
        new TransmissionHelper({}, babylonMaterial.getScene());
      } else if (!scene._transmissionHelper?._isRenderTargetValid()) {
        scene._transmissionHelper?._setupRenderTargets();
      }
    }
    let texturePromise = Promise.resolve(null);
    if (extension.transmissionTexture) {
      extension.transmissionTexture.nonColorData = true;
      texturePromise = this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Transmission)`;
        adapter.transmissionWeightTexture = texture;
      });
    }
    return texturePromise.then(() => {
    });
  }
};
unregisterGLTFExtension(NAME20);
registerGLTFExtension(NAME20, true, (loader) => new KHR_materials_transmission(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.js
var NAME21 = "KHR_materials_diffuse_transmission";
var KHR_materials_diffuse_transmission = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME21;
    this.order = 174;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME21);
    if (this.enabled) {
      loader.parent.transparencyAsCoverage = true;
    }
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadTranslucentPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async
  _loadTranslucentPropertiesAsync(context, material, babylonMaterial, extension) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    adapter.configureSubsurface();
    adapter.subsurfaceWeight = extension.diffuseTransmissionFactor ?? 0;
    adapter.subsurfaceColor = extension.diffuseTransmissionColorFactor !== void 0 ? Color3.FromArray(extension.diffuseTransmissionColorFactor) : Color3.White();
    const promises = new Array();
    if (extension.diffuseTransmissionTexture) {
      extension.diffuseTransmissionTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionTexture`, extension.diffuseTransmissionTexture).then((texture) => {
        texture.name = `${babylonMaterial.name} (Diffuse Transmission)`;
        adapter.subsurfaceWeightTexture = texture;
      }));
    }
    if (extension.diffuseTransmissionColorTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseTransmissionColorTexture`, extension.diffuseTransmissionColorTexture).then((texture) => {
        texture.name = `${babylonMaterial.name} (Diffuse Transmission Color)`;
        adapter.subsurfaceColorTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME21);
registerGLTFExtension(NAME21, true, (loader) => new KHR_materials_diffuse_transmission(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_volume.js
var NAME22 = "KHR_materials_volume";
var KHR_materials_volume = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME22;
    this.order = 173;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME22);
    if (this.enabled) {
      this._loader._disableInstancedMesh++;
    }
  }
  /** @internal */
  dispose() {
    if (this.enabled) {
      this._loader._disableInstancedMesh--;
    }
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadVolumePropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadVolumePropertiesAsync(context, material, babylonMaterial, extension) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    if (adapter.transmissionWeight === 0 && adapter.subsurfaceWeight === 0 || !extension.thicknessFactor) {
      return Promise.resolve();
    }
    adapter.transmissionDepth = extension.attenuationDistance !== void 0 ? extension.attenuationDistance : Number.MAX_VALUE;
    adapter.transmissionColor = extension.attenuationColor !== void 0 && extension.attenuationColor.length == 3 ? Color3.FromArray(extension.attenuationColor) : Color3.White();
    adapter.volumeThickness = extension.thicknessFactor ?? 0;
    const promises = new Array();
    if (extension.thicknessTexture) {
      extension.thicknessTexture.nonColorData = true;
      promises.push(this._loader.loadTextureInfoAsync(`${context}/thicknessTexture`, extension.thicknessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Thickness)`;
        adapter.volumeThicknessTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME22);
registerGLTFExtension(NAME22, true, (loader) => new KHR_materials_volume(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_dispersion.js
var NAME23 = "KHR_materials_dispersion";
var KHR_materials_dispersion = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME23;
    this.order = 174;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME23);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadDispersionPropertiesAsync(extensionContext, material, babylonMaterial, extension));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadDispersionPropertiesAsync(context, material, babylonMaterial, extension) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    if (adapter.transmissionWeight > 0 || !extension.dispersion) {
      return Promise.resolve();
    }
    adapter.transmissionDispersionAbbeNumber = 20 / extension.dispersion;
    return Promise.resolve();
  }
};
unregisterGLTFExtension(NAME23);
registerGLTFExtension(NAME23, true, (loader) => new KHR_materials_dispersion(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_materials_diffuse_roughness.js
var NAME24 = "KHR_materials_diffuse_roughness";
var KHR_materials_diffuse_roughness = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME24;
    this.order = 190;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME24);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));
      promises.push(this._loadDiffuseRoughnessPropertiesAsync(extensionContext, extension, babylonMaterial));
      return await Promise.all(promises).then(() => {
      });
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadDiffuseRoughnessPropertiesAsync(context, properties, babylonMaterial) {
    const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
    const promises = new Array();
    adapter.baseDiffuseRoughness = properties.diffuseRoughnessFactor ?? 0;
    if (properties.diffuseRoughnessTexture) {
      promises.push(this._loader.loadTextureInfoAsync(`${context}/diffuseRoughnessTexture`, properties.diffuseRoughnessTexture, (texture) => {
        texture.name = `${babylonMaterial.name} (Diffuse Roughness)`;
        adapter.baseDiffuseRoughnessTexture = texture;
      }));
    }
    return Promise.all(promises).then(() => {
    });
  }
};
unregisterGLTFExtension(NAME24);
registerGLTFExtension(NAME24, true, (loader) => new KHR_materials_diffuse_roughness(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_mesh_quantization.js
var NAME25 = "KHR_mesh_quantization";
var KHR_mesh_quantization = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME25;
    this.enabled = loader.isExtensionUsed(NAME25);
  }
  /** @internal */
  dispose() {
  }
};
unregisterGLTFExtension(NAME25);
registerGLTFExtension(NAME25, true, (loader) => new KHR_mesh_quantization(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_basisu.js
var NAME26 = "KHR_texture_basisu";
var KHR_texture_basisu = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME26;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME26);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadTextureAsync(context, texture, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, texture, this.name, async (extensionContext, extension) => {
      const sampler = texture.sampler == void 0 ? GLTFLoader2.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._loader.gltf.samplers, texture.sampler);
      const image = ArrayItem.Get(`${extensionContext}/source`, this._loader.gltf.images, extension.source);
      return await this._loader._createTextureAsync(context, sampler, image, (babylonTexture) => {
        assign(babylonTexture);
      }, texture._textureInfo.nonColorData ? { useRGBAIfASTCBC7NotAvailableWhenUASTC: true } : void 0, !texture._textureInfo.nonColorData);
    });
  }
};
unregisterGLTFExtension(NAME26);
registerGLTFExtension(NAME26, true, (loader) => new KHR_texture_basisu(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_texture_transform.js
var NAME27 = "KHR_texture_transform";
var KHR_texture_transform = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME27;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME27);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadTextureInfoAsync(context, textureInfo, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, textureInfo, this.name, async (extensionContext, extension) => {
      return await this._loader.loadTextureInfoAsync(context, textureInfo, (babylonTexture) => {
        if (!(babylonTexture instanceof Texture)) {
          throw new Error(`${extensionContext}: Texture type not supported`);
        }
        if (extension.offset) {
          babylonTexture.uOffset = extension.offset[0];
          babylonTexture.vOffset = extension.offset[1];
        }
        babylonTexture.uRotationCenter = 0;
        babylonTexture.vRotationCenter = 0;
        if (extension.rotation) {
          babylonTexture.wAng = -extension.rotation;
        }
        if (extension.scale) {
          babylonTexture.uScale = extension.scale[0];
          babylonTexture.vScale = extension.scale[1];
        }
        if (extension.texCoord != void 0) {
          babylonTexture.coordinatesIndex = extension.texCoord;
        }
        assign(babylonTexture);
      });
    });
  }
};
unregisterGLTFExtension(NAME27);
registerGLTFExtension(NAME27, true, (loader) => new KHR_texture_transform(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_xmp_json_ld.js
var NAME28 = "KHR_xmp_json_ld";
var KHR_xmp_json_ld = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME28;
    this.order = 100;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME28);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * Called after the loader state changes to LOADING.
   */
  onLoading() {
    if (this._loader.rootBabylonMesh === null) {
      return;
    }
    const xmpGltf = this._loader.gltf.extensions?.KHR_xmp_json_ld;
    const xmpNode = this._loader.gltf.asset?.extensions?.KHR_xmp_json_ld;
    if (xmpGltf && xmpNode) {
      const packet = +xmpNode.packet;
      if (xmpGltf.packets && packet < xmpGltf.packets.length) {
        this._loader.rootBabylonMesh.metadata = this._loader.rootBabylonMesh.metadata || {};
        this._loader.rootBabylonMesh.metadata.xmp = xmpGltf.packets[packet];
      }
    }
  }
};
unregisterGLTFExtension(NAME28);
registerGLTFExtension(NAME28, true, (loader) => new KHR_xmp_json_ld(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.data.js
function getColor3(_target, source, offset, scale) {
  return Color3.FromArray(source, offset).scale(scale);
}
function getAlpha(_target, source, offset, scale) {
  return source[offset + 3] * scale;
}
function getFloat(_target, source, offset, scale) {
  return source[offset] * scale;
}
function getMinusFloat(_target, source, offset, scale) {
  return -source[offset] * scale;
}
function getNextFloat(_target, source, offset, scale) {
  return source[offset + 1] * scale;
}
function getFloatBy2(_target, source, offset, scale) {
  return source[offset] * scale * 2;
}
function getTextureTransformTree(textureName) {
  return {
    scale: [
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uScale`, getFloat, () => 2),
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vScale`, getNextFloat, () => 2)
    ],
    offset: [
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.uOffset`, getFloat, () => 2),
      new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.vOffset`, getNextFloat, () => 2)
    ],
    rotation: [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, `${textureName}.wAng`, getMinusFloat, () => 1)]
  };
}
var CameraAnimationPropertyInfo = class extends AnimationPropertyInfo {
  /** @internal */
  buildAnimations(target, name2, fps, keys) {
    return [{ babylonAnimatable: target._babylonCamera, babylonAnimation: this._buildAnimation(name2, fps, keys) }];
  }
};
var MaterialAnimationPropertyInfo = class extends AnimationPropertyInfo {
  /** @internal */
  buildAnimations(target, name2, fps, keys) {
    const babylonAnimations = [];
    for (const fillMode in target._data) {
      babylonAnimations.push({
        babylonAnimatable: target._data[fillMode].babylonMaterial,
        babylonAnimation: this._buildAnimation(name2, fps, keys)
      });
    }
    return babylonAnimations;
  }
};
var LightAnimationPropertyInfo = class extends AnimationPropertyInfo {
  /** @internal */
  buildAnimations(target, name2, fps, keys) {
    return [{ babylonAnimatable: target._babylonLight, babylonAnimation: this._buildAnimation(name2, fps, keys) }];
  }
};
var MeshAnimationPropertyInfo = class extends AnimationPropertyInfo {
  /** @internal */
  buildAnimations(target, name2, fps, keys) {
    return target._primitiveBabylonMeshes ? target._primitiveBabylonMeshes.map((mesh) => ({ babylonAnimatable: mesh, babylonAnimation: this._buildAnimation(name2, fps, keys) })) : [];
  }
};
SetInterpolationForKey("/cameras/{}/orthographic/xmag", [
  new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoLeft", getMinusFloat, () => 1),
  new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoRight", getNextFloat, () => 1)
]);
SetInterpolationForKey("/cameras/{}/orthographic/ymag", [
  new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoBottom", getMinusFloat, () => 1),
  new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "orthoTop", getNextFloat, () => 1)
]);
SetInterpolationForKey("/cameras/{}/orthographic/zfar", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, () => 1)]);
SetInterpolationForKey("/cameras/{}/orthographic/znear", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, () => 1)]);
SetInterpolationForKey("/cameras/{}/perspective/yfov", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "fov", getFloat, () => 1)]);
SetInterpolationForKey("/cameras/{}/perspective/zfar", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "maxZ", getFloat, () => 1)]);
SetInterpolationForKey("/cameras/{}/perspective/znear", [new CameraAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "minZ", getFloat, () => 1)]);
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/baseColorFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "albedoColor", getColor3, () => 4),
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "alpha", getAlpha, () => 4)
]);
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "metallic", getFloat, () => 1)]);
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/metallicFactor", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "roughness", getFloat, () => 1)]);
var baseColorTextureInterpolation = getTextureTransformTree("albedoTexture");
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale", baseColorTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset", baseColorTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/rotation", baseColorTextureInterpolation.rotation);
var metallicRoughnessTextureInterpolation = getTextureTransformTree("metallicTexture");
SetInterpolationForKey("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/scale", metallicRoughnessTextureInterpolation.scale);
SetInterpolationForKey("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/offset", metallicRoughnessTextureInterpolation.offset);
SetInterpolationForKey("//materials/{}/pbrMetallicRoughness/metallicRoughnessTexture/rotation", metallicRoughnessTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/emissiveFactor", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "emissiveColor", getColor3, () => 3)]);
var normalTextureInterpolation = getTextureTransformTree("bumpTexture");
SetInterpolationForKey("/materials/{}/normalTexture/scale", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "bumpTexture.level", getFloat, () => 1)]);
SetInterpolationForKey("/materials/{}/normalTexture/extensions/KHR_texture_transform/scale", normalTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/normalTexture/extensions/KHR_texture_transform/offset", normalTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/normalTexture/extensions/KHR_texture_transform/rotation", normalTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/occlusionTexture/strength", [new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "ambientTextureStrength", getFloat, () => 1)]);
var occlusionTextureInterpolation = getTextureTransformTree("ambientTexture");
SetInterpolationForKey("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/scale", occlusionTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/offset", occlusionTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/occlusionTexture/extensions/KHR_texture_transform/rotation", occlusionTextureInterpolation.rotation);
var emissiveTextureInterpolation = getTextureTransformTree("emissiveTexture");
SetInterpolationForKey("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/scale", emissiveTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/offset", emissiveTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/emissiveTexture/extensions/KHR_texture_transform/rotation", emissiveTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyStrength", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "anisotropy.intensity", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyRotation", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "anisotropy.angle", getFloat, () => 1)
]);
var anisotropyTextureInterpolation = getTextureTransformTree("anisotropy.texture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/scale", anisotropyTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/offset", anisotropyTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_anisotropy/anisotropyTexture/extensions/KHR_texture_transform/rotation", anisotropyTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.intensity", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.roughness", getFloat, () => 1)
]);
var clearcoatTextureInterpolation = getTextureTransformTree("clearCoat.texture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/scale", clearcoatTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/offset", clearcoatTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatTexture/extensions/KHR_texture_transform/rotation", clearcoatTextureInterpolation.rotation);
var clearcoatNormalTextureInterpolation = getTextureTransformTree("clearCoat.bumpTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/scale", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "clearCoat.bumpTexture.level", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/scale", clearcoatNormalTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/offset", clearcoatNormalTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatNormalTexture/extensions/KHR_texture_transform/rotation", clearcoatNormalTextureInterpolation.rotation);
var clearcoatRoughnessTextureInterpolation = getTextureTransformTree("clearCoat.textureRoughness");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/scale", clearcoatRoughnessTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/offset", clearcoatRoughnessTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_clearcoat/clearcoatRoughnessTexture/extensions/KHR_texture_transform/rotation", clearcoatRoughnessTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_dispersion/dispersionFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.dispersion", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_emissive_strength/emissiveStrength", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "emissiveIntensity", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_ior/ior", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "indexOfRefraction", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.intensity", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceIor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.indexOfRefraction", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMinimum", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.minimumThickness", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessMaximum", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "iridescence.maximumThickness", getFloat, () => 1)
]);
var iridescenceTextureInterpolation = getTextureTransformTree("iridescence.texture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/scale", iridescenceTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/offset", iridescenceTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceTexture/extensions/KHR_texture_transform/rotation", iridescenceTextureInterpolation.rotation);
var iridescenceThicknessTextureInterpolation = getTextureTransformTree("iridescence.thicknessTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/scale", iridescenceThicknessTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/offset", iridescenceThicknessTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_iridescence/iridescenceThicknessTexture/extensions/KHR_texture_transform/rotation", iridescenceThicknessTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenColorFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "sheen.color", getColor3, () => 3)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "sheen.roughness", getFloat, () => 1)
]);
var sheenTextureInterpolation = getTextureTransformTree("sheen.texture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/scale", sheenTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/offset", sheenTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenColorTexture/extensions/KHR_texture_transform/rotation", sheenTextureInterpolation.rotation);
var sheenRoughnessTextureInterpolation = getTextureTransformTree("sheen.textureRoughness");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/scale", sheenRoughnessTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/offset", sheenRoughnessTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_sheen/sheenRoughnessTexture/extensions/KHR_texture_transform/rotation", sheenRoughnessTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "metallicF0Factor", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularColorFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "metallicReflectanceColor", getColor3, () => 3)
]);
var specularTextureInterpolation = getTextureTransformTree("metallicReflectanceTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/scale", specularTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/offset", specularTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularTexture/extensions/KHR_texture_transform/rotation", specularTextureInterpolation.rotation);
var specularColorTextureInterpolation = getTextureTransformTree("reflectanceTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/scale", specularColorTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/offset", specularColorTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_specular/specularColorTexture/extensions/KHR_texture_transform/rotation", specularColorTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_transmission/transmissionFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.refractionIntensity", getFloat, () => 1)
]);
var transmissionTextureInterpolation = getTextureTransformTree("subSurface.refractionIntensityTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/scale", transmissionTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/offset", transmissionTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_transmission/transmissionTexture/extensions/KHR_texture_transform/rotation", transmissionTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/attenuationColor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "subSurface.tintColor", getColor3, () => 3)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/attenuationDistance", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.tintColorAtDistance", getFloat, () => 1)
]);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/thicknessFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.maximumThickness", getFloat, () => 1)
]);
var thicknessTextureInterpolation = getTextureTransformTree("subSurface.thicknessTexture");
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/scale", thicknessTextureInterpolation.scale);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/offset", thicknessTextureInterpolation.offset);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_volume/thicknessTexture/extensions/KHR_texture_transform/rotation", thicknessTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "subSurface.translucencyIntensity", getFloat, () => 1)
]);
var diffuseTransmissionTextureInterpolation = getTextureTransformTree("subSurface.translucencyIntensityTexture");
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionTextureInterpolation.scale);
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionTextureInterpolation.offset);
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionTextureInterpolation.rotation);
SetInterpolationForKey("/materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorFactor", [
  new MaterialAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "subSurface.translucencyColor", getColor3, () => 3)
]);
var diffuseTransmissionColorTextureInterpolation = getTextureTransformTree("subSurface.translucencyColorTexture");
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/scale", diffuseTransmissionColorTextureInterpolation.scale);
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/offset", diffuseTransmissionColorTextureInterpolation.offset);
SetInterpolationForKey("materials/{}/extensions/KHR_materials_diffuse_transmission/diffuseTransmissionColorTexture/extensions/KHR_texture_transform/rotation", diffuseTransmissionColorTextureInterpolation.rotation);
SetInterpolationForKey("/extensions/KHR_lights_punctual/lights/{}/color", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, () => 3)]);
SetInterpolationForKey("/extensions/KHR_lights_punctual/lights/{}/intensity", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, () => 1)]);
SetInterpolationForKey("/extensions/KHR_lights_punctual/lights/{}/range", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "range", getFloat, () => 1)]);
SetInterpolationForKey("/extensions/KHR_lights_punctual/lights/{}/spot/innerConeAngle", [
  new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "innerAngle", getFloatBy2, () => 1)
]);
SetInterpolationForKey("/extensions/KHR_lights_punctual/lights/{}/spot/outerConeAngle", [
  new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "angle", getFloatBy2, () => 1)
]);
SetInterpolationForKey("/nodes/{}/extensions/EXT_lights_ies/color", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_COLOR3, "diffuse", getColor3, () => 3)]);
SetInterpolationForKey("/nodes/{}/extensions/EXT_lights_ies/multiplier", [new LightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "intensity", getFloat, () => 1)]);
SetInterpolationForKey("/nodes/{}/extensions/KHR_node_visibility/visible", [new MeshAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, "isVisible", getFloat, () => 1)]);

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_animation_pointer.js
var NAME29 = "KHR_animation_pointer";
var KHR_animation_pointer = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME29;
    this._loader = loader;
    this._pathToObjectConverter = GetPathToObjectConverter(this._loader.gltf);
  }
  /**
   * Defines whether this extension is enabled.
   */
  get enabled() {
    return this._loader.isExtensionUsed(NAME29);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    delete this._pathToObjectConverter;
  }
  /**
   * Loads a glTF animation channel.
   * @param context The context when loading the asset
   * @param animationContext The context of the animation when loading the asset
   * @param animation The glTF animation property
   * @param channel The glTF animation channel property
   * @param onLoad Called for each animation loaded
   * @returns A void promise that resolves when the load is complete or null if not handled
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad) {
    const extension = channel.target.extensions?.KHR_animation_pointer;
    if (!extension || !this._pathToObjectConverter) {
      return null;
    }
    if (channel.target.path !== "pointer") {
      Logger.Warn(`${context}/target/path: Value (${channel.target.path}) must be (${"pointer"}) when using the ${this.name} extension`);
    }
    if (channel.target.node != void 0) {
      Logger.Warn(`${context}/target/node: Value (${channel.target.node}) must not be present when using the ${this.name} extension`);
    }
    const extensionContext = `${context}/extensions/${this.name}`;
    const pointer = extension.pointer;
    if (!pointer) {
      throw new Error(`${extensionContext}: Pointer is missing`);
    }
    try {
      const obj = this._pathToObjectConverter.convert(pointer);
      if (!obj.info.interpolation) {
        throw new Error(`${extensionContext}/pointer: Interpolation is missing`);
      }
      return this._loader._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, {
        object: obj.object,
        info: obj.info.interpolation
      }, onLoad);
    } catch (e) {
      Logger.Warn(`${extensionContext}/pointer: Invalid pointer (${pointer}) skipped`);
      return null;
    }
  }
};
unregisterGLTFExtension(NAME29);
registerGLTFExtension(NAME29, true, (loader) => new KHR_animation_pointer(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_audio_emitter.js
var NAME30 = "MSFT_audio_emitter";
var MSFT_audio_emitter = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME30;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME30);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    this._clips = null;
    this._emitters = null;
  }
  /** @internal */
  onLoading() {
    const extensions = this._loader.gltf.extensions;
    if (extensions && extensions[this.name]) {
      const extension = extensions[this.name];
      this._clips = extension.clips;
      this._emitters = extension.emitters;
      ArrayItem.Assign(this._clips);
      ArrayItem.Assign(this._emitters);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadSceneAsync(context, scene) {
    return GLTFLoader2.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      promises.push(this._loader.loadSceneAsync(context, scene));
      for (const emitterIndex of extension.emitters) {
        const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);
        if (emitter.refDistance != void 0 || emitter.maxDistance != void 0 || emitter.rolloffFactor != void 0 || emitter.distanceModel != void 0 || emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
          throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);
        }
        promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));
      }
      await Promise.all(promises);
    });
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      const promises = new Array();
      const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh2) => {
        for (const emitterIndex of extension.emitters) {
          const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);
          promises.push(
            // eslint-disable-next-line github/no-then
            this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {
              for (const sound of emitter._babylonSounds) {
                sound.attachToMesh(babylonMesh2);
                if (emitter.innerAngle != void 0 || emitter.outerAngle != void 0) {
                  sound.setLocalDirectionToMesh(Vector3.Forward());
                  sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == void 0 ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == void 0 ? Math.PI : emitter.outerAngle), 0);
                }
              }
            })
          );
        }
        assign(babylonMesh2);
      });
      await Promise.all(promises);
      return babylonMesh;
    });
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadAnimationAsync(context, animation) {
    return GLTFLoader2.LoadExtensionAsync(context, animation, this.name, async (extensionContext, extension) => {
      const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);
      const promises = new Array();
      ArrayItem.Assign(extension.events);
      for (const event of extension.events) {
        promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));
      }
      await Promise.all(promises);
      return babylonAnimationGroup;
    });
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadClipAsync(context, clip) {
    if (clip._objectURL) {
      return clip._objectURL;
    }
    let promise;
    if (clip.uri) {
      promise = this._loader.loadUriAsync(context, clip, clip.uri);
    } else {
      const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);
      promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);
    }
    clip._objectURL = promise.then((data) => {
      return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));
    });
    return clip._objectURL;
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadEmitterAsync(context, emitter) {
    emitter._babylonSounds = emitter._babylonSounds || [];
    if (!emitter._babylonData) {
      const clipPromises = new Array();
      const name2 = emitter.name || `emitter${emitter.index}`;
      const options = {
        loop: false,
        autoplay: false,
        volume: emitter.volume == void 0 ? 1 : emitter.volume
      };
      for (let i = 0; i < emitter.clips.length; i++) {
        const clipContext = `/extensions/${this.name}/clips`;
        const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);
        clipPromises.push(
          // eslint-disable-next-line github/no-then
          this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {
            const sound = emitter._babylonSounds[i] = new Sound(name2, objectURL, this._loader.babylonScene, null, options);
            sound.refDistance = emitter.refDistance || 1;
            sound.maxDistance = emitter.maxDistance || 256;
            sound.rolloffFactor = emitter.rolloffFactor || 1;
            sound.distanceModel = emitter.distanceModel || "exponential";
          })
        );
      }
      const promise = Promise.all(clipPromises).then(() => {
        const weights = emitter.clips.map((clip) => {
          return clip.weight || 1;
        });
        const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);
        if (emitter.innerAngle) {
          weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);
        }
        if (emitter.outerAngle) {
          weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);
        }
        if (emitter.volume) {
          weightedSound.volume = emitter.volume;
        }
        emitter._babylonData.sound = weightedSound;
      });
      emitter._babylonData = {
        loaded: promise
      };
    }
    return emitter._babylonData.loaded;
  }
  _getEventAction(context, sound, action, time, startOffset) {
    switch (action) {
      case "play": {
        return (currentFrame) => {
          const frameOffset = (startOffset || 0) + (currentFrame - time);
          sound.play(frameOffset);
        };
      }
      case "stop": {
        return () => {
          sound.stop();
        };
      }
      case "pause": {
        return () => {
          sound.pause();
        };
      }
      default: {
        throw new Error(`${context}: Unsupported action ${action}`);
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {
    if (babylonAnimationGroup.targetedAnimations.length == 0) {
      return Promise.resolve();
    }
    const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];
    const emitterIndex = event.emitter;
    const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);
    return this._loadEmitterAsync(context, emitter).then(() => {
      const sound = emitter._babylonData.sound;
      if (sound) {
        const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));
        babylonAnimation.animation.addEvent(babylonAnimationEvent);
        babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {
          sound.stop();
        });
        babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {
          sound.pause();
        });
      }
    });
  }
};
unregisterGLTFExtension(NAME30);
registerGLTFExtension(NAME30, true, (loader) => new MSFT_audio_emitter(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_lod.js
var NAME31 = "MSFT_lod";
var MSFT_lod = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME31;
    this.order = 100;
    this.maxLODsToLoad = 10;
    this.onNodeLODsLoadedObservable = new Observable();
    this.onMaterialLODsLoadedObservable = new Observable();
    this._bufferLODs = new Array();
    this._nodeIndexLOD = null;
    this._nodeSignalLODs = new Array();
    this._nodePromiseLODs = new Array();
    this._nodeBufferLODs = new Array();
    this._materialIndexLOD = null;
    this._materialSignalLODs = new Array();
    this._materialPromiseLODs = new Array();
    this._materialBufferLODs = new Array();
    this._loader = loader;
    this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME31]?.maxLODsToLoad ?? this.maxLODsToLoad;
    this.enabled = this._loader.isExtensionUsed(NAME31);
  }
  /** @internal */
  dispose() {
    this._loader = null;
    this._nodeIndexLOD = null;
    this._nodeSignalLODs.length = 0;
    this._nodePromiseLODs.length = 0;
    this._nodeBufferLODs.length = 0;
    this._materialIndexLOD = null;
    this._materialSignalLODs.length = 0;
    this._materialPromiseLODs.length = 0;
    this._materialBufferLODs.length = 0;
    this.onMaterialLODsLoadedObservable.clear();
    this.onNodeLODsLoadedObservable.clear();
  }
  /** @internal */
  onReady() {
    for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {
      const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {
        if (indexLOD !== 0) {
          this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);
          this._loader.log(`Loaded node LOD ${indexLOD}`);
        }
        this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);
        if (indexLOD !== this._nodePromiseLODs.length - 1) {
          this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);
          this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);
          if (this._nodeSignalLODs[indexLOD]) {
            this._nodeSignalLODs[indexLOD].resolve();
          }
        }
      });
      this._loader._completePromises.push(promise);
    }
    for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {
      const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {
        if (indexLOD !== 0) {
          this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);
          this._loader.log(`Loaded material LOD ${indexLOD}`);
        }
        this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);
        if (indexLOD !== this._materialPromiseLODs.length - 1) {
          this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);
          this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);
          if (this._materialSignalLODs[indexLOD]) {
            this._materialSignalLODs[indexLOD].resolve();
          }
        }
      });
      this._loader._completePromises.push(promise);
    }
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadSceneAsync(context, scene) {
    const promise = this._loader.loadSceneAsync(context, scene);
    this._loadBufferLOD(this._bufferLODs, 0);
    return promise;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return GLTFLoader2.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {
      let firstPromise;
      const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);
      this._loader.logOpen(`${extensionContext}`);
      for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {
        const nodeLOD = nodeLODs[indexLOD];
        if (indexLOD !== 0) {
          this._nodeIndexLOD = indexLOD;
          this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();
        }
        const assignWrap = (babylonTransformNode) => {
          assign(babylonTransformNode);
          babylonTransformNode.setEnabled(false);
        };
        const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {
          if (indexLOD !== 0) {
            const previousNodeLOD = nodeLODs[indexLOD - 1];
            if (previousNodeLOD._babylonTransformNode) {
              this._disposeTransformNode(previousNodeLOD._babylonTransformNode);
              delete previousNodeLOD._babylonTransformNode;
            }
          }
          babylonMesh.setEnabled(true);
          return babylonMesh;
        });
        this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];
        if (indexLOD === 0) {
          firstPromise = promise;
        } else {
          this._nodeIndexLOD = null;
          this._nodePromiseLODs[indexLOD].push(promise);
        }
      }
      this._loader.logClose();
      return await firstPromise;
    });
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {
    if (this._nodeIndexLOD) {
      return null;
    }
    return GLTFLoader2.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {
      let firstPromise;
      const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);
      this._loader.logOpen(`${extensionContext}`);
      for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {
        const materialLOD = materialLODs[indexLOD];
        if (indexLOD !== 0) {
          this._materialIndexLOD = indexLOD;
        }
        const promise = this._loader._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {
          if (indexLOD === 0) {
            assign(babylonMaterial);
          }
        }).then((babylonMaterial) => {
          if (indexLOD !== 0) {
            assign(babylonMaterial);
            const previousDataLOD = materialLODs[indexLOD - 1]._data;
            if (previousDataLOD[babylonDrawMode]) {
              this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);
              delete previousDataLOD[babylonDrawMode];
            }
          }
          return babylonMaterial;
        });
        this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];
        if (indexLOD === 0) {
          firstPromise = promise;
        } else {
          this._materialIndexLOD = null;
          this._materialPromiseLODs[indexLOD].push(promise);
        }
      }
      this._loader.logClose();
      return await firstPromise;
    });
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  _loadUriAsync(context, property, uri) {
    if (this._nodeIndexLOD !== null) {
      this._loader.log(`deferred`);
      const previousIndexLOD = this._nodeIndexLOD - 1;
      this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();
      return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {
        return await this._loader.loadUriAsync(context, property, uri);
      });
    } else if (this._materialIndexLOD !== null) {
      this._loader.log(`deferred`);
      const previousIndexLOD = this._materialIndexLOD - 1;
      this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();
      return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {
        return await this._loader.loadUriAsync(context, property, uri);
      });
    }
    return null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadBufferAsync(context, buffer, byteOffset, byteLength) {
    if (this._loader.parent.useRangeRequests && !buffer.uri) {
      if (!this._loader.bin) {
        throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);
      }
      const loadAsync = async (bufferLODs, indexLOD) => {
        const start = byteOffset;
        const end = start + byteLength - 1;
        let bufferLOD = bufferLODs[indexLOD];
        if (bufferLOD) {
          bufferLOD.start = Math.min(bufferLOD.start, start);
          bufferLOD.end = Math.max(bufferLOD.end, end);
        } else {
          bufferLOD = { start, end, loaded: new Deferred() };
          bufferLODs[indexLOD] = bufferLOD;
        }
        return await bufferLOD.loaded.promise.then((data) => {
          return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);
        });
      };
      this._loader.log(`deferred`);
      if (this._nodeIndexLOD !== null) {
        return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);
      } else if (this._materialIndexLOD !== null) {
        return loadAsync(this._materialBufferLODs, this._materialIndexLOD);
      } else {
        return loadAsync(this._bufferLODs, 0);
      }
    }
    return null;
  }
  _loadBufferLOD(bufferLODs, indexLOD) {
    const bufferLOD = bufferLODs[indexLOD];
    if (bufferLOD) {
      this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);
      this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {
        bufferLOD.loaded.resolve(data);
      }, (error) => {
        bufferLOD.loaded.reject(error);
      });
    }
  }
  /**
   * @returns an array of LOD properties from lowest to highest.
   * @param context
   * @param property
   * @param array
   * @param ids
   */
  _getLODs(context, property, array, ids) {
    if (this.maxLODsToLoad <= 0) {
      throw new Error("maxLODsToLoad must be greater than zero");
    }
    const properties = [];
    for (let i = ids.length - 1; i >= 0; i--) {
      properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));
      if (properties.length === this.maxLODsToLoad) {
        return properties;
      }
    }
    properties.push(property);
    return properties;
  }
  _disposeTransformNode(babylonTransformNode) {
    const babylonMaterials = [];
    const babylonMaterial = babylonTransformNode.material;
    if (babylonMaterial) {
      babylonMaterials.push(babylonMaterial);
    }
    for (const babylonMesh of babylonTransformNode.getChildMeshes()) {
      if (babylonMesh.material) {
        babylonMaterials.push(babylonMesh.material);
      }
    }
    babylonTransformNode.dispose();
    const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial2) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial2));
    this._disposeMaterials(babylonMaterialsToDispose);
  }
  _disposeMaterials(babylonMaterials) {
    const babylonTextures = {};
    for (const babylonMaterial of babylonMaterials) {
      for (const babylonTexture of babylonMaterial.getActiveTextures()) {
        babylonTextures[babylonTexture.uniqueId] = babylonTexture;
      }
      babylonMaterial.dispose();
    }
    for (const uniqueId in babylonTextures) {
      for (const babylonMaterial of this._loader.babylonScene.materials) {
        if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {
          delete babylonTextures[uniqueId];
        }
      }
    }
    for (const uniqueId in babylonTextures) {
      babylonTextures[uniqueId].dispose();
    }
  }
};
unregisterGLTFExtension(NAME31);
registerGLTFExtension(NAME31, true, (loader) => new MSFT_lod(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_minecraftMesh.js
var NAME32 = "MSFT_minecraftMesh";
var MSFT_minecraftMesh = class {
  /** @internal */
  constructor(loader) {
    this.name = NAME32;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME32);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /** @internal */
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, async (extraContext, extra) => {
      if (extra) {
        if (!this._loader._pbrMaterialImpl) {
          throw new Error(`${extraContext}: Material type not supported`);
        }
        const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        if (babylonMaterial.needAlphaBlending()) {
          babylonMaterial.forceDepthWrite = true;
          babylonMaterial.separateCullingPass = true;
        }
        babylonMaterial.backFaceCulling = babylonMaterial.forceDepthWrite;
        babylonMaterial.twoSidedLighting = true;
        return await promise;
      }
    });
  }
};
unregisterGLTFExtension(NAME32);
registerGLTFExtension(NAME32, true, (loader) => new MSFT_minecraftMesh(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/MSFT_sRGBFactors.js
var NAME33 = "MSFT_sRGBFactors";
var MSFT_sRGBFactors = class {
  /** @internal */
  constructor(loader) {
    this.name = NAME33;
    this._loader = loader;
    this.enabled = this._loader.isExtensionUsed(NAME33);
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /** @internal*/
  // eslint-disable-next-line no-restricted-syntax
  loadMaterialPropertiesAsync(context, material, babylonMaterial) {
    return GLTFLoader2.LoadExtraAsync(context, material, this.name, async (extraContext, extra) => {
      if (extra) {
        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);
        const promise = this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial);
        const useExactSrgbConversions = babylonMaterial.getScene().getEngine().useExactSrgbConversions;
        if (!adapter.baseColorTexture) {
          adapter.baseColor.toLinearSpaceToRef(adapter.baseColor, useExactSrgbConversions);
        }
        if (!adapter.specularColorTexture) {
          adapter.specularColor.toLinearSpaceToRef(adapter.specularColor, useExactSrgbConversions);
        }
        return await promise;
      }
    });
  }
};
unregisterGLTFExtension(NAME33);
registerGLTFExtension(NAME33, true, (loader) => new MSFT_sRGBFactors(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.js
function getMappingForFullOperationName(fullOperationName) {
  const [op, extension] = fullOperationName.split(":");
  return getMappingForDeclaration({ op, extension });
}
function getMappingForDeclaration(declaration, returnNoOpIfNotAvailable = true) {
  const mapping = declaration.extension ? gltfExtensionsToFlowGraphMapping[declaration.extension]?.[declaration.op] : gltfToFlowGraphMapping[declaration.op];
  if (!mapping) {
    Logger.Warn(`No mapping found for operation ${declaration.op} and extension ${declaration.extension || "KHR_interactivity"}`);
    if (returnNoOpIfNotAvailable) {
      const inputs = {};
      const outputs = {
        flows: {}
      };
      if (declaration.inputValueSockets) {
        inputs.values = {};
        for (const key in declaration.inputValueSockets) {
          inputs.values[key] = {
            name: key
          };
        }
      }
      if (declaration.outputValueSockets) {
        outputs.values = {};
        Object.keys(declaration.outputValueSockets).forEach((key) => {
          outputs.values[key] = {
            name: key
          };
        });
      }
      return {
        blocks: [],
        // no blocks, just mapping
        inputs,
        outputs
      };
    }
  }
  return mapping;
}
function addNewInteractivityFlowGraphMapping(key, extension, mapping) {
  gltfExtensionsToFlowGraphMapping[extension] || (gltfExtensionsToFlowGraphMapping[extension] = {});
  gltfExtensionsToFlowGraphMapping[extension][key] = mapping;
}
var gltfExtensionsToFlowGraphMapping = {
  /**
   * This is the BABYLON extension for glTF interactivity.
   * It defines babylon-specific blocks and operations.
   */
  BABYLON: {
    /**
     * flow/log is a flow node that logs input to the console.
     * It has "in" and "out" flows, and takes a message as input.
     * The message can be any type of value.
     * The message is logged to the console when the "in" flow is triggered.
     * The "out" flow is triggered when the message is logged.
     */
    "flow/log": {
      blocks: [
        "FlowGraphConsoleLogBlock"
        /* FlowGraphBlockNames.ConsoleLog */
      ],
      inputs: {
        values: {
          message: { name: "message" }
        }
      }
    }
  }
};
var gltfToFlowGraphMapping = {
  "event/onStart": {
    blocks: [
      "FlowGraphSceneReadyEventBlock"
      /* FlowGraphBlockNames.SceneReadyEvent */
    ],
    outputs: {
      flows: {
        out: { name: "done" }
      }
    }
  },
  "event/onTick": {
    blocks: [
      "FlowGraphSceneTickEventBlock"
      /* FlowGraphBlockNames.SceneTickEvent */
    ],
    inputs: {},
    outputs: {
      values: {
        timeSinceLastTick: {
          name: "deltaTime",
          gltfType: "number"
          /*, dataTransformer: (time: number) => time / 1000*/
        }
      },
      flows: {
        out: { name: "done" }
      }
    }
  },
  "event/send": {
    blocks: [
      "FlowGraphSendCustomEventBlock"
      /* FlowGraphBlockNames.SendCustomEvent */
    ],
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      if (declaration.op !== "event/send" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
        throw new Error("Receive event should have a single configuration object, the event itself");
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        throw new Error("Event id should be a number");
      }
      const event = parser.arrays.events[eventId];
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.eventId = event.eventId;
      serializedObject.config.eventData = event.eventData;
      return serializedObjects;
    }
  },
  "event/receive": {
    blocks: [
      "FlowGraphReceiveCustomEventBlock"
      /* FlowGraphBlockNames.ReceiveCustomEvent */
    ],
    outputs: {
      flows: {
        out: { name: "done" }
      }
    },
    validation(gltfBlock, interactivityGraph) {
      if (!gltfBlock.configuration) {
        Logger.Error("Receive event should have a configuration object");
        return { valid: false, error: "Receive event should have a configuration object" };
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      if (!eventConfiguration) {
        Logger.Error("Receive event should have a single configuration object, the event itself");
        return { valid: false, error: "Receive event should have a single configuration object, the event itself" };
      }
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        Logger.Error("Event id should be a number");
        return { valid: false, error: "Event id should be a number" };
      }
      const event = interactivityGraph.events?.[eventId];
      if (!event) {
        Logger.Error(`Event with id ${eventId} not found`);
        return { valid: false, error: `Event with id ${eventId} not found` };
      }
      return { valid: true };
    },
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      if (declaration.op !== "event/receive" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {
        throw new Error("Receive event should have a single configuration object, the event itself");
      }
      const eventConfiguration = gltfBlock.configuration["event"];
      const eventId = eventConfiguration.value[0];
      if (typeof eventId !== "number") {
        throw new Error("Event id should be a number");
      }
      const event = parser.arrays.events[eventId];
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.eventId = event.eventId;
      serializedObject.config.eventData = event.eventData;
      return serializedObjects;
    }
  },
  "math/E": getSimpleInputMapping(
    "FlowGraphEBlock"
    /* FlowGraphBlockNames.E */
  ),
  "math/Pi": getSimpleInputMapping(
    "FlowGraphPIBlock"
    /* FlowGraphBlockNames.PI */
  ),
  "math/Inf": getSimpleInputMapping(
    "FlowGraphInfBlock"
    /* FlowGraphBlockNames.Inf */
  ),
  "math/NaN": getSimpleInputMapping(
    "FlowGraphNaNBlock"
    /* FlowGraphBlockNames.NaN */
  ),
  "math/abs": getSimpleInputMapping(
    "FlowGraphAbsBlock"
    /* FlowGraphBlockNames.Abs */
  ),
  "math/sign": getSimpleInputMapping(
    "FlowGraphSignBlock"
    /* FlowGraphBlockNames.Sign */
  ),
  "math/trunc": getSimpleInputMapping(
    "FlowGraphTruncBlock"
    /* FlowGraphBlockNames.Trunc */
  ),
  "math/floor": getSimpleInputMapping(
    "FlowGraphFloorBlock"
    /* FlowGraphBlockNames.Floor */
  ),
  "math/ceil": getSimpleInputMapping(
    "FlowGraphCeilBlock"
    /* FlowGraphBlockNames.Ceil */
  ),
  "math/round": {
    blocks: [
      "FlowGraphRoundBlock"
      /* FlowGraphBlockNames.Round */
    ],
    configuration: {},
    inputs: {
      values: {
        a: { name: "a" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.roundHalfAwayFromZero = true;
      return serializedObjects;
    }
  },
  "math/fract": getSimpleInputMapping(
    "FlowGraphFractBlock"
    /* FlowGraphBlockNames.Fraction */
  ),
  "math/neg": getSimpleInputMapping(
    "FlowGraphNegationBlock"
    /* FlowGraphBlockNames.Negation */
  ),
  "math/add": getSimpleInputMapping("FlowGraphAddBlock", ["a", "b"], true),
  "math/sub": getSimpleInputMapping("FlowGraphSubtractBlock", ["a", "b"], true),
  "math/mul": {
    blocks: [
      "FlowGraphMultiplyBlock"
      /* FlowGraphBlockNames.Multiply */
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.useMatrixPerComponent = true;
      serializedObjects[0].config.preventIntegerFloatArithmetic = true;
      let type = -1;
      Object.keys(_gltfBlock.values || {}).find((value) => {
        if (_gltfBlock.values?.[value].type !== void 0) {
          type = _gltfBlock.values[value].type;
          return true;
        }
        return false;
      });
      if (type !== -1) {
        serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;
      }
      return serializedObjects;
    },
    validation(gltfBlock) {
      if (gltfBlock.values) {
        return ValidateTypes(gltfBlock);
      }
      return { valid: true };
    }
  },
  "math/div": getSimpleInputMapping("FlowGraphDivideBlock", ["a", "b"], true),
  "math/rem": getSimpleInputMapping("FlowGraphModuloBlock", ["a", "b"]),
  "math/min": getSimpleInputMapping("FlowGraphMinBlock", ["a", "b"]),
  "math/max": getSimpleInputMapping("FlowGraphMaxBlock", ["a", "b"]),
  "math/clamp": getSimpleInputMapping("FlowGraphClampBlock", ["a", "b", "c"]),
  "math/saturate": getSimpleInputMapping(
    "FlowGraphSaturateBlock"
    /* FlowGraphBlockNames.Saturate */
  ),
  "math/mix": getSimpleInputMapping("FlowGraphMathInterpolationBlock", ["a", "b", "c"]),
  "math/eq": getSimpleInputMapping("FlowGraphEqualityBlock", ["a", "b"]),
  "math/lt": getSimpleInputMapping("FlowGraphLessThanBlock", ["a", "b"]),
  "math/le": getSimpleInputMapping("FlowGraphLessThanOrEqualBlock", ["a", "b"]),
  "math/gt": getSimpleInputMapping("FlowGraphGreaterThanBlock", ["a", "b"]),
  "math/ge": getSimpleInputMapping("FlowGraphGreaterThanOrEqualBlock", ["a", "b"]),
  "math/isNaN": getSimpleInputMapping(
    "FlowGraphIsNaNBlock"
    /* FlowGraphBlockNames.IsNaN */
  ),
  "math/isInf": getSimpleInputMapping(
    "FlowGraphIsInfBlock"
    /* FlowGraphBlockNames.IsInfinity */
  ),
  "math/select": {
    blocks: [
      "FlowGraphConditionalBlock"
      /* FlowGraphBlockNames.Conditional */
    ],
    inputs: {
      values: {
        condition: { name: "condition" },
        // Should we validate those have the same type here, or assume it is already validated?
        a: { name: "onTrue" },
        b: { name: "onFalse" }
      }
    },
    outputs: {
      values: {
        value: { name: "output" }
      }
    }
  },
  "math/random": {
    blocks: [
      "FlowGraphRandomBlock"
      /* FlowGraphBlockNames.Random */
    ],
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/sin": getSimpleInputMapping(
    "FlowGraphSinBlock"
    /* FlowGraphBlockNames.Sin */
  ),
  "math/cos": getSimpleInputMapping(
    "FlowGraphCosBlock"
    /* FlowGraphBlockNames.Cos */
  ),
  "math/tan": getSimpleInputMapping(
    "FlowGraphTanBlock"
    /* FlowGraphBlockNames.Tan */
  ),
  "math/asin": getSimpleInputMapping(
    "FlowGraphASinBlock"
    /* FlowGraphBlockNames.Asin */
  ),
  "math/acos": getSimpleInputMapping(
    "FlowGraphACosBlock"
    /* FlowGraphBlockNames.Acos */
  ),
  "math/atan": getSimpleInputMapping(
    "FlowGraphATanBlock"
    /* FlowGraphBlockNames.Atan */
  ),
  "math/atan2": getSimpleInputMapping("FlowGraphATan2Block", ["a", "b"]),
  "math/sinh": getSimpleInputMapping(
    "FlowGraphSinhBlock"
    /* FlowGraphBlockNames.Sinh */
  ),
  "math/cosh": getSimpleInputMapping(
    "FlowGraphCoshBlock"
    /* FlowGraphBlockNames.Cosh */
  ),
  "math/tanh": getSimpleInputMapping(
    "FlowGraphTanhBlock"
    /* FlowGraphBlockNames.Tanh */
  ),
  "math/asinh": getSimpleInputMapping(
    "FlowGraphASinhBlock"
    /* FlowGraphBlockNames.Asinh */
  ),
  "math/acosh": getSimpleInputMapping(
    "FlowGraphACoshBlock"
    /* FlowGraphBlockNames.Acosh */
  ),
  "math/atanh": getSimpleInputMapping(
    "FlowGraphATanhBlock"
    /* FlowGraphBlockNames.Atanh */
  ),
  "math/exp": getSimpleInputMapping(
    "FlowGraphExponentialBlock"
    /* FlowGraphBlockNames.Exponential */
  ),
  "math/log": getSimpleInputMapping(
    "FlowGraphLogBlock"
    /* FlowGraphBlockNames.Log */
  ),
  "math/log2": getSimpleInputMapping(
    "FlowGraphLog2Block"
    /* FlowGraphBlockNames.Log2 */
  ),
  "math/log10": getSimpleInputMapping(
    "FlowGraphLog10Block"
    /* FlowGraphBlockNames.Log10 */
  ),
  "math/sqrt": getSimpleInputMapping(
    "FlowGraphSquareRootBlock"
    /* FlowGraphBlockNames.SquareRoot */
  ),
  "math/cbrt": getSimpleInputMapping(
    "FlowGraphCubeRootBlock"
    /* FlowGraphBlockNames.CubeRoot */
  ),
  "math/pow": getSimpleInputMapping("FlowGraphPowerBlock", ["a", "b"]),
  "math/length": getSimpleInputMapping(
    "FlowGraphLengthBlock"
    /* FlowGraphBlockNames.Length */
  ),
  "math/normalize": getSimpleInputMapping(
    "FlowGraphNormalizeBlock"
    /* FlowGraphBlockNames.Normalize */
  ),
  "math/dot": getSimpleInputMapping("FlowGraphDotBlock", ["a", "b"]),
  "math/cross": getSimpleInputMapping("FlowGraphCrossBlock", ["a", "b"]),
  "math/rotate2D": {
    blocks: [
      "FlowGraphRotate2DBlock"
      /* FlowGraphBlockNames.Rotate2D */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        angle: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/rotate3D": {
    blocks: [
      "FlowGraphRotate3DBlock"
      /* FlowGraphBlockNames.Rotate3D */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        rotation: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/transform": {
    // glTF transform is vectorN with matrixN
    blocks: [
      "FlowGraphTransformVectorBlock"
      /* FlowGraphBlockNames.TransformVector */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine2": {
    blocks: [
      "FlowGraphCombineVector2Block"
      /* FlowGraphBlockNames.CombineVector2 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine3": {
    blocks: [
      "FlowGraphCombineVector3Block"
      /* FlowGraphBlockNames.CombineVector3 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/combine4": {
    blocks: [
      "FlowGraphCombineVector4Block"
      /* FlowGraphBlockNames.CombineVector4 */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  // one input, N outputs! outputs named using numbers.
  "math/extract2": {
    blocks: [
      "FlowGraphExtractVector2Block"
      /* FlowGraphBlockNames.ExtractVector2 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" }
      }
    }
  },
  "math/extract3": {
    blocks: [
      "FlowGraphExtractVector3Block"
      /* FlowGraphBlockNames.ExtractVector3 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" }
      }
    }
  },
  "math/extract4": {
    blocks: [
      "FlowGraphExtractVector4Block"
      /* FlowGraphBlockNames.ExtractVector4 */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" }
      }
    }
  },
  "math/transpose": getSimpleInputMapping(
    "FlowGraphTransposeBlock"
    /* FlowGraphBlockNames.Transpose */
  ),
  "math/determinant": getSimpleInputMapping(
    "FlowGraphDeterminantBlock"
    /* FlowGraphBlockNames.Determinant */
  ),
  "math/inverse": getSimpleInputMapping(
    "FlowGraphInvertMatrixBlock"
    /* FlowGraphBlockNames.InvertMatrix */
  ),
  "math/matMul": getSimpleInputMapping("FlowGraphMatrixMultiplicationBlock", ["a", "b"]),
  "math/matCompose": {
    blocks: [
      "FlowGraphMatrixCompose"
      /* FlowGraphBlockNames.MatrixCompose */
    ],
    inputs: {
      values: {
        translation: { name: "position", gltfType: "float3" },
        rotation: { name: "rotationQuaternion", gltfType: "float4" },
        scale: { name: "scaling", gltfType: "float3" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      const d = serializedObjects[0].dataInputs.find((input) => input.name === "rotationQuaternion");
      if (!d) {
        throw new Error("Rotation quaternion input not found");
      }
      if (context._connectionValues[d.uniqueId]) {
        context._connectionValues[d.uniqueId].type = "Quaternion";
      }
      return serializedObjects;
    }
  },
  "math/matDecompose": {
    blocks: [
      "FlowGraphMatrixDecompose"
      /* FlowGraphBlockNames.MatrixDecompose */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        translation: { name: "position" },
        rotation: { name: "rotationQuaternion" },
        scale: { name: "scaling" }
      }
    }
  },
  "math/quatConjugate": getSimpleInputMapping("FlowGraphConjugateBlock", ["a"]),
  "math/quatMul": {
    blocks: [
      "FlowGraphMultiplyBlock"
      /* FlowGraphBlockNames.Multiply */
    ],
    inputs: {
      values: {
        a: { name: "a", gltfType: "vector4" },
        b: { name: "b", gltfType: "vector4" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.type = "Quaternion";
      return serializedObjects;
    }
  },
  "math/quatAngleBetween": getSimpleInputMapping("FlowGraphAngleBetweenBlock", ["a", "b"]),
  "math/quatFromAxisAngle": {
    blocks: [
      "FlowGraphQuaternionFromAxisAngleBlock"
      /* FlowGraphBlockNames.QuaternionFromAxisAngle */
    ],
    inputs: {
      values: {
        axis: { name: "a", gltfType: "float3" },
        angle: { name: "b", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    }
  },
  "math/quatToAxisAngle": getSimpleInputMapping("FlowGraphAxisAngleFromQuaternionBlock", ["a"]),
  "math/quatFromDirections": getSimpleInputMapping("FlowGraphQuaternionFromDirectionsBlock", ["a", "b"]),
  "math/combine2x2": {
    blocks: [
      "FlowGraphCombineMatrix2DBlock"
      /* FlowGraphBlockNames.CombineMatrix2D */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract2x2": {
    blocks: [
      "FlowGraphExtractMatrix2DBlock"
      /* FlowGraphBlockNames.ExtractMatrix2D */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "float2x2" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" }
      }
    }
  },
  "math/combine3x3": {
    blocks: [
      "FlowGraphCombineMatrix3DBlock"
      /* FlowGraphBlockNames.CombineMatrix3D */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" },
        e: { name: "input_4", gltfType: "number" },
        f: { name: "input_5", gltfType: "number" },
        g: { name: "input_6", gltfType: "number" },
        h: { name: "input_7", gltfType: "number" },
        i: { name: "input_8", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract3x3": {
    blocks: [
      "FlowGraphExtractMatrix3DBlock"
      /* FlowGraphBlockNames.ExtractMatrix3D */
    ],
    inputs: {
      values: {
        a: { name: "input", gltfType: "float3x3" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" },
        "4": { name: "output_4" },
        "5": { name: "output_5" },
        "6": { name: "output_6" },
        "7": { name: "output_7" },
        "8": { name: "output_8" }
      }
    }
  },
  "math/combine4x4": {
    blocks: [
      "FlowGraphCombineMatrixBlock"
      /* FlowGraphBlockNames.CombineMatrix */
    ],
    inputs: {
      values: {
        a: { name: "input_0", gltfType: "number" },
        b: { name: "input_1", gltfType: "number" },
        c: { name: "input_2", gltfType: "number" },
        d: { name: "input_3", gltfType: "number" },
        e: { name: "input_4", gltfType: "number" },
        f: { name: "input_5", gltfType: "number" },
        g: { name: "input_6", gltfType: "number" },
        h: { name: "input_7", gltfType: "number" },
        i: { name: "input_8", gltfType: "number" },
        j: { name: "input_9", gltfType: "number" },
        k: { name: "input_10", gltfType: "number" },
        l: { name: "input_11", gltfType: "number" },
        m: { name: "input_12", gltfType: "number" },
        n: { name: "input_13", gltfType: "number" },
        o: { name: "input_14", gltfType: "number" },
        p: { name: "input_15", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      serializedObjects[0].config.inputIsColumnMajor = true;
      return serializedObjects;
    }
  },
  "math/extract4x4": {
    blocks: [
      "FlowGraphExtractMatrixBlock"
      /* FlowGraphBlockNames.ExtractMatrix */
    ],
    configuration: {},
    inputs: {
      values: {
        a: { name: "input", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        "0": { name: "output_0" },
        "1": { name: "output_1" },
        "2": { name: "output_2" },
        "3": { name: "output_3" },
        "4": { name: "output_4" },
        "5": { name: "output_5" },
        "6": { name: "output_6" },
        "7": { name: "output_7" },
        "8": { name: "output_8" },
        "9": { name: "output_9" },
        "10": { name: "output_10" },
        "11": { name: "output_11" },
        "12": { name: "output_12" },
        "13": { name: "output_13" },
        "14": { name: "output_14" },
        "15": { name: "output_15" }
      }
    }
  },
  "math/not": {
    blocks: [
      "FlowGraphBitwiseNotBlock"
      /* FlowGraphBlockNames.BitwiseNot */
    ],
    inputs: {
      values: {
        a: { name: "a" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketIn = serializedObjects[0].dataInputs[0];
      serializedObjects[0].config.valueType = context._connectionValues[socketIn.uniqueId]?.type ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/and": {
    blocks: [
      "FlowGraphBitwiseAndBlock"
      /* FlowGraphBlockNames.BitwiseAnd */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/or": {
    blocks: [
      "FlowGraphBitwiseOrBlock"
      /* FlowGraphBlockNames.BitwiseOr */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/xor": {
    blocks: [
      "FlowGraphBitwiseXorBlock"
      /* FlowGraphBlockNames.BitwiseXor */
    ],
    inputs: {
      values: {
        a: { name: "a" },
        b: { name: "b" }
      }
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {
      var _a;
      (_a = serializedObjects[0]).config || (_a.config = {});
      const socketInA = serializedObjects[0].dataInputs[0];
      const socketInB = serializedObjects[0].dataInputs[1];
      serializedObjects[0].config.valueType = context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? "FlowGraphInteger";
      return serializedObjects;
    }
  },
  "math/asr": getSimpleInputMapping("FlowGraphBitwiseRightShiftBlock", ["a", "b"]),
  "math/lsl": getSimpleInputMapping("FlowGraphBitwiseLeftShiftBlock", ["a", "b"]),
  "math/clz": getSimpleInputMapping(
    "FlowGraphLeadingZerosBlock"
    /* FlowGraphBlockNames.LeadingZeros */
  ),
  "math/ctz": getSimpleInputMapping(
    "FlowGraphTrailingZerosBlock"
    /* FlowGraphBlockNames.TrailingZeros */
  ),
  "math/popcnt": getSimpleInputMapping(
    "FlowGraphOneBitsCounterBlock"
    /* FlowGraphBlockNames.OneBitsCounter */
  ),
  "math/rad": getSimpleInputMapping(
    "FlowGraphDegToRadBlock"
    /* FlowGraphBlockNames.DegToRad */
  ),
  "math/deg": getSimpleInputMapping(
    "FlowGraphRadToDegBlock"
    /* FlowGraphBlockNames.RadToDeg */
  ),
  "type/boolToInt": getSimpleInputMapping(
    "FlowGraphBooleanToInt"
    /* FlowGraphBlockNames.BooleanToInt */
  ),
  "type/boolToFloat": getSimpleInputMapping(
    "FlowGraphBooleanToFloat"
    /* FlowGraphBlockNames.BooleanToFloat */
  ),
  "type/intToBool": getSimpleInputMapping(
    "FlowGraphIntToBoolean"
    /* FlowGraphBlockNames.IntToBoolean */
  ),
  "type/intToFloat": getSimpleInputMapping(
    "FlowGraphIntToFloat"
    /* FlowGraphBlockNames.IntToFloat */
  ),
  "type/floatToInt": getSimpleInputMapping(
    "FlowGraphFloatToInt"
    /* FlowGraphBlockNames.FloatToInt */
  ),
  "type/floatToBool": getSimpleInputMapping(
    "FlowGraphFloatToBoolean"
    /* FlowGraphBlockNames.FloatToBoolean */
  ),
  // flows
  "flow/sequence": {
    blocks: [
      "FlowGraphSequenceBlock"
      /* FlowGraphBlockNames.Sequence */
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;
      serializedObject.signalOutputs.forEach((output, index) => {
        output.name = "out_" + index;
      });
      return serializedObjects;
    }
  },
  "flow/branch": {
    blocks: [
      "FlowGraphBranchBlock"
      /* FlowGraphBlockNames.Branch */
    ],
    outputs: {
      flows: {
        true: { name: "onTrue" },
        false: { name: "onFalse" }
      }
    }
  },
  "flow/switch": {
    blocks: [
      "FlowGraphSwitchBlock"
      /* FlowGraphBlockNames.Switch */
    ],
    configuration: {
      cases: { name: "cases", inOptions: true, defaultValue: [] }
    },
    inputs: {
      values: {
        selection: { name: "case" },
        default: { name: "default" }
      }
    },
    validation(gltfBlock) {
      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
        const cases = gltfBlock.configuration.cases.value;
        const onlyIntegers = cases.every((caseValue) => {
          return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
        });
        if (!onlyIntegers) {
          Logger.Warn("Switch cases should be integers. Using empty array instead.");
          gltfBlock.configuration.cases.value = [];
          return { valid: true };
        }
        const uniqueCases = new Set(cases);
        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
      }
      return { valid: true };
    },
    extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
      if (declaration.op !== "flow/switch" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
        throw new Error("Switch should have a single configuration object, the cases array");
      }
      const serializedObject = serializedObjects[0];
      serializedObject.signalOutputs.forEach((output) => {
        if (output.name !== "default") {
          output.name = "out_" + output.name;
        }
      });
      return serializedObjects;
    }
  },
  "flow/while": {
    blocks: [
      "FlowGraphWhileLoopBlock"
      /* FlowGraphBlockNames.WhileLoop */
    ],
    outputs: {
      flows: {
        loopBody: { name: "executionFlow" }
      }
    }
  },
  "flow/for": {
    blocks: [
      "FlowGraphForLoopBlock"
      /* FlowGraphBlockNames.ForLoop */
    ],
    configuration: {
      initialIndex: { name: "initialIndex", gltfType: "number", inOptions: true, defaultValue: 0 }
    },
    inputs: {
      values: {
        startIndex: { name: "startIndex", gltfType: "number" },
        endIndex: { name: "endIndex", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        index: { name: "index" }
      },
      flows: {
        loopBody: { name: "executionFlow" }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.incrementIndexWhenLoopDone = true;
      return serializedObjects;
    }
  },
  "flow/doN": {
    blocks: [
      "FlowGraphDoNBlock"
      /* FlowGraphBlockNames.DoN */
    ],
    configuration: {},
    inputs: {
      values: {
        n: { name: "maxExecutions", gltfType: "number" }
      }
    },
    outputs: {
      values: {
        currentCount: { name: "executionCount" }
      }
    }
  },
  "flow/multiGate": {
    blocks: [
      "FlowGraphMultiGateBlock"
      /* FlowGraphBlockNames.MultiGate */
    ],
    configuration: {
      isRandom: { name: "isRandom", gltfType: "boolean", inOptions: true, defaultValue: false },
      isLoop: { name: "isLoop", gltfType: "boolean", inOptions: true, defaultValue: false }
    },
    extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {
      if (declaration.op !== "flow/multiGate" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {
        throw new Error("MultiGate should have a single configuration object, the number of output flows");
      }
      const serializedObject = serializedObjects[0];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;
      serializedObject.signalOutputs.forEach((output, index) => {
        output.name = "out_" + index;
      });
      return serializedObjects;
    }
  },
  "flow/waitAll": {
    blocks: [
      "FlowGraphWaitAllBlock"
      /* FlowGraphBlockNames.WaitAll */
    ],
    configuration: {
      inputFlows: { name: "inputSignalCount", gltfType: "number", inOptions: true, defaultValue: 0 }
    },
    inputs: {
      flows: {
        reset: { name: "reset" },
        "[segment]": { name: "in_$1" }
      }
    },
    validation(gltfBlock) {
      if (typeof gltfBlock.configuration?.inputFlows?.value[0] !== "number") {
        gltfBlock.configuration = gltfBlock.configuration || {
          inputFlows: { value: [0] }
        };
        gltfBlock.configuration.inputFlows.value = [0];
      }
      return { valid: true };
    }
  },
  "flow/throttle": {
    blocks: [
      "FlowGraphThrottleBlock"
      /* FlowGraphBlockNames.Throttle */
    ],
    outputs: {
      flows: {
        err: { name: "error" }
      }
    }
  },
  "flow/setDelay": {
    blocks: [
      "FlowGraphSetDelayBlock"
      /* FlowGraphBlockNames.SetDelay */
    ],
    outputs: {
      flows: {
        err: { name: "error" }
      }
    }
  },
  "flow/cancelDelay": {
    blocks: [
      "FlowGraphCancelDelayBlock"
      /* FlowGraphBlockNames.CancelDelay */
    ]
  },
  "variable/get": {
    blocks: [
      "FlowGraphGetVariableBlock"
      /* FlowGraphBlockNames.GetVariable */
    ],
    validation(gltfBlock) {
      if (!gltfBlock.configuration?.variable?.value) {
        Logger.Error("Variable get block should have a variable configuration");
        return { valid: false, error: "Variable get block should have a variable configuration" };
      }
      return { valid: true };
    },
    configuration: {
      variable: {
        name: "variable",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      }
    }
  },
  "variable/set": {
    blocks: [
      "FlowGraphSetVariableBlock"
      /* FlowGraphBlockNames.SetVariable */
    ],
    configuration: {
      variable: {
        name: "variable",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      }
    }
  },
  "variable/setMultiple": {
    blocks: [
      "FlowGraphSetVariableBlock"
      /* FlowGraphBlockNames.SetVariable */
    ],
    configuration: {
      variables: {
        name: "variables",
        gltfType: "number",
        flowGraphType: "string",
        inOptions: true,
        dataTransformer(index, parser) {
          return [index[0].map((i) => parser.getVariableName(i))];
        }
      }
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      const serializedGetVariable = serializedObjects[0];
      serializedGetVariable.dataInputs.forEach((input) => {
        input.name = parser.getVariableName(+input.name);
      });
      return serializedObjects;
    }
  },
  "variable/interpolate": {
    blocks: [
      "FlowGraphInterpolationBlock",
      "FlowGraphContextBlock",
      "FlowGraphPlayAnimationBlock",
      "FlowGraphBezierCurveEasing",
      "FlowGraphGetVariableBlock"
    ],
    configuration: {
      variable: {
        name: "propertyName",
        inOptions: true,
        isVariable: true,
        dataTransformer(index, parser) {
          return [parser.getVariableName(index[0])];
        }
      },
      useSlerp: {
        name: "animationType",
        inOptions: true,
        defaultValue: false,
        dataTransformer: (value) => {
          if (value[0] === true) {
            return [
              "Quaternion"
              /* FlowGraphTypes.Quaternion */
            ];
          } else {
            return [void 0];
          }
        }
      }
    },
    inputs: {
      values: {
        value: { name: "value_1" },
        duration: { name: "duration_1", gltfType: "number" },
        p1: {
          name: "controlPoint1",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        },
        p2: {
          name: "controlPoint2",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        }
      },
      flows: {
        in: {
          name: "in",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    outputs: {
      flows: {
        err: {
          name: "error",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        out: {
          name: "out",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        done: {
          name: "done",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "userVariables",
        inputBlockIndex: 2,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "animation",
        output: "animation",
        inputBlockIndex: 2,
        outputBlockIndex: 0,
        isVariable: true
      },
      {
        input: "easingFunction",
        output: "easingFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 3,
        isVariable: true
      },
      {
        input: "value_0",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 4,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      var _a, _b;
      const serializedValueInterpolation = serializedObjects[0];
      const propertyIndex = gltfBlock.configuration?.variable.value[0];
      if (typeof propertyIndex !== "number") {
        Logger.Error("Variable index is not defined for variable interpolation block");
        throw new Error("Variable index is not defined for variable interpolation block");
      }
      const variable = parser.arrays.staticVariables[propertyIndex];
      if (typeof serializedValueInterpolation.config.animationType.value === "undefined") {
        parser.arrays.staticVariables;
        serializedValueInterpolation.config.animationType.value = getAnimationTypeByFlowGraphType(variable.type);
      }
      const serializedGetVariable = serializedObjects[4];
      serializedGetVariable.config || (serializedGetVariable.config = {});
      (_a = serializedGetVariable.config).variable || (_a.variable = {});
      serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);
      (_b = serializedObjects[3]).config || (_b.config = {});
      return serializedObjects;
    }
  },
  "pointer/get": {
    blocks: [
      "FlowGraphGetPropertyBlock",
      "FlowGraphJsonPointerParserBlock"
      /* FlowGraphBlockNames.JsonPointerParser */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customGetFunction",
        output: "getFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        }
      });
      return serializedObjects;
    }
  },
  "pointer/set": {
    blocks: [
      "FlowGraphSetPropertyBlock",
      "FlowGraphJsonPointerParserBlock"
      /* FlowGraphBlockNames.JsonPointerParser */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        // must be defined due to the array taking over
        value: { name: "value" },
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customSetFunction",
        output: "setFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        }
      });
      return serializedObjects;
    }
  },
  "pointer/interpolate": {
    // interpolate, parse the pointer and play the animation generated. 3 blocks!
    blocks: [
      "FlowGraphInterpolationBlock",
      "FlowGraphJsonPointerParserBlock",
      "FlowGraphPlayAnimationBlock",
      "FlowGraphBezierCurveEasing"
      /* FlowGraphBlockNames.BezierCurveEasing */
    ],
    configuration: {
      pointer: {
        name: "jsonPointer",
        toBlock: "FlowGraphJsonPointerParserBlock"
        /* FlowGraphBlockNames.JsonPointerParser */
      }
    },
    inputs: {
      values: {
        value: { name: "value_1" },
        "[segment]": {
          name: "$1",
          toBlock: "FlowGraphJsonPointerParserBlock"
          /* FlowGraphBlockNames.JsonPointerParser */
        },
        duration: {
          name: "duration_1",
          gltfType: "number"
          /*, inOptions: true */
        },
        p1: {
          name: "controlPoint1",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        },
        p2: {
          name: "controlPoint2",
          toBlock: "FlowGraphBezierCurveEasing"
          /* FlowGraphBlockNames.BezierCurveEasing */
        }
      },
      flows: {
        in: {
          name: "in",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    outputs: {
      flows: {
        err: {
          name: "error",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        out: {
          name: "out",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        },
        done: {
          name: "done",
          toBlock: "FlowGraphPlayAnimationBlock"
          /* FlowGraphBlockNames.PlayAnimation */
        }
      }
    },
    interBlockConnectors: [
      {
        input: "object",
        output: "object",
        inputBlockIndex: 2,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "propertyName",
        output: "propertyName",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "customBuildAnimation",
        output: "generateAnimationsFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "animation",
        output: "animation",
        inputBlockIndex: 2,
        outputBlockIndex: 0,
        isVariable: true
      },
      {
        input: "easingFunction",
        output: "easingFunction",
        inputBlockIndex: 0,
        outputBlockIndex: 3,
        isVariable: true
      },
      {
        input: "value_0",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      }
    ],
    extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {
      serializedObjects.forEach((serializedObject) => {
        if (serializedObject.className === "FlowGraphJsonPointerParserBlock") {
          serializedObject.config || (serializedObject.config = {});
          serializedObject.config.outputValue = true;
        } else if (serializedObject.className === "FlowGraphInterpolationBlock") {
          serializedObject.config || (serializedObject.config = {});
          Object.keys(gltfBlock.values || []).forEach((key) => {
            const value = gltfBlock.values?.[key];
            if (key === "value" && value) {
              const type = value.type;
              if (type !== void 0) {
                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;
              }
            }
          });
        }
      });
      return serializedObjects;
    }
  },
  "animation/start": {
    blocks: ["FlowGraphPlayAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        },
        speed: { name: "speed", gltfType: "number" },
        startTime: { name: "from", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] },
        endTime: { name: "to", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "animation/stop": {
    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "animation/stopAt": {
    blocks: ["FlowGraphStopAnimationBlock", "FlowGraphArrayIndexBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
    configuration: {},
    inputs: {
      values: {
        animation: {
          name: "index",
          gltfType: "number",
          toBlock: "FlowGraphArrayIndexBlock"
          /* FlowGraphBlockNames.ArrayIndex */
        },
        stopTime: { name: "stopAtFrame", gltfType: "number", dataTransformer: (time, parser) => [time[0] * parser._animationTargetFps] }
      }
    },
    outputs: {
      flows: {
        err: { name: "error" }
      }
    },
    interBlockConnectors: [
      {
        input: "animationGroup",
        output: "value",
        inputBlockIndex: 0,
        outputBlockIndex: 1,
        isVariable: true
      },
      {
        input: "array",
        output: "animationGroups",
        inputBlockIndex: 1,
        outputBlockIndex: 2,
        isVariable: true
      }
    ],
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {
      const serializedObject = serializedObjects[serializedObjects.length - 1];
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.glTF = globalGLTF;
      return serializedObjects;
    }
  },
  "math/switch": {
    blocks: [
      "FlowGraphDataSwitchBlock"
      /* FlowGraphBlockNames.DataSwitch */
    ],
    configuration: {
      cases: { name: "cases", inOptions: true, defaultValue: [] }
    },
    inputs: {
      values: {
        selection: { name: "case" }
      }
    },
    validation(gltfBlock) {
      if (gltfBlock.configuration && gltfBlock.configuration.cases) {
        const cases = gltfBlock.configuration.cases.value;
        const onlyIntegers = cases.every((caseValue) => {
          return typeof caseValue === "number" && /^-?\d+$/.test(caseValue.toString());
        });
        if (!onlyIntegers) {
          Logger.Warn("Switch cases should be integers. Using empty array instead.");
          gltfBlock.configuration.cases.value = [];
          return { valid: true };
        }
        const uniqueCases = new Set(cases);
        gltfBlock.configuration.cases.value = Array.from(uniqueCases);
      }
      return { valid: true };
    },
    extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {
      const serializedObject = serializedObjects[0];
      serializedObject.dataInputs.forEach((input) => {
        if (input.name !== "default" && input.name !== "case") {
          input.name = "in_" + input.name;
        }
      });
      serializedObject.config || (serializedObject.config = {});
      serializedObject.config.treatCasesAsIntegers = true;
      return serializedObjects;
    }
  },
  "debug/log": {
    blocks: [
      "FlowGraphConsoleLogBlock"
      /* FlowGraphBlockNames.ConsoleLog */
    ],
    configuration: {
      message: { name: "messageTemplate", inOptions: true }
    }
  }
};
function getSimpleInputMapping(type, inputs = ["a"], inferType) {
  return {
    blocks: [type],
    inputs: {
      values: inputs.reduce((acc, input) => {
        acc[input] = { name: input };
        return acc;
      }, {})
    },
    outputs: {
      values: {
        value: { name: "value" }
      }
    },
    extraProcessor(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {
      var _a;
      if (inferType) {
        (_a = serializedObjects[0]).config || (_a.config = {});
        serializedObjects[0].config.preventIntegerFloatArithmetic = true;
        let type2 = -1;
        Object.keys(gltfBlock.values || {}).find((value) => {
          if (gltfBlock.values?.[value].type !== void 0) {
            type2 = gltfBlock.values[value].type;
            return true;
          }
          return false;
        });
        if (type2 !== -1) {
          serializedObjects[0].config.type = _parser.arrays.types[type2].flowGraphType;
        }
      }
      return serializedObjects;
    },
    validation(gltfBlock) {
      if (inferType) {
        return ValidateTypes(gltfBlock);
      }
      return { valid: true };
    }
  };
}
function ValidateTypes(gltfBlock) {
  if (gltfBlock.values) {
    const types = Object.keys(gltfBlock.values).map((key) => gltfBlock.values[key].type).filter((type) => type !== void 0);
    const allSameType = types.every((type) => type === types[0]);
    if (!allSameType) {
      return { valid: false, error: "All inputs must be of the same type" };
    }
  }
  return { valid: true };
}
function getAllSupportedNativeNodeTypes() {
  return Object.keys(gltfToFlowGraphMapping);
}

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.js
var gltfTypeToBabylonType = {
  float: { length: 1, flowGraphType: "number", elementType: "number" },
  bool: { length: 1, flowGraphType: "boolean", elementType: "boolean" },
  float2: { length: 2, flowGraphType: "Vector2", elementType: "number" },
  float3: { length: 3, flowGraphType: "Vector3", elementType: "number" },
  float4: { length: 4, flowGraphType: "Vector4", elementType: "number" },
  float4x4: { length: 16, flowGraphType: "Matrix", elementType: "number" },
  float2x2: { length: 4, flowGraphType: "Matrix2D", elementType: "number" },
  float3x3: { length: 9, flowGraphType: "Matrix3D", elementType: "number" },
  int: { length: 1, flowGraphType: "FlowGraphInteger", elementType: "number" }
};
var InteractivityGraphToFlowGraphParser = class {
  constructor(_interactivityGraph, _gltf, _animationTargetFps = 60) {
    this._interactivityGraph = _interactivityGraph;
    this._gltf = _gltf;
    this._animationTargetFps = _animationTargetFps;
    this._types = [];
    this._mappings = [];
    this._staticVariables = [];
    this._events = [];
    this._internalEventsCounter = 0;
    this._nodes = [];
    this._parseTypes();
    this._parseDeclarations();
    this._parseVariables();
    this._parseEvents();
    this._parseNodes();
  }
  get arrays() {
    return {
      types: this._types,
      mappings: this._mappings,
      staticVariables: this._staticVariables,
      events: this._events,
      nodes: this._nodes
    };
  }
  _parseTypes() {
    if (!this._interactivityGraph.types) {
      return;
    }
    for (const type of this._interactivityGraph.types) {
      this._types.push(gltfTypeToBabylonType[type.signature]);
    }
  }
  _parseDeclarations() {
    if (!this._interactivityGraph.declarations) {
      return;
    }
    for (const declaration of this._interactivityGraph.declarations) {
      const mapping = getMappingForDeclaration(declaration);
      if (!mapping) {
        Logger.Error(["No mapping found for declaration", declaration]);
        throw new Error("Error parsing declarations");
      }
      this._mappings.push({
        flowGraphMapping: mapping,
        fullOperationName: declaration.extension ? declaration.op + ":" + declaration.extension : declaration.op
      });
    }
  }
  _parseVariables() {
    if (!this._interactivityGraph.variables) {
      return;
    }
    for (const variable of this._interactivityGraph.variables) {
      const parsed = this._parseVariable(variable);
      this._staticVariables.push(parsed);
    }
  }
  _parseVariable(variable, dataTransform) {
    const type = this._types[variable.type];
    if (!type) {
      Logger.Error(["No type found for variable", variable]);
      throw new Error("Error parsing variables");
    }
    if (variable.value) {
      if (variable.value.length !== type.length) {
        Logger.Error(["Invalid value length for variable", variable, type]);
        throw new Error("Error parsing variables");
      }
    }
    const value = variable.value || [];
    if (!value.length) {
      switch (type.flowGraphType) {
        case "boolean":
          value.push(false);
          break;
        case "FlowGraphInteger":
          value.push(0);
          break;
        case "number":
          value.push(NaN);
          break;
        case "Vector2":
          value.push(NaN, NaN);
          break;
        case "Vector3":
          value.push(NaN, NaN, NaN);
          break;
        case "Vector4":
        case "Matrix2D":
        case "Quaternion":
          value.fill(NaN, 0, 4);
          break;
        case "Matrix":
          value.fill(NaN, 0, 16);
          break;
        case "Matrix3D":
          value.fill(NaN, 0, 9);
          break;
        default:
          break;
      }
    }
    if (type.elementType === "number" && typeof value[0] === "string") {
      value[0] = parseFloat(value[0]);
    }
    return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };
  }
  _parseEvents() {
    if (!this._interactivityGraph.events) {
      return;
    }
    for (const event of this._interactivityGraph.events) {
      const converted = {
        eventId: event.id || "internalEvent_" + this._internalEventsCounter++
      };
      if (event.values) {
        converted.eventData = Object.keys(event.values).map((key) => {
          const eventValue = event.values?.[key];
          if (!eventValue) {
            Logger.Error(["No value found for event key", key]);
            throw new Error("Error parsing events");
          }
          const type = this._types[eventValue.type];
          if (!type) {
            Logger.Error(["No type found for event value", eventValue]);
            throw new Error("Error parsing events");
          }
          const value = typeof eventValue.value !== "undefined" ? this._parseVariable(eventValue) : void 0;
          return {
            id: key,
            type: type.flowGraphType,
            eventData: true,
            value
          };
        });
      }
      this._events.push(converted);
    }
  }
  _parseNodes() {
    if (!this._interactivityGraph.nodes) {
      return;
    }
    for (const node of this._interactivityGraph.nodes) {
      if (typeof node.declaration !== "number") {
        Logger.Error(["No declaration found for node", node]);
        throw new Error("Error parsing nodes");
      }
      const mapping = this._mappings[node.declaration];
      if (!mapping) {
        Logger.Error(["No mapping found for node", node]);
        throw new Error("Error parsing nodes");
      }
      if (mapping.flowGraphMapping.validation) {
        const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);
        if (!validationResult.valid) {
          throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);
        }
      }
      const blocks = [];
      for (const blockType of mapping.flowGraphMapping.blocks) {
        const block = this._getEmptyBlock(blockType, mapping.fullOperationName);
        this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);
        blocks.push(block);
      }
      this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });
    }
  }
  _getEmptyBlock(className, type) {
    const uniqueId = RandomGUID();
    const dataInputs = [];
    const dataOutputs = [];
    const signalInputs = [];
    const signalOutputs = [];
    const config = {};
    const metadata = {};
    return {
      uniqueId,
      className,
      dataInputs,
      dataOutputs,
      signalInputs,
      signalOutputs,
      config,
      type,
      metadata
    };
  }
  _parseNodeConfiguration(node, block, nodeMapping, blockType) {
    const configuration = block.config;
    if (node.configuration) {
      const keys = Object.keys(node.configuration);
      for (const key of keys) {
        const value = node.configuration?.[key];
        if (!value) {
          Logger.Error(["No value found for node configuration", key]);
          throw new Error("Error parsing node configuration");
        }
        const configMapping = nodeMapping.configuration?.[key];
        const belongsToBlock = configMapping && configMapping.toBlock ? configMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;
        if (belongsToBlock) {
          const configKey = configMapping?.name || key;
          if ((!value || typeof value.value === "undefined") && typeof configMapping?.defaultValue !== "undefined") {
            configuration[configKey] = {
              value: configMapping.defaultValue
            };
          } else if (value.value.length >= 0) {
            configuration[configKey] = {
              value: value.value.length === 1 ? value.value[0] : value.value
            };
          } else {
            Logger.Warn(["Invalid value for node configuration", value]);
          }
          if (configMapping && configMapping.dataTransformer) {
            configuration[configKey].value = configMapping.dataTransformer([configuration[configKey].value], this)[0];
          }
        }
      }
    }
  }
  _parseNodeConnections(context) {
    for (let i = 0; i < this._nodes.length; i++) {
      const gltfNode = this._interactivityGraph.nodes?.[i];
      if (!gltfNode) {
        Logger.Error(["No node found for interactivity node", this._nodes[i]]);
        throw new Error("Error parsing node connections");
      }
      const flowGraphBlocks = this._nodes[i];
      const outputMapper = this._mappings[gltfNode.declaration];
      if (!outputMapper) {
        Logger.Error(["No mapping found for node", gltfNode]);
        throw new Error("Error parsing node connections");
      }
      const flowsFromGLTF = gltfNode.flows || {};
      const flowsKeys = Object.keys(flowsFromGLTF).sort();
      for (const flowKey of flowsKeys) {
        const flow = flowsFromGLTF[flowKey];
        const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];
        const socketOutName = flowMapping?.name || flowKey;
        const socketOut = this._createNewSocketConnection(socketOutName, true);
        const block = flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock) || flowGraphBlocks.blocks[0];
        block.signalOutputs.push(socketOut);
        const inputNodeId = flow.node;
        const nodeIn = this._nodes[inputNodeId];
        if (!nodeIn) {
          Logger.Error(["No node found for input node id", inputNodeId]);
          throw new Error("Error parsing node connections");
        }
        const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);
        if (!inputMapper) {
          Logger.Error(["No mapping found for input node", nodeIn]);
          throw new Error("Error parsing node connections");
        }
        let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || "in"];
        let arrayMapping = false;
        if (!flowInMapping) {
          for (const key in inputMapper.inputs?.flows) {
            if (key.startsWith("[") && key.endsWith("]")) {
              arrayMapping = true;
              flowInMapping = inputMapper.inputs?.flows?.[key];
            }
          }
        }
        const nodeInSocketName = flowInMapping ? arrayMapping ? flowInMapping.name.replace("$1", flow.socket || "") : flowInMapping.name : flow.socket || "in";
        const inputBlock = flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock) || nodeIn.blocks[0];
        let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);
        if (!socketIn) {
          socketIn = this._createNewSocketConnection(nodeInSocketName);
          inputBlock.signalInputs.push(socketIn);
        }
        socketIn.connectedPointIds.push(socketOut.uniqueId);
        socketOut.connectedPointIds.push(socketIn.uniqueId);
      }
      const valuesFromGLTF = gltfNode.values || {};
      const valuesKeys = Object.keys(valuesFromGLTF);
      for (const valueKey of valuesKeys) {
        const value = valuesFromGLTF[valueKey];
        let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];
        let arrayMapping = false;
        if (!valueMapping) {
          for (const key in outputMapper.flowGraphMapping.inputs?.values) {
            if (key.startsWith("[") && key.endsWith("]")) {
              arrayMapping = true;
              valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];
            }
          }
        }
        const socketInName = valueMapping ? arrayMapping ? valueMapping.name.replace("$1", valueKey) : valueMapping.name : valueKey;
        const socketIn = this._createNewSocketConnection(socketInName);
        const block = valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock) || flowGraphBlocks.blocks[0];
        block.dataInputs.push(socketIn);
        if (value.value !== void 0) {
          const convertedValue = this._parseVariable(value, valueMapping && valueMapping.dataTransformer);
          context._connectionValues[socketIn.uniqueId] = convertedValue;
        } else if (typeof value.node !== "undefined") {
          const nodeOutId = value.node;
          const nodeOutSocketName = value.socket || "value";
          const nodeOut = this._nodes[nodeOutId];
          if (!nodeOut) {
            Logger.Error(["No node found for output socket reference", value]);
            throw new Error("Error parsing node connections");
          }
          const outputMapper2 = getMappingForFullOperationName(nodeOut.fullOperationName);
          if (!outputMapper2) {
            Logger.Error(["No mapping found for output socket reference", value]);
            throw new Error("Error parsing node connections");
          }
          let valueMapping2 = outputMapper2.outputs?.values?.[nodeOutSocketName];
          let arrayMapping2 = false;
          if (!valueMapping2) {
            for (const key in outputMapper2.outputs?.values) {
              if (key.startsWith("[") && key.endsWith("]")) {
                arrayMapping2 = true;
                valueMapping2 = outputMapper2.outputs?.values?.[key];
              }
            }
          }
          const socketOutName = valueMapping2 ? arrayMapping2 ? valueMapping2.name.replace("$1", nodeOutSocketName) : valueMapping2?.name : nodeOutSocketName;
          const outBlock = valueMapping2 && valueMapping2.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping2.toBlock) || nodeOut.blocks[0];
          let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);
          if (!socketOut) {
            socketOut = this._createNewSocketConnection(socketOutName, true);
            outBlock.dataOutputs.push(socketOut);
          }
          socketIn.connectedPointIds.push(socketOut.uniqueId);
          socketOut.connectedPointIds.push(socketIn.uniqueId);
        } else {
          Logger.Error(["Invalid value for value connection", value]);
          throw new Error("Error parsing node connections");
        }
      }
      if (outputMapper.flowGraphMapping.interBlockConnectors) {
        for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {
          const input = connector.input;
          const output = connector.output;
          const isVariable = connector.isVariable;
          this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);
        }
      }
      if (outputMapper.flowGraphMapping.extraProcessor) {
        const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];
        if (!declaration) {
          Logger.Error(["No declaration found for extra processor", gltfNode]);
          throw new Error("Error parsing node connections");
        }
        flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(gltfNode, declaration, outputMapper.flowGraphMapping, this, flowGraphBlocks.blocks, context, this._gltf);
      }
    }
  }
  _createNewSocketConnection(name2, isOutput) {
    return {
      uniqueId: RandomGUID(),
      name: name2,
      _connectionType: isOutput ? 1 : 0,
      connectedPointIds: []
    };
  }
  _connectFlowGraphNodes(input, output, serializedInput, serializedOutput, isVariable) {
    const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;
    const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;
    const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);
    const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);
    if (!inputArray.find((s) => s.name === input)) {
      inputArray.push(inputConnection);
    }
    if (!outputArray.find((s) => s.name === output)) {
      outputArray.push(outputConnection);
    }
    inputConnection.connectedPointIds.push(outputConnection.uniqueId);
    outputConnection.connectedPointIds.push(inputConnection.uniqueId);
  }
  getVariableName(index) {
    return "staticVariable_" + index;
  }
  serializeToFlowGraph() {
    const context = {
      uniqueId: RandomGUID(),
      _userVariables: {},
      _connectionValues: {}
    };
    this._parseNodeConnections(context);
    for (let i = 0; i < this._staticVariables.length; i++) {
      const variable = this._staticVariables[i];
      context._userVariables[this.getVariableName(i)] = variable;
    }
    const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), []);
    return {
      rightHanded: true,
      allBlocks,
      executionContexts: [context]
    };
  }
};

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_interactivity.js
var NAME34 = "KHR_interactivity";
var KHR_interactivity = class {
  /**
   * @internal
   * @param _loader
   */
  constructor(_loader) {
    this._loader = _loader;
    this.name = NAME34;
    this.enabled = this._loader.isExtensionUsed(NAME34);
    this._pathConverter = GetPathToObjectConverter(this._loader.gltf);
    _loader._skipStartAnimationStep = true;
    const scene = _loader.babylonScene;
    if (scene) {
      _AddInteractivityObjectModel(scene);
    }
  }
  dispose() {
    this._loader = null;
    delete this._pathConverter;
  }
  // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises
  async onReady() {
    if (!this._loader.babylonScene || !this._pathConverter) {
      return;
    }
    const scene = this._loader.babylonScene;
    const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity;
    if (!interactivityDefinition) {
      return;
    }
    const coordinator = new FlowGraphCoordinator({ scene });
    coordinator.dispatchEventsSynchronously = false;
    const graphs = interactivityDefinition.graphs.map((graph) => {
      const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);
      return parser.serializeToFlowGraph();
    });
    await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));
    coordinator.start();
  }
};
function _AddInteractivityObjectModel(scene) {
  AddObjectAccessorToKey("/extensions/KHR_interactivity/?/activeCamera/rotation", {
    get: () => {
      if (!scene.activeCamera) {
        return new Quaternion(NaN, NaN, NaN, NaN);
      }
      const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();
      if (!scene.useRightHandedSystem) {
        quat.w *= -1;
        quat.x *= -1;
      }
      return quat;
    },
    type: "Quaternion",
    getTarget: () => scene.activeCamera
  });
  AddObjectAccessorToKey("/extensions/KHR_interactivity/?/activeCamera/position", {
    get: () => {
      if (!scene.activeCamera) {
        return new Vector3(NaN, NaN, NaN);
      }
      const pos = scene.activeCamera.getWorldMatrix().getTranslation();
      if (!scene.useRightHandedSystem) {
        pos.x *= -1;
      }
      return pos;
    },
    type: "Vector3",
    getTarget: () => scene.activeCamera
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/isPlaying", {
    get: (animation) => {
      return animation._babylonAnimationGroup?.isPlaying ?? false;
    },
    type: "boolean",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/minTime", {
    get: (animation) => {
      return (animation._babylonAnimationGroup?.from ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/maxTime", {
    get: (animation) => {
      return (animation._babylonAnimationGroup?.to ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/playhead", {
    get: (animation) => {
      return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
  AddObjectAccessorToKey("/animations/{}/extensions/KHR_interactivity/virtualPlayhead", {
    get: (animation) => {
      return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60;
    },
    type: "number",
    getTarget: (animation) => {
      return animation._babylonAnimationGroup;
    }
  });
}
addToBlockFactory(NAME34, "FlowGraphGLTFDataProvider", async () => {
  return (await import("./flowGraphGLTFDataProvider-VCBZO3UE.js")).FlowGraphGLTFDataProvider;
});
unregisterGLTFExtension(NAME34);
registerGLTFExtension(NAME34, true, (loader) => new KHR_interactivity(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_node_visibility.js
var NAME35 = "KHR_node_visibility";
AddObjectAccessorToKey("/nodes/{}/extensions/KHR_node_visibility/visible", {
  get: (node) => {
    const tn = node._babylonTransformNode;
    if (tn && tn.isVisible !== void 0) {
      return tn.isVisible;
    }
    return true;
  },
  set: (value, node) => {
    node._primitiveBabylonMeshes?.forEach((mesh) => {
      mesh.inheritVisibility = true;
    });
    if (node._babylonTransformNode) {
      node._babylonTransformNode.isVisible = value;
    }
    node._primitiveBabylonMeshes?.forEach((mesh) => {
      mesh.isVisible = value;
    });
  },
  getTarget: (node) => node._babylonTransformNode,
  getPropertyName: [() => "isVisible"],
  type: "boolean"
});
var KHR_node_visibility = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME35;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME35);
  }
  onReady() {
    if (!this._loader) {
      return;
    }
    const nodes = this._loader.gltf.nodes;
    if (nodes) {
      for (const node of nodes) {
        const babylonTransformNode = node._babylonTransformNode;
        if (babylonTransformNode) {
          babylonTransformNode.inheritVisibility = true;
          if (node.extensions && node.extensions.KHR_node_visibility && node.extensions.KHR_node_visibility.visible === false) {
            babylonTransformNode.isVisible = false;
          }
        }
      }
    }
  }
  dispose() {
    delete this._loader;
  }
};
unregisterGLTFExtension(NAME35);
registerGLTFExtension(NAME35, true, (loader) => new KHR_node_visibility(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_node_selectability.js
var NAME36 = "KHR_node_selectability";
addNewInteractivityFlowGraphMapping("event/onSelect", NAME36, {
  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
  blocks: ["FlowGraphMeshPickEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
  configuration: {
    stopPropagation: { name: "stopPropagation" },
    nodeIndex: {
      name: "variable",
      toBlock: "FlowGraphGetVariableBlock",
      dataTransformer(data) {
        return ["pickedMesh_" + data[0]];
      }
    }
  },
  outputs: {
    values: {
      selectedNodeIndex: {
        name: "index",
        toBlock: "FlowGraphIndexOfBlock"
        /* FlowGraphBlockNames.IndexOf */
      },
      controllerIndex: { name: "pointerId" },
      selectionPoint: { name: "pickedPoint" },
      selectionRayOrigin: { name: "pickOrigin" }
    },
    flows: {
      out: { name: "done" }
    }
  },
  interBlockConnectors: [
    {
      input: "asset",
      output: "value",
      inputBlockIndex: 0,
      outputBlockIndex: 1,
      isVariable: true
    },
    {
      input: "array",
      output: "nodes",
      inputBlockIndex: 2,
      outputBlockIndex: 3,
      isVariable: true
    },
    {
      input: "object",
      output: "pickedMesh",
      inputBlockIndex: 2,
      outputBlockIndex: 0,
      isVariable: true
    }
  ],
  extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
    const serializedObject = serializedObjects[serializedObjects.length - 1];
    serializedObject.config = serializedObject.config || {};
    serializedObject.config.glTF = globalGLTF;
    const nodeIndex = gltfBlock.configuration?.["nodeIndex"]?.value[0];
    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
      throw new Error("nodeIndex not found in configuration");
    }
    const variableName = "pickedMesh_" + nodeIndex;
    serializedObjects[1].config.variable = variableName;
    context._userVariables[variableName] = {
      className: "Mesh",
      id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,
      uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId
    };
    return serializedObjects;
  }
});
AddObjectAccessorToKey("/nodes/{}/extensions/KHR_node_selectability/selectable", {
  get: (node) => {
    const tn = node._babylonTransformNode;
    if (tn && tn.isPickable !== void 0) {
      return tn.isPickable;
    }
    return true;
  },
  set: (value, node) => {
    node._primitiveBabylonMeshes?.forEach((mesh) => {
      mesh.isPickable = value;
    });
  },
  getTarget: (node) => node._babylonTransformNode,
  getPropertyName: [() => "isPickable"],
  type: "boolean"
});
var KHR_node_selectability = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME36;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME36);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises
  async onReady() {
    this._loader.gltf.nodes?.forEach((node) => {
      if (node.extensions?.KHR_node_selectability && node.extensions?.KHR_node_selectability.selectable === false) {
        node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {
          mesh.isPickable = false;
        });
      }
    });
  }
  dispose() {
    this._loader = null;
  }
};
unregisterGLTFExtension(NAME36);
registerGLTFExtension(NAME36, true, (loader) => new KHR_node_selectability(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/KHR_node_hoverability.js
var NAME37 = "KHR_node_hoverability";
var MeshPointerOverPrefix = "targetMeshPointerOver_";
addNewInteractivityFlowGraphMapping("event/onHoverIn", NAME37, {
  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
  blocks: ["FlowGraphPointerOverEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
  configuration: {
    stopPropagation: { name: "stopPropagation" },
    nodeIndex: {
      name: "variable",
      toBlock: "FlowGraphGetVariableBlock",
      dataTransformer(data) {
        return [MeshPointerOverPrefix + data[0]];
      }
    }
  },
  outputs: {
    values: {
      hoverNodeIndex: {
        name: "index",
        toBlock: "FlowGraphIndexOfBlock"
        /* FlowGraphBlockNames.IndexOf */
      },
      controllerIndex: { name: "pointerId" }
    },
    flows: {
      out: { name: "done" }
    }
  },
  interBlockConnectors: [
    {
      input: "targetMesh",
      output: "value",
      inputBlockIndex: 0,
      outputBlockIndex: 1,
      isVariable: true
    },
    {
      input: "array",
      output: "nodes",
      inputBlockIndex: 2,
      outputBlockIndex: 3,
      isVariable: true
    },
    {
      input: "object",
      output: "meshUnderPointer",
      inputBlockIndex: 2,
      outputBlockIndex: 0,
      isVariable: true
    }
  ],
  extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
    const serializedObject = serializedObjects[serializedObjects.length - 1];
    serializedObject.config = serializedObject.config || {};
    serializedObject.config.glTF = globalGLTF;
    const nodeIndex = gltfBlock.configuration?.["nodeIndex"]?.value[0];
    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
      throw new Error("nodeIndex not found in configuration");
    }
    const variableName = MeshPointerOverPrefix + nodeIndex;
    serializedObjects[1].config.variable = variableName;
    context._userVariables[variableName] = {
      className: "Mesh",
      id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,
      uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId
    };
    return serializedObjects;
  }
});
var MeshPointerOutPrefix = "targetMeshPointerOut_";
addNewInteractivityFlowGraphMapping("event/onHoverOut", NAME37, {
  // using GetVariable as the nodeIndex is a configuration and not a value (i.e. it's not mutable)
  blocks: ["FlowGraphPointerOutEventBlock", "FlowGraphGetVariableBlock", "FlowGraphIndexOfBlock", "KHR_interactivity/FlowGraphGLTFDataProvider"],
  configuration: {
    stopPropagation: { name: "stopPropagation" },
    nodeIndex: {
      name: "variable",
      toBlock: "FlowGraphGetVariableBlock",
      dataTransformer(data) {
        return [MeshPointerOutPrefix + data[0]];
      }
    }
  },
  outputs: {
    values: {
      hoverNodeIndex: {
        name: "index",
        toBlock: "FlowGraphIndexOfBlock"
        /* FlowGraphBlockNames.IndexOf */
      },
      controllerIndex: { name: "pointerId" }
    },
    flows: {
      out: { name: "done" }
    }
  },
  interBlockConnectors: [
    {
      input: "targetMesh",
      output: "value",
      inputBlockIndex: 0,
      outputBlockIndex: 1,
      isVariable: true
    },
    {
      input: "array",
      output: "nodes",
      inputBlockIndex: 2,
      outputBlockIndex: 3,
      isVariable: true
    },
    {
      input: "object",
      output: "meshOutOfPointer",
      inputBlockIndex: 2,
      outputBlockIndex: 0,
      isVariable: true
    }
  ],
  extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects, context, globalGLTF) {
    const serializedObject = serializedObjects[serializedObjects.length - 1];
    serializedObject.config = serializedObject.config || {};
    serializedObject.config.glTF = globalGLTF;
    const nodeIndex = gltfBlock.configuration?.["nodeIndex"]?.value[0];
    if (nodeIndex === void 0 || typeof nodeIndex !== "number") {
      throw new Error("nodeIndex not found in configuration");
    }
    const variableName = MeshPointerOutPrefix + nodeIndex;
    serializedObjects[1].config.variable = variableName;
    context._userVariables[variableName] = {
      className: "Mesh",
      id: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.id,
      uniqueId: globalGLTF?.nodes?.[nodeIndex]._babylonTransformNode?.uniqueId
    };
    return serializedObjects;
  }
});
AddObjectAccessorToKey("/nodes/{}/extensions/KHR_node_hoverability/hoverable", {
  get: (node) => {
    const tn = node._babylonTransformNode;
    if (tn && tn.pointerOverDisableMeshTesting !== void 0) {
      return tn.pointerOverDisableMeshTesting;
    }
    return true;
  },
  set: (value, node) => {
    node._primitiveBabylonMeshes?.forEach((mesh) => {
      mesh.pointerOverDisableMeshTesting = !value;
    });
  },
  getTarget: (node) => node._babylonTransformNode,
  getPropertyName: [() => "pointerOverDisableMeshTesting"],
  type: "boolean"
});
var KHR_node_hoverability = class {
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME37;
    this._loader = loader;
    this.enabled = loader.isExtensionUsed(NAME37);
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-misused-promises
  async onReady() {
    this._loader.gltf.nodes?.forEach((node) => {
      if (node.extensions?.KHR_node_hoverability && node.extensions?.KHR_node_hoverability.hoverable === false) {
        node._babylonTransformNode?.getChildMeshes().forEach((mesh) => {
          mesh.pointerOverDisableMeshTesting = true;
        });
      }
    });
  }
  dispose() {
    this._loader = null;
  }
};
unregisterGLTFExtension(NAME37);
registerGLTFExtension(NAME37, true, (loader) => new KHR_node_hoverability(loader));

// node_modules/@babylonjs/loaders/glTF/2.0/Extensions/ExtrasAsMetadata.js
var NAME38 = "ExtrasAsMetadata";
var ExtrasAsMetadata = class {
  _assignExtras(babylonObject, gltfProp) {
    if (gltfProp.extras && Object.keys(gltfProp.extras).length > 0) {
      const metadata = babylonObject.metadata = babylonObject.metadata || {};
      const gltf = metadata.gltf = metadata.gltf || {};
      gltf.extras = gltfProp.extras;
    }
  }
  /**
   * @internal
   */
  constructor(loader) {
    this.name = NAME38;
    this.enabled = true;
    this._loader = loader;
  }
  /** @internal */
  dispose() {
    this._loader = null;
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadNodeAsync(context, node, assign) {
    return this._loader.loadNodeAsync(context, node, (babylonTransformNode) => {
      this._assignExtras(babylonTransformNode, node);
      assign(babylonTransformNode);
    });
  }
  /**
   * @internal
   */
  // eslint-disable-next-line no-restricted-syntax
  loadCameraAsync(context, camera, assign) {
    return this._loader.loadCameraAsync(context, camera, (babylonCamera) => {
      this._assignExtras(babylonCamera, camera);
      assign(babylonCamera);
    });
  }
  /**
   * @internal
   */
  createMaterial(context, material, babylonDrawMode) {
    const babylonMaterial = this._loader.createMaterial(context, material, babylonDrawMode);
    this._assignExtras(babylonMaterial, material);
    return babylonMaterial;
  }
};
unregisterGLTFExtension(NAME38);
registerGLTFExtension(NAME38, false, (loader) => new ExtrasAsMetadata(loader));

// node_modules/@babylonjs/loaders/STL/stlFileLoader.metadata.js
var STLFileLoaderMetadata = {
  name: "stl",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".stl": { isBinary: true }
  }
};

// node_modules/@babylonjs/loaders/STL/stlFileLoader.js
var STLFileLoader = class _STLFileLoader {
  constructor() {
    this.solidPattern = /solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g;
    this.facetsPattern = /facet([\s\S]*?)endfacet/g;
    this.normalPattern = /normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
    this.vertexPattern = /vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;
    this.name = STLFileLoaderMetadata.name;
    this.extensions = STLFileLoaderMetadata.extensions;
  }
  /**
   * Import meshes into a scene.
   * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported
   * @param scene The scene to import into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @param meshes The meshes array to import into
   * @returns True if successful or false otherwise
   */
  importMesh(meshesNames, scene, data, rootUrl, meshes) {
    let matches;
    if (typeof data !== "string") {
      if (this._isBinary(data)) {
        const babylonMesh = new Mesh("stlmesh", scene);
        this._parseBinary(babylonMesh, data);
        if (meshes) {
          meshes.push(babylonMesh);
        }
        return true;
      }
      data = new TextDecoder().decode(new Uint8Array(data));
    }
    while (matches = this.solidPattern.exec(data)) {
      let meshName = matches[1];
      const meshNameFromEnd = matches[3];
      if (meshNameFromEnd && meshName != meshNameFromEnd) {
        Tools.Error("Error in STL, solid name != endsolid name");
        return false;
      }
      if (meshesNames && meshName) {
        if (meshesNames instanceof Array) {
          if (!meshesNames.indexOf(meshName)) {
            continue;
          }
        } else {
          if (meshName !== meshesNames) {
            continue;
          }
        }
      }
      meshName = meshName || "stlmesh";
      const babylonMesh = new Mesh(meshName, scene);
      this._parseASCII(babylonMesh, matches[2]);
      if (meshes) {
        meshes.push(babylonMesh);
      }
    }
    return true;
  }
  /**
   * Load into a scene.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns true if successful or false otherwise
   */
  load(scene, data, rootUrl) {
    const result = this.importMesh(null, scene, data, rootUrl, null);
    return result;
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  loadAssetContainer(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    scene._blockEntityCollection = true;
    this.importMesh(null, scene, data, rootUrl, container.meshes);
    scene._blockEntityCollection = false;
    return container;
  }
  _isBinary(data) {
    const reader = new DataView(data);
    if (reader.byteLength <= 80) {
      return false;
    }
    const faceSize = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;
    const nFaces = reader.getUint32(80, true);
    if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {
      return true;
    }
    const ascii = [115, 111, 108, 105, 100];
    for (let off = 0; off < 5; off++) {
      if (reader.getUint8(off) !== ascii[off]) {
        return true;
      }
    }
    return false;
  }
  _parseBinary(mesh, data) {
    const reader = new DataView(data);
    const faces = reader.getUint32(80, true);
    const dataOffset = 84;
    const faceLength = 12 * 4 + 2;
    let offset = 0;
    const positions = new Float32Array(faces * 3 * 3);
    const normals = new Float32Array(faces * 3 * 3);
    const indices = new Uint32Array(faces * 3);
    let indicesCount = 0;
    for (let face = 0; face < faces; face++) {
      const start = dataOffset + face * faceLength;
      const normalX = reader.getFloat32(start, true);
      const normalY = reader.getFloat32(start + 4, true);
      const normalZ = reader.getFloat32(start + 8, true);
      for (let i = 1; i <= 3; i++) {
        const vertexstart = start + i * 12;
        positions[offset] = reader.getFloat32(vertexstart, true);
        normals[offset] = normalX;
        if (!_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
          positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);
          positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);
          normals[offset + 2] = normalY;
          normals[offset + 1] = normalZ;
        } else {
          positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);
          positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);
          normals[offset + 1] = normalY;
          normals[offset + 2] = normalZ;
        }
        offset += 3;
      }
      if (_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
        indices[indicesCount] = indicesCount;
        indices[indicesCount + 1] = indicesCount + 2;
        indices[indicesCount + 2] = indicesCount + 1;
        indicesCount += 3;
      } else {
        indices[indicesCount] = indicesCount++;
        indices[indicesCount] = indicesCount++;
        indices[indicesCount] = indicesCount++;
      }
    }
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  }
  _parseASCII(mesh, solidData) {
    const positions = [];
    const normals = [];
    const indices = [];
    let indicesCount = 0;
    let matches;
    while (matches = this.facetsPattern.exec(solidData)) {
      const facet = matches[1];
      const normalMatches = this.normalPattern.exec(facet);
      this.normalPattern.lastIndex = 0;
      if (!normalMatches) {
        continue;
      }
      const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];
      let vertexMatch;
      while (vertexMatch = this.vertexPattern.exec(facet)) {
        if (!_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
          positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));
          normals.push(normal[0], normal[1], normal[2]);
        } else {
          positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));
          normals.push(normal[0], normal[2], normal[1]);
        }
      }
      if (_STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {
        indices.push(indicesCount, indicesCount + 2, indicesCount + 1);
        indicesCount += 3;
      } else {
        indices.push(indicesCount++, indicesCount++, indicesCount++);
      }
      this.vertexPattern.lastIndex = 0;
    }
    this.facetsPattern.lastIndex = 0;
    mesh.setVerticesData(VertexBuffer.PositionKind, positions);
    mesh.setVerticesData(VertexBuffer.NormalKind, normals);
    mesh.setIndices(indices);
    mesh.computeWorldMatrix(true);
  }
};
STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = false;
RegisterSceneLoaderPlugin(new STLFileLoader());

// node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.metadata.js
var SPLATFileLoaderMetadata = {
  name: "splat",
  extensions: {
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".splat": { isBinary: true },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".ply": { isBinary: true },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".spz": { isBinary: true },
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".json": { isBinary: false },
    // For SOG metadata files
    // eslint-disable-next-line @typescript-eslint/naming-convention
    ".sog": { isBinary: true }
  }
};

// node_modules/@babylonjs/loaders/SPLAT/spz.js
function ParseSpz(data, scene, loadingOptions) {
  const ubuf = new Uint8Array(data);
  const ubufu32 = new Uint32Array(data.slice(0, 12));
  const splatCount = ubufu32[2];
  const shDegree = ubuf[12];
  const fractionalBits = ubuf[13];
  const flags = ubuf[14];
  const reserved = ubuf[15];
  const version = ubufu32[1];
  if (reserved || ubufu32[0] != 1347635022 || version != 2 && version != 3) {
    return new Promise((resolve) => {
      resolve({ mode: 3, data: buffer, hasVertexColors: false });
    });
  }
  const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
  const buffer = new ArrayBuffer(rowOutputLength * splatCount);
  const positionScale = 1 / (1 << fractionalBits);
  const int32View = new Int32Array(1);
  const uint8View = new Uint8Array(int32View.buffer);
  const read24bComponent = function(u8, offset) {
    uint8View[0] = u8[offset + 0];
    uint8View[1] = u8[offset + 1];
    uint8View[2] = u8[offset + 2];
    uint8View[3] = u8[offset + 2] & 128 ? 255 : 0;
    return int32View[0] * positionScale;
  };
  let byteOffset = 16;
  const position = new Float32Array(buffer);
  const scale = new Float32Array(buffer);
  const rgba = new Uint8ClampedArray(buffer);
  const rot = new Uint8ClampedArray(buffer);
  let coordinateSign = 1;
  let quaternionOffset = 0;
  if (!loadingOptions.flipY) {
    coordinateSign = -1;
    quaternionOffset = 255;
  }
  for (let i = 0; i < splatCount; i++) {
    position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);
    position[i * 8 + 1] = coordinateSign * read24bComponent(ubuf, byteOffset + 3);
    position[i * 8 + 2] = coordinateSign * read24bComponent(ubuf, byteOffset + 6);
    byteOffset += 9;
  }
  const shC0 = 0.282;
  for (let i = 0; i < splatCount; i++) {
    for (let component = 0; component < 3; component++) {
      const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];
      const value = (byteValue - 127.5) / (0.15 * 255);
      rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);
    }
    rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];
  }
  byteOffset += splatCount * 4;
  for (let i = 0; i < splatCount; i++) {
    scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16 - 10);
    scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16 - 10);
    scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16 - 10);
    byteOffset += 3;
  }
  if (version >= 3) {
    const sqrt12 = Math.SQRT1_2;
    for (let i = 0; i < splatCount; i++) {
      const r = [ubuf[byteOffset + 0], ubuf[byteOffset + 1], ubuf[byteOffset + 2], ubuf[byteOffset + 3]];
      const comp = r[0] + (r[1] << 8) + (r[2] << 16) + (r[3] << 24);
      const cmask = (1 << 9) - 1;
      const rotation = [];
      const iLargest = comp >>> 30;
      let remaining = comp;
      let sumSquares = 0;
      for (let i2 = 3; i2 >= 0; --i2) {
        if (i2 !== iLargest) {
          const mag = remaining & cmask;
          const negbit = remaining >>> 9 & 1;
          remaining = remaining >>> 10;
          rotation[i2] = sqrt12 * (mag / cmask);
          if (negbit === 1) {
            rotation[i2] = -rotation[i2];
          }
          sumSquares += rotation[i2] * rotation[i2];
        }
      }
      const square = 1 - sumSquares;
      rotation[iLargest] = Math.sqrt(Math.max(square, 0));
      rotation[1] *= coordinateSign;
      rotation[2] *= coordinateSign;
      const shuffle = [3, 0, 1, 2];
      for (let j = 0; j < 4; j++) {
        rot[i * 32 + 28 + j] = Math.round(127.5 + rotation[shuffle[j]] * 127.5);
      }
      byteOffset += 4;
    }
  } else {
    for (let i = 0; i < splatCount; i++) {
      const x = ubuf[byteOffset + 0];
      const y = ubuf[byteOffset + 1] * coordinateSign + quaternionOffset;
      const z = ubuf[byteOffset + 2] * coordinateSign + quaternionOffset;
      const nx = x / 127.5 - 1;
      const ny = y / 127.5 - 1;
      const nz = z / 127.5 - 1;
      rot[i * 32 + 28 + 1] = x;
      rot[i * 32 + 28 + 2] = y;
      rot[i * 32 + 28 + 3] = z;
      const v = 1 - (nx * nx + ny * ny + nz * nz);
      rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;
      byteOffset += 3;
    }
  }
  if (shDegree) {
    const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;
    const shComponentCount = shVectorCount * 3;
    const textureCount = Math.ceil(shComponentCount / 16);
    let shIndexRead = byteOffset;
    const sh = [];
    const engine = scene.getEngine();
    const width = engine.getCaps().maxTextureSize;
    const height = Math.ceil(splatCount / width);
    for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {
      const texture = new Uint8Array(height * width * 4 * 4);
      sh.push(texture);
    }
    for (let i = 0; i < splatCount; i++) {
      for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {
        const shValue = ubuf[shIndexRead++];
        const textureIndex = Math.floor(shIndexWrite / 16);
        const shArray = sh[textureIndex];
        const byteIndexInTexture = shIndexWrite % 16;
        const offsetPerSplat = i * 16;
        shArray[byteIndexInTexture + offsetPerSplat] = shValue;
      }
    }
    return new Promise((resolve) => {
      resolve({ mode: 0, data: buffer, hasVertexColors: false, sh, trainedWithAntialiasing: !!flags });
    });
  }
  return new Promise((resolve) => {
    resolve({ mode: 0, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });
  });
}

// node_modules/@babylonjs/loaders/SPLAT/sog.js
var SH_C0 = 0.28209479177387814;
async function LoadWebpImageData(rootUrlOrData, filename, engine) {
  const promise = new Promise((resolve, reject) => {
    const image = engine.createCanvasImage();
    if (!image) {
      throw new Error("Failed to create ImageBitmap");
    }
    image.onload = () => {
      try {
        const canvas = engine.createCanvas(image.width, image.height);
        if (!canvas) {
          throw new Error("Failed to create canvas");
        }
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Failed to get 2D context");
        }
        ctx.drawImage(image, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        resolve({ bits: new Uint8Array(imageData.data.buffer), width: imageData.width });
      } catch (error) {
        reject(`Error loading image ${image.src} with exception: ${error}`);
      }
    };
    image.onerror = (error) => {
      reject(`Error loading image ${image.src} with exception: ${error}`);
    };
    image.crossOrigin = "anonymous";
    let objectUrl;
    if (typeof rootUrlOrData === "string") {
      if (!filename) {
        throw new Error("filename is required when using a URL");
      }
      image.src = rootUrlOrData + filename;
    } else {
      const blob = new Blob([rootUrlOrData], { type: "image/webp" });
      objectUrl = URL.createObjectURL(blob);
      image.src = objectUrl;
    }
  });
  return await promise;
}
async function ParseSogDatas(data, imageDataArrays, scene) {
  const splatCount = data.count ? data.count : data.means.shape[0];
  const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4;
  const buffer = new ArrayBuffer(rowOutputLength * splatCount);
  const position = new Float32Array(buffer);
  const scale = new Float32Array(buffer);
  const rgba = new Uint8ClampedArray(buffer);
  const rot = new Uint8ClampedArray(buffer);
  const unlog = (n) => Math.sign(n) * (Math.exp(Math.abs(n)) - 1);
  const meansl = imageDataArrays[0].bits;
  const meansu = imageDataArrays[1].bits;
  if (!Array.isArray(data.means.mins) || !Array.isArray(data.means.maxs)) {
    throw new Error("Missing arrays in SOG data.");
  }
  for (let i = 0; i < splatCount; i++) {
    const index = i * 4;
    for (let j = 0; j < 3; j++) {
      const meansMin = data.means.mins[j];
      const meansMax = data.means.maxs[j];
      const meansup = meansu[index + j];
      const meanslow = meansl[index + j];
      const q = meansup << 8 | meanslow;
      const n = Scalar.Lerp(meansMin, meansMax, q / 65535);
      position[i * 8 + j] = unlog(n);
    }
  }
  const scales = imageDataArrays[2].bits;
  if (data.version === 2) {
    if (!data.scales.codebook) {
      throw new Error("Missing codebook in SOG version 2 scales data.");
    }
    for (let i = 0; i < splatCount; i++) {
      const index = i * 4;
      for (let j = 0; j < 3; j++) {
        const sc = data.scales.codebook[scales[index + j]];
        const sce = Math.exp(sc);
        scale[i * 8 + 3 + j] = sce;
      }
    }
  } else {
    if (!Array.isArray(data.scales.mins) || !Array.isArray(data.scales.maxs)) {
      throw new Error("Missing arrays in SOG scales data.");
    }
    for (let i = 0; i < splatCount; i++) {
      const index = i * 4;
      for (let j = 0; j < 3; j++) {
        const sc = scales[index + j];
        const lsc = Scalar.Lerp(data.scales.mins[j], data.scales.maxs[j], sc / 255);
        const lsce = Math.exp(lsc);
        scale[i * 8 + 3 + j] = lsce;
      }
    }
  }
  const colors = imageDataArrays[4].bits;
  if (data.version === 2) {
    if (!data.sh0.codebook) {
      throw new Error("Missing codebook in SOG version 2 sh0 data.");
    }
    for (let i = 0; i < splatCount; i++) {
      const index = i * 4;
      for (let j = 0; j < 3; j++) {
        const component = 0.5 + data.sh0.codebook[colors[index + j]] * SH_C0;
        rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * component)));
      }
      rgba[i * 32 + 24 + 3] = colors[index + 3];
    }
  } else {
    if (!Array.isArray(data.sh0.mins) || !Array.isArray(data.sh0.maxs)) {
      throw new Error("Missing arrays in SOG sh0 data.");
    }
    for (let i = 0; i < splatCount; i++) {
      const index = i * 4;
      for (let j = 0; j < 4; j++) {
        const colorsMin = data.sh0.mins[j];
        const colorsMax = data.sh0.maxs[j];
        const colort = colors[index + j];
        const c = Scalar.Lerp(colorsMin, colorsMax, colort / 255);
        let csh;
        if (j < 3) {
          csh = 0.5 + c * SH_C0;
        } else {
          csh = 1 / (1 + Math.exp(-c));
        }
        rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * csh)));
      }
    }
  }
  const toComp = (c) => (c / 255 - 0.5) * 2 / Math.SQRT2;
  const quatArray = imageDataArrays[3].bits;
  for (let i = 0; i < splatCount; i++) {
    const quatsr = quatArray[i * 4 + 0];
    const quatsg = quatArray[i * 4 + 1];
    const quatsb = quatArray[i * 4 + 2];
    const quatsa = quatArray[i * 4 + 3];
    const a = toComp(quatsr);
    const b = toComp(quatsg);
    const c = toComp(quatsb);
    const mode = quatsa - 252;
    const t = a * a + b * b + c * c;
    const d = Math.sqrt(Math.max(0, 1 - t));
    let q;
    switch (mode) {
      case 0:
        q = [d, a, b, c];
        break;
      // omitted = x
      case 1:
        q = [a, d, b, c];
        break;
      // omitted = y
      case 2:
        q = [a, b, d, c];
        break;
      // omitted = z
      case 3:
        q = [a, b, c, d];
        break;
      // omitted = w
      default:
        throw new Error("Invalid quaternion mode");
    }
    rot[i * 32 + 28 + 0] = q[0] * 127.5 + 127.5;
    rot[i * 32 + 28 + 1] = q[1] * 127.5 + 127.5;
    rot[i * 32 + 28 + 2] = q[2] * 127.5 + 127.5;
    rot[i * 32 + 28 + 3] = q[3] * 127.5 + 127.5;
  }
  if (data.shN) {
    const coeffCounts = [0, 3, 8, 15];
    const coeffs = data.shN.bands ? coeffCounts[data.shN.bands] : data.shN.shape[1] / 3;
    const shCentroids = imageDataArrays[5].bits;
    const shLabelsData = imageDataArrays[6].bits;
    const shCentroidsWidth = imageDataArrays[5].width;
    const shComponentCount = coeffs * 3;
    const textureCount = Math.ceil(shComponentCount / 16);
    const sh = [];
    const engine = scene.getEngine();
    const width = engine.getCaps().maxTextureSize;
    const height = Math.ceil(splatCount / width);
    for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {
      const texture = new Uint8Array(height * width * 4 * 4);
      sh.push(texture);
    }
    if (data.version === 2) {
      if (!data.shN.codebook) {
        throw new Error("Missing codebook in SOG version 2 shN data.");
      }
      for (let i = 0; i < splatCount; i++) {
        const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);
        const u = n % 64 * coeffs;
        const v = Math.floor(n / 64);
        for (let k = 0; k < coeffs; k++) {
          for (let j = 0; j < 3; j++) {
            const shIndexWrite = k * 3 + j;
            const textureIndex = Math.floor(shIndexWrite / 16);
            const shArray = sh[textureIndex];
            const byteIndexInTexture = shIndexWrite % 16;
            const offsetPerSplat = i * 16;
            const shValue = data.shN.codebook[shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4]] * 127.5 + 127.5;
            shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));
          }
        }
      }
    } else {
      for (let i = 0; i < splatCount; i++) {
        const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);
        const u = n % 64 * coeffs;
        const v = Math.floor(n / 64);
        const shMin = data.shN.mins;
        const shMax = data.shN.maxs;
        for (let j = 0; j < 3; j++) {
          for (let k = 0; k < coeffs / 3; k++) {
            const shIndexWrite = k * 3 + j;
            const textureIndex = Math.floor(shIndexWrite / 16);
            const shArray = sh[textureIndex];
            const byteIndexInTexture = shIndexWrite % 16;
            const offsetPerSplat = i * 16;
            const shValue = Scalar.Lerp(shMin, shMax, shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4] / 255) * 127.5 + 127.5;
            shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));
          }
        }
      }
    }
    return await new Promise((resolve) => {
      resolve({ mode: 0, data: buffer, hasVertexColors: false, sh });
    });
  }
  return await new Promise((resolve) => {
    resolve({ mode: 0, data: buffer, hasVertexColors: false });
  });
}
async function ParseSogMeta(dataOrFiles, rootUrl, scene) {
  let data;
  let files;
  if (dataOrFiles instanceof Map) {
    files = dataOrFiles;
    const metaFile = files.get("meta.json");
    if (!metaFile) {
      throw new Error("meta.json not found in files Map");
    }
    data = JSON.parse(new TextDecoder().decode(metaFile));
  } else {
    data = dataOrFiles;
  }
  const urls = [...data.means.files, ...data.scales.files, ...data.quats.files, ...data.sh0.files];
  if (data.shN) {
    urls.push(...data.shN.files);
  }
  const imageDataArrays = await Promise.all(urls.map(async (fileName) => {
    if (files && files.has(fileName)) {
      const fileData = files.get(fileName);
      return await LoadWebpImageData(fileData, fileName, scene.getEngine());
    } else {
      return await LoadWebpImageData(rootUrl, fileName, scene.getEngine());
    }
  }));
  return await ParseSogDatas(data, imageDataArrays, scene);
}

// node_modules/@babylonjs/loaders/SPLAT/splatFileLoader.js
var SPLATFileLoader = class _SPLATFileLoader {
  /**
   * Creates loader for gaussian splatting files
   * @param loadingOptions options for loading and parsing splat and PLY files.
   */
  constructor(loadingOptions = _SPLATFileLoader._DefaultLoadingOptions) {
    this.name = SPLATFileLoaderMetadata.name;
    this._assetContainer = null;
    this.extensions = SPLATFileLoaderMetadata.extensions;
    this._loadingOptions = loadingOptions;
  }
  /** @internal */
  createPlugin(options) {
    return new _SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);
  }
  /**
   * Imports  from the loaded gaussian splatting data and adds them to the scene
   * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file
   * @param scene the scene the meshes should be added to
   * @param data the gaussian splatting data to load
   * @param rootUrl root url to load from
   * @param _onProgress callback called while file is loading
   * @param _fileName Defines the name of the file to load
   * @returns a promise containing the loaded meshes, particles, skeletons and animations
   */
  async importMeshAsync(meshesNames, scene, data, rootUrl, _onProgress, _fileName) {
    return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {
      return {
        meshes,
        particleSystems: [],
        skeletons: [],
        animationGroups: [],
        transformNodes: [],
        geometries: [],
        lights: [],
        spriteManagers: []
      };
    });
  }
  static _BuildPointCloud(pointcloud, data) {
    if (!data.byteLength) {
      return false;
    }
    const uBuffer = new Uint8Array(data);
    const fBuffer = new Float32Array(data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const pointcloudfunc = function(particle, i) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      particle.position = new Vector3(x, y, z);
      const r = uBuffer[rowLength * i + 24 + 0] / 255;
      const g = uBuffer[rowLength * i + 24 + 1] / 255;
      const b = uBuffer[rowLength * i + 24 + 2] / 255;
      particle.color = new Color4(r, g, b, 1);
    };
    pointcloud.addPoints(vertexCount, pointcloudfunc);
    return true;
  }
  static _BuildMesh(scene, parsedPLY) {
    const mesh = new Mesh("PLYMesh", scene);
    const uBuffer = new Uint8Array(parsedPLY.data);
    const fBuffer = new Float32Array(parsedPLY.data);
    const rowLength = 3 * 4 + 3 * 4 + 4 + 4;
    const vertexCount = uBuffer.length / rowLength;
    const positions = [];
    const vertexData = new VertexData();
    for (let i = 0; i < vertexCount; i++) {
      const x = fBuffer[8 * i + 0];
      const y = fBuffer[8 * i + 1];
      const z = fBuffer[8 * i + 2];
      positions.push(x, y, z);
    }
    if (parsedPLY.hasVertexColors) {
      const colors = new Float32Array(vertexCount * 4);
      for (let i = 0; i < vertexCount; i++) {
        const r = uBuffer[rowLength * i + 24 + 0] / 255;
        const g = uBuffer[rowLength * i + 24 + 1] / 255;
        const b = uBuffer[rowLength * i + 24 + 2] / 255;
        colors[i * 4 + 0] = r;
        colors[i * 4 + 1] = g;
        colors[i * 4 + 2] = b;
        colors[i * 4 + 3] = 1;
      }
      vertexData.colors = colors;
    }
    vertexData.positions = positions;
    vertexData.indices = parsedPLY.faces;
    vertexData.applyToMesh(mesh);
    return mesh;
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax, @typescript-eslint/naming-convention
  async _unzipWithFFlateAsync(data) {
    let fflate = this._loadingOptions.fflate;
    if (!fflate) {
      if (typeof window.fflate === "undefined") {
        await Tools.LoadScriptAsync(this._loadingOptions.deflateURL ?? "https://unpkg.com/fflate/umd/index.js");
      }
      fflate = window.fflate;
    }
    const { unzipSync } = fflate;
    const unzipped = unzipSync(data);
    const files = /* @__PURE__ */ new Map();
    for (const [name2, content] of Object.entries(unzipped)) {
      files.set(name2, content);
    }
    return files;
  }
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  _parseAsync(meshesNames, scene, data, rootUrl) {
    const babylonMeshesArray = [];
    const makeGSFromParsedSOG = (parsedSOG) => {
      scene._blockEntityCollection = !!this._assetContainer;
      const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
      gaussianSplatting._parentContainer = this._assetContainer;
      gaussianSplatting.viewDirectionFactor.set(1, -1, 1);
      babylonMeshesArray.push(gaussianSplatting);
      gaussianSplatting.updateData(parsedSOG.data, parsedSOG.sh);
      scene._blockEntityCollection = false;
    };
    if (typeof data === "string") {
      const dataSOG = JSON.parse(data);
      if (dataSOG && dataSOG.means && dataSOG.scales && dataSOG.quats && dataSOG.sh0) {
        return new Promise((resolve) => {
          ParseSogMeta(dataSOG, rootUrl, scene).then((parsedSOG) => {
            makeGSFromParsedSOG(parsedSOG);
            resolve(babylonMeshesArray);
          }).catch(() => {
            throw new Error("Failed to parse SOG data.");
          });
        });
      }
    }
    const u8 = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
    if (u8[0] === 80 && u8[1] === 75) {
      return new Promise((resolve) => {
        this._unzipWithFFlateAsync(u8).then((files) => {
          ParseSogMeta(files, rootUrl, scene).then((parsedSOG) => {
            makeGSFromParsedSOG(parsedSOG);
            resolve(babylonMeshesArray);
          }).catch(() => {
            throw new Error("Failed to parse SOG zip data.");
          });
        });
      });
    }
    const readableStream = new ReadableStream({
      start(controller) {
        controller.enqueue(new Uint8Array(data));
        controller.close();
      }
    });
    const decompressionStream = new DecompressionStream("gzip");
    const decompressedStream = readableStream.pipeThrough(decompressionStream);
    return new Promise((resolve) => {
      new Response(decompressedStream).arrayBuffer().then((buffer) => {
        ParseSpz(buffer, scene, this._loadingOptions).then((parsedSPZ) => {
          scene._blockEntityCollection = !!this._assetContainer;
          const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
          if (parsedSPZ.trainedWithAntialiasing) {
            const gsMaterial = gaussianSplatting.material;
            gsMaterial.kernelSize = 0.1;
            gsMaterial.compensation = true;
          }
          gaussianSplatting._parentContainer = this._assetContainer;
          babylonMeshesArray.push(gaussianSplatting);
          gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh);
          scene._blockEntityCollection = false;
          resolve(babylonMeshesArray);
        });
      }).catch(() => {
        _SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {
          scene._blockEntityCollection = !!this._assetContainer;
          switch (parsedPLY.mode) {
            case 0:
              {
                const gaussianSplatting = new GaussianSplattingMesh("GaussianSplatting", null, scene, this._loadingOptions.keepInRam);
                gaussianSplatting._parentContainer = this._assetContainer;
                babylonMeshesArray.push(gaussianSplatting);
                gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh);
                if (parsedPLY.compressed || !parsedPLY.rawSplat) {
                  gaussianSplatting.viewDirectionFactor.set(-1, -1, 1);
                }
              }
              break;
            case 1:
              {
                const pointcloud = new PointsCloudSystem("PointCloud", 1, scene);
                if (_SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {
                  await pointcloud.buildMeshAsync().then((mesh) => {
                    babylonMeshesArray.push(mesh);
                  });
                } else {
                  pointcloud.dispose();
                }
              }
              break;
            case 2:
              {
                if (parsedPLY.faces) {
                  babylonMeshesArray.push(_SPLATFileLoader._BuildMesh(scene, parsedPLY));
                } else {
                  throw new Error("PLY mesh doesn't contain face informations.");
                }
              }
              break;
            default:
              throw new Error("Unsupported Splat mode");
          }
          scene._blockEntityCollection = false;
          resolve(babylonMeshesArray);
        });
      });
    });
  }
  /**
   * Load into an asset container.
   * @param scene The scene to load into
   * @param data The data to import
   * @param rootUrl The root url for scene and resources
   * @returns The loaded asset container
   */
  // eslint-disable-next-line no-restricted-syntax
  loadAssetContainerAsync(scene, data, rootUrl) {
    const container = new AssetContainer(scene);
    this._assetContainer = container;
    return this.importMeshAsync(null, scene, data, rootUrl).then((result) => {
      for (const mesh of result.meshes) {
        container.meshes.push(mesh);
      }
      this._assetContainer = null;
      return container;
    }).catch((ex) => {
      this._assetContainer = null;
      throw ex;
    });
  }
  /**
   * Imports all objects from the loaded OBJ data and adds them to the scene
   * @param scene the scene the objects should be added to
   * @param data the OBJ data to load
   * @param rootUrl root url to load from
   * @returns a promise which completes when objects have been loaded to the scene
   */
  // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax
  loadAsync(scene, data, rootUrl) {
    return this.importMeshAsync(null, scene, data, rootUrl).then(() => {
    });
  }
  /**
   * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license
   * Converts a .ply data array buffer to splat
   * if data array buffer is not ply, returns the original buffer
   * @param data the .ply data to load
   * @returns the loaded splat buffer
   */
  static _ConvertPLYToSplat(data) {
    const ubuf = new Uint8Array(data);
    const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));
    const headerEnd = "end_header\n";
    const headerEndIndex = header.indexOf(headerEnd);
    if (headerEndIndex < 0 || !header) {
      return new Promise((resolve) => {
        resolve({ mode: 0, data, rawSplat: true });
      });
    }
    const vertexCount = parseInt(/element vertex (\d+)\n/.exec(header)[1]);
    const faceElement = /element face (\d+)\n/.exec(header);
    let faceCount = 0;
    if (faceElement) {
      faceCount = parseInt(faceElement[1]);
    }
    const chunkElement = /element chunk (\d+)\n/.exec(header);
    let chunkCount = 0;
    if (chunkElement) {
      chunkCount = parseInt(chunkElement[1]);
    }
    let rowVertexOffset = 0;
    let rowChunkOffset = 0;
    const offsets = {
      double: 8,
      int: 4,
      uint: 4,
      float: 4,
      short: 2,
      ushort: 2,
      uchar: 1,
      list: 0
    };
    let ElementMode;
    (function(ElementMode2) {
      ElementMode2[ElementMode2["Vertex"] = 0] = "Vertex";
      ElementMode2[ElementMode2["Chunk"] = 1] = "Chunk";
      ElementMode2[ElementMode2["SH"] = 2] = "SH";
    })(ElementMode || (ElementMode = {}));
    let chunkMode = 1;
    const vertexProperties = [];
    const chunkProperties = [];
    const filtered = header.slice(0, headerEndIndex).split("\n");
    for (const prop of filtered) {
      if (prop.startsWith("property ")) {
        const [, type, name2] = prop.split(" ");
        if (chunkMode == 1) {
          chunkProperties.push({ name: name2, type, offset: rowChunkOffset });
          rowChunkOffset += offsets[type];
        } else if (chunkMode == 0) {
          vertexProperties.push({ name: name2, type, offset: rowVertexOffset });
          rowVertexOffset += offsets[type];
        } else if (chunkMode == 2) {
          vertexProperties.push({ name: name2, type, offset: rowVertexOffset });
        }
        if (!offsets[type]) {
          Logger.Warn(`Unsupported property type: ${type}.`);
        }
      } else if (prop.startsWith("element ")) {
        const [, type] = prop.split(" ");
        if (type == "chunk") {
          chunkMode = 1;
        } else if (type == "vertex") {
          chunkMode = 0;
        } else if (type == "sh") {
          chunkMode = 2;
        }
      }
    }
    const rowVertexLength = rowVertexOffset;
    const rowChunkLength = rowChunkOffset;
    return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(async (splatsData) => {
      const dataView = new DataView(data, headerEndIndex + headerEnd.length);
      let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;
      const faces = [];
      if (faceCount) {
        for (let i = 0; i < faceCount; i++) {
          const faceVertexCount = dataView.getUint8(offset);
          if (faceVertexCount != 3) {
            continue;
          }
          offset += 1;
          for (let j = 0; j < faceVertexCount; j++) {
            const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true);
            faces.push(vertexIndex);
          }
          offset += 12;
        }
      }
      if (chunkCount) {
        return await new Promise((resolve) => {
          resolve({ mode: 0, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: false, compressed: true, rawSplat: false });
        });
      }
      let propertyCount = 0;
      let propertyColorCount = 0;
      const splatProperties = ["x", "y", "z", "scale_0", "scale_1", "scale_2", "opacity", "rot_0", "rot_1", "rot_2", "rot_3"];
      const splatColorProperties = ["red", "green", "blue", "f_dc_0", "f_dc_1", "f_dc_2"];
      for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {
        const property = vertexProperties[propertyIndex];
        if (splatProperties.includes(property.name)) {
          propertyCount++;
        }
        if (splatColorProperties.includes(property.name)) {
          propertyColorCount++;
        }
      }
      const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;
      const currentMode = faceCount ? 2 : hasMandatoryProperties ? 0 : 1;
      return await new Promise((resolve) => {
        resolve({ mode: currentMode, data: splatsData.buffer, sh: splatsData.sh, faces, hasVertexColors: !!propertyColorCount, compressed: false, rawSplat: false });
      });
    });
  }
};
SPLATFileLoader._DefaultLoadingOptions = {
  keepInRam: false,
  flipY: false
};
RegisterSceneLoaderPlugin(new SPLATFileLoader());
export {
  BVHFileLoader,
  __exports as GLTF1,
  __exports2 as GLTF2,
  GLTFFileLoader,
  GLTFLoaderAnimationStartMode,
  GLTFLoaderCoordinateSystemMode,
  GLTFLoaderDefaultOptions,
  GLTFLoaderState,
  GLTFValidation,
  MTLFileLoader,
  OBJFileLoader,
  ReadBvh,
  SPLATFileLoader,
  STLFileLoader,
  SolidParser
};
//# sourceMappingURL=@babylonjs_loaders.js.map
