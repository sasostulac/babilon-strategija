{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/clipPlaneMaterialHelper.ts", "../../../dev/core/src/Materials/materialFlags.ts", "../../../dev/core/src/Materials/materialHelper.functions.pure.ts", "../../../dev/core/src/Materials/materialHelper.functions.ts"],
  "sourcesContent": ["import type { Effect } from \"./effect\";\r\nimport type { IClipPlanesHolder } from \"../Misc/interfaces/iClipPlanesHolder\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Plane } from \"../Maths/math.plane\";\r\n\r\n/** @internal */\r\nexport function AddClipPlaneUniforms(uniforms: string[]): void {\r\n    if (uniforms.indexOf(\"vClipPlane\") === -1) {\r\n        uniforms.push(\"vClipPlane\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane2\") === -1) {\r\n        uniforms.push(\"vClipPlane2\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane3\") === -1) {\r\n        uniforms.push(\"vClipPlane3\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane4\") === -1) {\r\n        uniforms.push(\"vClipPlane4\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane5\") === -1) {\r\n        uniforms.push(\"vClipPlane5\");\r\n    }\r\n    if (uniforms.indexOf(\"vClipPlane6\") === -1) {\r\n        uniforms.push(\"vClipPlane6\");\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function PrepareStringDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: string[]): void {\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    if (clipPlane) {\r\n        defines.push(\"#define CLIPPLANE\");\r\n    }\r\n    if (clipPlane2) {\r\n        defines.push(\"#define CLIPPLANE2\");\r\n    }\r\n    if (clipPlane3) {\r\n        defines.push(\"#define CLIPPLANE3\");\r\n    }\r\n    if (clipPlane4) {\r\n        defines.push(\"#define CLIPPLANE4\");\r\n    }\r\n    if (clipPlane5) {\r\n        defines.push(\"#define CLIPPLANE5\");\r\n    }\r\n    if (clipPlane6) {\r\n        defines.push(\"#define CLIPPLANE6\");\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport function PrepareDefinesForClipPlanes(primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder, defines: Record<string, any>): boolean {\r\n    let changed = false;\r\n\r\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\r\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\r\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\r\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\r\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\r\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\r\n\r\n    // Do not factorize this code, it breaks browsers optimizations.\r\n    if (defines[\"CLIPPLANE\"] !== clipPlane) {\r\n        defines[\"CLIPPLANE\"] = clipPlane;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\r\n        defines[\"CLIPPLANE2\"] = clipPlane2;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\r\n        defines[\"CLIPPLANE3\"] = clipPlane3;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\r\n        defines[\"CLIPPLANE4\"] = clipPlane4;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\r\n        defines[\"CLIPPLANE5\"] = clipPlane5;\r\n        changed = true;\r\n    }\r\n    if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\r\n        defines[\"CLIPPLANE6\"] = clipPlane6;\r\n        changed = true;\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/** @internal */\r\nexport function BindClipPlane(effect: Effect, primaryHolder: IClipPlanesHolder, secondaryHolder: IClipPlanesHolder): void {\r\n    let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\r\n    SetClipPlane(effect, \"vClipPlane\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\r\n    SetClipPlane(effect, \"vClipPlane2\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\r\n    SetClipPlane(effect, \"vClipPlane3\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\r\n    SetClipPlane(effect, \"vClipPlane4\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\r\n    SetClipPlane(effect, \"vClipPlane5\", clipPlane);\r\n    clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\r\n    SetClipPlane(effect, \"vClipPlane6\", clipPlane);\r\n}\r\n\r\nfunction SetClipPlane(effect: Effect, uniformName: string, clipPlane: Nullable<Plane>): void {\r\n    if (clipPlane) {\r\n        effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\r\n    }\r\n}\r\n", "import { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { Constants } from \"../Engines/constants\";\r\n\r\n/**\r\n * This groups all the flags used to control the materials channel.\r\n */\r\nexport class MaterialFlags {\r\n    // Flags used to enable or disable a type of texture for all Standard Materials\r\n    private static _DiffuseTextureEnabled = true;\r\n    /**\r\n     * Are diffuse textures enabled in the application.\r\n     */\r\n    public static get DiffuseTextureEnabled(): boolean {\r\n        return this._DiffuseTextureEnabled;\r\n    }\r\n    public static set DiffuseTextureEnabled(value: boolean) {\r\n        if (this._DiffuseTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DiffuseTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _BaseWeightTextureEnabled = true;\r\n    /**\r\n     * Is the OpenPBR Base Weight texture enabled in the application.\r\n     */\r\n    public static get BaseWeightTextureEnabled(): boolean {\r\n        return this._BaseWeightTextureEnabled;\r\n    }\r\n    public static set BaseWeightTextureEnabled(value: boolean) {\r\n        if (this._BaseWeightTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BaseWeightTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _BaseDiffuseRoughnessTextureEnabled = true;\r\n    /**\r\n     * Is the OpenPBR Base Diffuse Roughness texture enabled in the application.\r\n     */\r\n    public static get BaseDiffuseRoughnessTextureEnabled(): boolean {\r\n        return this._BaseDiffuseRoughnessTextureEnabled;\r\n    }\r\n    public static set BaseDiffuseRoughnessTextureEnabled(value: boolean) {\r\n        if (this._BaseDiffuseRoughnessTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BaseDiffuseRoughnessTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DetailTextureEnabled = true;\r\n    /**\r\n     * Are detail textures enabled in the application.\r\n     */\r\n    public static get DetailTextureEnabled(): boolean {\r\n        return this._DetailTextureEnabled;\r\n    }\r\n    public static set DetailTextureEnabled(value: boolean) {\r\n        if (this._DetailTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DetailTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _DecalMapEnabled = true;\r\n    /**\r\n     * Are decal maps enabled in the application.\r\n     */\r\n    public static get DecalMapEnabled(): boolean {\r\n        return this._DecalMapEnabled;\r\n    }\r\n    public static set DecalMapEnabled(value: boolean) {\r\n        if (this._DecalMapEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._DecalMapEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AmbientTextureEnabled = true;\r\n    /**\r\n     * Are ambient textures enabled in the application.\r\n     */\r\n    public static get AmbientTextureEnabled(): boolean {\r\n        return this._AmbientTextureEnabled;\r\n    }\r\n    public static set AmbientTextureEnabled(value: boolean) {\r\n        if (this._AmbientTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AmbientTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _OpacityTextureEnabled = true;\r\n    /**\r\n     * Are opacity textures enabled in the application.\r\n     */\r\n    public static get OpacityTextureEnabled(): boolean {\r\n        return this._OpacityTextureEnabled;\r\n    }\r\n    public static set OpacityTextureEnabled(value: boolean) {\r\n        if (this._OpacityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._OpacityTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ReflectionTextureEnabled = true;\r\n    /**\r\n     * Are reflection textures enabled in the application.\r\n     */\r\n    public static get ReflectionTextureEnabled(): boolean {\r\n        return this._ReflectionTextureEnabled;\r\n    }\r\n    public static set ReflectionTextureEnabled(value: boolean) {\r\n        if (this._ReflectionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ReflectionTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _EmissiveTextureEnabled = true;\r\n    /**\r\n     * Are emissive textures enabled in the application.\r\n     */\r\n    public static get EmissiveTextureEnabled(): boolean {\r\n        return this._EmissiveTextureEnabled;\r\n    }\r\n    public static set EmissiveTextureEnabled(value: boolean) {\r\n        if (this._EmissiveTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._EmissiveTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SpecularTextureEnabled = true;\r\n    /**\r\n     * Are specular textures enabled in the application.\r\n     */\r\n    public static get SpecularTextureEnabled(): boolean {\r\n        return this._SpecularTextureEnabled;\r\n    }\r\n    public static set SpecularTextureEnabled(value: boolean) {\r\n        if (this._SpecularTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SpecularTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _BumpTextureEnabled = true;\r\n    /**\r\n     * Are bump textures enabled in the application.\r\n     */\r\n    public static get BumpTextureEnabled(): boolean {\r\n        return this._BumpTextureEnabled;\r\n    }\r\n    public static set BumpTextureEnabled(value: boolean) {\r\n        if (this._BumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._BumpTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _LightmapTextureEnabled = true;\r\n    /**\r\n     * Are lightmap textures enabled in the application.\r\n     */\r\n    public static get LightmapTextureEnabled(): boolean {\r\n        return this._LightmapTextureEnabled;\r\n    }\r\n    public static set LightmapTextureEnabled(value: boolean) {\r\n        if (this._LightmapTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._LightmapTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionTextureEnabled = true;\r\n    /**\r\n     * Are refraction textures enabled in the application.\r\n     */\r\n    public static get RefractionTextureEnabled(): boolean {\r\n        return this._RefractionTextureEnabled;\r\n    }\r\n    public static set RefractionTextureEnabled(value: boolean) {\r\n        if (this._RefractionTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ColorGradingTextureEnabled = true;\r\n    /**\r\n     * Are color grading textures enabled in the application.\r\n     */\r\n    public static get ColorGradingTextureEnabled(): boolean {\r\n        return this._ColorGradingTextureEnabled;\r\n    }\r\n    public static set ColorGradingTextureEnabled(value: boolean) {\r\n        if (this._ColorGradingTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ColorGradingTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _FresnelEnabled = true;\r\n    /**\r\n     * Are fresnels enabled in the application.\r\n     */\r\n    public static get FresnelEnabled(): boolean {\r\n        return this._FresnelEnabled;\r\n    }\r\n    public static set FresnelEnabled(value: boolean) {\r\n        if (this._FresnelEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._FresnelEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_FresnelDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTextureEnabled = true;\r\n    /**\r\n     * Are clear coat textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTextureEnabled(): boolean {\r\n        return this._ClearCoatTextureEnabled;\r\n    }\r\n    public static set ClearCoatTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatBumpTextureEnabled = true;\r\n    /**\r\n     * Are clear coat bump textures enabled in the application.\r\n     */\r\n    public static get ClearCoatBumpTextureEnabled(): boolean {\r\n        return this._ClearCoatBumpTextureEnabled;\r\n    }\r\n    public static set ClearCoatBumpTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatBumpTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatBumpTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ClearCoatTintTextureEnabled = true;\r\n    /**\r\n     * Are clear coat tint textures enabled in the application.\r\n     */\r\n    public static get ClearCoatTintTextureEnabled(): boolean {\r\n        return this._ClearCoatTintTextureEnabled;\r\n    }\r\n    public static set ClearCoatTintTextureEnabled(value: boolean) {\r\n        if (this._ClearCoatTintTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ClearCoatTintTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _SheenTextureEnabled = true;\r\n    /**\r\n     * Are sheen textures enabled in the application.\r\n     */\r\n    public static get SheenTextureEnabled(): boolean {\r\n        return this._SheenTextureEnabled;\r\n    }\r\n    public static set SheenTextureEnabled(value: boolean) {\r\n        if (this._SheenTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._SheenTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _AnisotropicTextureEnabled = true;\r\n    /**\r\n     * Are anisotropic textures enabled in the application.\r\n     */\r\n    public static get AnisotropicTextureEnabled(): boolean {\r\n        return this._AnisotropicTextureEnabled;\r\n    }\r\n    public static set AnisotropicTextureEnabled(value: boolean) {\r\n        if (this._AnisotropicTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._AnisotropicTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _ThicknessTextureEnabled = true;\r\n    /**\r\n     * Are thickness textures enabled in the application.\r\n     */\r\n    public static get ThicknessTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set ThicknessTextureEnabled(value: boolean) {\r\n        if (this._ThicknessTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._ThicknessTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _RefractionIntensityTextureEnabled = true;\r\n    /**\r\n     * Are refraction intensity textures enabled in the application.\r\n     */\r\n    public static get RefractionIntensityTextureEnabled(): boolean {\r\n        return this._ThicknessTextureEnabled;\r\n    }\r\n    public static set RefractionIntensityTextureEnabled(value: boolean) {\r\n        if (this._RefractionIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._RefractionIntensityTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _TranslucencyIntensityTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get TranslucencyIntensityTextureEnabled(): boolean {\r\n        return this._TranslucencyIntensityTextureEnabled;\r\n    }\r\n    public static set TranslucencyIntensityTextureEnabled(value: boolean) {\r\n        if (this._TranslucencyIntensityTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._TranslucencyIntensityTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _TranslucencyColorTextureEnabled = true;\r\n    /**\r\n     * Are translucency tint textures enabled in the application.\r\n     */\r\n    public static get TranslucencyColorTextureEnabled(): boolean {\r\n        return this._TranslucencyColorTextureEnabled;\r\n    }\r\n    public static set TranslucencyColorTextureEnabled(value: boolean) {\r\n        if (this._TranslucencyColorTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._TranslucencyColorTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private static _IridescenceTextureEnabled = true;\r\n    /**\r\n     * Are translucency intensity textures enabled in the application.\r\n     */\r\n    public static get IridescenceTextureEnabled(): boolean {\r\n        return this._IridescenceTextureEnabled;\r\n    }\r\n    public static set IridescenceTextureEnabled(value: boolean) {\r\n        if (this._IridescenceTextureEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._IridescenceTextureEnabled = value;\r\n        AbstractEngine.MarkAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n}\r\n", "/** This file must only contain pure code and pure imports */\r\n\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect } from \"./effect\";\r\n\r\n// All non-type imports must be pure\r\n\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n// All code must be pure\r\n\r\n/**\r\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\r\n * @param defines The generated defines used in the effect\r\n * @param effect The effect we are binding the data to\r\n * @param scene The scene we are willing to render with logarithmic scale for\r\n */\r\nexport function BindLogDepth(defines: any, effect: Effect, scene: Scene): void {\r\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\r\n        const camera = scene.activeCamera as Camera;\r\n        if (camera.mode === Constants.ORTHOGRAPHIC_CAMERA) {\r\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\r\n        }\r\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\r\n    }\r\n}\r\n", "import { Logger } from \"../Misc/logger\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Effect, IEffectCreationOptions } from \"./effect\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { UniformBuffer } from \"./uniformBuffer\";\r\nimport type { BaseTexture } from \"./Textures/baseTexture\";\r\nimport type { PrePassConfiguration } from \"./prePassConfiguration\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport type { MaterialDefines } from \"./materialDefines\";\r\nimport type { EffectFallbacks } from \"./effectFallbacks\";\r\nimport { LightConstants } from \"../Lights/lightConstants\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport type { Material } from \"./material\";\r\nimport type { Nullable } from \"../types\";\r\nimport { PrepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\r\nimport type { MorphTargetManager } from \"../Morph/morphTargetManager\";\r\nimport type { IColor3Like } from \"core/Maths/math.like\";\r\nimport { MaterialFlags } from \"./materialFlags\";\r\nimport { Texture } from \"./Textures/texture\";\r\nimport type { CubeTexture } from \"./Textures/cubeTexture\";\r\nimport type { Color3 } from \"core/Maths/math.color\";\r\n\r\n// For backwards compatibility, we export everything from the pure version of this file.\r\nexport * from \"./materialHelper.functions.pure\";\r\n\r\n// Temps\r\nconst TempFogColor: IColor3Like = { r: 0, g: 0, b: 0 };\r\nconst TmpMorphInfluencers = {\r\n    NUM_MORPH_INFLUENCERS: 0,\r\n    NORMAL: false,\r\n    TANGENT: false,\r\n    UV: false,\r\n    UV2: false,\r\n    COLOR: false,\r\n};\r\n\r\n/**\r\n * Binds the fog information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param linearSpace Defines if the fog effect is applied in linear space\r\n */\r\nexport function BindFogParameters(scene: Scene, mesh?: AbstractMesh, effect?: Effect, linearSpace = false): void {\r\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== Constants.FOGMODE_NONE) {\r\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\r\n        // Convert fog color to linear space if used in a linear space computed shader.\r\n        if (linearSpace) {\r\n            scene.fogColor.toLinearSpaceToRef(TempFogColor, scene.getEngine().useExactSrgbConversions);\r\n            effect.setColor3(\"vFogColor\", TempFogColor);\r\n        } else {\r\n            effect.setColor3(\"vFogColor\", scene.fogColor);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes and defines required for morph targets.\r\n * @param morphTargetManager The manager for the morph targets\r\n * @param defines The current list of defines\r\n * @param attribs The current list of attributes\r\n * @param mesh The mesh to prepare the defines and attributes for\r\n * @param usePositionMorph Whether the position morph target is used\r\n * @param useNormalMorph Whether the normal morph target is used\r\n * @param useTangentMorph Whether the tangent morph target is used\r\n * @param useUVMorph Whether the UV morph target is used\r\n * @param useUV2Morph Whether the UV2 morph target is used\r\n * @param useColorMorph Whether the color morph target is used\r\n * @returns The maxSimultaneousMorphTargets for the effect\r\n */\r\nexport function PrepareDefinesAndAttributesForMorphTargets(\r\n    morphTargetManager: MorphTargetManager,\r\n    defines: string[],\r\n    attribs: string[],\r\n    mesh: AbstractMesh,\r\n    usePositionMorph: boolean,\r\n    useNormalMorph: boolean,\r\n    useTangentMorph: boolean,\r\n    useUVMorph: boolean,\r\n    useUV2Morph: boolean,\r\n    useColorMorph: boolean\r\n): number {\r\n    const numMorphInfluencers = morphTargetManager.numMaxInfluencers || morphTargetManager.numInfluencers;\r\n    if (numMorphInfluencers <= 0) {\r\n        return 0;\r\n    }\r\n\r\n    defines.push(\"#define MORPHTARGETS\");\r\n\r\n    if (morphTargetManager.hasPositions) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASPOSITIONS\");\r\n    }\r\n    if (morphTargetManager.hasNormals) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASNORMALS\");\r\n    }\r\n    if (morphTargetManager.hasTangents) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASTANGENTS\");\r\n    }\r\n    if (morphTargetManager.hasUVs) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASUVS\");\r\n    }\r\n    if (morphTargetManager.hasUV2s) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASUV2S\");\r\n    }\r\n    if (morphTargetManager.hasColors) {\r\n        defines.push(\"#define MORPHTARGETTEXTURE_HASCOLORS\");\r\n    }\r\n\r\n    if (morphTargetManager.supportsPositions && usePositionMorph) {\r\n        defines.push(\"#define MORPHTARGETS_POSITION\");\r\n    }\r\n    if (morphTargetManager.supportsNormals && useNormalMorph) {\r\n        defines.push(\"#define MORPHTARGETS_NORMAL\");\r\n    }\r\n    if (morphTargetManager.supportsTangents && useTangentMorph) {\r\n        defines.push(\"#define MORPHTARGETS_TANGENT\");\r\n    }\r\n    if (morphTargetManager.supportsUVs && useUVMorph) {\r\n        defines.push(\"#define MORPHTARGETS_UV\");\r\n    }\r\n    if (morphTargetManager.supportsUV2s && useUV2Morph) {\r\n        defines.push(\"#define MORPHTARGETS_UV2\");\r\n    }\r\n    if (morphTargetManager.supportsColors && useColorMorph) {\r\n        defines.push(\"#define MORPHTARGETS_COLOR\");\r\n    }\r\n\r\n    defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numMorphInfluencers);\r\n\r\n    if (morphTargetManager.isUsingTextureForTargets) {\r\n        defines.push(\"#define MORPHTARGETS_TEXTURE\");\r\n    }\r\n\r\n    TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = numMorphInfluencers;\r\n    TmpMorphInfluencers.NORMAL = useNormalMorph;\r\n    TmpMorphInfluencers.TANGENT = useTangentMorph;\r\n    TmpMorphInfluencers.UV = useUVMorph;\r\n    TmpMorphInfluencers.UV2 = useUV2Morph;\r\n    TmpMorphInfluencers.COLOR = useColorMorph;\r\n\r\n    PrepareAttributesForMorphTargets(attribs, mesh, TmpMorphInfluencers, usePositionMorph);\r\n    return numMorphInfluencers;\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param influencers The number of influencers\r\n */\r\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs: string[], mesh: AbstractMesh, influencers: number): void {\r\n    TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\r\n    TmpMorphInfluencers.NORMAL = false;\r\n    TmpMorphInfluencers.TANGENT = false;\r\n    TmpMorphInfluencers.UV = false;\r\n    TmpMorphInfluencers.UV2 = false;\r\n    TmpMorphInfluencers.COLOR = false;\r\n    PrepareAttributesForMorphTargets(attribs, mesh, TmpMorphInfluencers, true);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for morph targets according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the morph targets attributes for\r\n * @param defines The current Defines of the effect\r\n * @param usePositionMorph Whether the position morph target is used\r\n */\r\nexport function PrepareAttributesForMorphTargets(attribs: string[], mesh: AbstractMesh, defines: any, usePositionMorph = true): void {\r\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\r\n\r\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\r\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\r\n        const manager = (mesh as Mesh).morphTargetManager;\r\n        if (manager?.isUsingTextureForTargets) {\r\n            return;\r\n        }\r\n        const position = manager && manager.supportsPositions && usePositionMorph;\r\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\r\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\r\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\r\n        const uv2 = manager && manager.supportsUV2s && defines[\"UV2\"];\r\n        const color = manager && manager.supportsColors && defines[\"VERTEXCOLOR\"];\r\n        for (let index = 0; index < influencers; index++) {\r\n            if (position) {\r\n                attribs.push(Constants.PositionKind + index);\r\n            }\r\n\r\n            if (normal) {\r\n                attribs.push(Constants.NormalKind + index);\r\n            }\r\n\r\n            if (tangent) {\r\n                attribs.push(Constants.TangentKind + index);\r\n            }\r\n\r\n            if (uv) {\r\n                attribs.push(Constants.UVKind + \"_\" + index);\r\n            }\r\n\r\n            if (uv2) {\r\n                attribs.push(Constants.UV2Kind + \"_\" + index);\r\n            }\r\n\r\n            if (color) {\r\n                attribs.push(Constants.ColorKind + index);\r\n            }\r\n\r\n            if (attribs.length > maxAttributesCount) {\r\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Add the list of attributes required for instances to the attribs array.\r\n * @param attribs The current list of supported attribs\r\n * @param needsPreviousMatrices If the shader needs previous matrices\r\n */\r\nexport function PushAttributesForInstances(attribs: string[], needsPreviousMatrices: boolean = false): void {\r\n    attribs.push(\"world0\");\r\n    attribs.push(\"world1\");\r\n    attribs.push(\"world2\");\r\n    attribs.push(\"world3\");\r\n    if (needsPreviousMatrices) {\r\n        attribs.push(\"previousWorld0\");\r\n        attribs.push(\"previousWorld1\");\r\n        attribs.push(\"previousWorld2\");\r\n        attribs.push(\"previousWorld3\");\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the morph targets information from the mesh to the effect.\r\n * @param abstractMesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n */\r\nexport function BindMorphTargetParameters(abstractMesh: AbstractMesh, effect: Effect): void {\r\n    const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n    if (!abstractMesh || !manager) {\r\n        return;\r\n    }\r\n\r\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\r\n}\r\n\r\n/**\r\n * Binds the scene's uniform buffer to the effect.\r\n * @param effect defines the effect to bind to the scene uniform buffer\r\n * @param sceneUbo defines the uniform buffer storing scene data\r\n */\r\nexport function BindSceneUniformBuffer(effect: Effect, sceneUbo: UniformBuffer): void {\r\n    sceneUbo.bindToEffect(effect, \"Scene\");\r\n}\r\n\r\n/**\r\n * Update parameters for IBL\r\n * @param scene The scene\r\n * @param defines The list of shader defines for the material\r\n * @param ubo The uniform buffer to update\r\n * @param reflectionColor The color to use for the reflection\r\n * @param reflectionTexture The IBL texture\r\n * @param realTimeFiltering Whether realtime filtering of IBL texture is being used\r\n * @param supportTextureInfo Whether the texture info is supported\r\n * @param supportLocalProjection Whether local projection is supported\r\n * @param usePBR Whether PBR is being used\r\n * @param supportSH Whether spherical harmonics are supported\r\n * @param useColor Whether to use the reflection color\r\n * @param reflectionBlur The level of blur of the reflection\r\n */\r\nexport function BindIBLParameters(\r\n    scene: Scene,\r\n    defines: any,\r\n    ubo: UniformBuffer,\r\n    reflectionColor: Color3,\r\n    reflectionTexture: Nullable<BaseTexture> = null,\r\n    realTimeFiltering: boolean = false,\r\n    supportTextureInfo: boolean = false,\r\n    supportLocalProjection: boolean = false,\r\n    usePBR: boolean = false,\r\n    supportSH: boolean = false,\r\n    useColor: boolean = false,\r\n    reflectionBlur: number = 0\r\n): void {\r\n    if (scene.texturesEnabled) {\r\n        if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n            ubo.updateMatrix(\"reflectionMatrix\", reflectionTexture.getReflectionTextureMatrix());\r\n            ubo.updateFloat2(\"vReflectionInfos\", reflectionTexture.level * scene.iblIntensity, reflectionBlur);\r\n\r\n            if (supportLocalProjection && (<any>reflectionTexture).boundingBoxSize) {\r\n                const cubeTexture = <CubeTexture>reflectionTexture;\r\n\r\n                ubo.updateVector3(\"vReflectionPosition\", cubeTexture.boundingBoxPosition);\r\n                ubo.updateVector3(\"vReflectionSize\", cubeTexture.boundingBoxSize);\r\n            }\r\n\r\n            if (realTimeFiltering) {\r\n                const width = reflectionTexture.getSize().width;\r\n                ubo.updateFloat2(\"vReflectionFilteringInfo\", width, Math.log2(width));\r\n            }\r\n\r\n            if (supportSH && !defines.USEIRRADIANCEMAP) {\r\n                const polynomials = reflectionTexture.sphericalPolynomial;\r\n                if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {\r\n                    if (defines.SPHERICAL_HARMONICS) {\r\n                        const preScaledHarmonics = polynomials.preScaledHarmonics;\r\n                        ubo.updateVector3(\"vSphericalL00\", preScaledHarmonics.l00);\r\n                        ubo.updateVector3(\"vSphericalL1_1\", preScaledHarmonics.l1_1);\r\n                        ubo.updateVector3(\"vSphericalL10\", preScaledHarmonics.l10);\r\n                        ubo.updateVector3(\"vSphericalL11\", preScaledHarmonics.l11);\r\n                        ubo.updateVector3(\"vSphericalL2_2\", preScaledHarmonics.l2_2);\r\n                        ubo.updateVector3(\"vSphericalL2_1\", preScaledHarmonics.l2_1);\r\n                        ubo.updateVector3(\"vSphericalL20\", preScaledHarmonics.l20);\r\n                        ubo.updateVector3(\"vSphericalL21\", preScaledHarmonics.l21);\r\n                        ubo.updateVector3(\"vSphericalL22\", preScaledHarmonics.l22);\r\n                    } else {\r\n                        ubo.updateFloat3(\"vSphericalX\", polynomials.x.x, polynomials.x.y, polynomials.x.z);\r\n                        ubo.updateFloat3(\"vSphericalY\", polynomials.y.x, polynomials.y.y, polynomials.y.z);\r\n                        ubo.updateFloat3(\"vSphericalZ\", polynomials.z.x, polynomials.z.y, polynomials.z.z);\r\n                        ubo.updateFloat3(\"vSphericalXX_ZZ\", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);\r\n                        ubo.updateFloat3(\"vSphericalYY_ZZ\", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);\r\n                        ubo.updateFloat3(\"vSphericalZZ\", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);\r\n                        ubo.updateFloat3(\"vSphericalXY\", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);\r\n                        ubo.updateFloat3(\"vSphericalYZ\", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);\r\n                        ubo.updateFloat3(\"vSphericalZX\", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);\r\n                    }\r\n                }\r\n            } else if (usePBR) {\r\n                // If we're using an irradiance map with a dominant direction assigned, set it.\r\n                if (defines.USEIRRADIANCEMAP && defines.USE_IRRADIANCE_DOMINANT_DIRECTION) {\r\n                    ubo.updateVector3(\"vReflectionDominantDirection\", reflectionTexture.irradianceTexture!._dominantDirection!);\r\n                }\r\n            }\r\n\r\n            if (supportTextureInfo) {\r\n                ubo.updateFloat3(\"vReflectionMicrosurfaceInfos\", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);\r\n            }\r\n        }\r\n    }\r\n    if (useColor) {\r\n        ubo.updateColor3(\"vReflectionColor\", reflectionColor);\r\n    }\r\n}\r\n\r\n/**\r\n * Update parameters for IBL\r\n * @param scene The scene\r\n * @param defines The list of shader defines for the material\r\n * @param ubo The uniform buffer to update\r\n * @param reflectionTexture The IBL texture\r\n * @param realTimeFiltering Whether realtime filtering of IBL texture is being used\r\n */\r\nexport function BindIBLSamplers(scene: Scene, defines: any, ubo: UniformBuffer, reflectionTexture: Nullable<BaseTexture> = null, realTimeFiltering: boolean = false): void {\r\n    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n        if (defines.LODBASEDMICROSFURACE) {\r\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture);\r\n        } else {\r\n            ubo.setTexture(\"reflectionSampler\", reflectionTexture._lodTextureMid || reflectionTexture);\r\n            ubo.setTexture(\"reflectionSamplerLow\", reflectionTexture._lodTextureLow || reflectionTexture);\r\n            ubo.setTexture(\"reflectionSamplerHigh\", reflectionTexture._lodTextureHigh || reflectionTexture);\r\n        }\r\n\r\n        if (defines.USEIRRADIANCEMAP) {\r\n            ubo.setTexture(\"irradianceSampler\", reflectionTexture.irradianceTexture);\r\n        }\r\n\r\n        //if realtime filtering and using CDF maps, set them.\r\n        const cdfGenerator = scene.iblCdfGenerator;\r\n        if (realTimeFiltering && cdfGenerator) {\r\n            ubo.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Helps preparing the defines values about the UVs in used in the effect.\r\n * UVs are shared as much as we can across channels in the shaders.\r\n * @param texture The texture we are preparing the UVs for\r\n * @param defines The defines to update\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function PrepareDefinesForMergedUV(texture: BaseTexture, defines: any, key: string): void {\r\n    defines._needUVs = true;\r\n    defines[key] = true;\r\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\r\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\r\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\r\n    } else {\r\n        defines[key + \"DIRECTUV\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Binds a texture matrix value to its corresponding uniform\r\n * @param texture The texture to bind the matrix for\r\n * @param uniformBuffer The uniform buffer receiving the data\r\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\r\n */\r\nexport function BindTextureMatrix(texture: BaseTexture, uniformBuffer: UniformBuffer, key: string): void {\r\n    const matrix = texture.getTextureMatrix();\r\n\r\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare for baked vertex animations\r\n * @param defines The current Defines of the effect\r\n */\r\nexport function PrepareAttributesForBakedVertexAnimation(attribs: string[], mesh: AbstractMesh, defines: any): void {\r\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\r\n\r\n    if (enabled) {\r\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\r\n    }\r\n}\r\n\r\n// Copies the bones transformation matrices into the target array and returns the target's reference\r\nfunction CopyBonesTransformationMatrices(source: Float32Array, target: Float32Array): Float32Array {\r\n    target.set(source);\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n * Binds the bones information from the mesh to the effect.\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\r\n */\r\nexport function BindBonesParameters(mesh?: AbstractMesh, effect?: Effect, prePassConfiguration?: PrePassConfiguration): void {\r\n    if (!effect || !mesh) {\r\n        return;\r\n    }\r\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\r\n        mesh.computeBonesUsingShaders = false;\r\n    }\r\n\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        const skeleton = mesh.skeleton;\r\n\r\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\r\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\r\n            effect.setTexture(\"boneSampler\", boneTexture);\r\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\r\n        } else {\r\n            const matrices = skeleton.getTransformMatrices(mesh);\r\n\r\n            if (matrices) {\r\n                effect.setMatrices(\"mBones\", matrices);\r\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer!.getIndex(Constants.PREPASS_VELOCITY_TEXTURE_TYPE)) {\r\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\r\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\r\n                    }\r\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                    CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Binds the light information to the effect.\r\n * @param light The light containing the generator\r\n * @param effect The effect we are binding the data to\r\n * @param lightIndex The light index in the effect used to render\r\n */\r\nexport function BindLightProperties(light: Light, effect: Effect, lightIndex: number): void {\r\n    light.transferToEffect(effect, lightIndex + \"\");\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param light Light to bind\r\n * @param lightIndex Light index\r\n * @param scene The scene where the light belongs to\r\n * @param effect The effect we are binding the data to\r\n * @param useSpecular Defines if specular is supported\r\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\r\n */\r\nexport function BindLight(light: Light, lightIndex: number, scene: Scene, effect: Effect, useSpecular: boolean, receiveShadows = true): void {\r\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\r\n}\r\n\r\n/**\r\n * Binds the lights information from the scene to the effect for the given mesh.\r\n * @param scene The scene the lights belongs to\r\n * @param mesh The mesh we are binding the information to render\r\n * @param effect The effect we are binding the data to\r\n * @param defines The generated defines for the effect\r\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\r\n */\r\nexport function BindLights(scene: Scene, mesh: AbstractMesh, effect: Effect, defines: any, maxSimultaneousLights = 4): void {\r\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\r\n\r\n    for (let i = 0; i < len; i++) {\r\n        const light = mesh.lightSources[i];\r\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the list of attributes required for bones according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param mesh The mesh to prepare the bones attributes for\r\n * @param defines The current Defines of the effect\r\n * @param fallbacks The current effect fallback strategy\r\n */\r\nexport function PrepareAttributesForBones(attribs: string[], mesh: AbstractMesh, defines: any, fallbacks: EffectFallbacks): void {\r\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\r\n        fallbacks.addCPUSkinningFallback(0, mesh);\r\n\r\n        attribs.push(Constants.MatricesIndicesKind);\r\n        attribs.push(Constants.MatricesWeightsKind);\r\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\r\n            attribs.push(Constants.MatricesIndicesExtraKind);\r\n            attribs.push(Constants.MatricesWeightsExtraKind);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Check and prepare the list of attributes required for instances according to the effect defines.\r\n * @param attribs The current list of supported attribs\r\n * @param defines The current MaterialDefines of the effect\r\n */\r\nexport function PrepareAttributesForInstances(attribs: string[], defines: MaterialDefines): void {\r\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\r\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\r\n    }\r\n\r\n    if (defines.INSTANCESCOLOR) {\r\n        attribs.push(Constants.ColorInstanceKind);\r\n    }\r\n}\r\n\r\n/**\r\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\r\n * @param defines The defines to update while falling back\r\n * @param fallbacks The authorized effect fallbacks\r\n * @param maxSimultaneousLights The maximum number of lights allowed\r\n * @param rank the current rank of the Effect\r\n * @returns The newly affected rank\r\n */\r\nexport function HandleFallbacksForShadows(defines: any, fallbacks: EffectFallbacks, maxSimultaneousLights = 4, rank = 0): number {\r\n    let lightFallbackRank = 0;\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n\r\n        if (lightIndex > 0) {\r\n            lightFallbackRank = rank + lightIndex;\r\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\r\n        }\r\n\r\n        if (!defines[\"SHADOWS\"]) {\r\n            if (defines[\"SHADOW\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\r\n            }\r\n\r\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\r\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\r\n            }\r\n        }\r\n    }\r\n    return lightFallbackRank++;\r\n}\r\n\r\n/**\r\n * Gets the current status of the fog (should it be enabled?)\r\n * @param mesh defines the mesh to evaluate for fog support\r\n * @param scene defines the hosting scene\r\n * @returns true if fog must be enabled\r\n */\r\nexport function GetFogState(mesh: AbstractMesh, scene: Scene) {\r\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Constants.FOGMODE_NONE;\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\r\n * @param mesh defines the current mesh\r\n * @param scene defines the current scene\r\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\r\n * @param pointsCloud defines if point cloud rendering has to be turned on\r\n * @param fogEnabled defines if fog has to be turned on\r\n * @param alphaTest defines if alpha testing has to be turned on\r\n * @param defines defines the current list of defines\r\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\r\n * @param useVertexPulling Defines if vertex pulling is used\r\n * @param renderingMesh The mesh used for rendering\r\n * @param setVertexOutputInvariant Defines if the vertex output should be invariant\r\n */\r\nexport function PrepareDefinesForMisc(\r\n    mesh: AbstractMesh,\r\n    scene: Scene,\r\n    useLogarithmicDepth: boolean,\r\n    pointsCloud: boolean,\r\n    fogEnabled: boolean,\r\n    alphaTest: boolean,\r\n    defines: any,\r\n    applyDecalAfterDetail: boolean = false,\r\n    useVertexPulling: boolean = false,\r\n    renderingMesh?: AbstractMesh,\r\n    setVertexOutputInvariant?: boolean\r\n): void {\r\n    if (defines._areMiscDirty) {\r\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\r\n        defines[\"POINTSIZE\"] = pointsCloud;\r\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\r\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\r\n        defines[\"ALPHATEST\"] = alphaTest;\r\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\r\n        defines[\"USE_VERTEX_PULLING\"] = useVertexPulling;\r\n\r\n        const indexBuffer = renderingMesh?.geometry?.getIndexBuffer();\r\n\r\n        defines[\"VERTEX_PULLING_USE_INDEX_BUFFER\"] = !!indexBuffer;\r\n        defines[\"VERTEX_PULLING_INDEX_BUFFER_32BITS\"] = indexBuffer ? indexBuffer.is32Bits : false;\r\n\r\n        defines[\"VERTEXOUTPUT_INVARIANT\"] = !!setVertexOutputInvariant;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\r\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\r\n * @returns true if normals will be required for the rest of the effect\r\n */\r\nexport function PrepareDefinesForLights(scene: Scene, mesh: AbstractMesh, defines: any, specularSupported: boolean, maxSimultaneousLights = 4, disableLighting = false): boolean {\r\n    if (!defines._areLightsDirty) {\r\n        return defines._needNormals;\r\n    }\r\n\r\n    let lightIndex = 0;\r\n    const state = {\r\n        needNormals: defines._needNormals, // prevents overriding previous reflection or other needs for normals\r\n        needRebuild: false,\r\n        lightmapMode: false,\r\n        shadowEnabled: false,\r\n        specularEnabled: false,\r\n    };\r\n\r\n    if (scene.lightsEnabled && !disableLighting) {\r\n        for (const light of mesh.lightSources) {\r\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\r\n\r\n            lightIndex++;\r\n            if (lightIndex === maxSimultaneousLights) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\r\n    defines[\"SHADOWS\"] = state.shadowEnabled;\r\n\r\n    // Resetting all other lights if any\r\n    const maxLightCount = Math.max(maxSimultaneousLights, defines[\"MAXLIGHTCOUNT\"] || 0);\r\n\r\n    for (let index = lightIndex; index < maxLightCount; index++) {\r\n        if (defines[\"LIGHT\" + index] !== undefined) {\r\n            defines[\"LIGHT\" + index] = false;\r\n            defines[\"HEMILIGHT\" + index] = false;\r\n            defines[\"POINTLIGHT\" + index] = false;\r\n            defines[\"DIRLIGHT\" + index] = false;\r\n            defines[\"SPOTLIGHT\" + index] = false;\r\n            defines[\"AREALIGHT\" + index] = false;\r\n            defines[\"CLUSTLIGHT\" + index] = false;\r\n            defines[\"SHADOW\" + index] = false;\r\n            defines[\"SHADOWCSM\" + index] = false;\r\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\r\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\r\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\r\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\r\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\r\n            defines[\"SHADOWPCF\" + index] = false;\r\n            defines[\"SHADOWPCSS\" + index] = false;\r\n            defines[\"SHADOWPOISSON\" + index] = false;\r\n            defines[\"SHADOWESM\" + index] = false;\r\n            defines[\"SHADOWCLOSEESM\" + index] = false;\r\n            defines[\"SHADOWCUBE\" + index] = false;\r\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\r\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\r\n        }\r\n    }\r\n\r\n    defines[\"MAXLIGHTCOUNT\"] = maxSimultaneousLights;\r\n\r\n    const caps = scene.getEngine().getCaps();\r\n\r\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"SHADOWFLOAT\"] =\r\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\r\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\r\n\r\n    if (state.needRebuild) {\r\n        defines.rebuild();\r\n    }\r\n\r\n    return state.needNormals;\r\n}\r\n\r\n/**\r\n * Prepare defines relating to IBL logic.\r\n * @param scene The scene\r\n * @param reflectionTexture The texture to use for IBL\r\n * @param defines The defines to update\r\n * @param realTimeFiltering Whether realtime filting of IBL texture is being used\r\n * @param realTimeFilteringQuality The quality of realtime filtering\r\n * @param forceSHInVertex Whether the SH are handled in the vertex shader\r\n * @returns true if the defines were updated\r\n */\r\nexport function PrepareDefinesForIBL(\r\n    scene: Scene,\r\n    reflectionTexture: Nullable<BaseTexture>,\r\n    defines: any,\r\n    realTimeFiltering: boolean = false,\r\n    realTimeFilteringQuality: number = Constants.TEXTURE_FILTERING_QUALITY_LOW,\r\n    forceSHInVertex: boolean = false\r\n): boolean {\r\n    if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n        if (!reflectionTexture.isReadyOrNotBlocking()) {\r\n            return false;\r\n        }\r\n        defines._needNormals = true;\r\n        defines.REFLECTION = true;\r\n        defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;\r\n        defines.RGBDREFLECTION = reflectionTexture.isRGBD;\r\n        defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;\r\n        defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;\r\n        defines.USEIRRADIANCEMAP = false;\r\n\r\n        const engine = scene.getEngine();\r\n        if (realTimeFiltering && realTimeFilteringQuality > 0) {\r\n            defines.NUM_SAMPLES = \"\" + realTimeFilteringQuality;\r\n            if (engine._features.needTypeSuffixInShaderConstants) {\r\n                defines.NUM_SAMPLES = defines.NUM_SAMPLES + \"u\";\r\n            }\r\n\r\n            defines.REALTIME_FILTERING = true;\r\n            if (scene.iblCdfGenerator) {\r\n                defines.IBL_CDF_FILTERING = true;\r\n            }\r\n        } else {\r\n            defines.REALTIME_FILTERING = false;\r\n        }\r\n\r\n        defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;\r\n        defines.REFLECTIONMAP_3D = reflectionTexture.isCube;\r\n        defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && scene.useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;\r\n\r\n        defines.REFLECTIONMAP_CUBIC = false;\r\n        defines.REFLECTIONMAP_EXPLICIT = false;\r\n        defines.REFLECTIONMAP_PLANAR = false;\r\n        defines.REFLECTIONMAP_PROJECTION = false;\r\n        defines.REFLECTIONMAP_SKYBOX = false;\r\n        defines.REFLECTIONMAP_SPHERICAL = false;\r\n        defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n        defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n        defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n\r\n        switch (reflectionTexture.coordinatesMode) {\r\n            case Texture.EXPLICIT_MODE:\r\n                defines.REFLECTIONMAP_EXPLICIT = true;\r\n                break;\r\n            case Texture.PLANAR_MODE:\r\n                defines.REFLECTIONMAP_PLANAR = true;\r\n                break;\r\n            case Texture.PROJECTION_MODE:\r\n                defines.REFLECTIONMAP_PROJECTION = true;\r\n                break;\r\n            case Texture.SKYBOX_MODE:\r\n                defines.REFLECTIONMAP_SKYBOX = true;\r\n                break;\r\n            case Texture.SPHERICAL_MODE:\r\n                defines.REFLECTIONMAP_SPHERICAL = true;\r\n                break;\r\n            case Texture.EQUIRECTANGULAR_MODE:\r\n                defines.REFLECTIONMAP_EQUIRECTANGULAR = true;\r\n                break;\r\n            case Texture.FIXED_EQUIRECTANGULAR_MODE:\r\n                defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;\r\n                break;\r\n            case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:\r\n                defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;\r\n                break;\r\n            case Texture.CUBIC_MODE:\r\n            case Texture.INVCUBIC_MODE:\r\n            default:\r\n                defines.REFLECTIONMAP_CUBIC = true;\r\n                defines.USE_LOCAL_REFLECTIONMAP_CUBIC = (<any>reflectionTexture).boundingBoxSize ? true : false;\r\n                break;\r\n        }\r\n\r\n        if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {\r\n            if (reflectionTexture.irradianceTexture) {\r\n                defines.USEIRRADIANCEMAP = true;\r\n                defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n                defines.USESPHERICALINVERTEX = false;\r\n                if (reflectionTexture.irradianceTexture._dominantDirection) {\r\n                    defines.USE_IRRADIANCE_DOMINANT_DIRECTION = true;\r\n                }\r\n            }\r\n            // Assume using spherical polynomial if the reflection texture is a cube map\r\n            else if (reflectionTexture.isCube) {\r\n                defines.USESPHERICALFROMREFLECTIONMAP = true;\r\n                defines.USEIRRADIANCEMAP = false;\r\n                defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n                defines.USESPHERICALINVERTEX = forceSHInVertex;\r\n            }\r\n        }\r\n    } else {\r\n        defines.REFLECTION = false;\r\n        defines.REFLECTIONMAP_3D = false;\r\n        defines.REFLECTIONMAP_SPHERICAL = false;\r\n        defines.REFLECTIONMAP_PLANAR = false;\r\n        defines.REFLECTIONMAP_CUBIC = false;\r\n        defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n        defines.REFLECTIONMAP_PROJECTION = false;\r\n        defines.REFLECTIONMAP_SKYBOX = false;\r\n        defines.REFLECTIONMAP_EXPLICIT = false;\r\n        defines.REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n        defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n        defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n        defines.INVERTCUBICMAP = false;\r\n        defines.USESPHERICALFROMREFLECTIONMAP = false;\r\n        defines.USEIRRADIANCEMAP = false;\r\n        defines.USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n        defines.USESPHERICALINVERTEX = false;\r\n        defines.REFLECTIONMAP_OPPOSITEZ = false;\r\n        defines.LODINREFLECTIONALPHA = false;\r\n        defines.GAMMAREFLECTION = false;\r\n        defines.RGBDREFLECTION = false;\r\n        defines.LINEARSPECULARREFLECTION = false;\r\n    }\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the light information passed in parameter\r\n * @param scene The scene we are intending to draw\r\n * @param mesh The mesh the effect is compiling for\r\n * @param light The light the effect is compiling for\r\n * @param lightIndex The index of the light\r\n * @param defines The defines to update\r\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\r\n * @param state Defines the current state regarding what is needed (normals, etc...)\r\n * @param state.needNormals\r\n * @param state.needRebuild\r\n * @param state.shadowEnabled\r\n * @param state.specularEnabled\r\n * @param state.lightmapMode\r\n */\r\nexport function PrepareDefinesForLight(\r\n    scene: Scene,\r\n    mesh: AbstractMesh,\r\n    light: Light,\r\n    lightIndex: number,\r\n    defines: any,\r\n    specularSupported: boolean,\r\n    state: {\r\n        needNormals: boolean;\r\n        needRebuild: boolean;\r\n        shadowEnabled: boolean;\r\n        specularEnabled: boolean;\r\n        lightmapMode: boolean;\r\n    }\r\n) {\r\n    state.needNormals = true;\r\n\r\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\r\n        state.needRebuild = true;\r\n    }\r\n\r\n    defines[\"LIGHT\" + lightIndex] = true;\r\n\r\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\r\n    defines[\"HEMILIGHT\" + lightIndex] = false;\r\n    defines[\"POINTLIGHT\" + lightIndex] = false;\r\n    defines[\"DIRLIGHT\" + lightIndex] = false;\r\n    defines[\"AREALIGHT\" + lightIndex] = false;\r\n    defines[\"CLUSTLIGHT\" + lightIndex] = false;\r\n\r\n    light.prepareLightSpecificDefines(defines, lightIndex);\r\n\r\n    // FallOff.\r\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\r\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\r\n\r\n    switch (light.falloffType) {\r\n        case LightConstants.FALLOFF_GLTF:\r\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_PHYSICAL:\r\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\r\n            break;\r\n        case LightConstants.FALLOFF_STANDARD:\r\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\r\n            break;\r\n    }\r\n\r\n    // Specular\r\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\r\n        state.specularEnabled = true;\r\n    }\r\n\r\n    // Shadows\r\n    defines[\"SHADOW\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\r\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\r\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\r\n    defines[\"SHADOWPCF\" + lightIndex] = false;\r\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\r\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\r\n    defines[\"SHADOWESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\r\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\r\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\r\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\r\n\r\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\r\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\r\n        if (shadowGenerator) {\r\n            const shadowMap = shadowGenerator.getShadowMap();\r\n            if (shadowMap) {\r\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\r\n                    state.shadowEnabled = true;\r\n                    shadowGenerator.prepareDefines(defines, lightIndex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\r\n        state.lightmapMode = true;\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\r\n    } else {\r\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\r\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the list of defines associated with frame values for shader compilation\r\n * @param scene defines the current scene\r\n * @param engine defines the current engine\r\n * @param material defines the material we are compiling the shader for\r\n * @param defines specifies the list of active defines\r\n * @param useInstances defines if instances have to be turned on\r\n * @param useClipPlane defines if clip plane have to be turned on\r\n * @param useThinInstances defines if thin instances have to be turned on\r\n */\r\nexport function PrepareDefinesForFrameBoundValues(\r\n    scene: Scene,\r\n    engine: AbstractEngine,\r\n    material: Material,\r\n    defines: any,\r\n    useInstances: boolean,\r\n    useClipPlane: Nullable<boolean> = null,\r\n    useThinInstances: boolean = false\r\n): void {\r\n    let changed = PrepareDefinesForCamera(scene, defines);\r\n\r\n    if (useClipPlane !== false) {\r\n        changed = PrepareDefinesForClipPlanes(material, scene, defines);\r\n    }\r\n\r\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\r\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"INSTANCES\"] !== useInstances) {\r\n        defines[\"INSTANCES\"] = useInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\r\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\r\n        changed = true;\r\n    }\r\n\r\n    if (changed) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for bones\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBones(mesh: AbstractMesh, defines: any) {\r\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\r\n\r\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\r\n\r\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\r\n            defines[\"BONETEXTURE\"] = true;\r\n        } else {\r\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\r\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\r\n\r\n            const prePassRenderer = mesh.getScene().prePassRenderer;\r\n            if (prePassRenderer && prePassRenderer.enabled) {\r\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\r\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\r\n            }\r\n        }\r\n    } else {\r\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\r\n        defines[\"BonesPerMesh\"] = 0;\r\n        if (defines[\"BONETEXTURE\"] !== undefined) {\r\n            defines[\"BONETEXTURE\"] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for morph targets\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMorphTargets(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).morphTargetManager;\r\n    if (manager) {\r\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\r\n        defines[\"MORPHTARGETS_UV2\"] = manager.supportsUV2s && defines[\"UV2\"];\r\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\r\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\r\n        defines[\"MORPHTARGETS_POSITION\"] = manager.supportsPositions;\r\n        defines[\"MORPHTARGETS_COLOR\"] = manager.supportsColors;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = manager.hasUVs;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = manager.hasUV2s;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = manager.hasTangents;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = manager.hasNormals;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = manager.hasPositions;\r\n        defines[\"MORPHTARGETTEXTURE_HASCOLORS\"] = manager.hasColors;\r\n\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\r\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\r\n\r\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\r\n    } else {\r\n        defines[\"MORPHTARGETS_UV\"] = false;\r\n        defines[\"MORPHTARGETS_UV2\"] = false;\r\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\r\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\r\n        defines[\"MORPHTARGETS_POSITION\"] = false;\r\n        defines[\"MORPHTARGETS_COLOR\"] = false;\r\n\r\n        defines[\"MORPHTARGETTEXTURE_HASUVS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASUV2S\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASTANGENTS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASNORMALS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HASPOSITIONS\"] = false;\r\n        defines[\"MORPHTARGETTEXTURE_HAS_COLORS\"] = false;\r\n\r\n        defines[\"MORPHTARGETS\"] = false;\r\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines for baked vertex animation\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForBakedVertexAnimation(mesh: AbstractMesh, defines: any) {\r\n    const manager = (<Mesh>mesh).bakedVertexAnimationManager;\r\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\r\n}\r\n\r\n/**\r\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\r\n * @param mesh The mesh containing the geometry data we will draw\r\n * @param defines The defines to update\r\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\r\n * @param useBones Precise whether bones should be used or not (override mesh info)\r\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\r\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\r\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\r\n * @returns false if defines are considered not dirty and have not been checked\r\n */\r\nexport function PrepareDefinesForAttributes(\r\n    mesh: AbstractMesh,\r\n    defines: any,\r\n    useVertexColor: boolean,\r\n    useBones: boolean,\r\n    useMorphTargets = false,\r\n    useVertexAlpha = true,\r\n    useBakedVertexAnimation = true\r\n): boolean {\r\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\r\n        return false;\r\n    }\r\n\r\n    defines._normals = defines._needNormals;\r\n    defines._uvs = defines._needUVs;\r\n\r\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(Constants.NormalKind);\r\n\r\n    if (defines._needNormals && mesh.isVerticesDataPresent(Constants.TangentKind)) {\r\n        defines[\"TANGENT\"] = true;\r\n    }\r\n\r\n    for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\r\n    }\r\n\r\n    if (useVertexColor) {\r\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(Constants.ColorKind);\r\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\r\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\r\n    }\r\n\r\n    if (mesh.isVerticesDataPresent(Constants.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\r\n        defines[\"INSTANCESCOLOR\"] = true;\r\n    }\r\n\r\n    if (useBones) {\r\n        PrepareDefinesForBones(mesh, defines);\r\n    }\r\n\r\n    if (useMorphTargets) {\r\n        PrepareDefinesForMorphTargets(mesh, defines);\r\n    }\r\n\r\n    if (useBakedVertexAnimation) {\r\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Prepares the defines related to multiview\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n */\r\nexport function PrepareDefinesForMultiview(scene: Scene, defines: any) {\r\n    if (scene.activeCamera) {\r\n        const previousMultiview = defines.MULTIVIEW;\r\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\r\n        if (defines.MULTIVIEW != previousMultiview) {\r\n            defines.markAsUnprocessed();\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to order independant transparency\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param needAlphaBlending Determines if the material needs alpha blending\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function PrepareDefinesForOIT(scene: Scene, defines: any, needAlphaBlending: boolean) {\r\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\r\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\r\n\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\r\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\r\n\r\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\r\n        defines.markAsUnprocessed();\r\n    }\r\n}\r\n\r\n/**\r\n * Prepares the defines related to the prepass\r\n * @param scene The scene we are intending to draw\r\n * @param defines The defines to update\r\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\r\n */\r\nexport function PrepareDefinesForPrePass(scene: Scene, defines: any, canRenderToMRT: boolean) {\r\n    const previousPrePass = defines.PREPASS;\r\n\r\n    if (!defines._arePrePassDirty) {\r\n        return;\r\n    }\r\n\r\n    const texturesList = [\r\n        {\r\n            type: Constants.PREPASS_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_POSITION\",\r\n            index: \"PREPASS_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE,\r\n            define: \"PREPASS_LOCAL_POSITION\",\r\n            index: \"PREPASS_LOCAL_POSITION_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY\",\r\n            index: \"PREPASS_VELOCITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE,\r\n            define: \"PREPASS_VELOCITY_LINEAR\",\r\n            index: \"PREPASS_VELOCITY_LINEAR_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\r\n            define: \"PREPASS_REFLECTIVITY\",\r\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\r\n            define: \"PREPASS_IRRADIANCE\",\r\n            index: \"PREPASS_IRRADIANCE_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\r\n            define: \"PREPASS_ALBEDO_SQRT\",\r\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_DEPTH\",\r\n            index: \"PREPASS_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE,\r\n            define: \"PREPASS_SCREENSPACE_DEPTH\",\r\n            index: \"PREPASS_SCREENSPACE_DEPTH_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_NORMAL\",\r\n            index: \"PREPASS_NORMAL_INDEX\",\r\n        },\r\n        {\r\n            type: Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE,\r\n            define: \"PREPASS_WORLD_NORMAL\",\r\n            index: \"PREPASS_WORLD_NORMAL_INDEX\",\r\n        },\r\n    ];\r\n\r\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\r\n        defines.PREPASS = true;\r\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\r\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\r\n        defines.PREPASS_COLOR = true;\r\n        defines.PREPASS_COLOR_INDEX = 0;\r\n\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\r\n            if (index !== -1) {\r\n                defines[texturesList[i].define] = true;\r\n                defines[texturesList[i].index] = index;\r\n            } else {\r\n                defines[texturesList[i].define] = false;\r\n            }\r\n        }\r\n    } else {\r\n        defines.PREPASS = false;\r\n        for (let i = 0; i < texturesList.length; i++) {\r\n            defines[texturesList[i].define] = false;\r\n        }\r\n    }\r\n\r\n    if (defines.PREPASS != previousPrePass) {\r\n        defines.markAsUnprocessed();\r\n        defines.markAsImageProcessingDirty();\r\n    }\r\n}\r\n\r\n/**\r\n * Helper used to prepare the defines relative to the active camera\r\n * @param scene defines the current scene\r\n * @param defines specifies the list of active defines\r\n * @returns true if the defines have been updated, else false\r\n */\r\nexport function PrepareDefinesForCamera(scene: Scene, defines: any): boolean {\r\n    let changed = false;\r\n\r\n    if (scene.activeCamera) {\r\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\r\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\r\n        const isOrtho = scene.activeCamera.mode === Constants.ORTHOGRAPHIC_CAMERA ? 1 : 0;\r\n        const isPersp = scene.activeCamera.mode === Constants.PERSPECTIVE_CAMERA ? 1 : 0;\r\n\r\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\r\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\r\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\r\n            changed = true;\r\n        }\r\n    }\r\n\r\n    return changed;\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\r\n * @param lightIndex defines the light index\r\n * @param uniformsList The uniform list\r\n * @param samplersList The sampler list\r\n * @param projectedLightTexture defines if projected texture must be used\r\n * @param uniformBuffersList defines an optional list of uniform buffers\r\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\r\n * @param iesLightTexture defines if IES texture must be used\r\n * @param clusteredLightTextures defines if the clustered light textures must be used\r\n */\r\nexport function PrepareUniformsAndSamplersForLight(\r\n    lightIndex: number,\r\n    uniformsList: string[],\r\n    samplersList: string[],\r\n    projectedLightTexture?: any,\r\n    uniformBuffersList: Nullable<string[]> = null,\r\n    updateOnlyBuffersList = false,\r\n    iesLightTexture = false,\r\n    clusteredLightTextures = false\r\n) {\r\n    if (uniformBuffersList) {\r\n        uniformBuffersList.push(\"Light\" + lightIndex);\r\n    }\r\n\r\n    if (updateOnlyBuffersList) {\r\n        return;\r\n    }\r\n\r\n    uniformsList.push(\r\n        \"vLightData\" + lightIndex,\r\n        \"vLightDiffuse\" + lightIndex,\r\n        \"vLightSpecular\" + lightIndex,\r\n        \"vLightDirection\" + lightIndex,\r\n        \"vLightWidth\" + lightIndex,\r\n        \"vLightHeight\" + lightIndex,\r\n        \"vLightFalloff\" + lightIndex,\r\n        \"vLightGround\" + lightIndex,\r\n        \"vSliceData\" + lightIndex,\r\n        \"vSliceRanges\" + lightIndex,\r\n        \"lightMatrix\" + lightIndex,\r\n        \"shadowsInfo\" + lightIndex,\r\n        \"depthValues\" + lightIndex\r\n    );\r\n\r\n    samplersList.push(\"shadowTexture\" + lightIndex);\r\n    samplersList.push(\"depthTexture\" + lightIndex);\r\n\r\n    uniformsList.push(\r\n        \"viewFrustumZ\" + lightIndex,\r\n        \"cascadeBlendFactor\" + lightIndex,\r\n        \"lightSizeUVCorrection\" + lightIndex,\r\n        \"depthCorrection\" + lightIndex,\r\n        \"penumbraDarkness\" + lightIndex,\r\n        \"frustumLengths\" + lightIndex\r\n    );\r\n\r\n    if (projectedLightTexture) {\r\n        samplersList.push(\"projectionLightTexture\" + lightIndex);\r\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\r\n    }\r\n    if (iesLightTexture) {\r\n        samplersList.push(\"iesLightTexture\" + lightIndex);\r\n    }\r\n    if (clusteredLightTextures) {\r\n        samplersList.push(\"lightDataTexture\" + lightIndex);\r\n        samplersList.push(\"tileMaskTexture\" + lightIndex);\r\n    }\r\n}\r\n\r\n/**\r\n * Append uniforms and samplers related to IBL to the provided lists\r\n * @param uniformsList The list of uniforms to append to\r\n * @param samplersList The list of samplers to append to\r\n * @param useSH Whether to include spherical harmonics uniforms\r\n */\r\nexport function PrepareUniformsAndSamplersForIBL(uniformsList: string[], samplersList: string[], useSH: boolean): void {\r\n    const iblUniforms = [\r\n        \"vReflectionMicrosurfaceInfos\",\r\n        \"vReflectionDominantDirection\",\r\n        \"reflectionMatrix\",\r\n        \"vReflectionInfos\",\r\n        \"vReflectionPosition\",\r\n        \"vReflectionSize\",\r\n        \"vReflectionColor\",\r\n        \"vReflectionFilteringInfo\",\r\n    ];\r\n    if (useSH) {\r\n        iblUniforms.push(\r\n            \"vSphericalX\",\r\n            \"vSphericalY\",\r\n            \"vSphericalZ\",\r\n            \"vSphericalXX_ZZ\",\r\n            \"vSphericalYY_ZZ\",\r\n            \"vSphericalZZ\",\r\n            \"vSphericalXY\",\r\n            \"vSphericalYZ\",\r\n            \"vSphericalZX\",\r\n            \"vSphericalL00\",\r\n            \"vSphericalL1_1\",\r\n            \"vSphericalL10\",\r\n            \"vSphericalL11\",\r\n            \"vSphericalL2_2\",\r\n            \"vSphericalL2_1\",\r\n            \"vSphericalL20\",\r\n            \"vSphericalL21\",\r\n            \"vSphericalL22\"\r\n        );\r\n    }\r\n    uniformsList.push(...iblUniforms);\r\n\r\n    const iblSamplers = [\"reflectionSampler\", \"reflectionSamplerLow\", \"reflectionSamplerHigh\", \"irradianceSampler\", \"icdfSampler\"];\r\n    samplersList.push(...iblSamplers);\r\n}\r\n\r\n/**\r\n * Prepares the uniforms and samplers list to be used in the effect\r\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\r\n * @param samplersList The sampler list\r\n * @param defines The defines helping in the list generation\r\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\r\n */\r\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions: string[] | IEffectCreationOptions, samplersList?: string[], defines?: any, maxSimultaneousLights = 4): void {\r\n    let uniformsList: string[];\r\n    let uniformBuffersList: string[] | undefined;\r\n\r\n    if ((<IEffectCreationOptions>uniformsListOrOptions).uniformsNames) {\r\n        const options = <IEffectCreationOptions>uniformsListOrOptions;\r\n        uniformsList = options.uniformsNames;\r\n        uniformBuffersList = options.uniformBuffersNames;\r\n        samplersList = options.samplers;\r\n        defines = options.defines;\r\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\r\n    } else {\r\n        uniformsList = <string[]>uniformsListOrOptions;\r\n        if (!samplersList) {\r\n            samplersList = [];\r\n        }\r\n    }\r\n\r\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\r\n        if (!defines[\"LIGHT\" + lightIndex]) {\r\n            break;\r\n        }\r\n        PrepareUniformsAndSamplersForLight(\r\n            lightIndex,\r\n            uniformsList,\r\n            samplersList,\r\n            defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex],\r\n            uniformBuffersList,\r\n            false,\r\n            defines[\"IESLIGHTTEXTURE\" + lightIndex],\r\n            defines[\"CLUSTLIGHT\" + lightIndex]\r\n        );\r\n    }\r\n\r\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\r\n        uniformsList.push(\"morphTargetInfluences\");\r\n        uniformsList.push(\"morphTargetCount\");\r\n    }\r\n\r\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\r\n        uniformsList.push(\"bakedVertexAnimationSettings\");\r\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\r\n        uniformsList.push(\"bakedVertexAnimationTime\");\r\n        samplersList.push(\"bakedVertexAnimationTexture\");\r\n    }\r\n}\r\n\r\n/**\r\n *\r\n * @param ubo Add uniforms to UBO\r\n * @param supportTextureInfo Add uniforms for texture info if true\r\n * @param supportLocalProjection Add uniforms for local projection if true\r\n * @param usePBR Add uniforms for IBL if true\r\n * @param supportSH Add uniforms for spherical harmonics if true\r\n * @param useColor Add uniforms for reflection color if true\r\n */\r\nexport function PrepareUniformLayoutForIBL(\r\n    ubo: UniformBuffer,\r\n    supportTextureInfo: boolean = false,\r\n    supportLocalProjection: boolean = false,\r\n    usePBR: boolean = false,\r\n    supportSH: boolean = false,\r\n    useColor: boolean = false\r\n): void {\r\n    ubo.addUniform(\"vReflectionInfos\", 2);\r\n    ubo.addUniform(\"reflectionMatrix\", 16);\r\n    if (supportTextureInfo) {\r\n        ubo.addUniform(\"vReflectionMicrosurfaceInfos\", 3);\r\n    }\r\n\r\n    if (supportLocalProjection) {\r\n        ubo.addUniform(\"vReflectionPosition\", 3);\r\n        ubo.addUniform(\"vReflectionSize\", 3);\r\n    }\r\n\r\n    if (usePBR) {\r\n        ubo.addUniform(\"vReflectionFilteringInfo\", 2);\r\n        ubo.addUniform(\"vReflectionDominantDirection\", 3);\r\n    }\r\n\r\n    if (useColor) {\r\n        ubo.addUniform(\"vReflectionColor\", 3);\r\n    }\r\n\r\n    if (supportSH) {\r\n        ubo.addUniform(\"vSphericalL00\", 3);\r\n        ubo.addUniform(\"vSphericalL1_1\", 3);\r\n        ubo.addUniform(\"vSphericalL10\", 3);\r\n        ubo.addUniform(\"vSphericalL11\", 3);\r\n        ubo.addUniform(\"vSphericalL2_2\", 3);\r\n        ubo.addUniform(\"vSphericalL2_1\", 3);\r\n        ubo.addUniform(\"vSphericalL20\", 3);\r\n        ubo.addUniform(\"vSphericalL21\", 3);\r\n        ubo.addUniform(\"vSphericalL22\", 3);\r\n\r\n        ubo.addUniform(\"vSphericalX\", 3);\r\n        ubo.addUniform(\"vSphericalY\", 3);\r\n        ubo.addUniform(\"vSphericalZ\", 3);\r\n        ubo.addUniform(\"vSphericalXX_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalYY_ZZ\", 3);\r\n        ubo.addUniform(\"vSphericalZZ\", 3);\r\n        ubo.addUniform(\"vSphericalXY\", 3);\r\n        ubo.addUniform(\"vSphericalYZ\", 3);\r\n        ubo.addUniform(\"vSphericalZX\", 3);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
