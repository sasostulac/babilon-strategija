{
  "version": 3,
  "sources": ["../../../dev/core/src/Materials/PBR/openpbrMaterial.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { serialize, expandToProperty, addAccessorsForMaterialProperty } from \"../../Misc/decorators\";\r\nimport { GetEnvironmentBRDFTexture, GetEnvironmentFuzzBRDFTexture } from \"../../Misc/brdfTextureTools\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { Scene } from \"../../scene\";\r\nimport type { Color4 } from \"../../Maths/math.color\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { ImageProcessingConfiguration } from \"../imageProcessingConfiguration\";\r\nimport type { BaseTexture } from \"../../Materials/Textures/baseTexture\";\r\nimport { Texture } from \"../Textures/texture\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { Material } from \"../material\";\r\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\r\nimport type { Engine } from \"../../Engines/engine\";\r\nimport type { AbstractMesh } from \"../../Meshes/abstractMesh\";\r\nimport type { Effect, IEffectCreationOptions } from \"../../Materials/effect\";\r\nimport { MaterialDefines } from \"../materialDefines\";\r\nimport { ImageProcessingDefinesMixin } from \"../imageProcessingConfiguration.defines\";\r\nimport { EffectFallbacks } from \"../effectFallbacks\";\r\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\r\nimport {\r\n    BindBonesParameters,\r\n    BindFogParameters,\r\n    BindLights,\r\n    BindLogDepth,\r\n    BindMorphTargetParameters,\r\n    BindTextureMatrix,\r\n    BindIBLParameters,\r\n    BindIBLSamplers,\r\n    HandleFallbacksForShadows,\r\n    PrepareAttributesForBakedVertexAnimation,\r\n    PrepareAttributesForBones,\r\n    PrepareAttributesForInstances,\r\n    PrepareAttributesForMorphTargets,\r\n    PrepareDefinesForAttributes,\r\n    PrepareDefinesForFrameBoundValues,\r\n    PrepareDefinesForLights,\r\n    PrepareDefinesForIBL,\r\n    PrepareDefinesForMergedUV,\r\n    PrepareDefinesForMisc,\r\n    PrepareDefinesForMultiview,\r\n    PrepareDefinesForOIT,\r\n    PrepareDefinesForPrePass,\r\n    PrepareUniformsAndSamplersList,\r\n    PrepareUniformsAndSamplersForIBL,\r\n    PrepareUniformLayoutForIBL,\r\n} from \"../materialHelper.functions\";\r\nimport { Constants } from \"../../Engines/constants\";\r\nimport { VertexBuffer } from \"../../Buffers/buffer\";\r\nimport { MaterialPluginEvent } from \"../materialPluginEvent\";\r\nimport { MaterialHelperGeometryRendering } from \"../materialHelper.geometryrendering\";\r\nimport { PrePassConfiguration } from \"../prePassConfiguration\";\r\nimport type { IMaterialCompilationOptions, ICustomShaderNameResolveOptions } from \"../../Materials/material\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { MaterialFlags } from \"../materialFlags\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { UVDefinesMixin } from \"../uv.defines\";\r\nimport { Vector2, Vector4, TmpVectors } from \"core/Maths/math.vector\";\r\nimport type { Vector3, Matrix } from \"core/Maths/math.vector\";\r\nimport type { Mesh } from \"../../Meshes/mesh\";\r\nimport { ImageProcessingMixin } from \"../imageProcessing\";\r\nimport { PushMaterial } from \"../pushMaterial\";\r\nimport { SmartArray } from \"../../Misc/smartArray\";\r\nimport type { RenderTargetTexture } from \"../Textures/renderTargetTexture\";\r\nimport type { IAnimatable } from \"../../Animations/animatable.interface\";\r\n\r\nconst onCreatedEffectParameters = { effect: null as unknown as Effect, subMesh: null as unknown as Nullable<SubMesh> };\r\n\r\nclass Uniform {\r\n    public name: string;\r\n    public numComponents: number;\r\n    public linkedProperties: { [name: string]: Property<PropertyType> } = {};\r\n    public populateVectorFromLinkedProperties(vector: Vector4 | Vector3 | Vector2): void {\r\n        const destinationSize = vector.dimension[0];\r\n        for (const propKey in this.linkedProperties) {\r\n            const prop = this.linkedProperties[propKey];\r\n            const sourceSize = prop.numComponents;\r\n            if (destinationSize < sourceSize || prop.targetUniformComponentOffset > destinationSize - sourceSize) {\r\n                if (sourceSize == 1) {\r\n                    Logger.Error(`Float property ${prop.name} has an offset that is too large.`);\r\n                } else {\r\n                    Logger.Error(`Vector${sourceSize} property ${prop.name} won't fit in Vector${destinationSize} or has an offset that is too large.`);\r\n                }\r\n                return;\r\n            }\r\n            if (typeof prop.value === \"number\") {\r\n                Uniform._tmpArray[prop.targetUniformComponentOffset] = prop.value;\r\n            } else {\r\n                prop.value.toArray(Uniform._tmpArray, prop.targetUniformComponentOffset);\r\n            }\r\n        }\r\n        vector.fromArray(Uniform._tmpArray);\r\n    }\r\n    public constructor(name: string, componentNum: number) {\r\n        this.name = name;\r\n        this.numComponents = componentNum;\r\n    }\r\n    private static _tmpArray: number[] = [0, 0, 0, 0];\r\n}\r\n\r\ntype PropertyType = Vector2 | Vector3 | Vector4 | number | Color3 | Color4;\r\n\r\n/**\r\n * Defines a property for the OpenPBRMaterial.\r\n */\r\nclass Property<T extends PropertyType> {\r\n    public name: string;\r\n    public targetUniformName: string;\r\n    public defaultValue: T;\r\n    public value: T;\r\n    // public includeAlphaFromProp: string = \"\";\r\n\r\n    /**\r\n     * If not given a type, there will be no uniform defined for this property and\r\n     * it will be assumed that the value will be packed into the already existing \"uniformName\" uniform.\r\n     */\r\n    public targetUniformComponentNum: number = 4; // Default to vec4\r\n    public targetUniformComponentOffset: number = 0;\r\n\r\n    /**\r\n     * Creates a new Property instance.\r\n     * @param name The name of the property in the shader\r\n     * @param defaultValue The default value of the property\r\n     * @param targetUniformName The name of the property in the shader uniform block\r\n     * @param targetUniformComponentNum The number of components in the target uniform. All properties that are\r\n     * packed into the same uniform must agree on the size of the target uniform.\r\n     * @param targetUniformComponentOffset The offset in the uniform where this property will be packed.\r\n     */\r\n    constructor(name: string, defaultValue: T, targetUniformName: string, targetUniformComponentNum: number, targetUniformComponentOffset: number = 0) {\r\n        this.name = name;\r\n        this.targetUniformName = targetUniformName;\r\n        this.defaultValue = defaultValue;\r\n        this.value = defaultValue;\r\n        this.targetUniformComponentNum = targetUniformComponentNum;\r\n        this.targetUniformComponentOffset = targetUniformComponentOffset;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of components of the property based on its default value type.\r\n     */\r\n    public get numComponents(): number {\r\n        if (typeof this.defaultValue === \"number\") {\r\n            return 1;\r\n        }\r\n        return this.defaultValue.dimension[0];\r\n    }\r\n}\r\n\r\nclass Sampler {\r\n    public name: string;\r\n    public value: Nullable<BaseTexture> = null; // Texture value, default to null\r\n    public samplerPrefix: string = \"\"; // The name of the sampler in the shader\r\n    public textureDefine: string = \"\"; // The define used in the shader for this sampler\r\n\r\n    /**\r\n     * The name of the sampler used in the shader.\r\n     * If this naming changes, we'll also need to change:\r\n     * - samplerFragmentDeclaration.fx\r\n     * - openpbr.fragment.fx\r\n     */\r\n    public get samplerName(): string {\r\n        return this.samplerPrefix + \"Sampler\";\r\n    }\r\n    /**\r\n     * The name of the sampler info used in the shader.\r\n     * If this naming changes, we'll also need to change:\r\n     * - openpbr.vertex.fx\r\n     * - openpbr.fragment.fx\r\n     */\r\n    public get samplerInfoName(): string {\r\n        return \"v\" + this.samplerPrefix.charAt(0).toUpperCase() + this.samplerPrefix.slice(1) + \"Infos\";\r\n    }\r\n    /**\r\n     * The name of the matrix used for this sampler in the shader.\r\n     * If this naming changes, we'll also need to change:\r\n     * - materialHelper.functions.BindTextureMatrix\r\n     * - samplerVertexImplementation.fx\r\n     * - openpbr.fragment.fx\r\n     */\r\n    public get samplerMatrixName(): string {\r\n        return this.samplerPrefix + \"Matrix\";\r\n    }\r\n    /**\r\n     * Creates a new Sampler instance.\r\n     * @param name The name of the texture property\r\n     * @param samplerPrefix The prefix used for the name of the sampler in the shader\r\n     * @param textureDefine The define used in the shader for this sampler\r\n     */\r\n    constructor(name: string, samplerPrefix: string, textureDefine: string) {\r\n        this.name = name;\r\n        this.samplerPrefix = samplerPrefix;\r\n        this.textureDefine = textureDefine;\r\n    }\r\n}\r\n\r\nclass OpenPBRMaterialDefinesBase extends UVDefinesMixin(MaterialDefines) {}\r\n/**\r\n * Manages the defines for the PBR Material.\r\n * @internal\r\n */\r\nexport class OpenPBRMaterialDefines extends ImageProcessingDefinesMixin(OpenPBRMaterialDefinesBase) {\r\n    public NUM_SAMPLES = \"0\";\r\n    public REALTIME_FILTERING = false;\r\n    public IBL_CDF_FILTERING = false;\r\n\r\n    public VERTEXCOLOR = false;\r\n\r\n    public BAKED_VERTEX_ANIMATION_TEXTURE = false;\r\n\r\n    public VERTEXALPHA = false;\r\n    public ALPHATEST = false;\r\n    public DEPTHPREPASS = false;\r\n    public ALPHABLEND = false;\r\n    public ALPHA_FROM_BASE_COLOR_TEXTURE = false;\r\n    public ALPHATESTVALUE = \"0.5\";\r\n    public PREMULTIPLYALPHA = false;\r\n\r\n    public REFLECTIVITY_GAMMA = false;\r\n    public REFLECTIVITYDIRECTUV = 0;\r\n    public SPECULARTERM = false;\r\n\r\n    public LODBASEDMICROSFURACE = true;\r\n\r\n    public METALLICWORKFLOW = true;\r\n    public ROUGHNESSSTOREINMETALMAPALPHA = false;\r\n    public ROUGHNESSSTOREINMETALMAPGREEN = false;\r\n    public METALLNESSSTOREINMETALMAPBLUE = false;\r\n    public AOSTOREINMETALMAPRED = false;\r\n    public SPECULAR_WEIGHT_IN_ALPHA = false;\r\n    public SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = false;\r\n    public SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;\r\n    public COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = false;\r\n    public USE_GLTF_STYLE_ANISOTROPY = false;\r\n    public THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = false;\r\n\r\n    public ENVIRONMENTBRDF = false;\r\n    public ENVIRONMENTBRDF_RGBD = false;\r\n    public FUZZENVIRONMENTBRDF = false;\r\n\r\n    public NORMAL = false;\r\n    public TANGENT = false;\r\n    public OBJECTSPACE_NORMALMAP = false;\r\n    public PARALLAX = false;\r\n    public PARALLAX_RHS = false;\r\n    public PARALLAXOCCLUSION = false;\r\n    public NORMALXYSCALE = true;\r\n    /**\r\n     * Enables anisotropic logic. Still needed because it's used in pbrHelperFunctions\r\n     */\r\n    public ANISOTROPIC = false;\r\n    /**\r\n     * Tells the shader to use OpenPBR's anisotropic roughness remapping\r\n     */\r\n    public ANISOTROPIC_OPENPBR = true;\r\n    /**\r\n     * Tells the shader to apply anisotropy to the base layer\r\n     */\r\n    public ANISOTROPIC_BASE = false;\r\n    /**\r\n     * Tells the shader to apply anisotropy to the coat layer\r\n     */\r\n    public ANISOTROPIC_COAT = false;\r\n\r\n    /**\r\n     * Number of samples to use for the fuzz IBL lighting calculations\r\n     */\r\n    public FUZZ_IBL_SAMPLES = 6;\r\n\r\n    /**\r\n     * Tells the shader to enable the fuzz layer\r\n     */\r\n    public FUZZ = false;\r\n\r\n    /**\r\n     * Tells the shader to enable the thin film layer\r\n     */\r\n    public THIN_FILM = false;\r\n\r\n    /**\r\n     * Tells the shader to enable the legacy iridescence code\r\n     * Iridescence is the name of thin film interference in the PBR material.\r\n     */\r\n    public IRIDESCENCE = false;\r\n\r\n    public REFLECTION = false;\r\n    public REFLECTIONMAP_3D = false;\r\n    public REFLECTIONMAP_SPHERICAL = false;\r\n    public REFLECTIONMAP_PLANAR = false;\r\n    public REFLECTIONMAP_CUBIC = false;\r\n    public USE_LOCAL_REFLECTIONMAP_CUBIC = false;\r\n    public REFLECTIONMAP_PROJECTION = false;\r\n    public REFLECTIONMAP_SKYBOX = false;\r\n    public REFLECTIONMAP_EXPLICIT = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR = false;\r\n    public REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;\r\n    public REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;\r\n    public INVERTCUBICMAP = false;\r\n    public USESPHERICALFROMREFLECTIONMAP = false;\r\n    public USEIRRADIANCEMAP = false;\r\n    public USE_IRRADIANCE_DOMINANT_DIRECTION = false;\r\n    public USESPHERICALINVERTEX = false;\r\n    public REFLECTIONMAP_OPPOSITEZ = false;\r\n    public LODINREFLECTIONALPHA = false;\r\n    public GAMMAREFLECTION = false;\r\n    public RGBDREFLECTION = false;\r\n    public RADIANCEOCCLUSION = false;\r\n    public HORIZONOCCLUSION = false;\r\n\r\n    public INSTANCES = false;\r\n    public THIN_INSTANCES = false;\r\n    public INSTANCESCOLOR = false;\r\n\r\n    public PREPASS = false;\r\n    public PREPASS_COLOR = false;\r\n    public PREPASS_COLOR_INDEX = -1;\r\n    public PREPASS_IRRADIANCE = false;\r\n    public PREPASS_IRRADIANCE_INDEX = -1;\r\n    public PREPASS_ALBEDO = false;\r\n    public PREPASS_ALBEDO_INDEX = -1;\r\n    public PREPASS_ALBEDO_SQRT = false;\r\n    public PREPASS_ALBEDO_SQRT_INDEX = -1;\r\n    public PREPASS_DEPTH = false;\r\n    public PREPASS_DEPTH_INDEX = -1;\r\n    public PREPASS_SCREENSPACE_DEPTH = false;\r\n    public PREPASS_SCREENSPACE_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH = false;\r\n    public PREPASS_NORMALIZED_VIEW_DEPTH_INDEX = -1;\r\n    public PREPASS_NORMAL = false;\r\n    public PREPASS_NORMAL_INDEX = -1;\r\n    public PREPASS_NORMAL_WORLDSPACE = false;\r\n    public PREPASS_WORLD_NORMAL = false;\r\n    public PREPASS_WORLD_NORMAL_INDEX = -1;\r\n    public PREPASS_POSITION = false;\r\n    public PREPASS_POSITION_INDEX = -1;\r\n    public PREPASS_LOCAL_POSITION = false;\r\n    public PREPASS_LOCAL_POSITION_INDEX = -1;\r\n    public PREPASS_VELOCITY = false;\r\n    public PREPASS_VELOCITY_INDEX = -1;\r\n    public PREPASS_VELOCITY_LINEAR = false;\r\n    public PREPASS_VELOCITY_LINEAR_INDEX = -1;\r\n    public PREPASS_REFLECTIVITY = false;\r\n    public PREPASS_REFLECTIVITY_INDEX = -1;\r\n    public SCENE_MRT_COUNT = 0;\r\n\r\n    public NUM_BONE_INFLUENCERS = 0;\r\n    public BonesPerMesh = 0;\r\n    public BONETEXTURE = false;\r\n    public BONES_VELOCITY_ENABLED = false;\r\n\r\n    public NONUNIFORMSCALING = false;\r\n\r\n    public MORPHTARGETS = false;\r\n    public MORPHTARGETS_POSITION = false;\r\n    public MORPHTARGETS_NORMAL = false;\r\n    public MORPHTARGETS_TANGENT = false;\r\n    public MORPHTARGETS_UV = false;\r\n    public MORPHTARGETS_UV2 = false;\r\n    public MORPHTARGETS_COLOR = false;\r\n    public MORPHTARGETTEXTURE_HASPOSITIONS = false;\r\n    public MORPHTARGETTEXTURE_HASNORMALS = false;\r\n    public MORPHTARGETTEXTURE_HASTANGENTS = false;\r\n    public MORPHTARGETTEXTURE_HASUVS = false;\r\n    public MORPHTARGETTEXTURE_HASUV2S = false;\r\n    public MORPHTARGETTEXTURE_HASCOLORS = false;\r\n    public NUM_MORPH_INFLUENCERS = 0;\r\n    public MORPHTARGETS_TEXTURE = false;\r\n\r\n    public USEPHYSICALLIGHTFALLOFF = false;\r\n    public USEGLTFLIGHTFALLOFF = false;\r\n    public TWOSIDEDLIGHTING = false;\r\n    public MIRRORED = false;\r\n    public SHADOWFLOAT = false;\r\n    public CLIPPLANE = false;\r\n    public CLIPPLANE2 = false;\r\n    public CLIPPLANE3 = false;\r\n    public CLIPPLANE4 = false;\r\n    public CLIPPLANE5 = false;\r\n    public CLIPPLANE6 = false;\r\n    public POINTSIZE = false;\r\n    public FOG = false;\r\n    public LOGARITHMICDEPTH = false;\r\n    public CAMERA_ORTHOGRAPHIC = false;\r\n    public CAMERA_PERSPECTIVE = false;\r\n    public AREALIGHTSUPPORTED = true;\r\n\r\n    public FORCENORMALFORWARD = false;\r\n\r\n    public SPECULARAA = false;\r\n\r\n    public UNLIT = false;\r\n\r\n    public DECAL_AFTER_DETAIL = false;\r\n\r\n    public DEBUGMODE = 0;\r\n\r\n    public CLUSTLIGHT_SLICES = 0;\r\n    public CLUSTLIGHT_BATCH = 0;\r\n\r\n    // BRDF defines\r\n    BRDF_V_HEIGHT_CORRELATED = true;\r\n    MS_BRDF_ENERGY_CONSERVATION = true;\r\n    SPHERICAL_HARMONICS = true;\r\n    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = true;\r\n    MIX_IBL_RADIANCE_WITH_IRRADIANCE = true;\r\n    LEGACY_SPECULAR_ENERGY_CONSERVATION = false;\r\n    BASE_DIFFUSE_MODEL = Constants.MATERIAL_DIFFUSE_MODEL_E_OREN_NAYAR;\r\n    DIELECTRIC_SPECULAR_MODEL = Constants.MATERIAL_DIELECTRIC_SPECULAR_MODEL_OPENPBR;\r\n    CONDUCTOR_SPECULAR_MODEL = Constants.MATERIAL_CONDUCTOR_SPECULAR_MODEL_OPENPBR;\r\n\r\n    /**\r\n     * Initializes the PBR Material defines.\r\n     * @param externalProperties The external properties\r\n     */\r\n    constructor(externalProperties?: { [name: string]: { type: string; default: any } }) {\r\n        super(externalProperties);\r\n        this.rebuild();\r\n    }\r\n\r\n    /**\r\n     * Resets the PBR Material defines.\r\n     */\r\n    public override reset(): void {\r\n        super.reset();\r\n        this.ALPHATESTVALUE = \"0.5\";\r\n        this.NORMALXYSCALE = true;\r\n    }\r\n}\r\n\r\nclass OpenPBRMaterialBase extends ImageProcessingMixin(PushMaterial) {}\r\n/**\r\n * A Physically based material that follows the specification of OpenPBR.\r\n *\r\n * For more information, please refer to the documentation :\r\n * https://academysoftwarefoundation.github.io/OpenPBR/index.html\r\n */\r\nexport class OpenPBRMaterial extends OpenPBRMaterialBase {\r\n    /**\r\n     * Base Weight is a multiplier on the diffuse and metal lobes.\r\n     * See OpenPBR's specs for base_weight\r\n     */\r\n    public baseWeight: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseWeight\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseWeight: Property<number> = new Property<number>(\"base_weight\", 1, \"vBaseWeight\", 1);\r\n\r\n    /**\r\n     * Base Weight is a multiplier on the diffuse and metal lobes.\r\n     * See OpenPBR's specs for base_weight\r\n     */\r\n    public baseWeightTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseWeightTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseWeightTexture: Sampler = new Sampler(\"base_weight\", \"baseWeight\", \"BASE_WEIGHT\");\r\n\r\n    /**\r\n     * Color of the base diffuse lobe.\r\n     * See OpenPBR's specs for base_color\r\n     */\r\n    public baseColor: Color3;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseColor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseColor: Property<Color3> = new Property<Color3>(\"base_color\", Color3.White(), \"vBaseColor\", 4);\r\n\r\n    /**\r\n     * Base Color Texture property.\r\n     * See OpenPBR's specs for base_color\r\n     */\r\n    public baseColorTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseColorTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseColorTexture: Sampler = new Sampler(\"base_color\", \"baseColor\", \"BASE_COLOR\");\r\n\r\n    /**\r\n     * Roughness of the diffuse lobe.\r\n     * See OpenPBR's specs for base_diffuse_roughness\r\n     */\r\n    public baseDiffuseRoughness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseDiffuseRoughness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseDiffuseRoughness: Property<number> = new Property<number>(\"base_diffuse_roughness\", 0, \"vBaseDiffuseRoughness\", 1);\r\n\r\n    /**\r\n     * Roughness texture of the diffuse lobe.\r\n     * See OpenPBR's specs for base_diffuse_roughness\r\n     */\r\n    public baseDiffuseRoughnessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseDiffuseRoughnessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseDiffuseRoughnessTexture: Sampler = new Sampler(\"base_diffuse_roughness\", \"baseDiffuseRoughness\", \"BASE_DIFFUSE_ROUGHNESS\");\r\n\r\n    /**\r\n     * Metalness of the base lobe.\r\n     * See OpenPBR's specs for base_metalness\r\n     */\r\n    public baseMetalness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseMetalness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseMetalness: Property<number> = new Property<number>(\"base_metalness\", 0, \"vReflectanceInfo\", 4, 0);\r\n\r\n    /**\r\n     * Metalness texture.\r\n     * See OpenPBR's specs for base_metalness\r\n     */\r\n    public baseMetalnessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"baseMetalnessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _baseMetalnessTexture: Sampler = new Sampler(\"base_metalness\", \"baseMetalness\", \"BASE_METALNESS\");\r\n\r\n    /**\r\n     * Weight of the specular lobe.\r\n     * See OpenPBR's specs for specular_weight\r\n     */\r\n    public specularWeight: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularWeight\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularWeight: Property<number> = new Property<number>(\"specular_weight\", 1, \"vReflectanceInfo\", 4, 3);\r\n\r\n    /**\r\n     * Weight texture of the specular lobe.\r\n     * See OpenPBR's specs for specular_weight\r\n     */\r\n    public specularWeightTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularWeightTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularWeightTexture: Sampler = new Sampler(\"specular_weight\", \"specularWeight\", \"SPECULAR_WEIGHT\");\r\n\r\n    /**\r\n     * Color of the specular lobe.\r\n     * See OpenPBR's specs for specular_color\r\n     */\r\n    public specularColor: Color3;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularColor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularColor: Property<Color3> = new Property<Color3>(\"specular_color\", Color3.White(), \"vSpecularColor\", 4);\r\n\r\n    /**\r\n     * Specular Color Texture property.\r\n     * See OpenPBR's specs for specular_color\r\n     */\r\n    public specularColorTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularColorTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularColorTexture: Sampler = new Sampler(\"specular_color\", \"specularColor\", \"SPECULAR_COLOR\");\r\n\r\n    /**\r\n     * Roughness of the specular lobe.\r\n     * See OpenPBR's specs for specular_roughness\r\n     */\r\n    public specularRoughness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularRoughness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularRoughness: Property<number> = new Property<number>(\"specular_roughness\", 0.3, \"vReflectanceInfo\", 4, 1);\r\n\r\n    /**\r\n     * Roughness texture of the specular lobe.\r\n     * See OpenPBR's specs for specular_roughness\r\n     */\r\n    public specularRoughnessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularRoughnessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularRoughnessTexture: Sampler = new Sampler(\"specular_roughness\", \"specularRoughness\", \"SPECULAR_ROUGHNESS\");\r\n\r\n    /**\r\n     * Anisotropic roughness of the specular lobe.\r\n     * See OpenPBR's specs for specular_roughness_anisotropy\r\n     */\r\n    public specularRoughnessAnisotropy: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularRoughnessAnisotropy\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularRoughnessAnisotropy: Property<number> = new Property<number>(\"specular_roughness_anisotropy\", 0, \"vSpecularAnisotropy\", 3, 2);\r\n\r\n    /**\r\n     * Anisotropic Roughness texture.\r\n     * See OpenPBR's specs for specular_roughness\r\n     */\r\n    public specularRoughnessAnisotropyTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularRoughnessAnisotropyTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularRoughnessAnisotropyTexture: Sampler = new Sampler(\"specular_roughness_anisotropy\", \"specularRoughnessAnisotropy\", \"SPECULAR_ROUGHNESS_ANISOTROPY\");\r\n\r\n    /**\r\n     * IOR of the specular lobe.\r\n     * See OpenPBR's specs for specular_ior\r\n     */\r\n    public specularIor: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"specularIor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _specularIor: Property<number> = new Property<number>(\"specular_ior\", 1.5, \"vReflectanceInfo\", 4, 2);\r\n\r\n    /**\r\n     * Defines the amount of clear coat on the surface.\r\n     * See OpenPBR's specs for coat_weight\r\n     */\r\n    public coatWeight: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatWeight\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatWeight: Property<number> = new Property<number>(\"coat_weight\", 0.0, \"vCoatWeight\", 1, 0);\r\n\r\n    /**\r\n     * Coat weight texture.\r\n     * See OpenPBR's specs for coat_weight\r\n     */\r\n    public coatWeightTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatWeightTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatWeightTexture: Sampler = new Sampler(\"coat_weight\", \"coatWeight\", \"COAT_WEIGHT\");\r\n\r\n    /**\r\n     * Defines the color of the clear coat on the surface.\r\n     * See OpenPBR's specs for coat_color\r\n     */\r\n    public coatColor: Color3;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatColor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatColor: Property<Color3> = new Property<Color3>(\"coat_color\", Color3.White(), \"vCoatColor\", 3, 0);\r\n\r\n    /**\r\n     * Color texture of the clear coat.\r\n     * See OpenPBR's specs for coat_color\r\n     */\r\n    public coatColorTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatColorTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatColorTexture: Sampler = new Sampler(\"coat_color\", \"coatColor\", \"COAT_COLOR\");\r\n\r\n    /**\r\n     * Defines the roughness of the clear coat on the surface.\r\n     * See OpenPBR's specs for coat_roughness\r\n     */\r\n    public coatRoughness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatRoughness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatRoughness: Property<number> = new Property<number>(\"coat_roughness\", 0.0, \"vCoatRoughness\", 1, 0);\r\n\r\n    /**\r\n     * Roughness texture of the clear coat.\r\n     * See OpenPBR's specs for coat_roughness\r\n     */\r\n    public coatRoughnessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatRoughnessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatRoughnessTexture: Sampler = new Sampler(\"coat_roughness\", \"coatRoughness\", \"COAT_ROUGHNESS\");\r\n\r\n    /**\r\n     * Defines the anisotropy of the clear coat on the surface.\r\n     * See OpenPBR's specs for coat_roughness_anisotropy\r\n     */\r\n    public coatRoughnessAnisotropy: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatRoughnessAnisotropy\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatRoughnessAnisotropy: Property<number> = new Property<number>(\"coat_roughness_anisotropy\", 0, \"vCoatRoughnessAnisotropy\", 1);\r\n\r\n    /**\r\n     * Anisotropic Roughness texture of the clear coat.\r\n     * See OpenPBR's specs for coat_roughness_anisotropy\r\n     */\r\n    public coatRoughnessAnisotropyTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatRoughnessAnisotropyTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatRoughnessAnisotropyTexture: Sampler = new Sampler(\"coat_roughness_anisotropy\", \"coatRoughnessAnisotropy\", \"COAT_ROUGHNESS_ANISOTROPY\");\r\n\r\n    /**\r\n     * Defines the IOR of the clear coat on the surface.\r\n     * See OpenPBR's specs for coat_ior\r\n     */\r\n    public coatIor: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatIor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatIor: Property<number> = new Property<number>(\"coat_ior\", 1.5, \"vCoatIor\", 1, 0);\r\n\r\n    /**\r\n     * Defines the amount that interreflections within the coat allow the underlying surface\r\n     * to be darkened. A value of 1.0 means that the physically correct amount of darkening\r\n     * is applied, while a value of 0.0 means that no darkening is applied.\r\n     * See OpenPBR's specs for coat_darkening\r\n     */\r\n    public coatDarkening: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatDarkening\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatDarkening: Property<number> = new Property<number>(\"coat_darkening\", 1.0, \"vCoatDarkening\", 1, 0);\r\n\r\n    /**\r\n     * Defines the amount that interreflections within the coat allow the underlying surface\r\n     * to be darkened. A value of 1.0 means that the physically correct amount of darkening\r\n     * is applied, while a value of 0.0 means that no darkening is applied.\r\n     * See OpenPBR's specs for coat_darkening\r\n     */\r\n    public coatDarkeningTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"coatDarkeningTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _coatDarkeningTexture: Sampler = new Sampler(\"coat_darkening\", \"coatDarkening\", \"COAT_DARKENING\");\r\n\r\n    /**\r\n     * Specifies whether the coat roughness is taken from the\r\n     * same texture as the coat_weight.\r\n     */\r\n    public useCoatRoughnessFromWeightTexture: boolean = false;\r\n\r\n    /**\r\n     * Defines the weight of the fuzz layer on the surface.\r\n     * See OpenPBR's specs for fuzz_weight\r\n     */\r\n    public fuzzWeight: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzWeight\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzWeight: Property<number> = new Property<number>(\"fuzz_weight\", 0.0, \"vFuzzWeight\", 1, 0);\r\n\r\n    /**\r\n     * Weight texture of the fuzz layer.\r\n     * See OpenPBR's specs for fuzz_weight\r\n     */\r\n    public fuzzWeightTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzWeightTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzWeightTexture: Sampler = new Sampler(\"fuzz_weight\", \"fuzzWeight\", \"FUZZ_WEIGHT\");\r\n\r\n    /**\r\n     * Defines the color of the fuzz layer on the surface.\r\n     * See OpenPBR's specs for fuzz_color\r\n     */\r\n    public fuzzColor: Color3;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzColor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzColor: Property<Color3> = new Property<Color3>(\"fuzz_color\", Color3.White(), \"vFuzzColor\", 3, 0);\r\n\r\n    /**\r\n     * Color texture of the fuzz layer.\r\n     * See OpenPBR's specs for fuzz_color\r\n     */\r\n    public fuzzColorTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzColorTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzColorTexture: Sampler = new Sampler(\"fuzz_color\", \"fuzzColor\", \"FUZZ_COLOR\");\r\n\r\n    /**\r\n     * Defines the roughness of the fuzz layer on the surface.\r\n     * See OpenPBR's specs for fuzz_roughness\r\n     */\r\n    public fuzzRoughness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzRoughness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzRoughness: Property<number> = new Property<number>(\"fuzz_roughness\", 0.5, \"vFuzzRoughness\", 1, 0);\r\n\r\n    /**\r\n     * Roughness texture of the fuzz layer.\r\n     * See OpenPBR's specs for fuzz_roughness\r\n     */\r\n    public fuzzRoughnessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"fuzzRoughnessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _fuzzRoughnessTexture: Sampler = new Sampler(\"fuzz_roughness\", \"fuzzRoughness\", \"FUZZ_ROUGHNESS\");\r\n\r\n    /**\r\n     * Defines the normal of the material's geometry.\r\n     * See OpenPBR's specs for geometry_normal\r\n     */\r\n    public geometryNormalTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryNormalTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryNormalTexture: Sampler = new Sampler(\"geometry_normal\", \"geometryNormal\", \"GEOMETRY_NORMAL\");\r\n\r\n    /**\r\n     * Defines the tangent of the material's geometry. Used only for anisotropic reflections.\r\n     * See OpenPBR's specs for geometry_tangent\r\n     */\r\n    public geometryTangent: Vector2;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryTangent\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryTangent: Property<Vector2> = new Property<Vector2>(\"geometry_tangent\", new Vector2(1, 0), \"vSpecularAnisotropy\", 3, 0);\r\n\r\n    /**\r\n     * Defines the angle of the tangent of the material's geometry. Used only for anisotropic reflections.\r\n     * See OpenPBR's specs for geometry_tangent\r\n     */\r\n    public get geometryTangentAngle(): number {\r\n        return Math.atan2(this.geometryTangent.y, this.geometryTangent.x);\r\n    }\r\n\r\n    public set geometryTangentAngle(value: number) {\r\n        this.geometryTangent = new Vector2(Math.cos(value), Math.sin(value));\r\n    }\r\n\r\n    /**\r\n     * Defines the tangent of the material's geometry. Used only for anisotropic reflections.\r\n     * See OpenPBR's specs for geometry_tangent\r\n     */\r\n    public geometryTangentTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryTangentTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryTangentTexture: Sampler = new Sampler(\"geometry_tangent\", \"geometryTangent\", \"GEOMETRY_TANGENT\");\r\n\r\n    /**\r\n     * Defines the normal of the material's coat layer.\r\n     * See OpenPBR's specs for geometry_coat_normal\r\n     */\r\n    public geometryCoatNormalTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryCoatNormalTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryCoatNormalTexture: Sampler = new Sampler(\"geometry_coat_normal\", \"geometryCoatNormal\", \"GEOMETRY_COAT_NORMAL\");\r\n\r\n    /**\r\n     * Defines the tangent of the material's coat layer. Used only for anisotropic reflections.\r\n     * See OpenPBR's specs for geometry_coat_tangent\r\n     */\r\n    public geometryCoatTangent: Vector2;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryCoatTangent\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryCoatTangent: Property<Vector2> = new Property<Vector2>(\"geometry_coat_tangent\", new Vector2(1, 0), \"vGeometryCoatTangent\", 2, 0);\r\n\r\n    /**\r\n     * Defines the angle of the tangent of the material's coat layer.\r\n     */\r\n    public get geometryCoatTangentAngle(): number {\r\n        return Math.atan2(this.geometryCoatTangent.y, this.geometryCoatTangent.x);\r\n    }\r\n\r\n    /**\r\n     * Defines the angle of the tangent of the material's coat layer.\r\n     */\r\n    public set geometryCoatTangentAngle(value: number) {\r\n        this.geometryCoatTangent = new Vector2(Math.cos(value), Math.sin(value));\r\n    }\r\n\r\n    /**\r\n     * Defines the tangent of the material's coat layer. Used only for anisotropic reflections.\r\n     * See OpenPBR's specs for geometry_coat_tangent\r\n     */\r\n    public geometryCoatTangentTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryCoatTangentTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryCoatTangentTexture: Sampler = new Sampler(\"geometry_coat_tangent\", \"geometryCoatTangent\", \"GEOMETRY_COAT_TANGENT\");\r\n\r\n    /**\r\n     * Defines the opacity of the material's geometry.\r\n     * See OpenPBR's specs for geometry_opacity\r\n     */\r\n    public geometryOpacity: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryOpacity\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryOpacity: Property<number> = new Property<number>(\"geometry_opacity\", 1.0, \"vBaseColor\", 4, 3);\r\n\r\n    /**\r\n     * Defines the opacity texture of the material's geometry.\r\n     * See OpenPBR's specs for geometry_opacity\r\n     */\r\n    public geometryOpacityTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"geometryOpacityTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _geometryOpacityTexture: Sampler = new Sampler(\"geometry_opacity\", \"geometryOpacity\", \"GEOMETRY_OPACITY\");\r\n\r\n    /**\r\n     * Defines the luminance of the material's emission.\r\n     * See OpenPBR's specs for emission_luminance\r\n     */\r\n    public emissionLuminance: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"emissionLuminance\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _emissionLuminance: Property<number> = new Property<number>(\"emission_luminance\", 1.0, \"vLightingIntensity\", 4, 1);\r\n\r\n    /**\r\n     * Defines the color of the material's emission.\r\n     * See OpenPBR's specs for emission_color\r\n     */\r\n    public emissionColor: Color3;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"emissionColor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _emissionColor: Property<Color3> = new Property<Color3>(\"emission_color\", Color3.Black(), \"vEmissionColor\", 3);\r\n\r\n    /**\r\n     * Defines the texture of the material's emission color.\r\n     * See OpenPBR's specs for emission_color\r\n     */\r\n    public emissionColorTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"emissionColorTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _emissionColorTexture: Sampler = new Sampler(\"emission_color\", \"emissionColor\", \"EMISSION_COLOR\");\r\n\r\n    /**\r\n     * Defines the weight of the thin film layer on top of the base layer for iridescent effects.\r\n     */\r\n    public thinFilmWeight: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmWeight\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmWeight: Property<number> = new Property<number>(\"thin_film_weight\", 0.0, \"vThinFilmWeight\", 1, 0);\r\n\r\n    /**\r\n     * Thin film weight texture.\r\n     */\r\n    public thinFilmWeightTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmWeightTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmWeightTexture: Sampler = new Sampler(\"thin_film_weight\", \"thinFilmWeight\", \"THIN_FILM_WEIGHT\");\r\n\r\n    /**\r\n     * Defines the thickness of the thin film layer in μm. If a texture is provided for thinFilmWeightTexture,\r\n     * this value will act as a multiplier to the texture values.\r\n     * See OpenPBR's specs for thin_film_thickness\r\n     */\r\n    public thinFilmThickness: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmThickness\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmThickness: Property<number> = new Property<number>(\"thin_film_thickness\", 0.5, \"vThinFilmThickness\", 2, 0);\r\n\r\n    /**\r\n     * Defines the minimum thickness of the thin film layer in μm.\r\n     */\r\n    public thinFilmThicknessMin: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmThicknessMin\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmThicknessMin: Property<number> = new Property<number>(\"thin_film_thickness_min\", 0.0, \"vThinFilmThickness\", 2, 1);\r\n\r\n    /**\r\n     * Defines the maximum thickness of the thin film layer in μm.\r\n     */\r\n    public thinFilmThicknessTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmThicknessTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmThicknessTexture: Sampler = new Sampler(\"thin_film_thickness\", \"thinFilmThickness\", \"THIN_FILM_THICKNESS\");\r\n\r\n    /**\r\n     * Defines the index of refraction of the thin film layer.\r\n     */\r\n    public thinFilmIor: number;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"thinFilmIor\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _thinFilmIor: Property<number> = new Property<number>(\"thin_film_ior\", 1.4, \"vThinFilmIor\", 1, 0);\r\n\r\n    /**\r\n     * Defines the ambient occlusion texture.\r\n     */\r\n    public ambientOcclusionTexture: Nullable<BaseTexture>;\r\n    @addAccessorsForMaterialProperty(\"_markAllSubMeshesAsTexturesDirty\", \"ambientOcclusionTexture\")\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    private _ambientOcclusionTexture: Sampler = new Sampler(\"ambient_occlusion\", \"ambientOcclusion\", \"AMBIENT_OCCLUSION\");\r\n\r\n    private _propertyList: { [name: string]: Property<any> };\r\n    private _uniformsList: { [name: string]: Uniform } = {};\r\n    private _samplersList: { [name: string]: Sampler } = {};\r\n    private _samplerDefines: { [name: string]: { type: string; default: any } } = {};\r\n\r\n    private static _noiseTextures: { [id: number]: BaseTexture } = {};\r\n\r\n    /**\r\n     * Intensity of the direct lights e.g. the four lights available in your scene.\r\n     * This impacts both the direct diffuse and specular highlights.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public directIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Intensity of the environment e.g. how much the environment will light the object\r\n     * either through harmonics for rough material or through the reflection for shiny ones.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentIntensity: number = 1.0;\r\n\r\n    /**\r\n     * Specifies that the specular weight is stored in the alpha channel of the specular weight texture.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useSpecularWeightFromTextureAlpha = false;\r\n\r\n    /**\r\n     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public forceAlphaTest = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesAndMiscDirty\")\r\n    public alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAmbientInGrayScale = false;\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    @serialize()\r\n    public get usePhysicalLightFalloff(): boolean {\r\n        return this._lightFalloff === Material.LIGHTFALLOFF_PHYSICAL;\r\n    }\r\n\r\n    /**\r\n     * BJS is using an hardcoded light falloff based on a manually sets up range.\r\n     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.\r\n     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.\r\n     */\r\n    public set usePhysicalLightFalloff(value: boolean) {\r\n        if (value !== this.usePhysicalLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;\r\n            } else {\r\n                this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    @serialize()\r\n    public get useGLTFLightFalloff(): boolean {\r\n        return this._lightFalloff === Material.LIGHTFALLOFF_GLTF;\r\n    }\r\n\r\n    /**\r\n     * In order to support the falloff compatibility with gltf, a special mode has been added\r\n     * to reproduce the gltf light falloff.\r\n     */\r\n    public set useGLTFLightFalloff(value: boolean) {\r\n        if (value !== this.useGLTFLightFalloff) {\r\n            // Ensure the effect will be rebuilt.\r\n            this._markAllSubMeshesAsTexturesDirty();\r\n\r\n            if (value) {\r\n                this._lightFalloff = Material.LIGHTFALLOFF_GLTF;\r\n            } else {\r\n                this._lightFalloff = Material.LIGHTFALLOFF_STANDARD;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the normal map in parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallax = false;\r\n\r\n    /**\r\n     * Allows using the normal map in parallax occlusion mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public disableLighting = false;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take normal mapping into account.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceIrradianceInFragment = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsLightsDirty\")\r\n    public maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will invert (x = 1.0 - x).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will invert (y = 1.0 - y).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public twoSidedLighting = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Let user defines the brdf lookup texture used for IBL.\r\n     * A default 8bit version is embedded but you could point at :\r\n     * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png\r\n     * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds\r\n     * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png\r\n     * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the normalmap values.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\r\n    public useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    @serialize()\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public applyDecalMapAfterDetailMap = false;\r\n\r\n    /**\r\n     * Force all the PBR materials to compile to glsl even on WebGPU engines.\r\n     * False by default. This is mostly meant for backward compatibility.\r\n     */\r\n    public static ForceGLSL = false;\r\n\r\n    /**\r\n     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.\r\n     */\r\n    private _lightingInfos: Vector4 = new Vector4(this.directIntensity, 1.0, this.environmentIntensity, 1.0);\r\n\r\n    /**\r\n     * Stores the radiance (and, possibly, irradiance) values in a texture.\r\n     * @internal\r\n     */\r\n    public _radianceTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Specifies that the specular weight will be read from the alpha channel.\r\n     * This is for compatibility with glTF's KHR_materials_specular extension.\r\n     * @internal\r\n     */\r\n    public _useSpecularWeightFromAlpha = false;\r\n\r\n    /**\r\n     * Specifies that the specular weight will be read from the alpha channel of the specular color texture.\r\n     * This is for compatibility with glTF's KHR_materials_specular extension.\r\n     * @internal\r\n     */\r\n    public _useSpecularWeightFromSpecularColorTexture = false;\r\n\r\n    /**\r\n     * Specifies if the material uses anisotropy weight read from the geometry tangent texture's blue channel.\r\n     * This is for compatibility with glTF's anisotropy extension.\r\n     * @internal\r\n     */\r\n    public _useSpecularRoughnessAnisotropyFromTangentTexture = false;\r\n\r\n    /**\r\n     * Specifies if the material uses coat anisotropy weight read from the coat's geometry tangent texture's blue channel.\r\n     * This is for compatibility with glTF's clearcoat_anisotropy extension.\r\n     * @internal\r\n     */\r\n    public _useCoatRoughnessAnisotropyFromTangentTexture = false;\r\n\r\n    /**\r\n     * Assume the anisotropy data is stored in the format specified by\r\n     * KHR_materials_anisotropy.\r\n     * @internal\r\n     */\r\n    public _useGltfStyleAnisotropy = false;\r\n\r\n    /**\r\n     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal\r\n     * makes the reflect vector face the model (under horizon).\r\n     * @internal\r\n     */\r\n    public _useHorizonOcclusion = true;\r\n\r\n    /**\r\n     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit\r\n     * too much the area relying on ambient texture to define their ambient occlusion.\r\n     * @internal\r\n     */\r\n    public _useRadianceOcclusion = true;\r\n\r\n    /**\r\n     * Specifies that the alpha is coming from the base color texture's alpha channel.\r\n     * This is for compatibility with glTF.\r\n     * @internal\r\n     */\r\n    public _useAlphaFromBaseColorTexture = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.\r\n     * This is for compatibility with glTF.\r\n     * @internal\r\n     */\r\n    public _useAmbientOcclusionFromMetallicTextureRed = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the roughness information in its green channel.\r\n     * This is for compatibility with glTF.\r\n     * @internal\r\n     */\r\n    public _useRoughnessFromMetallicTextureGreen = false;\r\n\r\n    /**\r\n     * Specifies if the metallic texture contains the metallic information in its blue channel.\r\n     * This is for compatibility with glTF.\r\n     * @internal\r\n     */\r\n    public _useMetallicFromMetallicTextureBlue = false;\r\n\r\n    /**\r\n     * Specifies if the thin film thickness is stored in the green channel of the thin film thickness texture.\r\n     */\r\n    public _useThinFilmThicknessFromTextureGreen = false;\r\n\r\n    /**\r\n     * Defines the  falloff type used in this material.\r\n     * It by default is Physical.\r\n     * @internal\r\n     */\r\n    public _lightFalloff = Material.LIGHTFALLOFF_PHYSICAL;\r\n\r\n    /**\r\n     * Allows using an object space normal map (instead of tangent space).\r\n     * @internal\r\n     */\r\n    public _useObjectSpaceNormalMap = false;\r\n\r\n    /**\r\n     * Allows using the normal map in parallax mode.\r\n     * @internal\r\n     */\r\n    public _useParallax = false;\r\n\r\n    /**\r\n     * Allows using the normal map in parallax occlusion mode.\r\n     * @internal\r\n     */\r\n    public _useParallaxOcclusion = false;\r\n\r\n    /**\r\n     * Controls the scale bias of the parallax mode.\r\n     * @internal\r\n     */\r\n    public _parallaxScaleBias = 0.05;\r\n\r\n    /**\r\n     * If sets to true, disables all the lights affecting the material.\r\n     * @internal\r\n     */\r\n    public _disableLighting = false;\r\n\r\n    /**\r\n     * Number of Simultaneous lights allowed on the material.\r\n     * @internal\r\n     */\r\n    public _maxSimultaneousLights = 4;\r\n\r\n    /**\r\n     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapX = false;\r\n\r\n    /**\r\n     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).\r\n     * @internal\r\n     */\r\n    public _invertNormalMapY = false;\r\n\r\n    /**\r\n     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.\r\n     * @internal\r\n     */\r\n    public _twoSidedLighting = false;\r\n\r\n    /**\r\n     * Defines the alpha limits in alpha test mode.\r\n     * @internal\r\n     */\r\n    public _alphaCutOff = 0.4;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useAlphaFresnel = false;\r\n\r\n    /**\r\n     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.\r\n     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)\r\n     * @internal\r\n     */\r\n    public _useLinearAlphaFresnel = false;\r\n\r\n    /**\r\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\r\n     * from cos theta and roughness:\r\n     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf\r\n     * @internal\r\n     */\r\n    public _environmentBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Specifies the environment BRDF texture used to compute the scale and offset roughness values\r\n     * from cos theta and roughness for the fuzz layer:\r\n     * https://github.com/tizian/ltc-sheen?tab=readme-ov-file\r\n     * @internal\r\n     */\r\n    public _environmentFuzzBRDFTexture: Nullable<BaseTexture> = null;\r\n\r\n    /**\r\n     * Force the shader to compute irradiance in the fragment shader in order to take normal mapping into account.\r\n     * @internal\r\n     */\r\n    public _forceIrradianceInFragment = false;\r\n\r\n    private _realTimeFiltering: boolean = false;\r\n    /**\r\n     * Enables realtime filtering on the texture.\r\n     */\r\n    public get realTimeFiltering() {\r\n        return this._realTimeFiltering;\r\n    }\r\n    public set realTimeFiltering(b: boolean) {\r\n        this._realTimeFiltering = b;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private _realTimeFilteringQuality: number = Constants.TEXTURE_FILTERING_QUALITY_LOW;\r\n    /**\r\n     * Quality switch for realtime filtering\r\n     */\r\n    public get realTimeFilteringQuality(): number {\r\n        return this._realTimeFilteringQuality;\r\n    }\r\n    public set realTimeFilteringQuality(n: number) {\r\n        this._realTimeFilteringQuality = n;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    private _fuzzSampleNumber: number = 4;\r\n\r\n    /**\r\n     * The number of samples used to compute the fuzz IBL lighting.\r\n     */\r\n    public get fuzzSampleNumber(): number {\r\n        return this._fuzzSampleNumber;\r\n    }\r\n    public set fuzzSampleNumber(n: number) {\r\n        this._fuzzSampleNumber = n;\r\n        this.markAsDirty(Constants.MATERIAL_TextureDirtyFlag);\r\n    }\r\n\r\n    /**\r\n     * Can this material render to several textures at once\r\n     */\r\n    public override get canRenderToMRT() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Force normal to face away from face.\r\n     * @internal\r\n     */\r\n    public _forceNormalForward = false;\r\n\r\n    /**\r\n     * Enables specular anti aliasing in the PBR shader.\r\n     * It will both interacts on the Geometry for analytical and IBL lighting.\r\n     * It also prefilter the roughness map based on the normalmap values.\r\n     * @internal\r\n     */\r\n    public _enableSpecularAntiAliasing = false;\r\n\r\n    /**\r\n     * Stores the available render targets.\r\n     */\r\n    private _renderTargets = new SmartArray<RenderTargetTexture>(16);\r\n\r\n    /**\r\n     * If set to true, no lighting calculations will be applied.\r\n     */\r\n    private _unlit = false;\r\n\r\n    /**\r\n     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)\r\n     */\r\n    private _applyDecalMapAfterDetailMap = false;\r\n\r\n    private _debugMode = 0;\r\n\r\n    private _shadersLoaded = false;\r\n    private _breakShaderLoadedCheck = false;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Defines the material debug mode.\r\n     * It helps seeing only some components of the material while troubleshooting.\r\n     */\r\n    @expandToProperty(\"_markAllSubMeshesAsMiscDirty\")\r\n    public debugMode = 0;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * Specify from where on screen the debug mode should start.\r\n     * The value goes from -1 (full screen) to 1 (not visible)\r\n     * It helps with side by side comparison against the final render\r\n     * This defaults to -1\r\n     */\r\n    public debugLimit = -1;\r\n\r\n    /**\r\n     * @internal\r\n     * This is reserved for the inspector.\r\n     * As the default viewing range might not be enough (if the ambient is really small for instance)\r\n     * You can use the factor to better multiply the final value.\r\n     */\r\n    public debugFactor = 1;\r\n\r\n    /**\r\n     * Defines additional PrePass parameters for the material.\r\n     */\r\n    public readonly prePassConfiguration: PrePassConfiguration;\r\n\r\n    protected _cacheHasRenderTargetTextures = false;\r\n\r\n    /**\r\n     * Instantiates a new OpenPBRMaterial instance.\r\n     *\r\n     * @param name The material name\r\n     * @param scene The scene the material will be use in.\r\n     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false\r\n     */\r\n    constructor(name: string, scene?: Scene, forceGLSL = false) {\r\n        super(name, scene, undefined, forceGLSL || OpenPBRMaterial.ForceGLSL);\r\n        // TODO: Check if we're running WebGL 2.0 or above\r\n        if (this.getScene() && !this.getScene()?.getEngine().isWebGPU && (this.getScene().getEngine() as Engine).webGLVersion < 2) {\r\n            Logger.Error(\"OpenPBRMaterial: WebGL 2.0 or above is required for this material.\");\r\n        }\r\n\r\n        if (!OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]) {\r\n            OpenPBRMaterial._noiseTextures[this.getScene().uniqueId] = new Texture(\r\n                \"https://assets.babylonjs.com/textures/blue_noise/blue_noise_rgb.png\",\r\n                this.getScene(),\r\n                false,\r\n                true,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE\r\n            );\r\n            this.getScene().onDisposeObservable.addOnce(() => {\r\n                OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]?.dispose();\r\n                delete OpenPBRMaterial._noiseTextures[this.getScene().uniqueId];\r\n            });\r\n        }\r\n\r\n        // Setup the default processing configuration to the scene.\r\n        this._attachImageProcessingConfiguration(null);\r\n\r\n        this.getRenderTargetTextures = (): SmartArray<RenderTargetTexture> => {\r\n            this._renderTargets.reset();\r\n\r\n            if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {\r\n                this._renderTargets.push(<RenderTargetTexture>this._radianceTexture);\r\n            }\r\n\r\n            this._eventInfo.renderTargets = this._renderTargets;\r\n            this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);\r\n\r\n            return this._renderTargets;\r\n        };\r\n\r\n        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());\r\n        this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());\r\n        this.prePassConfiguration = new PrePassConfiguration();\r\n\r\n        // Build the internal property list that can be used to generate and update the uniform buffer\r\n        this._propertyList = {};\r\n        for (const key of Object.getOwnPropertyNames(this)) {\r\n            const value = (this as any)[key];\r\n            if (value instanceof Property) {\r\n                this._propertyList[key] = value;\r\n            }\r\n        }\r\n        // Build the internal uniforms list that is used for combining and updating\r\n        // property values in the uniform buffer\r\n        const propertyKeys = Object.keys(this._propertyList);\r\n        propertyKeys.forEach((key) => {\r\n            const prop = this._propertyList[key];\r\n            let uniform = this._uniformsList[prop.targetUniformName];\r\n            if (!uniform) {\r\n                uniform = new Uniform(prop.targetUniformName, prop.targetUniformComponentNum);\r\n                this._uniformsList[prop.targetUniformName] = uniform;\r\n            } else if (uniform.numComponents !== prop.targetUniformComponentNum) {\r\n                Logger.Error(`Uniform ${prop.targetUniformName} already exists of size ${uniform.numComponents}, but trying to set it to ${prop.targetUniformComponentNum}.`);\r\n            }\r\n            uniform.linkedProperties[prop.name] = prop;\r\n        });\r\n\r\n        // Build the internal list of samplers\r\n        this._samplersList = {};\r\n        for (const key of Object.getOwnPropertyNames(this)) {\r\n            const value = (this as any)[key];\r\n            if (value instanceof Sampler) {\r\n                this._samplersList[key] = value;\r\n            }\r\n        }\r\n\r\n        // For each sampler in _samplersList, add defines to be added to OpenPBRMaterialDefines\r\n        for (const samplerKey in this._samplersList) {\r\n            const sampler = this._samplersList[samplerKey];\r\n            const defineName = sampler.textureDefine;\r\n            this._samplerDefines[defineName] = { type: \"boolean\", default: false };\r\n            this._samplerDefines[defineName + \"DIRECTUV\"] = { type: \"number\", default: 0 };\r\n            this._samplerDefines[defineName + \"_GAMMA\"] = { type: \"boolean\", default: false };\r\n        }\r\n\r\n        // Arg. Why do I have to add these references to get rid of the linting errors?\r\n        this._baseWeight;\r\n        this._baseWeightTexture;\r\n        this._baseColor;\r\n        this._baseColorTexture;\r\n        this._baseDiffuseRoughness;\r\n        this._baseDiffuseRoughnessTexture;\r\n        this._baseMetalness;\r\n        this._baseMetalnessTexture;\r\n        this._specularWeight;\r\n        this._specularWeightTexture;\r\n        this._specularColor;\r\n        this._specularColorTexture;\r\n        this._specularRoughness;\r\n        this._specularIor;\r\n        this._specularRoughnessTexture;\r\n        this._specularRoughnessAnisotropy;\r\n        this._specularRoughnessAnisotropyTexture;\r\n        this._coatWeight;\r\n        this._coatWeightTexture;\r\n        this._coatColor;\r\n        this._coatColorTexture;\r\n        this._coatRoughness;\r\n        this._coatRoughnessTexture;\r\n        this._coatRoughnessAnisotropy;\r\n        this._coatRoughnessAnisotropyTexture;\r\n        this._coatIor;\r\n        this._coatDarkening;\r\n        this._coatDarkeningTexture;\r\n        this._fuzzWeight;\r\n        this._fuzzWeightTexture;\r\n        this._fuzzColor;\r\n        this._fuzzColorTexture;\r\n        this._fuzzRoughness;\r\n        this._fuzzRoughnessTexture;\r\n        this._geometryNormalTexture;\r\n        this._geometryTangent;\r\n        this._geometryTangentTexture;\r\n        this._geometryCoatNormalTexture;\r\n        this._geometryCoatTangent;\r\n        this._geometryCoatTangentTexture;\r\n        this._geometryOpacity;\r\n        this._geometryOpacityTexture;\r\n        this._thinFilmWeight;\r\n        this._thinFilmWeightTexture;\r\n        this._thinFilmThickness;\r\n        this._thinFilmThicknessMin;\r\n        this._thinFilmThicknessTexture;\r\n        this._thinFilmIor;\r\n        this._emissionLuminance;\r\n        this._emissionColor;\r\n        this._emissionColorTexture;\r\n        this._ambientOcclusionTexture;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that current material needs to register RTT\r\n     */\r\n    public override get hasRenderTargetTextures(): boolean {\r\n        if (MaterialFlags.ReflectionTextureEnabled && this._radianceTexture && this._radianceTexture.isRenderTarget) {\r\n            return true;\r\n        }\r\n\r\n        return this._cacheHasRenderTargetTextures;\r\n    }\r\n\r\n    /**\r\n     * Can this material render to prepass\r\n     */\r\n    public override get isPrePassCapable(): boolean {\r\n        return !this.disableDepthWrite;\r\n    }\r\n\r\n    /**\r\n     * @returns the name of the material class.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"OpenPBRMaterial\";\r\n    }\r\n\r\n    protected override _transparencyMode: number = Material.MATERIAL_OPAQUE;\r\n\r\n    @serialize()\r\n    public override get transparencyMode(): number {\r\n        return this._transparencyMode;\r\n    }\r\n\r\n    public override set transparencyMode(value: number) {\r\n        if (this._transparencyMode === value) {\r\n            return;\r\n        }\r\n\r\n        this._transparencyMode = value;\r\n\r\n        this._markAllSubMeshesAsTexturesAndMiscDirty();\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.\r\n     */\r\n    protected _shouldUseAlphaFromBaseColorTexture(): boolean {\r\n        return this._hasAlphaChannel() && this._transparencyMode !== Material.MATERIAL_OPAQUE && !this.geometryOpacityTexture;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not there is a usable alpha channel for transparency.\r\n     */\r\n    protected _hasAlphaChannel(): boolean {\r\n        return (this.baseColorTexture != null && this.baseColorTexture.hasAlpha && this._useAlphaFromBaseColorTexture) || this.geometryOpacityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * Makes a duplicate of the current material.\r\n     * @param name - name to use for the new material.\r\n     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g baseColor and opacity), only clone it once and reuse it on the other channels. Default false.\r\n     * @param rootUrl defines the root URL to use to load textures\r\n     * @returns cloned material instance\r\n     */\r\n    public override clone(name: string, cloneTexturesOnlyOnce: boolean = true, rootUrl = \"\"): OpenPBRMaterial {\r\n        const clone = SerializationHelper.Clone(() => new OpenPBRMaterial(name, this.getScene()), this, { cloneTexturesOnlyOnce });\r\n\r\n        clone.id = name;\r\n        clone.name = name;\r\n\r\n        this.stencil.copyTo(clone.stencil);\r\n\r\n        this._clonePlugins(clone, rootUrl);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Serializes this PBR Material.\r\n     * @returns - An object with the serialized material.\r\n     */\r\n    public override serialize(): any {\r\n        const serializationObject = super.serialize();\r\n        serializationObject.customType = \"BABYLON.OpenPBRMaterial\";\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Parses a PBR Material from a serialized object.\r\n     * @param source - Serialized object.\r\n     * @param scene - BJS scene instance.\r\n     * @param rootUrl - url for the scene object\r\n     * @returns - OpenPBRMaterial\r\n     */\r\n    public static override Parse(source: any, scene: Scene, rootUrl: string): OpenPBRMaterial {\r\n        const material = SerializationHelper.Parse(() => new OpenPBRMaterial(source.name, scene), source, scene, rootUrl);\r\n\r\n        if (source.stencil) {\r\n            material.stencil.parse(source.stencil, scene, rootUrl);\r\n        }\r\n\r\n        Material._ParsePlugins(source, material, scene, rootUrl);\r\n\r\n        return material;\r\n    }\r\n\r\n    /**\r\n     * Force shader compilation\r\n     * @param mesh - Define the mesh we want to force the compilation for\r\n     * @param onCompiled - Define a callback triggered when the compilation completes\r\n     * @param options - Define the options used to create the compilation\r\n     */\r\n    public override forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void {\r\n        const localOptions = {\r\n            clipPlane: false,\r\n            useInstances: false,\r\n            ...options,\r\n        };\r\n\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n        const checkReady = () => {\r\n            if (this._breakShaderLoadedCheck) {\r\n                return;\r\n            }\r\n\r\n            const defines = new OpenPBRMaterialDefines({\r\n                ...(this._eventInfo.defineNames || {}),\r\n                ...(this._samplerDefines || {}),\r\n            });\r\n            const effect = this._prepareEffect(mesh, mesh, defines, undefined, undefined, localOptions.useInstances, localOptions.clipPlane)!;\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = null;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n            if (effect.isReady()) {\r\n                if (onCompiled) {\r\n                    onCompiled(this);\r\n                }\r\n            } else {\r\n                effect.onCompileObservable.add(() => {\r\n                    if (onCompiled) {\r\n                        onCompiled(this);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        checkReady();\r\n    }\r\n\r\n    /**\r\n     * Specifies that the submesh is ready to be used.\r\n     * @param mesh - BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.\r\n     * @param useInstances - Specifies that instances should be used.\r\n     * @returns - boolean indicating that the submesh is ready or not.\r\n     */\r\n    public override isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean {\r\n        if (!this._uniformBufferLayoutBuilt) {\r\n            this.buildUniformLayout();\r\n        }\r\n\r\n        const drawWrapper = subMesh._drawWrapper;\r\n\r\n        if (drawWrapper.effect && this.isFrozen) {\r\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (!subMesh.materialDefines) {\r\n            this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);\r\n            subMesh.materialDefines = new OpenPBRMaterialDefines({\r\n                ...(this._eventInfo.defineNames || {}),\r\n                ...(this._samplerDefines || {}),\r\n            });\r\n        }\r\n\r\n        const defines = <OpenPBRMaterialDefines>subMesh.materialDefines;\r\n        if (this._isReadyForSubMesh(subMesh)) {\r\n            return true;\r\n        }\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        if (defines._areTexturesDirty) {\r\n            this._eventInfo.hasRenderTargetTextures = false;\r\n            this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);\r\n            this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;\r\n            if (scene.texturesEnabled) {\r\n                // Loop through samplers, check MaterialFlag and whether the texture is ready or not.\r\n                for (const key in this._samplersList) {\r\n                    const sampler = this._samplersList[key];\r\n                    if (sampler.value) {\r\n                        if (!sampler.value.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const radianceTexture = this._getRadianceTexture();\r\n                if (radianceTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    if (!radianceTexture.isReadyOrNotBlocking()) {\r\n                        return false;\r\n                    }\r\n                    if (radianceTexture.irradianceTexture) {\r\n                        if (!radianceTexture.irradianceTexture.isReadyOrNotBlocking()) {\r\n                            return false;\r\n                        }\r\n                    } else {\r\n                        // Not ready until spherical are ready too.\r\n                        if (!radianceTexture.sphericalPolynomial && radianceTexture.getInternalTexture()?._sphericalPolynomialPromise) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    // This is blocking.\r\n                    if (!this._environmentBRDFTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (this._environmentFuzzBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    // This is blocking.\r\n                    if (!this._environmentFuzzBRDFTexture.isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (OpenPBRMaterial._noiseTextures[scene.uniqueId]) {\r\n                    if (!OpenPBRMaterial._noiseTextures[scene.uniqueId].isReady()) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        this._eventInfo.isReadyForSubMesh = true;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\r\n\r\n        if (!this._eventInfo.isReadyForSubMesh) {\r\n            return false;\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            if (!this._imageProcessingConfiguration.isReady()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Check if Area Lights have LTC texture.\r\n        if (defines[\"AREALIGHTUSED\"]) {\r\n            for (let index = 0; index < mesh.lightSources.length; index++) {\r\n                if (!mesh.lightSources[index]._isReady()) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {\r\n            mesh.createNormals(true);\r\n            Logger.Warn(\"OpenPBRMaterial: Normals have been created for the mesh: \" + mesh.name);\r\n        }\r\n\r\n        const previousEffect = subMesh.effect;\r\n        const lightDisposed = defines._areLightsDisposed;\r\n        let effect = this._prepareEffect(mesh, subMesh.getRenderingMesh(), defines, this.onCompiled, this.onError, useInstances, null);\r\n\r\n        let forceWasNotReadyPreviously = false;\r\n\r\n        if (effect) {\r\n            if (this._onEffectCreatedObservable) {\r\n                onCreatedEffectParameters.effect = effect;\r\n                onCreatedEffectParameters.subMesh = subMesh;\r\n                this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);\r\n            }\r\n\r\n            // Use previous effect while new one is compiling\r\n            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {\r\n                effect = previousEffect;\r\n                defines.markAsUnprocessed();\r\n\r\n                forceWasNotReadyPreviously = this.isFrozen;\r\n\r\n                if (lightDisposed) {\r\n                    // re register in case it takes more than one frame.\r\n                    defines._areLightsDisposed = true;\r\n                    return false;\r\n                }\r\n            } else {\r\n                scene.resetCachedMaterial();\r\n                subMesh.setEffect(effect, defines, this._materialContext);\r\n            }\r\n        }\r\n\r\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        defines._renderId = scene.getRenderId();\r\n        drawWrapper._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;\r\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\r\n\r\n        this._checkScenePerformancePriority();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Initializes the uniform buffer layout for the shader.\r\n     */\r\n    public override buildUniformLayout(): void {\r\n        // Order is important !\r\n        const ubo = this._uniformBuffer;\r\n        ubo.addUniform(\"vTangentSpaceParams\", 2);\r\n        ubo.addUniform(\"vLightingIntensity\", 4);\r\n\r\n        ubo.addUniform(\"pointSize\", 1);\r\n\r\n        ubo.addUniform(\"vDebugMode\", 2);\r\n\r\n        ubo.addUniform(\"cameraInfo\", 4);\r\n        PrepareUniformLayoutForIBL(ubo, true, true, true, true, true);\r\n\r\n        Object.values(this._uniformsList).forEach((uniform) => {\r\n            ubo.addUniform(uniform.name, uniform.numComponents);\r\n        });\r\n\r\n        Object.values(this._samplersList).forEach((sampler) => {\r\n            ubo.addUniform(sampler.samplerInfoName, 2);\r\n            ubo.addUniform(sampler.samplerMatrixName, 16);\r\n        });\r\n\r\n        super.buildUniformLayout();\r\n    }\r\n\r\n    /**\r\n     * Binds the submesh data.\r\n     * @param world - The world matrix.\r\n     * @param mesh - The BJS mesh.\r\n     * @param subMesh - A submesh of the BJS mesh.\r\n     */\r\n    public override bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void {\r\n        const scene = this.getScene();\r\n\r\n        const defines = <OpenPBRMaterialDefines>subMesh.materialDefines;\r\n        if (!defines) {\r\n            return;\r\n        }\r\n\r\n        const effect = subMesh.effect;\r\n\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        this._activeEffect = effect;\r\n\r\n        // Matrices Mesh.\r\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\r\n        mesh.transferToEffect(world);\r\n\r\n        const engine = scene.getEngine();\r\n\r\n        // Binding unconditionally\r\n        this._uniformBuffer.bindToEffect(effect, \"Material\");\r\n\r\n        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);\r\n\r\n        MaterialHelperGeometryRendering.Bind(engine.currentRenderPassId, this._activeEffect, mesh, world, this);\r\n\r\n        const camera = scene.activeCamera;\r\n        if (camera) {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", camera.minZ, camera.maxZ, 0, 0);\r\n        } else {\r\n            this._uniformBuffer.updateFloat4(\"cameraInfo\", 0, 0, 0, 0);\r\n        }\r\n\r\n        this._eventInfo.subMesh = subMesh;\r\n        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);\r\n\r\n        // Normal Matrix\r\n        if (defines.OBJECTSPACE_NORMALMAP) {\r\n            world.toNormalMatrix(this._normalMatrix);\r\n            this.bindOnlyNormalMatrix(this._normalMatrix);\r\n        }\r\n\r\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\r\n\r\n        // Bones\r\n        BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);\r\n\r\n        let radianceTexture: Nullable<BaseTexture> = null;\r\n        const ubo = this._uniformBuffer;\r\n        if (mustRebind) {\r\n            this.bindViewProjection(effect);\r\n            radianceTexture = this._getRadianceTexture();\r\n\r\n            if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || subMesh._drawWrapper._forceRebindOnNextCall) {\r\n                // Texture uniforms\r\n                if (scene.texturesEnabled) {\r\n                    // Loop through samplers and bind info and matrix for each texture.\r\n                    for (const key in this._samplersList) {\r\n                        const sampler = this._samplersList[key];\r\n                        if (sampler.value) {\r\n                            ubo.updateFloat2(sampler.samplerInfoName, sampler.value.coordinatesIndex, sampler.value.level);\r\n                            BindTextureMatrix(sampler.value, ubo, sampler.samplerPrefix);\r\n                        }\r\n                    }\r\n\r\n                    if (this.geometryNormalTexture) {\r\n                        if (scene._mirroredCameraPosition) {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? 1.0 : -1.0, this._invertNormalMapY ? 1.0 : -1.0);\r\n                        } else {\r\n                            ubo.updateFloat2(\"vTangentSpaceParams\", this._invertNormalMapX ? -1.0 : 1.0, this._invertNormalMapY ? -1.0 : 1.0);\r\n                        }\r\n                    }\r\n\r\n                    BindIBLParameters(scene, defines, ubo, Color3.White(), radianceTexture, this.realTimeFiltering, true, true, true, true, true);\r\n                }\r\n\r\n                // Point size\r\n                if (this.pointsCloud) {\r\n                    ubo.updateFloat(\"pointSize\", this.pointSize);\r\n                }\r\n\r\n                Object.values(this._uniformsList).forEach((uniform) => {\r\n                    // If the property actually defines a uniform, update it.\r\n                    if (uniform.numComponents === 4) {\r\n                        uniform.populateVectorFromLinkedProperties(TmpVectors.Vector4[0]);\r\n                        ubo.updateVector4(uniform.name, TmpVectors.Vector4[0]);\r\n                    } else if (uniform.numComponents === 3) {\r\n                        uniform.populateVectorFromLinkedProperties(TmpVectors.Vector3[0]);\r\n                        ubo.updateVector3(uniform.name, TmpVectors.Vector3[0]);\r\n                    } else if (uniform.numComponents === 2) {\r\n                        uniform.populateVectorFromLinkedProperties(TmpVectors.Vector2[0]);\r\n                        ubo.updateFloat2(uniform.name, TmpVectors.Vector2[0].x, TmpVectors.Vector2[0].y);\r\n                    } else if (uniform.numComponents === 1) {\r\n                        ubo.updateFloat(uniform.name, uniform.linkedProperties[Object.keys(uniform.linkedProperties)[0]].value as number);\r\n                    }\r\n                });\r\n\r\n                // Misc\r\n                this._lightingInfos.x = this.directIntensity;\r\n                this._lightingInfos.y = this.emissionLuminance;\r\n                this._lightingInfos.z = this.environmentIntensity * scene.environmentIntensity;\r\n                this._lightingInfos.w = 1.0; // This is used to be _specularIntensity.\r\n\r\n                ubo.updateVector4(\"vLightingIntensity\", this._lightingInfos);\r\n\r\n                ubo.updateFloat2(\"vDebugMode\", this.debugLimit, this.debugFactor);\r\n            }\r\n\r\n            // Textures\r\n            if (scene.texturesEnabled) {\r\n                // Loop through samplers and set textures\r\n                for (const key in this._samplersList) {\r\n                    const sampler = this._samplersList[key];\r\n                    if (sampler.value) {\r\n                        ubo.setTexture(sampler.samplerName, sampler.value);\r\n                    }\r\n                }\r\n\r\n                BindIBLSamplers(scene, defines, ubo, radianceTexture, this.realTimeFiltering);\r\n\r\n                if (defines.ENVIRONMENTBRDF) {\r\n                    ubo.setTexture(\"environmentBrdfSampler\", this._environmentBRDFTexture);\r\n                }\r\n\r\n                if (defines.FUZZENVIRONMENTBRDF) {\r\n                    ubo.setTexture(\"environmentFuzzBrdfSampler\", this._environmentFuzzBRDFTexture);\r\n                }\r\n\r\n                if (defines.ANISOTROPIC || defines.FUZZ) {\r\n                    ubo.setTexture(\"blueNoiseSampler\", OpenPBRMaterial._noiseTextures[this.getScene().uniqueId]);\r\n                }\r\n            }\r\n\r\n            // OIT with depth peeling\r\n            if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {\r\n                this.getScene().depthPeelingRenderer!.bind(effect);\r\n            }\r\n\r\n            this._eventInfo.subMesh = subMesh;\r\n            this._callbackPluginEventBindForSubMesh(this._eventInfo);\r\n\r\n            // Clip plane\r\n            BindClipPlane(this._activeEffect, this, scene);\r\n\r\n            this.bindEyePosition(effect);\r\n        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\r\n            this._needToBindSceneUbo = true;\r\n        }\r\n\r\n        if (mustRebind || !this.isFrozen) {\r\n            // Lights\r\n            if (scene.lightsEnabled && !this._disableLighting) {\r\n                BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);\r\n            }\r\n\r\n            // View\r\n            if ((scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) || radianceTexture || mesh.receiveShadows || defines.PREPASS) {\r\n                this.bindView(effect);\r\n            }\r\n\r\n            // Fog\r\n            BindFogParameters(scene, mesh, this._activeEffect, true);\r\n\r\n            // Morph targets\r\n            if (defines.NUM_MORPH_INFLUENCERS) {\r\n                BindMorphTargetParameters(mesh, this._activeEffect);\r\n            }\r\n\r\n            if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {\r\n                mesh.bakedVertexAnimationManager?.bind(effect, defines.INSTANCES);\r\n            }\r\n\r\n            // image processing\r\n            this._imageProcessingConfiguration.bind(this._activeEffect);\r\n\r\n            // Log. depth\r\n            BindLogDepth(defines, this._activeEffect, scene);\r\n        }\r\n\r\n        this._afterBind(mesh, this._activeEffect, subMesh);\r\n\r\n        ubo.update();\r\n    }\r\n\r\n    /**\r\n     * Returns the animatable textures.\r\n     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.\r\n     * @returns - Array of animatable textures.\r\n     */\r\n    public override getAnimatables(): IAnimatable[] {\r\n        const results = super.getAnimatables();\r\n\r\n        // Loop through samplers and push animated textures to list.\r\n        for (const key in this._samplersList) {\r\n            const sampler = this._samplersList[key];\r\n            if (sampler.value && sampler.value.animations && sampler.value.animations.length > 0) {\r\n                results.push(sampler.value);\r\n            }\r\n        }\r\n\r\n        if (this._radianceTexture && this._radianceTexture.animations && this._radianceTexture.animations.length > 0) {\r\n            results.push(this._radianceTexture);\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of the actively used textures.\r\n     * @returns - Array of BaseTextures\r\n     */\r\n    public override getActiveTextures(): BaseTexture[] {\r\n        const activeTextures = super.getActiveTextures();\r\n\r\n        // Loop through samplers and push active textures\r\n        for (const key in this._samplersList) {\r\n            const sampler = this._samplersList[key];\r\n            if (sampler.value) {\r\n                activeTextures.push(sampler.value);\r\n            }\r\n        }\r\n\r\n        if (this._radianceTexture) {\r\n            activeTextures.push(this._radianceTexture);\r\n        }\r\n\r\n        return activeTextures;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if a texture is used in the material.\r\n     * @param texture - Base texture to use.\r\n     * @returns - Boolean specifying if a texture is used in the material.\r\n     */\r\n    public override hasTexture(texture: BaseTexture): boolean {\r\n        if (super.hasTexture(texture)) {\r\n            return true;\r\n        }\r\n\r\n        // Loop through samplers and check each texture for equality\r\n        for (const key in this._samplersList) {\r\n            const sampler = this._samplersList[key];\r\n            if (sampler.value === texture) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (this._radianceTexture === texture) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the required values to the prepass renderer.\r\n     * It can't be sets when subsurface scattering of this material is disabled.\r\n     * When scene have ability to enable subsurface prepass effect, it will enable.\r\n     * @returns - If prepass is enabled or not.\r\n     */\r\n    public override setPrePassRenderer(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Disposes the resources of the material.\r\n     * @param forceDisposeEffect - Forces the disposal of effects.\r\n     * @param forceDisposeTextures - Forces the disposal of all textures.\r\n     */\r\n    public override dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void {\r\n        this._breakShaderLoadedCheck = true;\r\n        if (forceDisposeTextures) {\r\n            if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {\r\n                this._environmentBRDFTexture.dispose();\r\n            }\r\n            if (this._environmentFuzzBRDFTexture && this.getScene().environmentFuzzBRDFTexture !== this._environmentFuzzBRDFTexture) {\r\n                this._environmentFuzzBRDFTexture.dispose();\r\n            }\r\n\r\n            // Loop through samplers and dispose the textures\r\n            for (const key in this._samplersList) {\r\n                const sampler = this._samplersList[key];\r\n                sampler.value?.dispose();\r\n            }\r\n\r\n            this._radianceTexture?.dispose();\r\n        }\r\n\r\n        this._renderTargets.dispose();\r\n\r\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\r\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\r\n        }\r\n\r\n        super.dispose(forceDisposeEffect, forceDisposeTextures);\r\n    }\r\n\r\n    /**\r\n     * Returns the texture used for reflections.\r\n     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.\r\n     */\r\n    private _getRadianceTexture(): Nullable<BaseTexture> {\r\n        if (this._radianceTexture) {\r\n            return this._radianceTexture;\r\n        }\r\n\r\n        return this.getScene().environmentTexture;\r\n    }\r\n\r\n    private _prepareEffect(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: OpenPBRMaterialDefines,\r\n        onCompiled: Nullable<(effect: Effect) => void> = null,\r\n        onError: Nullable<(effect: Effect, errors: string) => void> = null,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): Nullable<Effect> {\r\n        this._prepareDefines(mesh, renderingMesh, defines, useInstances, useClipPlane);\r\n\r\n        if (!defines.isDirty) {\r\n            return null;\r\n        }\r\n\r\n        defines.markAsProcessed();\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Fallbacks\r\n        const fallbacks = new EffectFallbacks();\r\n        let fallbackRank = 0;\r\n        if (defines.USESPHERICALINVERTEX) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALINVERTEX\");\r\n        }\r\n\r\n        if (defines.FOG) {\r\n            fallbacks.addFallback(fallbackRank, \"FOG\");\r\n        }\r\n        if (defines.SPECULARAA) {\r\n            fallbacks.addFallback(fallbackRank, \"SPECULARAA\");\r\n        }\r\n        if (defines.POINTSIZE) {\r\n            fallbacks.addFallback(fallbackRank, \"POINTSIZE\");\r\n        }\r\n        if (defines.LOGARITHMICDEPTH) {\r\n            fallbacks.addFallback(fallbackRank, \"LOGARITHMICDEPTH\");\r\n        }\r\n        if (defines.PARALLAX) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX\");\r\n        }\r\n        if (defines.PARALLAX_RHS) {\r\n            fallbacks.addFallback(fallbackRank, \"PARALLAX_RHS\");\r\n        }\r\n        if (defines.PARALLAXOCCLUSION) {\r\n            fallbacks.addFallback(fallbackRank++, \"PARALLAXOCCLUSION\");\r\n        }\r\n\r\n        if (defines.ENVIRONMENTBRDF) {\r\n            fallbacks.addFallback(fallbackRank++, \"ENVIRONMENTBRDF\");\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            fallbacks.addFallback(fallbackRank++, \"TANGENT\");\r\n        }\r\n\r\n        fallbackRank = HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);\r\n\r\n        if (defines.SPECULARTERM) {\r\n            fallbacks.addFallback(fallbackRank++, \"SPECULARTERM\");\r\n        }\r\n\r\n        if (defines.USESPHERICALFROMREFLECTIONMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USESPHERICALFROMREFLECTIONMAP\");\r\n        }\r\n\r\n        if (defines.USEIRRADIANCEMAP) {\r\n            fallbacks.addFallback(fallbackRank++, \"USEIRRADIANCEMAP\");\r\n        }\r\n\r\n        if (defines.NORMAL) {\r\n            fallbacks.addFallback(fallbackRank++, \"NORMAL\");\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            fallbacks.addFallback(fallbackRank++, \"VERTEXCOLOR\");\r\n        }\r\n\r\n        if (defines.MORPHTARGETS) {\r\n            fallbacks.addFallback(fallbackRank++, \"MORPHTARGETS\");\r\n        }\r\n\r\n        if (defines.MULTIVIEW) {\r\n            fallbacks.addFallback(0, \"MULTIVIEW\");\r\n        }\r\n\r\n        //Attributes\r\n        const attribs = [VertexBuffer.PositionKind];\r\n\r\n        if (defines.NORMAL) {\r\n            attribs.push(VertexBuffer.NormalKind);\r\n        }\r\n\r\n        if (defines.TANGENT) {\r\n            attribs.push(VertexBuffer.TangentKind);\r\n        }\r\n\r\n        for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n            if (defines[\"UV\" + i]) {\r\n                attribs.push(`uv${i === 1 ? \"\" : i}`);\r\n            }\r\n        }\r\n\r\n        if (defines.VERTEXCOLOR) {\r\n            attribs.push(VertexBuffer.ColorKind);\r\n        }\r\n\r\n        PrepareAttributesForBones(attribs, mesh, defines, fallbacks);\r\n        PrepareAttributesForInstances(attribs, defines);\r\n        PrepareAttributesForMorphTargets(attribs, mesh, defines);\r\n        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\r\n\r\n        let shaderName = \"openpbr\";\r\n\r\n        const uniforms = [\r\n            \"world\",\r\n            \"view\",\r\n            \"viewProjection\",\r\n            \"vEyePosition\",\r\n            \"vLightsType\",\r\n            \"visibility\",\r\n            \"vFogInfos\",\r\n            \"vFogColor\",\r\n            \"pointSize\",\r\n            \"mBones\",\r\n            \"normalMatrix\",\r\n            \"vLightingIntensity\",\r\n            \"logarithmicDepthConstant\",\r\n            \"vTangentSpaceParams\",\r\n            \"boneTextureWidth\",\r\n            \"vDebugMode\",\r\n            \"morphTargetTextureInfo\",\r\n            \"morphTargetTextureIndices\",\r\n            \"cameraInfo\",\r\n        ];\r\n\r\n        for (const uniformName in this._uniformsList) {\r\n            uniforms.push(uniformName);\r\n        }\r\n\r\n        const samplers = [\r\n            \"environmentBrdfSampler\",\r\n            \"blueNoiseSampler\",\r\n            \"boneSampler\",\r\n            \"morphTargets\",\r\n            \"oitDepthSampler\",\r\n            \"oitFrontColorSampler\",\r\n            \"areaLightsLTC1Sampler\",\r\n            \"areaLightsLTC2Sampler\",\r\n        ];\r\n\r\n        if (defines.FUZZENVIRONMENTBRDF) {\r\n            samplers.push(\"environmentFuzzBrdfSampler\");\r\n        }\r\n\r\n        for (const key in this._samplersList) {\r\n            const sampler = this._samplersList[key];\r\n            samplers.push(sampler.samplerName);\r\n\r\n            // Push uniforms for texture infos and matrix\r\n            uniforms.push(sampler.samplerInfoName);\r\n            uniforms.push(sampler.samplerMatrixName);\r\n        }\r\n\r\n        PrepareUniformsAndSamplersForIBL(uniforms, samplers, true);\r\n\r\n        const uniformBuffers = [\"Material\", \"Scene\", \"Mesh\"];\r\n\r\n        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };\r\n\r\n        this._eventInfo.fallbacks = fallbacks;\r\n        this._eventInfo.fallbackRank = fallbackRank;\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.uniforms = uniforms;\r\n        this._eventInfo.attributes = attribs;\r\n        this._eventInfo.samplers = samplers;\r\n        this._eventInfo.uniformBuffersNames = uniformBuffers;\r\n        this._eventInfo.customCode = undefined;\r\n        this._eventInfo.mesh = mesh;\r\n        this._eventInfo.indexParameters = indexParameters;\r\n        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);\r\n\r\n        MaterialHelperGeometryRendering.AddUniformsAndSamplers(uniforms, samplers);\r\n\r\n        PrePassConfiguration.AddUniforms(uniforms);\r\n        PrePassConfiguration.AddSamplers(samplers);\r\n        AddClipPlaneUniforms(uniforms);\r\n\r\n        if (ImageProcessingConfiguration) {\r\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);\r\n            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);\r\n        }\r\n\r\n        PrepareUniformsAndSamplersList(<IEffectCreationOptions>{\r\n            uniformsNames: uniforms,\r\n            uniformBuffersNames: uniformBuffers,\r\n            samplers: samplers,\r\n            defines: defines,\r\n            maxSimultaneousLights: this._maxSimultaneousLights,\r\n        });\r\n\r\n        const csnrOptions: ICustomShaderNameResolveOptions = {};\r\n\r\n        if (this.customShaderNameResolve) {\r\n            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);\r\n        }\r\n\r\n        const join = defines.toString();\r\n        const effect = engine.createEffect(\r\n            shaderName,\r\n            <IEffectCreationOptions>{\r\n                attributes: attribs,\r\n                uniformsNames: uniforms,\r\n                uniformBuffersNames: uniformBuffers,\r\n                samplers: samplers,\r\n                defines: join,\r\n                fallbacks: fallbacks,\r\n                onCompiled: onCompiled,\r\n                onError: onError,\r\n                indexParameters,\r\n                processFinalCode: csnrOptions.processFinalCode,\r\n                processCodeAfterIncludes: this._eventInfo.customCode,\r\n                multiTarget: defines.PREPASS,\r\n                shaderLanguage: this._shaderLanguage,\r\n                extraInitializationsAsync: this._shadersLoaded\r\n                    ? undefined\r\n                    : async () => {\r\n                          if (this.shaderLanguage === ShaderLanguage.WGSL) {\r\n                              await Promise.all([import(\"../../ShadersWGSL/openpbr.vertex\"), import(\"../../ShadersWGSL/openpbr.fragment\")]);\r\n                          } else {\r\n                              await Promise.all([import(\"../../Shaders/openpbr.vertex\"), import(\"../../Shaders/openpbr.fragment\")]);\r\n                          }\r\n\r\n                          this._shadersLoaded = true;\r\n                      },\r\n            },\r\n            engine\r\n        );\r\n\r\n        this._eventInfo.customCode = undefined;\r\n\r\n        return effect;\r\n    }\r\n\r\n    private _prepareDefines(\r\n        mesh: AbstractMesh,\r\n        renderingMesh: AbstractMesh,\r\n        defines: OpenPBRMaterialDefines,\r\n        useInstances: Nullable<boolean> = null,\r\n        useClipPlane: Nullable<boolean> = null\r\n    ): void {\r\n        const useThinInstances = renderingMesh.hasThinInstances;\r\n\r\n        const scene = this.getScene();\r\n        const engine = scene.getEngine();\r\n\r\n        // Lights\r\n        PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);\r\n        defines._needNormals = true;\r\n\r\n        // Multiview\r\n        PrepareDefinesForMultiview(scene, defines);\r\n\r\n        // PrePass\r\n        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;\r\n        PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);\r\n\r\n        // Order independant transparency\r\n        PrepareDefinesForOIT(scene, defines, oit);\r\n\r\n        MaterialHelperGeometryRendering.PrepareDefines(engine.currentRenderPassId, mesh, defines);\r\n\r\n        // Textures\r\n        defines.METALLICWORKFLOW = true;\r\n        if (defines._areTexturesDirty) {\r\n            defines._needUVs = false;\r\n            for (let i = 1; i <= Constants.MAX_SUPPORTED_UV_SETS; ++i) {\r\n                defines[\"MAINUV\" + i] = false;\r\n            }\r\n            if (scene.texturesEnabled) {\r\n                // Loop through samplers and prepare defines for each texture\r\n                for (const key in this._samplersList) {\r\n                    const sampler = this._samplersList[key];\r\n                    if (sampler.value) {\r\n                        PrepareDefinesForMergedUV(sampler.value, defines, sampler.textureDefine);\r\n                        defines[sampler.textureDefine + \"_GAMMA\"] = sampler.value.gammaSpace;\r\n                    } else {\r\n                        defines[sampler.textureDefine] = false;\r\n                    }\r\n                }\r\n\r\n                const radianceTexture = this._getRadianceTexture();\r\n                const useSHInFragment: boolean =\r\n                    this._forceIrradianceInFragment ||\r\n                    this.realTimeFiltering ||\r\n                    this._twoSidedLighting ||\r\n                    engine.getCaps().maxVaryingVectors <= 8 ||\r\n                    this._baseDiffuseRoughnessTexture != null;\r\n                PrepareDefinesForIBL(scene, radianceTexture, defines, this.realTimeFiltering, this.realTimeFilteringQuality, !useSHInFragment);\r\n\r\n                if (this._baseMetalnessTexture) {\r\n                    defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;\r\n                }\r\n\r\n                defines.SPECULAR_WEIGHT_IN_ALPHA = this._useSpecularWeightFromAlpha;\r\n                defines.SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE = this._useSpecularWeightFromSpecularColorTexture;\r\n                defines.SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useSpecularRoughnessAnisotropyFromTangentTexture;\r\n                defines.COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE = this._useCoatRoughnessAnisotropyFromTangentTexture;\r\n                defines.ROUGHNESSSTOREINMETALMAPGREEN = this._useRoughnessFromMetallicTextureGreen;\r\n                defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallicFromMetallicTextureBlue;\r\n                defines.THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE = this._useThinFilmThicknessFromTextureGreen;\r\n\r\n                if (this.geometryNormalTexture) {\r\n                    if (this._useParallax && this.baseColorTexture && MaterialFlags.DiffuseTextureEnabled) {\r\n                        defines.PARALLAX = true;\r\n                        defines.PARALLAX_RHS = scene.useRightHandedSystem;\r\n                        defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;\r\n                    } else {\r\n                        defines.PARALLAX = false;\r\n                    }\r\n                    defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;\r\n                } else {\r\n                    defines.PARALLAX = false;\r\n                    defines.PARALLAX_RHS = false;\r\n                    defines.PARALLAXOCCLUSION = false;\r\n                    defines.OBJECTSPACE_NORMALMAP = false;\r\n                }\r\n\r\n                if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {\r\n                    defines.ENVIRONMENTBRDF = true;\r\n                    defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;\r\n                } else {\r\n                    defines.ENVIRONMENTBRDF = false;\r\n                    defines.ENVIRONMENTBRDF_RGBD = false;\r\n                }\r\n\r\n                if (this._environmentFuzzBRDFTexture) {\r\n                    defines.FUZZENVIRONMENTBRDF = true;\r\n                } else {\r\n                    defines.FUZZENVIRONMENTBRDF = false;\r\n                }\r\n\r\n                if (this._shouldUseAlphaFromBaseColorTexture()) {\r\n                    defines.ALPHA_FROM_BASE_COLOR_TEXTURE = true;\r\n                } else {\r\n                    defines.ALPHA_FROM_BASE_COLOR_TEXTURE = false;\r\n                }\r\n            }\r\n\r\n            if (this._lightFalloff === Material.LIGHTFALLOFF_STANDARD) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            } else if (this._lightFalloff === Material.LIGHTFALLOFF_GLTF) {\r\n                defines.USEPHYSICALLIGHTFALLOFF = false;\r\n                defines.USEGLTFLIGHTFALLOFF = true;\r\n            } else {\r\n                defines.USEPHYSICALLIGHTFALLOFF = true;\r\n                defines.USEGLTFLIGHTFALLOFF = false;\r\n            }\r\n\r\n            if (!this.backFaceCulling && this._twoSidedLighting) {\r\n                defines.TWOSIDEDLIGHTING = true;\r\n            } else {\r\n                defines.TWOSIDEDLIGHTING = false;\r\n            }\r\n\r\n            // We need it to not invert normals in two sided lighting mode (based on the winding of the face)\r\n            defines.MIRRORED = !!scene._mirroredCameraPosition;\r\n\r\n            defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;\r\n        }\r\n\r\n        if (defines._areTexturesDirty || defines._areMiscDirty) {\r\n            defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? \".\" : \"\"}`;\r\n            defines.PREMULTIPLYALPHA = this.alphaMode === Constants.ALPHA_PREMULTIPLIED || this.alphaMode === Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;\r\n            defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);\r\n        }\r\n\r\n        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {\r\n            this._imageProcessingConfiguration.prepareDefines(defines);\r\n        }\r\n\r\n        defines.FORCENORMALFORWARD = this._forceNormalForward;\r\n\r\n        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;\r\n\r\n        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;\r\n\r\n        if (\r\n            (this.specularRoughnessAnisotropy > 0.0 || this.coatRoughnessAnisotropy > 0.0) &&\r\n            OpenPBRMaterial._noiseTextures[scene.uniqueId] &&\r\n            MaterialFlags.ReflectionTextureEnabled\r\n        ) {\r\n            // ANISOTROPIC is used to include common shader functions needed for anisotropy\r\n            // ANISOTROPIC_BASE is used to process anisotropy for the base layer\r\n            // ANISOTROPIC_COAT is used to process anisotropy for the coat layer\r\n            defines.ANISOTROPIC = true;\r\n            if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n            if (this._useGltfStyleAnisotropy) {\r\n                defines.USE_GLTF_STYLE_ANISOTROPY = true;\r\n            }\r\n            defines.ANISOTROPIC_BASE = this.specularRoughnessAnisotropy > 0.0;\r\n            defines.ANISOTROPIC_COAT = this.coatRoughnessAnisotropy > 0.0;\r\n        } else {\r\n            defines.ANISOTROPIC = false;\r\n            defines.USE_GLTF_STYLE_ANISOTROPY = false;\r\n            defines.ANISOTROPIC_BASE = false;\r\n            defines.ANISOTROPIC_COAT = false;\r\n        }\r\n\r\n        defines.THIN_FILM = this.thinFilmWeight > 0.0;\r\n        defines.IRIDESCENCE = this.thinFilmWeight > 0.0;\r\n\r\n        defines.FUZZ = this.fuzzWeight > 0 && MaterialFlags.ReflectionTextureEnabled;\r\n        if (defines.FUZZ) {\r\n            if (!mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {\r\n                defines._needUVs = true;\r\n                defines.MAINUV1 = true;\r\n            }\r\n            this._environmentFuzzBRDFTexture = GetEnvironmentFuzzBRDFTexture(this.getScene());\r\n            defines.FUZZ_IBL_SAMPLES = this.fuzzSampleNumber;\r\n        } else {\r\n            this._environmentFuzzBRDFTexture = null;\r\n            defines.FUZZENVIRONMENTBRDF = false;\r\n            defines.FUZZ_IBL_SAMPLES = 0;\r\n        }\r\n\r\n        // Misc.\r\n        if (defines._areMiscDirty) {\r\n            PrepareDefinesForMisc(\r\n                mesh,\r\n                scene,\r\n                this._useLogarithmicDepth,\r\n                this.pointsCloud,\r\n                this.fogEnabled,\r\n                this.needAlphaTestingForMesh(mesh),\r\n                defines,\r\n                this._applyDecalMapAfterDetailMap,\r\n                this._useVertexPulling,\r\n                renderingMesh,\r\n                this._isVertexOutputInvariant\r\n            );\r\n            defines.UNLIT = this._unlit || ((this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind));\r\n            defines.DEBUGMODE = this._debugMode;\r\n        }\r\n\r\n        // Values that need to be evaluated on every frame\r\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);\r\n\r\n        // External config\r\n        this._eventInfo.defines = defines;\r\n        this._eventInfo.mesh = mesh;\r\n        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);\r\n\r\n        // Attribs\r\n        PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== Material.MATERIAL_OPAQUE);\r\n\r\n        // External config\r\n        this._callbackPluginEventPrepareDefines(this._eventInfo);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.OpenPBRMaterial\", OpenPBRMaterial);\r\n"],
  "mappings": "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",
  "names": []
}
