import {
  DracoCodec,
  EncodeMesh,
  EncoderWorkerFunction,
  RawTexture,
  _IsConfigurationAvailable,
  deepMerge
} from "./chunk-ZLQLNLFU.js";
import {
  InstancedMesh
} from "./chunk-WXTV6JAP.js";
import {
  ShaderMaterial
} from "./chunk-TFXAMCS6.js";
import {
  Mesh,
  TransformNode,
  VertexData
} from "./chunk-QTWJPCZG.js";
import {
  MaterialPluginBase
} from "./chunk-GFGXOKMX.js";
import {
  Material,
  MaterialDefines
} from "./chunk-PRSXSHZ4.js";
import {
  SceneComponentConstants
} from "./chunk-DJTOTRI3.js";
import {
  Engine,
  RenderTargetTexture
} from "./chunk-X4TNHLCS.js";
import {
  Curve3,
  Path2
} from "./chunk-LQWTLKWG.js";
import {
  Texture,
  useOpenGLOrientationForUV
} from "./chunk-IKA6V2KA.js";
import {
  __decorate,
  serialize
} from "./chunk-URVCX2UN.js";
import {
  Color3,
  Color4
} from "./chunk-5HS37WJT.js";
import {
  TmpVectors,
  Vector2,
  Vector3,
  Vector4
} from "./chunk-EURVBQY7.js";
import {
  Epsilon
} from "./chunk-JKI5MLKH.js";
import {
  DrawWrapper
} from "./chunk-SMWNVZJL.js";
import {
  AreIndices32Bits,
  Buffer,
  GetTypedArrayData,
  VertexBuffer
} from "./chunk-LAFJMI44.js";
import {
  DeepCopier,
  Tools
} from "./chunk-LNRVDUKV.js";
import {
  RegisterClass
} from "./chunk-S7NDMBDF.js";
import {
  TextureSampler
} from "./chunk-OF4ZSZ6U.js";
import {
  EngineStore
} from "./chunk-ZVW3KNNR.js";
import {
  Observable
} from "./chunk-2YUEJ7I2.js";
import {
  Logger
} from "./chunk-J4DZ2XK7.js";

// node_modules/@babylonjs/core/Meshes/linesMesh.js
Mesh._LinesMeshParser = (parsedMesh, scene) => {
  return LinesMesh.Parse(parsedMesh, scene);
};
var LinesMesh = class _LinesMesh extends Mesh {
  _isShaderMaterial(shader) {
    if (!shader) {
      return false;
    }
    return shader.getClassName() === "ShaderMaterial";
  }
  /**
   * Creates a new LinesMesh
   * @param name defines the name
   * @param scene defines the hosting scene
   * @param parent defines the parent mesh if any
   * @param source defines the optional source LinesMesh used to clone data from
   * @param doNotCloneChildren When cloning, skip cloning child meshes of source, default False.
   * When false, achieved by calling a clone(), also passing False.
   * This will make creation of children, recursive.
   * @param useVertexColor defines if this LinesMesh supports vertex color
   * @param useVertexAlpha defines if this LinesMesh supports vertex alpha
   * @param material material to use to draw the line. If not provided, will create a new one
   */
  constructor(name, scene = null, parent = null, source = null, doNotCloneChildren, useVertexColor, useVertexAlpha, material) {
    super(name, scene, parent, source, doNotCloneChildren);
    this.useVertexColor = useVertexColor;
    this.useVertexAlpha = useVertexAlpha;
    this.color = new Color3(1, 1, 1);
    this.alpha = 1;
    this._shaderLanguage = 0;
    this._ownsMaterial = false;
    if (source) {
      this.color = source.color.clone();
      this.alpha = source.alpha;
      this.useVertexColor = source.useVertexColor;
      this.useVertexAlpha = source.useVertexAlpha;
    }
    this.intersectionThreshold = 0.1;
    const defines = [];
    const options = {
      attributes: [VertexBuffer.PositionKind],
      uniforms: ["world", "viewProjection"],
      needAlphaBlending: true,
      defines,
      useClipPlane: null,
      shaderLanguage: 0
    };
    if (!this.useVertexAlpha) {
      options.needAlphaBlending = false;
    } else {
      options.defines.push("#define VERTEXALPHA");
    }
    if (!this.useVertexColor) {
      options.uniforms.push("color");
      this._color4 = new Color4();
    } else {
      options.defines.push("#define VERTEXCOLOR");
      options.attributes.push(VertexBuffer.ColorKind);
    }
    if (material) {
      this.material = material;
    } else {
      const engine = this.getScene().getEngine();
      if (engine.isWebGPU && !_LinesMesh.ForceGLSL) {
        this._shaderLanguage = 1;
      }
      options.shaderLanguage = this._shaderLanguage;
      options.extraInitializationsAsync = async () => {
        if (this._shaderLanguage === 1) {
          await Promise.all([import("./color.vertex-LAEBUQI5.js"), import("./color.fragment-UHQDYUIX.js")]);
        } else {
          await Promise.all([import("./color.vertex-VTKEFPIS.js"), import("./color.fragment-7CIAWBWD.js")]);
        }
      };
      const material2 = new ShaderMaterial("colorShader", this.getScene(), "color", options, false);
      material2.doNotSerialize = true;
      this._ownsMaterial = true;
      this._setInternalMaterial(material2);
    }
  }
  /**
   * @returns the string "LineMesh"
   */
  getClassName() {
    return "LinesMesh";
  }
  /**
   * @internal
   */
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  /**
   * @internal
   */
  set material(value) {
    const currentMaterial = this.material;
    if (currentMaterial === value) {
      return;
    }
    const shouldDispose = currentMaterial && this._ownsMaterial;
    this._ownsMaterial = false;
    this._setInternalMaterial(value);
    if (shouldDispose) {
      currentMaterial?.dispose();
    }
  }
  _setInternalMaterial(material) {
    this._setMaterial(material);
    if (this.material) {
      this.material.fillMode = Material.LineListDrawMode;
      this.material.disableLighting = true;
    }
  }
  /**
   * @internal
   */
  get checkCollisions() {
    return false;
  }
  set checkCollisions(value) {
  }
  /**
   * @internal
   */
  _bind(_subMesh, colorEffect) {
    if (!this._geometry) {
      return this;
    }
    const indexToBind = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(colorEffect, indexToBind);
    } else {
      this._geometry._bind(colorEffect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    if (!this.useVertexColor && this._isShaderMaterial(this.material)) {
      const { r, g, b } = this.color;
      this._color4.set(r, g, b, this.alpha);
      this.material.setColor4("color", this._color4);
    }
    return this;
  }
  /**
   * @internal
   */
  _draw(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    const engine = this.getScene().getEngine();
    if (this._unIndexed) {
      engine.drawArraysType(Material.LineListDrawMode, subMesh.verticesStart, subMesh.verticesCount, instancesCount);
    } else {
      engine.drawElementsType(Material.LineListDrawMode, subMesh.indexStart, subMesh.indexCount, instancesCount);
    }
    return this;
  }
  /**
   * Disposes of the line mesh (this disposes of the automatically created material if not instructed otherwise).
   * @param doNotRecurse If children should be disposed
   * @param disposeMaterialAndTextures This parameter is used to force disposing the material in case it is not the default one
   * @param doNotDisposeMaterial If the material should not be disposed (default: false, meaning the material might be disposed)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false, doNotDisposeMaterial) {
    if (!doNotDisposeMaterial) {
      if (this._ownsMaterial) {
        this.material?.dispose(false, false, true);
      } else if (disposeMaterialAndTextures) {
        this.material?.dispose(false, false, true);
      }
    }
    super.dispose(doNotRecurse);
  }
  /**
   * Returns a new LineMesh object cloned from the current one.
   * @param name defines the cloned mesh name
   * @param newParent defines the new mesh parent
   * @param doNotCloneChildren if set to true, none of the mesh children are cloned (false by default)
   * @returns the new mesh
   */
  clone(name, newParent = null, doNotCloneChildren) {
    if (newParent && newParent._addToSceneRootNodes === void 0) {
      const createOptions = newParent;
      createOptions.source = this;
      return new _LinesMesh(name, this.getScene(), createOptions.parent, createOptions.source, createOptions.doNotCloneChildren);
    }
    return new _LinesMesh(name, this.getScene(), newParent, this, doNotCloneChildren);
  }
  /**
   * Creates a new InstancedLinesMesh object from the mesh model.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/copies/instances
   * @param name defines the name of the new instance
   * @returns a new InstancedLinesMesh
   */
  createInstance(name) {
    const instance = new InstancedLinesMesh(name, this);
    if (this.instancedBuffers) {
      instance.instancedBuffers = {};
      for (const key in this.instancedBuffers) {
        instance.instancedBuffers[key] = this.instancedBuffers[key];
      }
    }
    return instance;
  }
  /**
   * Serializes this ground mesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.color = this.color.asArray();
    serializationObject.alpha = this.alpha;
  }
  /**
   * Parses a serialized ground mesh
   * @param parsedMesh the serialized mesh
   * @param scene the scene to create the ground mesh in
   * @returns the created ground mesh
   */
  static Parse(parsedMesh, scene) {
    const result = new _LinesMesh(parsedMesh.name, scene);
    result.color = Color3.FromArray(parsedMesh.color);
    result.alpha = parsedMesh.alpha;
    return result;
  }
};
LinesMesh.ForceGLSL = false;
var InstancedLinesMesh = class extends InstancedMesh {
  constructor(name, source) {
    super(name, source);
    this.intersectionThreshold = source.intersectionThreshold;
  }
  /**
   * @returns the string "InstancedLinesMesh".
   */
  getClassName() {
    return "InstancedLinesMesh";
  }
};

// node_modules/@babylonjs/core/Meshes/polygonMesh.js
var IndexedVector2 = class extends Vector2 {
  constructor(original, index) {
    super(original.x, original.y);
    this.index = index;
  }
};
var PolygonPoints = class {
  constructor() {
    this.elements = [];
  }
  add(originalPoints) {
    const result = [];
    for (const point of originalPoints) {
      const newPoint = new IndexedVector2(point, this.elements.length);
      result.push(newPoint);
      this.elements.push(newPoint);
    }
    return result;
  }
  computeBounds() {
    const lmin = new Vector2(this.elements[0].x, this.elements[0].y);
    const lmax = new Vector2(this.elements[0].x, this.elements[0].y);
    for (const point of this.elements) {
      if (point.x < lmin.x) {
        lmin.x = point.x;
      } else if (point.x > lmax.x) {
        lmax.x = point.x;
      }
      if (point.y < lmin.y) {
        lmin.y = point.y;
      } else if (point.y > lmax.y) {
        lmax.y = point.y;
      }
    }
    return {
      min: lmin,
      max: lmax,
      width: lmax.x - lmin.x,
      height: lmax.y - lmin.y
    };
  }
};
var Polygon = class {
  /**
   * Creates a rectangle
   * @param xmin bottom X coord
   * @param ymin bottom Y coord
   * @param xmax top X coord
   * @param ymax top Y coord
   * @returns points that make the resulting rectangle
   */
  static Rectangle(xmin, ymin, xmax, ymax) {
    return [new Vector2(xmin, ymin), new Vector2(xmax, ymin), new Vector2(xmax, ymax), new Vector2(xmin, ymax)];
  }
  /**
   * Creates a circle
   * @param radius radius of circle
   * @param cx scale in x
   * @param cy scale in y
   * @param numberOfSides number of sides that make up the circle
   * @returns points that make the resulting circle
   */
  static Circle(radius, cx = 0, cy = 0, numberOfSides = 32) {
    const result = [];
    let angle = 0;
    const increment = Math.PI * 2 / numberOfSides;
    for (let i = 0; i < numberOfSides; i++) {
      result.push(new Vector2(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius));
      angle -= increment;
    }
    return result;
  }
  /**
   * Creates a polygon from input string
   * @param input Input polygon data
   * @returns the parsed points
   */
  static Parse(input) {
    const floats = input.split(/[^-+eE.\d]+/).map(parseFloat).filter((val) => !isNaN(val));
    let i;
    const result = [];
    for (i = 0; i < (floats.length & 2147483646); i += 2) {
      result.push(new Vector2(floats[i], floats[i + 1]));
    }
    return result;
  }
  /**
   * Starts building a polygon from x and y coordinates
   * @param x x coordinate
   * @param y y coordinate
   * @returns the started path2
   */
  static StartingAt(x, y) {
    return Path2.StartingAt(x, y);
  }
};
var PolygonMeshBuilder = class {
  _addToepoint(points) {
    for (const p of points) {
      this._epoints.push(p.x, p.y);
    }
  }
  /**
   * Creates a PolygonMeshBuilder
   * @param name name of the builder
   * @param contours Path of the polygon
   * @param scene scene to add to when creating the mesh
   * @param earcutInjection can be used to inject your own earcut reference
   */
  constructor(name, contours, scene, earcutInjection = earcut) {
    this._points = new PolygonPoints();
    this._outlinepoints = new PolygonPoints();
    this._holes = new Array();
    this._epoints = new Array();
    this._eholes = new Array();
    this.bjsEarcut = earcutInjection;
    this._name = name;
    this._scene = scene || EngineStore.LastCreatedScene;
    let points;
    if (contours instanceof Path2) {
      points = contours.getPoints();
    } else {
      points = contours;
    }
    this._addToepoint(points);
    this._points.add(points);
    this._outlinepoints.add(points);
    if (typeof this.bjsEarcut === "undefined") {
      Logger.Warn("Earcut was not found, the polygon will not be built.");
    }
  }
  /**
   * Adds a hole within the polygon
   * @param hole Array of points defining the hole
   * @returns this
   */
  addHole(hole) {
    this._points.add(hole);
    const holepoints = new PolygonPoints();
    holepoints.add(hole);
    this._holes.push(holepoints);
    this._eholes.push(this._epoints.length / 2);
    this._addToepoint(hole);
    return this;
  }
  /**
   * Creates the polygon
   * @param updatable If the mesh should be updatable
   * @param depth The depth of the mesh created
   * @param smoothingThreshold Dot product threshold for smoothed normals
   * @returns the created mesh
   */
  build(updatable = false, depth = 0, smoothingThreshold = 2) {
    const result = new Mesh(this._name, this._scene);
    const vertexData = this.buildVertexData(depth, smoothingThreshold);
    result.setVerticesData(VertexBuffer.PositionKind, vertexData.positions, updatable);
    result.setVerticesData(VertexBuffer.NormalKind, vertexData.normals, updatable);
    result.setVerticesData(VertexBuffer.UVKind, vertexData.uvs, updatable);
    result.setIndices(vertexData.indices);
    return result;
  }
  /**
   * Creates the polygon
   * @param depth The depth of the mesh created
   * @param smoothingThreshold Dot product threshold for smoothed normals
   * @returns the created VertexData
   */
  buildVertexData(depth = 0, smoothingThreshold = 2) {
    const result = new VertexData();
    const normals = [];
    const positions = [];
    const uvs = [];
    const bounds = this._points.computeBounds();
    for (const p of this._points.elements) {
      normals.push(0, 1, 0);
      positions.push(p.x, 0, p.y);
      uvs.push((p.x - bounds.min.x) / bounds.width, (p.y - bounds.min.y) / bounds.height);
    }
    const indices = [];
    const res = this.bjsEarcut(this._epoints, this._eholes, 2);
    for (let i = 0; i < res.length; i++) {
      indices.push(res[i]);
    }
    if (depth > 0) {
      const positionscount = positions.length / 3;
      for (const p of this._points.elements) {
        normals.push(0, -1, 0);
        positions.push(p.x, -depth, p.y);
        uvs.push(1 - (p.x - bounds.min.x) / bounds.width, 1 - (p.y - bounds.min.y) / bounds.height);
      }
      const totalCount = indices.length;
      for (let i = 0; i < totalCount; i += 3) {
        const i0 = indices[i + 0];
        const i1 = indices[i + 1];
        const i2 = indices[i + 2];
        indices.push(i2 + positionscount);
        indices.push(i1 + positionscount);
        indices.push(i0 + positionscount);
      }
      this._addSide(positions, normals, uvs, indices, bounds, this._outlinepoints, depth, false, smoothingThreshold);
      for (const hole of this._holes) {
        this._addSide(positions, normals, uvs, indices, bounds, hole, depth, true, smoothingThreshold);
      }
    }
    result.indices = indices;
    result.positions = positions;
    result.normals = normals;
    result.uvs = uvs;
    return result;
  }
  /**
   * Adds a side to the polygon
   * @param positions points that make the polygon
   * @param normals normals of the polygon
   * @param uvs uvs of the polygon
   * @param indices indices of the polygon
   * @param bounds bounds of the polygon
   * @param points points of the polygon
   * @param depth depth of the polygon
   * @param flip flip of the polygon
   * @param smoothingThreshold
   */
  _addSide(positions, normals, uvs, indices, bounds, points, depth, flip, smoothingThreshold) {
    let startIndex = positions.length / 3;
    let ulength = 0;
    for (let i = 0; i < points.elements.length; i++) {
      const p = points.elements[i];
      const p1 = points.elements[(i + 1) % points.elements.length];
      positions.push(p.x, 0, p.y);
      positions.push(p.x, -depth, p.y);
      positions.push(p1.x, 0, p1.y);
      positions.push(p1.x, -depth, p1.y);
      const p0 = points.elements[(i + points.elements.length - 1) % points.elements.length];
      const p2 = points.elements[(i + 2) % points.elements.length];
      let vc = new Vector3(-(p1.y - p.y), 0, p1.x - p.x);
      let vp = new Vector3(-(p.y - p0.y), 0, p.x - p0.x);
      let vn = new Vector3(-(p2.y - p1.y), 0, p2.x - p1.x);
      if (!flip) {
        vc = vc.scale(-1);
        vp = vp.scale(-1);
        vn = vn.scale(-1);
      }
      const vcNorm = vc.normalizeToNew();
      let vpNorm = vp.normalizeToNew();
      let vnNorm = vn.normalizeToNew();
      const dotp = Vector3.Dot(vpNorm, vcNorm);
      if (dotp > smoothingThreshold) {
        if (dotp < Epsilon - 1) {
          vpNorm = new Vector3(p.x, 0, p.y).subtract(new Vector3(p1.x, 0, p1.y)).normalize();
        } else {
          vpNorm = vp.add(vc).normalize();
        }
      } else {
        vpNorm = vcNorm;
      }
      const dotn = Vector3.Dot(vn, vc);
      if (dotn > smoothingThreshold) {
        if (dotn < Epsilon - 1) {
          vnNorm = new Vector3(p1.x, 0, p1.y).subtract(new Vector3(p.x, 0, p.y)).normalize();
        } else {
          vnNorm = vn.add(vc).normalize();
        }
      } else {
        vnNorm = vcNorm;
      }
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      ulength += vc.length();
      uvs.push(ulength / bounds.width, 0);
      uvs.push(ulength / bounds.width, 1);
      normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
      normals.push(vpNorm.x, vpNorm.y, vpNorm.z);
      normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
      normals.push(vnNorm.x, vnNorm.y, vnNorm.z);
      if (!flip) {
        indices.push(startIndex);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 3);
        indices.push(startIndex + 2);
      } else {
        indices.push(startIndex);
        indices.push(startIndex + 2);
        indices.push(startIndex + 1);
        indices.push(startIndex + 1);
        indices.push(startIndex + 2);
        indices.push(startIndex + 3);
      }
      startIndex += 4;
    }
  }
};

// node_modules/@babylonjs/core/Meshes/Builders/polygonBuilder.js
function CreatePolygonVertexData(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrp) {
  const faceUV = fUV || new Array(3);
  const faceColors = fColors;
  const colors = [];
  const wrap = wrp || false;
  for (let f = 0; f < 3; f++) {
    if (faceUV[f] === void 0) {
      faceUV[f] = new Vector4(0, 0, 1, 1);
    }
    if (faceColors && faceColors[f] === void 0) {
      faceColors[f] = new Color4(1, 1, 1, 1);
    }
  }
  const positions = polygon.getVerticesData(VertexBuffer.PositionKind);
  const normals = polygon.getVerticesData(VertexBuffer.NormalKind);
  const uvs = polygon.getVerticesData(VertexBuffer.UVKind);
  const indices = polygon.getIndices();
  const startIndex = positions.length / 9;
  let disp = 0;
  let distX = 0;
  let distZ = 0;
  let dist = 0;
  let totalLen = 0;
  const cumulate = [0];
  if (wrap) {
    for (let idx2 = startIndex; idx2 < positions.length / 3; idx2 += 4) {
      distX = positions[3 * (idx2 + 2)] - positions[3 * idx2];
      distZ = positions[3 * (idx2 + 2) + 2] - positions[3 * idx2 + 2];
      dist = Math.sqrt(distX * distX + distZ * distZ);
      totalLen += dist;
      cumulate.push(totalLen);
    }
  }
  let idx = 0;
  let face = 0;
  for (let index = 0; index < normals.length; index += 3) {
    if (Math.abs(normals[index + 1]) < 1e-3) {
      face = 1;
    }
    if (Math.abs(normals[index + 1] - 1) < 1e-3) {
      face = 0;
    }
    if (Math.abs(normals[index + 1] + 1) < 1e-3) {
      face = 2;
    }
    idx = index / 3;
    if (face === 1) {
      disp = idx - startIndex;
      if (disp % 4 < 1.5) {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4)] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].x;
        }
      } else {
        if (wrap) {
          uvs[2 * idx] = faceUV[face].x + (faceUV[face].z - faceUV[face].x) * cumulate[Math.floor(disp / 4) + 1] / totalLen;
        } else {
          uvs[2 * idx] = faceUV[face].z;
        }
      }
      if (disp % 2 === 0) {
        uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1 - faceUV[face].w : faceUV[face].w;
      } else {
        uvs[2 * idx + 1] = useOpenGLOrientationForUV ? 1 - faceUV[face].y : faceUV[face].y;
      }
    } else {
      uvs[2 * idx] = (1 - uvs[2 * idx]) * faceUV[face].x + uvs[2 * idx] * faceUV[face].z;
      uvs[2 * idx + 1] = (1 - uvs[2 * idx + 1]) * faceUV[face].y + uvs[2 * idx + 1] * faceUV[face].w;
      if (useOpenGLOrientationForUV) {
        uvs[2 * idx + 1] = 1 - uvs[2 * idx + 1];
      }
    }
    if (faceColors) {
      colors.push(faceColors[face].r, faceColors[face].g, faceColors[face].b, faceColors[face].a);
    }
  }
  VertexData._ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs);
  const vertexData = new VertexData();
  vertexData.indices = indices;
  vertexData.positions = positions;
  vertexData.normals = normals;
  vertexData.uvs = uvs;
  if (faceColors) {
    const totalColors = sideOrientation === VertexData.DOUBLESIDE ? colors.concat(colors) : colors;
    vertexData.colors = totalColors;
  }
  return vertexData;
}
function CreatePolygon(name, options, scene = null, earcutInjection = earcut) {
  options.sideOrientation = Mesh._GetDefaultSideOrientation(options.sideOrientation);
  const shape = options.shape;
  const holes = options.holes || [];
  const depth = options.depth || 0;
  const smoothingThreshold = options.smoothingThreshold || 2;
  const contours = [];
  let hole = [];
  for (let i = 0; i < shape.length; i++) {
    contours[i] = new Vector2(shape[i].x, shape[i].z);
  }
  const epsilon = 1e-8;
  if (contours[0].equalsWithEpsilon(contours[contours.length - 1], epsilon)) {
    contours.pop();
  }
  const polygonTriangulation = new PolygonMeshBuilder(name, contours, scene || EngineStore.LastCreatedScene, earcutInjection);
  for (let hNb = 0; hNb < holes.length; hNb++) {
    hole = [];
    for (let hPoint = 0; hPoint < holes[hNb].length; hPoint++) {
      hole.push(new Vector2(holes[hNb][hPoint].x, holes[hNb][hPoint].z));
    }
    polygonTriangulation.addHole(hole);
  }
  const polygon = polygonTriangulation.build(false, depth, smoothingThreshold);
  polygon._originalBuilderSideOrientation = options.sideOrientation;
  const vertexData = CreatePolygonVertexData(polygon, options.sideOrientation, options.faceUV, options.faceColors, options.frontUVs, options.backUVs, options.wrap);
  vertexData.applyToMesh(polygon, options.updatable);
  return polygon;
}
function ExtrudePolygon(name, options, scene = null, earcutInjection = earcut) {
  return CreatePolygon(name, options, scene, earcutInjection);
}
var PolygonBuilder = {
  ExtrudePolygon,
  CreatePolygon
};
VertexData.CreatePolygon = CreatePolygonVertexData;
Mesh.CreatePolygon = (name, shape, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    updatable,
    sideOrientation
  };
  return CreatePolygon(name, options, scene, earcutInjection);
};
Mesh.ExtrudePolygon = (name, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection = earcut) => {
  const options = {
    shape,
    holes,
    depth,
    updatable,
    sideOrientation
  };
  return ExtrudePolygon(name, options, scene, earcutInjection);
};

// node_modules/@babylonjs/core/Meshes/Builders/textBuilder.js
var ShapePath = class {
  /** Create the ShapePath used to support glyphs
   * @param resolution defines the resolution used to determine the number of points per curve (default is 4)
   */
  constructor(resolution) {
    this._paths = [];
    this._tempPaths = [];
    this._holes = [];
    this._resolution = resolution;
  }
  /** Move the virtual cursor to a coordinate
   * @param x defines the x coordinate
   * @param y defines the y coordinate
   */
  moveTo(x, y) {
    this._currentPath = new Path2(x, y);
    this._tempPaths.push(this._currentPath);
  }
  /** Draw a line from the virtual cursor to a given coordinate
   * @param x defines the x coordinate
   * @param y defines the y coordinate
   */
  lineTo(x, y) {
    this._currentPath.addLineTo(x, y);
  }
  /** Create a quadratic curve from the virtual cursor to a given coordinate
   * @param cpx defines the x coordinate of the control point
   * @param cpy defines the y coordinate of the control point
   * @param x defines the x coordinate of the end point
   * @param y defines the y coordinate of the end point
   */
  quadraticCurveTo(cpx, cpy, x, y) {
    this._currentPath.addQuadraticCurveTo(cpx, cpy, x, y, this._resolution);
  }
  /**
   * Create a bezier curve from the virtual cursor to a given coordinate
   * @param cpx1 defines the x coordinate of the first control point
   * @param cpy1 defines the y coordinate of the first control point
   * @param cpx2 defines the x coordinate of the second control point
   * @param cpy2 defines the y coordinate of the second control point
   * @param x defines the x coordinate of the end point
   * @param y defines the y coordinate of the end point
   */
  bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y) {
    this._currentPath.addBezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y, this._resolution);
  }
  /** Extract holes based on CW / CCW */
  extractHoles() {
    for (const path of this._tempPaths) {
      if (path.area() > 0) {
        this._holes.push(path);
      } else {
        this._paths.push(path);
      }
    }
    if (!this._paths.length && this._holes.length) {
      const temp = this._holes;
      this._holes = this._paths;
      this._paths = temp;
    }
    this._tempPaths.length = 0;
  }
  /** Gets the list of paths */
  get paths() {
    return this._paths;
  }
  /** Gets the list of holes */
  get holes() {
    return this._holes;
  }
};
function CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData) {
  const glyph = fontData.glyphs[char] || fontData.glyphs["?"];
  if (!glyph) {
    return null;
  }
  const shapePath = new ShapePath(resolution);
  if (glyph.o) {
    const outline = glyph.o.split(" ");
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.moveTo(x, y);
          break;
        }
        case "l": {
          const x = parseInt(outline[i++]) * scale + offsetX;
          const y = parseInt(outline[i++]) * scale + offsetY;
          shapePath.lineTo(x, y);
          break;
        }
        case "q": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        }
        case "b": {
          const cpx = parseInt(outline[i++]) * scale + offsetX;
          const cpy = parseInt(outline[i++]) * scale + offsetY;
          const cpx1 = parseInt(outline[i++]) * scale + offsetX;
          const cpy1 = parseInt(outline[i++]) * scale + offsetY;
          const cpx2 = parseInt(outline[i++]) * scale + offsetX;
          const cpy2 = parseInt(outline[i++]) * scale + offsetY;
          shapePath.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
        }
      }
    }
  }
  shapePath.extractHoles();
  return { offsetX: glyph.ha * scale, shapePath };
}
function CreateTextShapePaths(text, size, resolution, fontData) {
  const chars = Array.from(text);
  const scale = size / fontData.resolution;
  const lineHeight = (fontData.boundingBox.yMax - fontData.boundingBox.yMin + fontData.underlineThickness) * scale;
  const shapePaths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= lineHeight;
    } else {
      const ret = CreateShapePath(char, scale, offsetX, offsetY, resolution, fontData);
      if (ret) {
        offsetX += ret.offsetX;
        shapePaths.push(ret.shapePath);
      }
    }
  }
  return shapePaths;
}
function CreateText(name, text, fontData, options = {
  size: 50,
  resolution: 8,
  depth: 1
}, scene = null, earcutInjection = earcut) {
  const shapePaths = CreateTextShapePaths(text, options.size || 50, options.resolution || 8, fontData);
  const meshes = [];
  let letterIndex = 0;
  for (const shapePath of shapePaths) {
    if (!shapePath.paths.length) {
      continue;
    }
    const holes = shapePath.holes.slice();
    for (const path of shapePath.paths) {
      const holeVectors = [];
      const shapeVectors = [];
      const points = path.getPoints();
      for (const point of points) {
        shapeVectors.push(new Vector3(point.x, 0, point.y));
      }
      const localHolesCopy = holes.slice();
      for (const hole of localHolesCopy) {
        const points2 = hole.getPoints();
        let found = false;
        for (const point of points2) {
          if (path.isPointInside(point)) {
            found = true;
            break;
          }
        }
        if (!found) {
          continue;
        }
        const holePoints = [];
        for (const point of points2) {
          holePoints.push(new Vector3(point.x, 0, point.y));
        }
        holeVectors.push(holePoints);
        holes.splice(holes.indexOf(hole), 1);
      }
      if (!holeVectors.length && holes.length) {
        for (const hole of holes) {
          const points2 = hole.getPoints();
          const holePoints = [];
          for (const point of points2) {
            holePoints.push(new Vector3(point.x, 0, point.y));
          }
          holeVectors.push(holePoints);
        }
      }
      const mesh = ExtrudePolygon(name, {
        shape: shapeVectors,
        holes: holeVectors.length ? holeVectors : void 0,
        depth: options.depth || 1,
        faceUV: options.faceUV || options.perLetterFaceUV?.(letterIndex),
        faceColors: options.faceColors || options.perLetterFaceColors?.(letterIndex),
        sideOrientation: Mesh._GetDefaultSideOrientation(options.sideOrientation || Mesh.DOUBLESIDE)
      }, scene, earcutInjection);
      meshes.push(mesh);
      letterIndex++;
    }
  }
  const newMesh = Mesh.MergeMeshes(meshes, true, true);
  if (newMesh) {
    const bbox = newMesh.getBoundingInfo().boundingBox;
    newMesh.position.x += -(bbox.minimumWorld.x + bbox.maximumWorld.x) / 2;
    newMesh.position.y += -(bbox.minimumWorld.y + bbox.maximumWorld.y) / 2;
    newMesh.position.z += -(bbox.minimumWorld.z + bbox.maximumWorld.z) / 2 + bbox.extendSize.z;
    newMesh.name = name;
    const pivot = new TransformNode("pivot", scene);
    pivot.rotation.x = -Math.PI / 2;
    newMesh.parent = pivot;
    newMesh.bakeCurrentTransformIntoVertices();
    newMesh.parent = null;
    pivot.dispose();
  }
  return newMesh;
}

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTextureSceneComponent.js
var ProceduralTextureSceneComponent = class {
  /**
   * Creates a new instance of the component for the given scene
   * @param scene Defines the scene to register the component in
   */
  constructor(scene) {
    this.name = SceneComponentConstants.NAME_PROCEDURALTEXTURE;
    this.scene = scene;
  }
  /**
   * Registers the component in a given scene
   */
  register() {
    this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE, this, this._beforeClear);
  }
  /**
   * Rebuilds the elements related to this component in case of
   * context lost for instance.
   */
  rebuild() {
  }
  /**
   * Disposes the component and the associated resources.
   */
  dispose() {
  }
  _beforeClear() {
    if (this.scene.proceduralTexturesEnabled) {
      Tools.StartPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
      for (let proceduralIndex = 0; proceduralIndex < this.scene.proceduralTextures.length; proceduralIndex++) {
        const proceduralTexture = this.scene.proceduralTextures[proceduralIndex];
        if (proceduralTexture._shouldRender()) {
          proceduralTexture.render();
        }
      }
      Tools.EndPerformanceCounter("Procedural textures", this.scene.proceduralTextures.length > 0);
    }
  }
};

// node_modules/@babylonjs/core/Materials/Textures/Procedurals/proceduralTexture.js
var ProceduralTexture = class _ProceduralTexture extends Texture {
  /**
   * Gets the shader language type used to generate vertex and fragment source code.
   */
  get shaderLanguage() {
    return this._shaderLanguage;
  }
  /**
   * Instantiates a new procedural texture.
   * Procedural texturing is a way to programmatically create a texture. There are 2 types of procedural textures: code-only, and code that references some classic 2D images, sometimes called 'refMaps' or 'sampler' images.
   * This is the base class of any Procedural texture and contains most of the shareable code.
   * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/proceduralTextures
   * @param name  Define the name of the texture
   * @param size Define the size of the texture to create
   * @param fragment Define the fragment shader to use to generate the texture or null if it is defined later:
   *  * object: \{ fragmentElement: "fragmentShaderCode" \}, used with shader code in script tags
   *  * object: \{ fragmentSource: "fragment shader code string" \}, the string contains the shader code
   *  * string: the string contains a name "XXX" to lookup in Effect.ShadersStore["XXXFragmentShader"]
   * @param scene Define the scene the texture belongs to
   * @param fallbackTexture Define a fallback texture in case there were issues to create the custom texture
   * @param generateMipMaps Define if the texture should creates mip maps or not
   * @param isCube Define if the texture is a cube texture or not (this will render each faces of the cube)
   * @param textureType The FBO internal texture type
   */
  constructor(name, size, fragment, scene, fallbackTexture = null, generateMipMaps = true, isCube = false, textureType = 0) {
    super(null, scene, !generateMipMaps);
    this.isEnabled = true;
    this.autoClear = true;
    this.onGeneratedObservable = new Observable();
    this.onBeforeGenerationObservable = new Observable();
    this.nodeMaterialSource = null;
    this.defines = "";
    this._textures = {};
    this._currentRefreshId = -1;
    this._frameId = -1;
    this._refreshRate = 1;
    this._vertexBuffers = {};
    this._uniforms = new Array();
    this._samplers = new Array();
    this._floats = {};
    this._ints = {};
    this._floatsArrays = {};
    this._colors3 = {};
    this._colors4 = {};
    this._vectors2 = {};
    this._vectors3 = {};
    this._vectors4 = {};
    this._matrices = {};
    this._fallbackTextureUsed = false;
    this._cachedDefines = null;
    this._contentUpdateId = -1;
    this._rtWrapper = null;
    if (fallbackTexture !== null && !(fallbackTexture instanceof Texture)) {
      this._options = fallbackTexture;
      this._fallbackTexture = fallbackTexture.fallbackTexture ?? null;
    } else {
      this._options = {};
      this._fallbackTexture = fallbackTexture;
    }
    this._shaderLanguage = this._options.shaderLanguage ?? 0;
    scene = this.getScene() || EngineStore.LastCreatedScene;
    let component = scene._getComponent(SceneComponentConstants.NAME_PROCEDURALTEXTURE);
    if (!component) {
      component = new ProceduralTextureSceneComponent(scene);
      scene._addComponent(component);
    }
    scene.proceduralTextures.push(this);
    this._fullEngine = scene.getEngine();
    this.name = name;
    this.isRenderTarget = true;
    this._size = size;
    this._textureType = textureType;
    this._generateMipMaps = generateMipMaps;
    this._drawWrapper = new DrawWrapper(this._fullEngine);
    this.setFragment(fragment);
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, textureType);
    this._texture = rtWrapper.texture;
    const vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._fullEngine, vertices, VertexBuffer.PositionKind, false, false, 2);
    this._createIndexBuffer();
  }
  _createRtWrapper(isCube, size, generateMipMaps, textureType) {
    if (isCube) {
      this._rtWrapper = this._fullEngine.createRenderTargetCubeTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      this.setFloat("face", 0);
    } else {
      this._rtWrapper = this._fullEngine.createRenderTargetTexture(size, {
        generateMipMaps,
        generateDepthBuffer: false,
        generateStencilBuffer: false,
        type: textureType,
        ...this._options
      });
      if (this._rtWrapper.is3D) {
        this.setFloat("layer", 0);
        this.setInt("layerNum", 0);
      }
    }
    return this._rtWrapper;
  }
  /**
   * The effect that is created when initializing the post process.
   * @returns The created effect corresponding the postprocess.
   */
  getEffect() {
    return this._drawWrapper.effect;
  }
  /**
   * @internal
   */
  _setEffect(effect) {
    this._drawWrapper.effect = effect;
  }
  /**
   * Gets texture content (Use this function wisely as reading from a texture can be slow)
   * @returns an ArrayBufferView promise (Uint8Array or Float32Array)
   */
  getContent() {
    if (this._contentData && this._frameId === this._contentUpdateId) {
      return this._contentData;
    }
    if (this._contentData) {
      this._contentData.then((buffer) => {
        this._contentData = this.readPixels(0, 0, buffer);
        this._contentUpdateId = this._frameId;
      });
    } else {
      this._contentData = this.readPixels(0, 0);
      this._contentUpdateId = this._frameId;
    }
    return this._contentData;
  }
  _createIndexBuffer() {
    const engine = this._fullEngine;
    const indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = engine.createIndexBuffer(indices);
  }
  /** @internal */
  _rebuild() {
    const vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vb) {
      vb._rebuild();
    }
    this._createIndexBuffer();
    if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
      this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    }
  }
  /**
   * Resets the texture in order to recreate its associated resources.
   * This can be called in case of context loss or if you change the shader code and need to regenerate the texture with the new code
   */
  reset() {
    this._drawWrapper.effect?.dispose();
    this._drawWrapper.effect = null;
    this._cachedDefines = null;
  }
  _getDefines() {
    return this.defines;
  }
  /**
   * Executes a function when the texture will be ready to be drawn.
   * @param func The callback to be used.
   */
  executeWhenReady(func) {
    if (this.isReady()) {
      func(this);
      return;
    }
    const effect = this.getEffect();
    if (effect) {
      effect.executeWhenCompiled(() => {
        func(this);
      });
    }
  }
  /**
   * Is the texture ready to be used ? (rendered at least once)
   * @returns true if ready, otherwise, false.
   */
  isReady() {
    const engine = this._fullEngine;
    if (this.nodeMaterialSource) {
      return this._drawWrapper.effect.isReady();
    }
    if (!this._fragment) {
      return false;
    }
    if (this._fallbackTextureUsed) {
      return true;
    }
    if (!this._texture) {
      return false;
    }
    const defines = this._getDefines();
    if (this._drawWrapper.effect && defines === this._cachedDefines && this._drawWrapper.effect.isReady()) {
      return true;
    }
    const shaders = {
      vertex: "procedural",
      fragmentElement: this._fragment.fragmentElement,
      fragmentSource: this._fragment.fragmentSource,
      fragment: typeof this._fragment === "string" ? this._fragment : void 0
    };
    if (this._cachedDefines !== defines) {
      this._cachedDefines = defines;
      this._drawWrapper.effect = engine.createEffect(shaders, [VertexBuffer.PositionKind], this._uniforms, this._samplers, defines, void 0, void 0, () => {
        this._rtWrapper?.dispose();
        this._rtWrapper = this._texture = null;
        if (this._fallbackTexture) {
          this._texture = this._fallbackTexture._texture;
          if (this._texture) {
            this._texture.incrementReferences();
          }
        }
        this._fallbackTextureUsed = true;
      }, void 0, this._shaderLanguage, async () => {
        if (this._options.extraInitializationsAsync) {
          if (this.shaderLanguage === 1) {
            await Promise.all([import("./procedural.vertex-NZOMKMTV.js"), this._options.extraInitializationsAsync()]);
          } else {
            await Promise.all([import("./procedural.vertex-3LYQLRZF.js"), this._options.extraInitializationsAsync()]);
          }
        } else {
          if (this.shaderLanguage === 1) {
            await import("./procedural.vertex-NZOMKMTV.js");
          } else {
            await import("./procedural.vertex-3LYQLRZF.js");
          }
        }
      });
    }
    return this._drawWrapper.effect.isReady();
  }
  /**
   * Resets the refresh counter of the texture and start bak from scratch.
   * Could be useful to regenerate the texture if it is setup to render only once.
   */
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  /**
   * Set the fragment shader to use in order to render the texture.
   * @param fragment This can be set to a path (into the shader store) or to a json object containing a fragmentElement property.
   */
  setFragment(fragment) {
    this._fragment = fragment;
  }
  /**
   * Define the refresh rate of the texture or the rendering frequency.
   * Use 0 to render just once, 1 to render on every frame, 2 to render every two frames and so on...
   */
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(value) {
    this._refreshRate = value;
    this.resetRefreshCounter();
  }
  /** @internal */
  _shouldRender() {
    if (!this.isEnabled || !this.isReady() || !this._texture) {
      if (this._texture) {
        this._texture.isReady = false;
      }
      return false;
    }
    if (this._fallbackTextureUsed) {
      return false;
    }
    if (this._currentRefreshId === -1) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    if (this.refreshRate === this._currentRefreshId) {
      this._currentRefreshId = 1;
      this._frameId++;
      return true;
    }
    this._currentRefreshId++;
    return false;
  }
  /**
   * Get the size the texture is rendering at.
   * @returns the size (on cube texture it is always squared)
   */
  getRenderSize() {
    return this._size;
  }
  /**
   * Resize the texture to new value.
   * @param size Define the new size the texture should have
   * @param generateMipMaps Define whether the new texture should create mip maps
   */
  resize(size, generateMipMaps) {
    if (this._fallbackTextureUsed || !this._rtWrapper || !this._texture) {
      return;
    }
    const isCube = this._texture.isCube;
    this._rtWrapper.dispose();
    const rtWrapper = this._createRtWrapper(isCube, size, generateMipMaps, this._textureType);
    this._texture = rtWrapper.texture;
    this._size = size;
    this._generateMipMaps = generateMipMaps;
  }
  _checkUniform(uniformName) {
    if (this._uniforms.indexOf(uniformName) === -1) {
      this._uniforms.push(uniformName);
    }
  }
  /**
   * Set a texture in the shader program used to render.
   * @param name Define the name of the uniform samplers as defined in the shader
   * @param texture Define the texture to bind to this sampler
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setTexture(name, texture) {
    if (this._samplers.indexOf(name) === -1) {
      this._samplers.push(name);
    }
    this._textures[name] = texture;
    return this;
  }
  /**
   * Set a float in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloat(name, value) {
    this._checkUniform(name);
    this._floats[name] = value;
    return this;
  }
  /**
   * Set a int in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setInt(name, value) {
    this._checkUniform(name);
    this._ints[name] = value;
    return this;
  }
  /**
   * Set an array of floats in the shader.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setFloats(name, value) {
    this._checkUniform(name);
    this._floatsArrays[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Color3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor3(name, value) {
    this._checkUniform(name);
    this._colors3[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Color4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setColor4(name, value) {
    this._checkUniform(name);
    this._colors4[name] = value;
    return this;
  }
  /**
   * Set a vec2 in the shader from a Vector2.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector2(name, value) {
    this._checkUniform(name);
    this._vectors2[name] = value;
    return this;
  }
  /**
   * Set a vec3 in the shader from a Vector3.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector3(name, value) {
    this._checkUniform(name);
    this._vectors3[name] = value;
    return this;
  }
  /**
   * Set a vec4 in the shader from a Vector4.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setVector4(name, value) {
    this._checkUniform(name);
    this._vectors4[name] = value;
    return this;
  }
  /**
   * Set a mat4 in the shader from a MAtrix.
   * @param name Define the name of the uniform as defined in the shader
   * @param value Define the value to give to the uniform
   * @returns the texture itself allowing "fluent" like uniform updates
   */
  setMatrix(name, value) {
    this._checkUniform(name);
    this._matrices[name] = value;
    return this;
  }
  /**
   * Render the texture to its associated render target.
   * @param useCameraPostProcess Define if camera post process should be applied to the texture
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  render(useCameraPostProcess) {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const engine = this._fullEngine;
    engine.enableEffect(this._drawWrapper);
    this.onBeforeGenerationObservable.notifyObservers(this);
    engine.setState(false);
    if (!this.nodeMaterialSource) {
      for (const name in this._textures) {
        this._drawWrapper.effect.setTexture(name, this._textures[name]);
      }
      for (const name in this._ints) {
        this._drawWrapper.effect.setInt(name, this._ints[name]);
      }
      for (const name in this._floats) {
        this._drawWrapper.effect.setFloat(name, this._floats[name]);
      }
      for (const name in this._floatsArrays) {
        this._drawWrapper.effect.setArray(name, this._floatsArrays[name]);
      }
      for (const name in this._colors3) {
        this._drawWrapper.effect.setColor3(name, this._colors3[name]);
      }
      for (const name in this._colors4) {
        const color = this._colors4[name];
        this._drawWrapper.effect.setFloat4(name, color.r, color.g, color.b, color.a);
      }
      for (const name in this._vectors2) {
        this._drawWrapper.effect.setVector2(name, this._vectors2[name]);
      }
      for (const name in this._vectors3) {
        this._drawWrapper.effect.setVector3(name, this._vectors3[name]);
      }
      for (const name in this._vectors4) {
        this._drawWrapper.effect.setVector4(name, this._vectors4[name]);
      }
      for (const name in this._matrices) {
        this._drawWrapper.effect.setMatrix(name, this._matrices[name]);
      }
    }
    if (!this._texture || !this._rtWrapper) {
      return;
    }
    engine._debugPushGroup?.(`procedural texture generation for ${this.name}`, 1);
    const viewPort = engine.currentViewport;
    if (this.isCube) {
      for (let face = 0; face < 6; face++) {
        engine.bindFramebuffer(this._rtWrapper, face, void 0, void 0, true);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        this._drawWrapper.effect.setFloat("face", face);
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, true);
      }
    } else {
      let numLayers = 1;
      if (this._rtWrapper.is3D) {
        numLayers = this._rtWrapper.depth;
      } else if (this._rtWrapper.is2DArray) {
        numLayers = this._rtWrapper.layers;
      }
      for (let layer = 0; layer < numLayers; layer++) {
        engine.bindFramebuffer(this._rtWrapper, 0, void 0, void 0, true, 0, layer);
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, this._drawWrapper.effect);
        if (this._rtWrapper.is3D || this._rtWrapper.is2DArray) {
          this._drawWrapper.effect?.setFloat("layer", numLayers !== 1 ? layer / (numLayers - 1) : 0);
          this._drawWrapper.effect?.setInt("layerNum", layer);
          for (const name in this._textures) {
            this._drawWrapper.effect.setTexture(name, this._textures[name]);
          }
        }
        if (this.autoClear) {
          engine.clear(scene.clearColor, true, false, false);
        }
        engine.drawElementsType(Material.TriangleFillMode, 0, 6);
        engine.unBindFramebuffer(this._rtWrapper, !this._generateMipMaps);
      }
    }
    if (viewPort) {
      engine.setViewport(viewPort);
    }
    if (this.isCube) {
      engine.generateMipMapsForCubemap(this._texture, true);
    }
    engine._debugPopGroup?.(1);
    if (this.onGenerated) {
      this.onGenerated();
    }
    this.onGeneratedObservable.notifyObservers(this);
  }
  /**
   * Clone the texture.
   * @returns the cloned texture
   */
  clone() {
    const textureSize = this.getSize();
    const newTexture = new _ProceduralTexture(this.name, textureSize.width, this._fragment, this.getScene(), this._fallbackTexture, this._generateMipMaps);
    newTexture.hasAlpha = this.hasAlpha;
    newTexture.level = this.level;
    newTexture.coordinatesMode = this.coordinatesMode;
    return newTexture;
  }
  /**
   * Dispose the texture and release its associated resources.
   */
  dispose() {
    const scene = this.getScene();
    if (!scene) {
      return;
    }
    const index = scene.proceduralTextures.indexOf(this);
    if (index >= 0) {
      scene.proceduralTextures.splice(index, 1);
    }
    const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (vertexBuffer) {
      vertexBuffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer && this._fullEngine._releaseBuffer(this._indexBuffer)) {
      this._indexBuffer = null;
    }
    this.onGeneratedObservable.clear();
    this.onBeforeGenerationObservable.clear();
    super.dispose();
  }
};
__decorate([
  serialize()
], ProceduralTexture.prototype, "isEnabled", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "autoClear", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_generateMipMaps", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "_size", void 0);
__decorate([
  serialize()
], ProceduralTexture.prototype, "refreshRate", null);
RegisterClass("BABYLON.ProceduralTexture", ProceduralTexture);

// node_modules/@babylonjs/core/Helpers/materialConversionHelper.js
function CubicBezierCurve(t, p0, p1, p2, p3) {
  return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
}
function SpecularPowerToRoughness(specularPower, p0 = new Vector2(0, 1), p1 = new Vector2(0, 0.1), p2 = new Vector2(0, 0.1), p3 = new Vector2(1300, 0.1)) {
  const t = Math.pow(specularPower / p3.x, 0.333333);
  return CubicBezierCurve(t, p0.y, p1.y, p2.y, p3.y);
}

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineMaterialDefaults.js
var GreasedLineMaterialDefaults = class {
};
GreasedLineMaterialDefaults.DEFAULT_COLOR = Color3.White();
GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED = 1;
GreasedLineMaterialDefaults.DEFAULT_WIDTH = 0.1;

// node_modules/@babylonjs/core/Misc/greasedLineTools.js
var GreasedLineTools = class _GreasedLineTools {
  /**
   * Converts GreasedLinePoints to number[][]
   * @param points GreasedLinePoints
   * @param options GreasedLineToolsConvertPointsOptions
   * @returns number[][] with x, y, z coordinates of the points, like [[x, y, z, x, y, z, ...], [x, y, z, ...]]
   */
  static ConvertPoints(points, options) {
    if (points.length && Array.isArray(points) && typeof points[0] === "number") {
      return [points];
    } else if (points.length && Array.isArray(points[0]) && typeof points[0][0] === "number") {
      return points;
    } else if (points.length && !Array.isArray(points[0]) && points[0] instanceof Vector3) {
      const positions = [];
      for (let j = 0; j < points.length; j++) {
        const p = points[j];
        positions.push(p.x, p.y, p.z);
      }
      return [positions];
    } else if (points.length > 0 && Array.isArray(points[0]) && points[0].length > 0 && points[0][0] instanceof Vector3) {
      const positions = [];
      const vectorPoints = points;
      for (const p of vectorPoints) {
        positions.push(p.flatMap((p2) => [p2.x, p2.y, p2.z]));
      }
      return positions;
    } else if (points instanceof Float32Array) {
      if (options?.floatArrayStride) {
        const positions = [];
        const stride = options.floatArrayStride * 3;
        for (let i = 0; i < points.length; i += stride) {
          const linePoints = new Array(stride);
          for (let j = 0; j < stride; j++) {
            linePoints[j] = points[i + j];
          }
          positions.push(linePoints);
        }
        return positions;
      } else {
        return [Array.from(points)];
      }
    } else if (points.length && points[0] instanceof Float32Array) {
      const positions = [];
      for (const p of points) {
        positions.push(Array.from(p));
      }
      return positions;
    }
    return [];
  }
  /**
   * Omit zero length lines predicate for the MeshesToLines function
   * @param p1 point1 position of the face
   * @param p2 point2 position of the face
   * @param p3 point3 position of the face
   * @returns original points or null if any edge length is zero
   */
  static OmitZeroLengthPredicate(p1, p2, p3) {
    const fileredPoints = [];
    if (p2.subtract(p1).lengthSquared() > 0) {
      fileredPoints.push([p1, p2]);
    }
    if (p3.subtract(p2).lengthSquared() > 0) {
      fileredPoints.push([p2, p3]);
    }
    if (p1.subtract(p3).lengthSquared() > 0) {
      fileredPoints.push([p3, p1]);
    }
    return fileredPoints.length === 0 ? null : fileredPoints;
  }
  /**
   * Omit duplicate lines predicate for the MeshesToLines function
   * @param p1 point1 position of the face
   * @param p2 point2 position of the face
   * @param p3 point3 position of the face
   * @param points array of points to search in
   * @returns original points or null if any edge length is zero
   */
  static OmitDuplicatesPredicate(p1, p2, p3, points) {
    const fileredPoints = [];
    if (!_GreasedLineTools._SearchInPoints(p1, p2, points)) {
      fileredPoints.push([p1, p2]);
    }
    if (!_GreasedLineTools._SearchInPoints(p2, p3, points)) {
      fileredPoints.push([p2, p3]);
    }
    if (!_GreasedLineTools._SearchInPoints(p3, p1, points)) {
      fileredPoints.push([p3, p1]);
    }
    return fileredPoints.length === 0 ? null : fileredPoints;
  }
  static _SearchInPoints(p1, p2, points) {
    for (const ps of points) {
      for (let i = 0; i < ps.length; i++) {
        if (ps[i]?.equals(p1)) {
          if (ps[i + 1]?.equals(p2) || ps[i - 1]?.equals(p2)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  /**
   * Gets mesh triangles as line positions
   * @param meshes array of meshes
   * @param predicate predicate function which decides whether to include the mesh triangle/face in the ouput
   * @returns array of arrays of points
   */
  static MeshesToLines(meshes, predicate) {
    const points = [];
    for (let meshIndex = 0; meshIndex < meshes.length; meshIndex++) {
      const mesh = meshes[meshIndex];
      const vertices = mesh.getVerticesData(VertexBuffer.PositionKind);
      const indices = mesh.getIndices();
      if (vertices && indices) {
        for (let i = 0, ii = 0; i < indices.length; i++) {
          const vi1 = indices[ii++] * 3;
          const vi2 = indices[ii++] * 3;
          const vi3 = indices[ii++] * 3;
          const p1 = new Vector3(vertices[vi1], vertices[vi1 + 1], vertices[vi1 + 2]);
          const p2 = new Vector3(vertices[vi2], vertices[vi2 + 1], vertices[vi2 + 2]);
          const p3 = new Vector3(vertices[vi3], vertices[vi3 + 1], vertices[vi3 + 2]);
          if (predicate) {
            const pointsFromPredicate = predicate(p1, p2, p3, points, i, vi1, mesh, meshIndex, vertices, indices);
            if (pointsFromPredicate) {
              for (const p of pointsFromPredicate) {
                points.push(p);
              }
            }
          } else {
            points.push([p1, p2], [p2, p3], [p3, p1]);
          }
        }
      }
    }
    return points;
  }
  /**
   * Converts number coordinates to Vector3s
   * @param points number array of x, y, z, x, y z, ... coordinates
   * @returns Vector3 array
   */
  static ToVector3Array(points) {
    if (Array.isArray(points[0])) {
      const array2 = [];
      const inputArray2 = points;
      for (const subInputArray of inputArray2) {
        const subArray = [];
        for (let i = 0; i < subInputArray.length; i += 3) {
          subArray.push(new Vector3(subInputArray[i], subInputArray[i + 1], subInputArray[i + 2]));
        }
        array2.push(subArray);
      }
      return array2;
    }
    const inputArray = points;
    const array = [];
    for (let i = 0; i < inputArray.length; i += 3) {
      array.push(new Vector3(inputArray[i], inputArray[i + 1], inputArray[i + 2]));
    }
    return array;
  }
  /**
   * Gets a number array from a Vector3 array.
   * You can you for example to convert your Vector3[] offsets to the required number[] for the offsets option.
   * @param points Vector3 array
   * @returns an array of x, y, z coordinates as numbers [x, y, z, x, y, z, x, y, z, ....]
   */
  static ToNumberArray(points) {
    return points.flatMap((v) => [v.x, v.y, v.z]);
  }
  /**
   * Calculates the sum of points of every line and the number of points in each line.
   * This function is useful when you are drawing multiple lines in one mesh and you want
   * to know the counts. For example for creating an offsets table.
   * @param points point array
   * @returns points count info
   */
  static GetPointsCountInfo(points) {
    const counts = new Array(points.length);
    let total = 0;
    for (let n = points.length; n--; ) {
      counts[n] = points[n].length / 3;
      total += counts[n];
    }
    return { total, counts };
  }
  /**
   * Gets the length of the line counting all it's segments length
   * @param data array of line points
   * @returns length of the line
   */
  static GetLineLength(data) {
    if (data.length === 0) {
      return 0;
    }
    let points;
    if (typeof data[0] === "number") {
      points = _GreasedLineTools.ToVector3Array(data);
    } else {
      points = data;
    }
    const tmp = TmpVectors.Vector3[0];
    let length = 0;
    for (let index = 0; index < points.length - 1; index++) {
      const point1 = points[index];
      const point2 = points[index + 1];
      length += point2.subtractToRef(point1, tmp).length();
    }
    return length;
  }
  /**
   * Gets the length from the beginning to each point of the line as array.
   * @param data array of line points
   * @param buf optional pre-allocated buffer to reduce memory pressure, should be at least `data.length * 4 / 3` bytes
   * @returns length array of the line
   */
  static GetLineLengthArray(data, buf) {
    const out = buf ? new Float32Array(buf, 0, data.length / 3) : new Float32Array(data.length / 3);
    let length = 0;
    for (let index = 0, pointsLength = data.length / 3 - 1; index < pointsLength; index++) {
      let x = data[index * 3 + 0];
      let y = data[index * 3 + 1];
      let z = data[index * 3 + 2];
      x -= data[index * 3 + 3];
      y -= data[index * 3 + 4];
      z -= data[index * 3 + 5];
      const currentLength = Math.sqrt(x * x + y * y + z * z);
      length += currentLength;
      out[index + 1] = length;
    }
    return out;
  }
  /**
   * Divides a segment into smaller segments.
   * A segment is a part of the line between it's two points.
   * @param point1 first point of the line
   * @param point2 second point of the line
   * @param segmentCount number of segments we want to have in the divided line
   * @returns
   */
  static SegmentizeSegmentByCount(point1, point2, segmentCount) {
    const dividedLinePoints = [];
    const diff = point2.subtract(point1);
    const divisor = TmpVectors.Vector3[0];
    divisor.setAll(segmentCount);
    const segmentVector = TmpVectors.Vector3[1];
    diff.divideToRef(divisor, segmentVector);
    let nextPoint = point1.clone();
    dividedLinePoints.push(nextPoint);
    for (let index = 0; index < segmentCount; index++) {
      nextPoint = nextPoint.clone();
      dividedLinePoints.push(nextPoint.addInPlace(segmentVector));
    }
    return dividedLinePoints;
  }
  /**
   * Divides a line into segments.
   * A segment is a part of the line between it's two points.
   * @param what line points
   * @param segmentLength length of each segment of the resulting line (distance between two line points)
   * @returns line point
   */
  static SegmentizeLineBySegmentLength(what, segmentLength) {
    const subLines = what[0] instanceof Vector3 ? _GreasedLineTools.GetLineSegments(what) : typeof what[0] === "number" ? _GreasedLineTools.GetLineSegments(_GreasedLineTools.ToVector3Array(what)) : what;
    const points = [];
    for (const s of subLines) {
      if (s.length > segmentLength) {
        const segments = _GreasedLineTools.SegmentizeSegmentByCount(s.point1, s.point2, Math.ceil(s.length / segmentLength));
        for (const seg of segments) {
          points.push(seg);
        }
      } else {
        points.push(s.point1);
        points.push(s.point2);
      }
    }
    return points;
  }
  /**
   * Divides a line into segments.
   * A segment is a part of the line between it's two points.
   * @param what line points
   * @param segmentCount number of segments
   * @returns line point
   */
  static SegmentizeLineBySegmentCount(what, segmentCount) {
    const points = typeof what[0] === "number" ? _GreasedLineTools.ToVector3Array(what) : what;
    const segmentLength = _GreasedLineTools.GetLineLength(points) / segmentCount;
    return _GreasedLineTools.SegmentizeLineBySegmentLength(points, segmentLength);
  }
  /**
   * Gets line segments.
   * A segment is a part of the line between it's two points.
   * @param points line points
   * @returns segments information of the line segment including starting point, ending point and the distance between them
   */
  static GetLineSegments(points) {
    const segments = [];
    for (let index = 0; index < points.length - 1; index++) {
      const point1 = points[index];
      const point2 = points[index + 1];
      const length = point2.subtract(point1).length();
      segments.push({ point1, point2, length });
    }
    return segments;
  }
  /**
   * Gets the minimum and the maximum length of a line segment in the line.
   * A segment is a part of the line between it's two points.
   * @param points line points
   * @returns
   */
  static GetMinMaxSegmentLength(points) {
    const subLines = _GreasedLineTools.GetLineSegments(points);
    const sorted = subLines.sort((s) => s.length);
    return {
      min: sorted[0].length,
      max: sorted[sorted.length - 1].length
    };
  }
  /**
   * Finds the last visible position in world space of the line according to the visibility parameter
   * @param lineSegments segments of the line
   * @param lineLength total length of the line
   * @param visbility normalized value of visibility
   * @param localSpace if true the result will be in local space (default is false)
   * @returns world space coordinate of the last visible piece of the line
   */
  static GetPositionOnLineByVisibility(lineSegments, lineLength, visbility, localSpace = false) {
    const lengthVisibilityRatio = lineLength * visbility;
    let sumSegmentLengths = 0;
    let segmentIndex = 0;
    const lineSegmentsLength = lineSegments.length;
    for (let i = 0; i < lineSegmentsLength; i++) {
      if (lengthVisibilityRatio <= sumSegmentLengths + lineSegments[i].length) {
        segmentIndex = i;
        break;
      }
      sumSegmentLengths += lineSegments[i].length;
    }
    const s = (lengthVisibilityRatio - sumSegmentLengths) / lineSegments[segmentIndex].length;
    lineSegments[segmentIndex].point2.subtractToRef(lineSegments[segmentIndex].point1, TmpVectors.Vector3[0]);
    TmpVectors.Vector3[1] = TmpVectors.Vector3[0].multiplyByFloats(s, s, s);
    if (!localSpace) {
      TmpVectors.Vector3[1].addInPlace(lineSegments[segmentIndex].point1);
    }
    return TmpVectors.Vector3[1].clone();
  }
  /**
   * Creates lines in a shape of circle/arc.
   * A segment is a part of the line between it's two points.
   * @param radiusX radiusX of the circle
   * @param segments number of segments in the circle
   * @param z z coordinate of the points. Defaults to 0.
   * @param radiusY radiusY of the circle - you can draw an oval if using different values
   * @param segmentAngle angle offset of the segments. Defaults to Math.PI * 2 / segments. Change this value to draw a part of the circle.
   * @returns line points
   */
  static GetCircleLinePoints(radiusX, segments, z = 0, radiusY = radiusX, segmentAngle = Math.PI * 2 / segments) {
    const points = [];
    for (let i = 0; i <= segments; i++) {
      points.push(new Vector3(Math.cos(i * segmentAngle) * radiusX, Math.sin(i * segmentAngle) * radiusY, z));
    }
    return points;
  }
  /**
   * Gets line points in a shape of a bezier curve
   * @param p0 bezier point0
   * @param p1 bezier point1
   * @param p2 bezier point2
   * @param segments number of segments in the curve
   * @returns
   */
  static GetBezierLinePoints(p0, p1, p2, segments) {
    return Curve3.CreateQuadraticBezier(p0, p1, p2, segments).getPoints().flatMap((v) => [v.x, v.y, v.z]);
  }
  /**
   *
   * @param position position of the arrow cap (mainly you want to create a triangle, set widthUp and widthDown to the same value and omit widthStartUp and widthStartDown)
   * @param direction direction which the arrow points to
   * @param length length (size) of the arrow cap itself
   * @param widthUp the arrow width above the line
   * @param widthDown the arrow width belove the line
   * @param widthStartUp the arrow width at the start of the arrow above the line. In most scenarios this is 0.
   * @param widthStartDown the arrow width at the start of the arrow below the line. In most scenarios this is 0.
   * @returns
   */
  static GetArrowCap(position, direction, length, widthUp, widthDown, widthStartUp = 0, widthStartDown = 0) {
    const points = [position.clone(), position.add(direction.multiplyByFloats(length, length, length))];
    const widths = [widthUp, widthDown, widthStartUp, widthStartDown];
    return {
      points,
      widths
    };
  }
  /**
   * Gets 3D positions of points from a text and font
   * @param text Text
   * @param size Size of the font
   * @param resolution Resolution of the font
   * @param fontData defines the font data (can be generated with http://gero3.github.io/facetype.js/)
   * @param z z coordinate
   * @param includeInner include the inner parts of the font in the result. Default true. If false, only the outlines will be returned.
   * @returns number[][] of 3D positions
   */
  static GetPointsFromText(text, size, resolution, fontData, z = 0, includeInner = true) {
    const allPoints = [];
    const shapePaths = CreateTextShapePaths(text, size, resolution, fontData);
    for (const sp of shapePaths) {
      for (const p of sp.paths) {
        const points = [];
        const points2d = p.getPoints();
        for (const p2d of points2d) {
          points.push(p2d.x, p2d.y, z);
        }
        allPoints.push(points);
      }
      if (includeInner) {
        for (const h of sp.holes) {
          const holes = [];
          const points2d = h.getPoints();
          for (const p2d of points2d) {
            holes.push(p2d.x, p2d.y, z);
          }
          allPoints.push(holes);
        }
      }
    }
    return allPoints;
  }
  /**
   * Converts an array of Color3 to Uint8Array
   * @param colors Arrray of Color3
   * @returns Uin8Array of colors [r, g, b, a, r, g, b, a, ...]
   */
  static Color3toRGBAUint8(colors) {
    const colorTable = new Uint8Array(colors.length * 4);
    for (let i = 0, j = 0; i < colors.length; i++) {
      colorTable[j++] = colors[i].r * 255;
      colorTable[j++] = colors[i].g * 255;
      colorTable[j++] = colors[i].b * 255;
      colorTable[j++] = 255;
    }
    return colorTable;
  }
  /**
   * Creates a RawTexture from an RGBA color array and sets it on the plugin material instance.
   * @param name name of the texture
   * @param colors Uint8Array of colors
   * @param colorsSampling sampling mode of the created texture
   * @param scene Scene
   * @returns the colors texture
   */
  static CreateColorsTexture(name, colors, colorsSampling, scene) {
    const maxTextureSize = scene.getEngine().getCaps().maxTextureSize ?? 1;
    const width = colors.length > maxTextureSize ? maxTextureSize : colors.length;
    const height = Math.ceil(colors.length / maxTextureSize);
    if (height > 1) {
      colors = [...colors, ...Array(width * height - colors.length).fill(colors[0])];
    }
    const colorsArray = _GreasedLineTools.Color3toRGBAUint8(colors);
    const colorsTexture = new RawTexture(colorsArray, width, height, Engine.TEXTUREFORMAT_RGBA, scene, false, true, colorsSampling);
    colorsTexture.name = name;
    return colorsTexture;
  }
  /**
   * A minimum size texture for the colors sampler2D when there is no colors texture defined yet.
   * For fast switching using the useColors property without the need to use defines.
   * @param scene Scene
   * @returns empty colors texture
   */
  static PrepareEmptyColorsTexture(scene) {
    if (!GreasedLineMaterialDefaults.EmptyColorsTexture) {
      const colorsArray = new Uint8Array(4);
      GreasedLineMaterialDefaults.EmptyColorsTexture = new RawTexture(colorsArray, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false, false, RawTexture.NEAREST_NEAREST);
      GreasedLineMaterialDefaults.EmptyColorsTexture.name = "grlEmptyColorsTexture";
    }
    return GreasedLineMaterialDefaults.EmptyColorsTexture;
  }
  /**
   * Diposes the shared empty colors texture
   */
  static DisposeEmptyColorsTexture() {
    GreasedLineMaterialDefaults.EmptyColorsTexture?.dispose();
    GreasedLineMaterialDefaults.EmptyColorsTexture = null;
  }
  /**
   * Converts boolean to number.
   * @param bool the bool value
   * @returns 1 if true, 0 if false.
   */
  static BooleanToNumber(bool) {
    return bool ? 1 : 0;
  }
};

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersGLSL.js
function GetCustomCode(shaderType, cameraFacing) {
  if (shaderType === "vertex") {
    const obj = {
      CUSTOM_VERTEX_DEFINITIONS: `
                attribute float grl_widths;
                attribute vec3 grl_offsets;
                attribute float grl_colorPointers;
                varying float grlCounters;
                varying float grlColorPointer;

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute vec4 grl_previousAndSide;
                    attribute vec4 grl_nextAndCounters;

                    vec2 grlFix( vec4 i, float aspect ) {
                        vec2 res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute vec3 grl_slopes;
                    attribute float grl_counters;
                #endif
                `,
      CUSTOM_VERTEX_UPDATE_POSITION: `
                #ifdef GREASED_LINE_CAMERA_FACING
                    vec3 grlPositionOffset = grl_offsets;
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);
                #endif
                `,
      CUSTOM_VERTEX_MAIN_END: `
                grlColorPointer = grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    float grlAspect = grl_aspect_resolution_lineWidth.x;
                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;

                    vec3 grlPrevious = grl_previousAndSide.xyz;
                    float grlSide = grl_previousAndSide.w;

                    vec3 grlNext = grl_nextAndCounters.xyz;
                    grlCounters = grl_nextAndCounters.w;
                    float grlWidth = grlBaseWidth * grl_widths;
                    
                    vec3 worldDir = normalize(grlNext - grlPrevious);
                    vec3 nearPosition = positionUpdated + (worldDir * 0.01);
                    mat4 grlMatrix = viewProjection * finalWorld;
                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);
                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);
                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);
                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);
                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);

                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);

                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM
                        grlNormal.xy *= -.5 * grlWidth;
                    #else
                        grlNormal.xy *= .5 * grlWidth;
                    #endif

                    grlNormal *= grl_projection;

                    #ifdef GREASED_LINE_SIZE_ATTENUATION
                        grlNormal.xy *= grlFinalPosition.w;
                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;
                    #endif

                    grlFinalPosition.xy += grlNormal.xy * grlSide;
                    gl_Position = grlFinalPosition;

                    vPositionW = vec3(grlFinalPosition);
                #else
                    grlCounters = grl_counters;
                #endif
                `
    };
    if (cameraFacing) {
      obj["!gl_Position\\=viewProjection\\*worldPos;"] = "//";
    }
    return obj;
  }
  if (shaderType === "fragment") {
    return {
      CUSTOM_FRAGMENT_DEFINITIONS: `
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying float grlCounters;
                    varying float grlColorPointer;
                    uniform sampler2D grl_colors;
                `,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `
                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;
                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;
                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;
                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;

                    float grlUseDash = grl_dashOptions.x;
                    float grlDashArray = grl_dashOptions.y;
                    float grlDashOffset = grl_dashOptions.z;
                    float grlDashRatio = grl_dashOptions.w;

                    grlFinalColor.a *= step(grlCounters, grlVisibility);
                    if(grlFinalColor.a == 0.) discard;

                    if(grlUseDash == 1.){
                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));
                        if (grlFinalColor.a == 0.) discard;
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == ${0}.) {
                            grlFinalColor.rgb = grl_singleColor;
                        } else if (grlColorMode == ${1}.) {
                            grlFinalColor.rgb += grl_singleColor;
                        } else if (grlColorMode == ${2}.) {
                            grlFinalColor.rgb *= grl_singleColor;
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);
                            #else
                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));
                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);
                            #endif
                            if (grlColorMode == ${0}.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == ${1}.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == ${2}.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif
                `
    };
  }
  return null;
}

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterialShadersWGSL.js
function GetCustomCode2(shaderType, cameraFacing) {
  if (shaderType === "vertex") {
    const obj = {
      CUSTOM_VERTEX_DEFINITIONS: `
                attribute grl_widths: f32;
                attribute grl_colorPointers: f32;
                varying grlCounters: f32;
                varying grlColorPointer: f32;

                #ifdef GREASED_LINE_USE_OFFSETS
                    attribute grl_offsets: vec3f;   
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    attribute grl_previousAndSide : vec4f;
                    attribute grl_nextAndCounters : vec4f;

                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {
                        var res = i.xy / i.w;
                        res.x *= aspect;
                        return res;
                    }
                #else
                    attribute grl_slopes: f32;
                    attribute grl_counters: f32;
                #endif


                `,
      CUSTOM_VERTEX_UPDATE_POSITION: `
                #ifdef GREASED_LINE_USE_OFFSETS
                    var grlPositionOffset: vec3f = input.grl_offsets;
                #else
                    var grlPositionOffset = vec3f(0.);
                #endif

                #ifdef GREASED_LINE_CAMERA_FACING
                    positionUpdated += grlPositionOffset;
                #else
                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);
                #endif
                `,
      CUSTOM_VERTEX_MAIN_END: `
                vertexOutputs.grlColorPointer = input.grl_colorPointers;

                #ifdef GREASED_LINE_CAMERA_FACING

                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;
                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;

                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;
                    let grlSide: f32 = input.grl_previousAndSide.w;

                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;
                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;

                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;

                    let worldDir: vec3f = normalize(grlNext - grlPrevious);
                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.01);
                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;
                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); 
                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);
                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);
                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);
                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);

                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);

                    let grlHalfWidth: f32 = 0.5 * grlWidth;
                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)
                        grlNormal.x *= -grlHalfWidth;
                        grlNormal.y *= -grlHalfWidth;
                    #else
                        grlNormal.x *= grlHalfWidth;
                        grlNormal.y *= grlHalfWidth;
                    #endif

                    grlNormal *= uniforms.grl_projection;

                    #if defined(GREASED_LINE_SIZE_ATTENUATION)
                        grlNormal.x *= grlFinalPosition.w;
                        grlNormal.y *= grlFinalPosition.w;

                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;
                        grlNormal.x /= pr.x;
                        grlNormal.y /= pr.y;
                    #endif

                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);
                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;
                
                #else
                    vertexOutputs.grlCounters = input.grl_counters;
                #endif
                `
    };
    if (cameraFacing) {
      obj["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"] = "//";
    }
    return obj;
  }
  if (shaderType === "fragment") {
    return {
      CUSTOM_FRAGMENT_DEFINITIONS: `
                    #ifdef PBR
                         #define grlFinalColor finalColor
                    #else
                         #define grlFinalColor color
                    #endif

                    varying grlCounters: f32;
                    varying grlColorPointer: 32;

                    var grl_colors: texture_2d<f32>;
                    var grl_colorsSampler: sampler;
                `,
      CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `
                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;
                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;
                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;
                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;

                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;
                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;
                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;
                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;

                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);
                    if (grlFinalColor.a == 0.0) {
                        discard;
                    }

                    if (grlUseDash == 1.0) {
                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;
                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));

                        if (grlFinalColor.a == 0.0) {
                            discard;
                        }
                    }

                    #ifdef GREASED_LINE_HAS_COLOR
                        if (grlColorMode == ${0}.) {
                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == ${1}.) {
                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        } else if (grlColorMode == ${2}.) {
                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);
                        }
                    #else
                        if (grlUseColors == 1.) {
                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));
                            #else
                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));
                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);
                            #endif
                            if (grlColorMode == ${0}.) {
                                grlFinalColor = grlColor;
                            } else if (grlColorMode == ${1}.) {
                                grlFinalColor += grlColor;
                            } else if (grlColorMode == ${2}.) {
                                grlFinalColor *= grlColor;
                            }
                        }
                    #endif


                `
    };
  }
  return null;
}

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLinePluginMaterial.js
var MaterialGreasedLineDefines = class extends MaterialDefines {
  constructor() {
    super(...arguments);
    this.GREASED_LINE_HAS_COLOR = false;
    this.GREASED_LINE_SIZE_ATTENUATION = false;
    this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = false;
    this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = false;
    this.GREASED_LINE_CAMERA_FACING = true;
    this.GREASED_LINE_USE_OFFSETS = false;
  }
};
var GreasedLinePluginMaterial = class _GreasedLinePluginMaterial extends MaterialPluginBase {
  /**
   * Gets a boolean indicating that the plugin is compatible with a given shader language
   * @param _shaderLanguage The shader language to use
   * @returns true if the plugin is compatible with the shader language. Return always true since both GLSL and WGSL are supported
   */
  isCompatible(_shaderLanguage) {
    return true;
  }
  /**
   * Creates a new instance of the GreasedLinePluginMaterial
   * @param material Base material for the plugin
   * @param scene The scene
   * @param options Plugin options
   */
  constructor(material, scene, options) {
    options = options || {
      color: GreasedLineMaterialDefaults.DEFAULT_COLOR
    };
    const defines = new MaterialGreasedLineDefines();
    defines.GREASED_LINE_HAS_COLOR = !!options.color && !options.useColors;
    defines.GREASED_LINE_SIZE_ATTENUATION = options.sizeAttenuation ?? false;
    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = options.colorDistributionType === 1;
    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = (scene ?? material.getScene()).useRightHandedSystem;
    defines.GREASED_LINE_CAMERA_FACING = options.cameraFacing ?? true;
    super(material, _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME, 200, defines, true, true);
    this.colorsTexture = null;
    this._forceGLSL = false;
    this._forceGLSL = options?.forceGLSL || _GreasedLinePluginMaterial.ForceGLSL;
    this._scene = scene ?? material.getScene();
    this._engine = this._scene.getEngine();
    this._cameraFacing = options.cameraFacing ?? true;
    this.visibility = options.visibility ?? 1;
    this.useDash = options.useDash ?? false;
    this.dashRatio = options.dashRatio ?? 0.5;
    this.dashOffset = options.dashOffset ?? 0;
    this.width = options.width ? options.width : options.sizeAttenuation ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
    this._sizeAttenuation = options.sizeAttenuation ?? false;
    this.colorMode = options.colorMode ?? 0;
    this._color = options.color ?? null;
    this.useColors = options.useColors ?? false;
    this._colorsDistributionType = options.colorDistributionType ?? 0;
    this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;
    this._colors = options.colors ?? null;
    this.dashCount = options.dashCount ?? 1;
    this.resolution = options.resolution ?? new Vector2(this._engine.getRenderWidth(), this._engine.getRenderHeight());
    if (options.colorsTexture) {
      this.colorsTexture = options.colorsTexture;
    } else {
      if (this._colors) {
        this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${material.name}-colors-texture`, this._colors, this.colorsSampling, this._scene);
      } else {
        this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
        GreasedLineTools.PrepareEmptyColorsTexture(this._scene);
      }
    }
    this._engine.onDisposeObservable.add(() => {
      GreasedLineTools.DisposeEmptyColorsTexture();
    });
  }
  /**
   * Get the shader attributes
   * @param attributes array which will be filled with the attributes
   */
  getAttributes(attributes) {
    attributes.push("grl_offsets");
    attributes.push("grl_widths");
    attributes.push("grl_colorPointers");
    attributes.push("grl_counters");
    if (this._cameraFacing) {
      attributes.push("grl_previousAndSide");
      attributes.push("grl_nextAndCounters");
    } else {
      attributes.push("grl_slopes");
    }
  }
  /**
   * Get the shader samplers
   * @param samplers
   */
  getSamplers(samplers) {
    samplers.push("grl_colors");
  }
  /**
   * Get the shader textures
   * @param activeTextures array which will be filled with the textures
   */
  getActiveTextures(activeTextures) {
    if (this.colorsTexture) {
      activeTextures.push(this.colorsTexture);
    }
  }
  /**
   * Get the shader uniforms
   * @param shaderLanguage The shader language to use
   * @returns uniforms
   */
  getUniforms(shaderLanguage = 0) {
    const ubo = [
      { name: "grl_singleColor", size: 3, type: "vec3" },
      { name: "grl_textureSize", size: 2, type: "vec2" },
      { name: "grl_dashOptions", size: 4, type: "vec4" },
      { name: "grl_colorMode_visibility_colorsWidth_useColors", size: 4, type: "vec4" }
    ];
    if (this._cameraFacing) {
      ubo.push({ name: "grl_projection", size: 16, type: "mat4" }, { name: "grl_aspect_resolution_lineWidth", size: 4, type: "vec4" });
    }
    if (shaderLanguage === 1) {
      ubo.push({
        name: "viewProjection",
        size: 16,
        type: "mat4"
      });
    }
    return {
      ubo,
      vertex: this._cameraFacing && this._isGLSL(shaderLanguage) ? `
                    uniform vec4 grl_aspect_resolution_lineWidth;
                    uniform mat4 grl_projection;
    ` : "",
      fragment: this._isGLSL(shaderLanguage) ? `
                    uniform vec4 grl_dashOptions;
                    uniform vec2 grl_textureSize;
                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;
                    uniform vec3 grl_singleColor;
    ` : ""
    };
  }
  // only getter, it doesn't make sense to use this plugin on a mesh other than GreasedLineMesh
  // and it doesn't make sense to disable it on the mesh
  get isEnabled() {
    return true;
  }
  /**
   * Bind the uniform buffer
   * @param uniformBuffer
   */
  bindForSubMesh(uniformBuffer) {
    if (this._cameraFacing) {
      uniformBuffer.updateMatrix("grl_projection", this._scene.getProjectionMatrix());
      if (!this._isGLSL(this._material.shaderLanguage)) {
        uniformBuffer.updateMatrix("viewProjection", this._scene.getTransformMatrix());
      }
      const resolutionLineWidth = TmpVectors.Vector4[0];
      resolutionLineWidth.x = this._aspect;
      resolutionLineWidth.y = this._resolution.x;
      resolutionLineWidth.z = this._resolution.y;
      resolutionLineWidth.w = this.width;
      uniformBuffer.updateVector4("grl_aspect_resolution_lineWidth", resolutionLineWidth);
    }
    const dashOptions = TmpVectors.Vector4[0];
    dashOptions.x = GreasedLineTools.BooleanToNumber(this.useDash);
    dashOptions.y = this._dashArray;
    dashOptions.z = this.dashOffset;
    dashOptions.w = this.dashRatio;
    uniformBuffer.updateVector4("grl_dashOptions", dashOptions);
    const colorModeVisibilityColorsWidthUseColors = TmpVectors.Vector4[1];
    colorModeVisibilityColorsWidthUseColors.x = this.colorMode;
    colorModeVisibilityColorsWidthUseColors.y = this.visibility;
    colorModeVisibilityColorsWidthUseColors.z = this.colorsTexture ? this.colorsTexture.getSize().width : 0;
    colorModeVisibilityColorsWidthUseColors.w = GreasedLineTools.BooleanToNumber(this.useColors);
    uniformBuffer.updateVector4("grl_colorMode_visibility_colorsWidth_useColors", colorModeVisibilityColorsWidthUseColors);
    if (this._color) {
      uniformBuffer.updateColor3("grl_singleColor", this._color);
    }
    const texture = this.colorsTexture ?? GreasedLineMaterialDefaults.EmptyColorsTexture;
    uniformBuffer.setTexture("grl_colors", texture);
    uniformBuffer.updateFloat2("grl_textureSize", texture?.getSize().width ?? 1, texture?.getSize().height ?? 1);
  }
  /**
   * Prepare the defines
   * @param defines
   * @param _scene
   * @param mesh
   */
  prepareDefines(defines, _scene, mesh) {
    defines.GREASED_LINE_HAS_COLOR = !!this.color && !this.useColors;
    defines.GREASED_LINE_SIZE_ATTENUATION = this._sizeAttenuation;
    defines.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE = this._colorsDistributionType === 1;
    defines.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM = _scene.useRightHandedSystem;
    defines.GREASED_LINE_CAMERA_FACING = this._cameraFacing;
    defines.GREASED_LINE_USE_OFFSETS = !!mesh.offsets;
  }
  /**
   * Get the class name
   * @returns class name
   */
  getClassName() {
    return _GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME;
  }
  /**
   * Get shader code
   * @param shaderType vertex/fragment
   * @param shaderLanguage GLSL or WGSL
   * @returns shader code
   */
  getCustomCode(shaderType, shaderLanguage = 0) {
    if (this._isGLSL(shaderLanguage)) {
      return GetCustomCode(shaderType, this._cameraFacing);
    }
    return GetCustomCode2(shaderType, this._cameraFacing);
  }
  /**
   * Disposes the plugin material.
   */
  dispose() {
    this.colorsTexture?.dispose();
    super.dispose();
  }
  /**
   * Returns the colors used to colorize the line
   */
  get colors() {
    return this._colors;
  }
  /**
   * Sets the colors used to colorize the line
   */
  set colors(value) {
    this.setColors(value);
  }
  /**
   * Creates or updates the colors texture
   * @param colors color table RGBA
   * @param lazy if lazy, the colors are not updated
   * @param forceNewTexture force creation of a new texture
   */
  setColors(colors, lazy = false, forceNewTexture = false) {
    const origColorsCount = this._colors?.length ?? 0;
    this._colors = colors;
    if (colors === null || colors.length === 0) {
      this.colorsTexture?.dispose();
      return;
    }
    if (lazy && !forceNewTexture) {
      return;
    }
    if (this.colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
      this.colorsTexture.update(colorArray);
    } else {
      this.colorsTexture?.dispose();
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, colors, this.colorsSampling, this._scene);
    }
  }
  /**
   * Updates the material. Use when material created in lazy mode.
   */
  updateLazy() {
    if (this._colors) {
      this.setColors(this._colors, false, true);
    }
  }
  /**
   * Gets the number of dashes in the line
   */
  get dashCount() {
    return this._dashCount;
  }
  /**
   * Sets the number of dashes in the line
   * @param value dash
   */
  set dashCount(value) {
    this._dashCount = value;
    this._dashArray = 1 / value;
  }
  /**
   * If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
   * Not supported for non camera facing lines.
   */
  get sizeAttenuation() {
    return this._sizeAttenuation;
  }
  /**
   * Turn on/off size attenuation of the width option and widths array.
   * Not supported for non camera facing lines.
   * @param value If set to true the line will be rendered always with the same width regardless how far it is located from the camera.
   */
  set sizeAttenuation(value) {
    this._sizeAttenuation = value;
    this.markAllDefinesAsDirty();
  }
  /**
   * Gets the color of the line
   */
  get color() {
    return this._color;
  }
  /**
   * Sets the color of the line
   * @param value Color3 or null to clear the color. You need to clear the color if you use colors and useColors = true
   */
  set color(value) {
    this.setColor(value);
  }
  /**
   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
   * @param value color
   * @param doNotMarkDirty if true, the material will not be marked as dirty
   */
  setColor(value, doNotMarkDirty = false) {
    if (this._color === null && value !== null || this._color !== null && value === null) {
      this._color = value;
      if (!doNotMarkDirty) {
        this.markAllDefinesAsDirty();
      }
    } else {
      this._color = value;
    }
  }
  /**
   * Gets the color distributiopn type
   */
  get colorsDistributionType() {
    return this._colorsDistributionType;
  }
  /**
   * Sets the color distribution type
   * @see GreasedLineMeshColorDistributionType
   * @param value color distribution type
   */
  set colorsDistributionType(value) {
    this._colorsDistributionType = value;
    this.markAllDefinesAsDirty();
  }
  /**
   * Gets the resolution
   */
  get resolution() {
    return this._resolution;
  }
  /**
   * Sets the resolution
   * @param value resolution of the screen for GreasedLine
   */
  set resolution(value) {
    this._aspect = value.x / value.y;
    this._resolution = value;
  }
  /**
   * Serializes this plugin material
   * @returns serializationObjec
   */
  serialize() {
    const serializationObject = super.serialize();
    const greasedLineMaterialOptions = {
      colorDistributionType: this._colorsDistributionType,
      colorsSampling: this.colorsSampling,
      colorMode: this.colorMode,
      dashCount: this._dashCount,
      dashOffset: this.dashOffset,
      dashRatio: this.dashRatio,
      resolution: this._resolution,
      sizeAttenuation: this._sizeAttenuation,
      useColors: this.useColors,
      useDash: this.useDash,
      visibility: this.visibility,
      width: this.width
    };
    if (this._colors) {
      greasedLineMaterialOptions.colors = this._colors;
    }
    if (this._color) {
      greasedLineMaterialOptions.color = this._color;
    }
    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
    return serializationObject;
  }
  /**
   * Parses a serialized objects
   * @param source serialized object
   * @param scene scene
   * @param rootUrl root url for textures
   */
  parse(source, scene, rootUrl) {
    super.parse(source, scene, rootUrl);
    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
    this.colorsTexture?.dispose();
    if (greasedLineMaterialOptions.color) {
      this.setColor(greasedLineMaterialOptions.color, true);
    }
    if (greasedLineMaterialOptions.colorDistributionType) {
      this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;
    }
    if (greasedLineMaterialOptions.colors) {
      this.colors = greasedLineMaterialOptions.colors;
    }
    if (greasedLineMaterialOptions.colorsSampling) {
      this.colorsSampling = greasedLineMaterialOptions.colorsSampling;
    }
    if (greasedLineMaterialOptions.colorMode) {
      this.colorMode = greasedLineMaterialOptions.colorMode;
    }
    if (greasedLineMaterialOptions.useColors) {
      this.useColors = greasedLineMaterialOptions.useColors;
    }
    if (greasedLineMaterialOptions.visibility) {
      this.visibility = greasedLineMaterialOptions.visibility;
    }
    if (greasedLineMaterialOptions.useDash) {
      this.useDash = greasedLineMaterialOptions.useDash;
    }
    if (greasedLineMaterialOptions.dashCount) {
      this.dashCount = greasedLineMaterialOptions.dashCount;
    }
    if (greasedLineMaterialOptions.dashRatio) {
      this.dashRatio = greasedLineMaterialOptions.dashRatio;
    }
    if (greasedLineMaterialOptions.dashOffset) {
      this.dashOffset = greasedLineMaterialOptions.dashOffset;
    }
    if (greasedLineMaterialOptions.width) {
      this.width = greasedLineMaterialOptions.width;
    }
    if (greasedLineMaterialOptions.sizeAttenuation) {
      this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;
    }
    if (greasedLineMaterialOptions.resolution) {
      this.resolution = greasedLineMaterialOptions.resolution;
    }
    if (this.colors) {
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this._material.name}-colors-texture`, this.colors, this.colorsSampling, scene);
    } else {
      GreasedLineTools.PrepareEmptyColorsTexture(scene);
    }
    this.markAllDefinesAsDirty();
  }
  /**
   * Makes a duplicate of the current configuration into another one.
   * @param plugin define the config where to copy the info
   */
  copyTo(plugin) {
    const dest = plugin;
    dest.colorsTexture?.dispose();
    if (this._colors) {
      dest.colorsTexture = GreasedLineTools.CreateColorsTexture(`${dest._material.name}-colors-texture`, this._colors, dest.colorsSampling, this._scene);
    }
    dest.setColor(this.color, true);
    dest.colorsDistributionType = this.colorsDistributionType;
    dest.colorsSampling = this.colorsSampling;
    dest.colorMode = this.colorMode;
    dest.useColors = this.useColors;
    dest.visibility = this.visibility;
    dest.useDash = this.useDash;
    dest.dashCount = this.dashCount;
    dest.dashRatio = this.dashRatio;
    dest.dashOffset = this.dashOffset;
    dest.width = this.width;
    dest.sizeAttenuation = this.sizeAttenuation;
    dest.resolution = this.resolution;
    dest.markAllDefinesAsDirty();
  }
  _isGLSL(shaderLanguage) {
    return shaderLanguage === 0 || this._forceGLSL;
  }
};
GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME = "GreasedLinePluginMaterial";
GreasedLinePluginMaterial.ForceGLSL = false;
RegisterClass(`BABYLON.${GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME}`, GreasedLinePluginMaterial);

// node_modules/@babylonjs/core/Materials/GreasedLine/greasedLineSimpleMaterial.js
var GreasedLineUseOffsetsSimpleMaterialDefine = "GREASED_LINE_USE_OFFSETS";
var GreasedLineSimpleMaterial = class _GreasedLineSimpleMaterial extends ShaderMaterial {
  /**
   * GreasedLineSimple material constructor
   * @param name material name
   * @param scene the scene
   * @param options material options
   */
  constructor(name, scene, options) {
    const engine = scene.getEngine();
    const isWGSL = engine.isWebGPU && !(options.forceGLSL || _GreasedLineSimpleMaterial.ForceGLSL);
    const defines = [
      `COLOR_DISTRIBUTION_TYPE_LINE ${1}.`,
      `COLOR_DISTRIBUTION_TYPE_SEGMENT ${0}.`,
      `COLOR_MODE_SET ${0}.`,
      `COLOR_MODE_ADD ${1}.`,
      `COLOR_MODE_MULTIPLY ${2}.`
    ];
    if (scene.useRightHandedSystem) {
      defines.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");
    }
    const attributes = ["position", "grl_widths", "grl_offsets", "grl_colorPointers"];
    if (options.cameraFacing) {
      defines.push("GREASED_LINE_CAMERA_FACING");
      attributes.push("grl_previousAndSide", "grl_nextAndCounters");
    } else {
      attributes.push("grl_slopes");
      attributes.push("grl_counters");
    }
    const uniforms = [
      "grlColorsWidth",
      "grlUseColors",
      "grlWidth",
      "grlColor",
      "grl_colorModeAndColorDistributionType",
      "grlResolution",
      "grlAspect",
      "grlAizeAttenuation",
      "grlDashArray",
      "grlDashOffset",
      "grlDashRatio",
      "grlUseDash",
      "grlVisibility",
      "grlColors"
    ];
    if (!isWGSL) {
      uniforms.push("world", "viewProjection", "view", "projection");
    }
    super(name, scene, {
      vertex: "greasedLine",
      fragment: "greasedLine"
    }, {
      uniformBuffers: isWGSL ? ["Scene", "Mesh"] : void 0,
      attributes,
      uniforms,
      samplers: isWGSL ? [] : ["grlColors"],
      defines,
      extraInitializationsAsync: async () => {
        if (isWGSL) {
          await Promise.all([import("./greasedLine.vertex-I6AMRTMW.js"), import("./greasedLine.fragment-ZZ2TK37R.js")]);
        } else {
          await Promise.all([import("./greasedLine.vertex-XD5KYKPL.js"), import("./greasedLine.fragment-BYTPZNON.js")]);
        }
      },
      shaderLanguage: isWGSL ? 1 : 0
    });
    this._color = Color3.White();
    this._colorsDistributionType = 0;
    this._colorsTexture = null;
    options = options || {
      color: GreasedLineMaterialDefaults.DEFAULT_COLOR
    };
    this.visibility = options.visibility ?? 1;
    this.useDash = options.useDash ?? false;
    this.dashRatio = options.dashRatio ?? 0.5;
    this.dashOffset = options.dashOffset ?? 0;
    this.dashCount = options.dashCount ?? 1;
    this.width = options.width ? options.width : options.sizeAttenuation && options.cameraFacing ? GreasedLineMaterialDefaults.DEFAULT_WIDTH_ATTENUATED : GreasedLineMaterialDefaults.DEFAULT_WIDTH;
    this.sizeAttenuation = options.sizeAttenuation ?? false;
    this.color = options.color ?? Color3.White();
    this.useColors = options.useColors ?? false;
    this.colorsDistributionType = options.colorDistributionType ?? 0;
    this.colorsSampling = options.colorsSampling ?? RawTexture.NEAREST_NEAREST;
    this.colorMode = options.colorMode ?? 0;
    this._colors = options.colors ?? null;
    this._cameraFacing = options.cameraFacing ?? true;
    this.resolution = options.resolution ?? new Vector2(engine.getRenderWidth(), engine.getRenderHeight());
    if (options.colorsTexture) {
      this.colorsTexture = options.colorsTexture;
    } else {
      if (this._colors) {
        this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, this._colors, this.colorsSampling, scene);
      } else {
        this._color = this._color ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
        this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
      }
    }
    if (isWGSL) {
      const sampler = new TextureSampler();
      sampler.setParameters();
      sampler.samplingMode = this.colorsSampling;
      this.setTextureSampler("grlColorsSampler", sampler);
    }
    engine.onDisposeObservable.add(() => {
      GreasedLineTools.DisposeEmptyColorsTexture();
    });
  }
  /**
   * Disposes the plugin material.
   */
  dispose() {
    this._colorsTexture?.dispose();
    super.dispose();
  }
  _setColorModeAndColorDistributionType() {
    this.setVector2("grl_colorModeAndColorDistributionType", new Vector2(this._colorMode, this._colorsDistributionType));
  }
  /**
   * Updates the material. Use when material created in lazy mode.
   */
  updateLazy() {
    if (this._colors) {
      this.setColors(this._colors, false, true);
    }
  }
  /**
   * Returns the colors used to colorize the line
   */
  get colors() {
    return this._colors;
  }
  /**
   * Sets the colors used to colorize the line
   */
  set colors(value) {
    this.setColors(value);
  }
  /**
   * Creates or updates the colors texture
   * @param colors color table RGBA
   * @param lazy if lazy, the colors are not updated
   * @param forceNewTexture force creation of a new texture
   */
  setColors(colors, lazy = false, forceNewTexture = false) {
    const origColorsCount = this._colors?.length ?? 0;
    this._colors = colors;
    if (colors === null || colors.length === 0) {
      this._colorsTexture?.dispose();
      return;
    }
    if (lazy && !forceNewTexture) {
      return;
    }
    if (this._colorsTexture && origColorsCount === colors.length && !forceNewTexture) {
      const colorArray = GreasedLineTools.Color3toRGBAUint8(colors);
      this._colorsTexture.update(colorArray);
    } else {
      this._colorsTexture?.dispose();
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, colors, this.colorsSampling, this.getScene());
    }
  }
  /**
   * Gets the colors texture
   */
  get colorsTexture() {
    return this._colorsTexture ?? null;
  }
  /**
   * Sets the colorsTexture
   */
  set colorsTexture(value) {
    this._colorsTexture = value;
    this.setFloat("grlColorsWidth", this._colorsTexture.getSize().width);
    this.setTexture("grlColors", this._colorsTexture);
  }
  /**
   * Line base width. At each point the line width is calculated by widths[pointIndex] * width
   */
  get width() {
    return this._width;
  }
  /**
   * Line base width. At each point the line width is calculated by widths[pointIndex] * width
   */
  set width(value) {
    this._width = value;
    this.setFloat("grlWidth", value);
  }
  /**
   * Whether to use the colors option to colorize the line
   */
  get useColors() {
    return this._useColors;
  }
  set useColors(value) {
    this._useColors = value;
    this.setFloat("grlUseColors", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * The type of sampling of the colors texture. The values are the same when using with textures.
   */
  get colorsSampling() {
    return this._colorsSampling;
  }
  /**
   * The type of sampling of the colors texture. The values are the same when using with textures.
   */
  set colorsSampling(value) {
    this._colorsSampling = value;
  }
  /**
   * Normalized value of how much of the line will be visible
   * 0 - 0% of the line will be visible
   * 1 - 100% of the line will be visible
   */
  get visibility() {
    return this._visibility;
  }
  set visibility(value) {
    this._visibility = value;
    this.setFloat("grlVisibility", value);
  }
  /**
   * Turns on/off dash mode
   */
  get useDash() {
    return this._useDash;
  }
  /**
   * Turns on/off dash mode
   */
  set useDash(value) {
    this._useDash = value;
    this.setFloat("grlUseDash", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * Gets the dash offset
   */
  get dashOffset() {
    return this._dashOffset;
  }
  /**
   * Sets the dash offset
   */
  set dashOffset(value) {
    this._dashOffset = value;
    this.setFloat("grlDashOffset", value);
  }
  /**
   * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
   */
  get dashRatio() {
    return this._dashRatio;
  }
  /**
   * Length of the dash. 0 to 1. 0.5 means half empty, half drawn.
   */
  set dashRatio(value) {
    this._dashRatio = value;
    this.setFloat("grlDashRatio", value);
  }
  /**
   * Gets the number of dashes in the line
   */
  get dashCount() {
    return this._dashCount;
  }
  /**
   * Sets the number of dashes in the line
   * @param value dash
   */
  set dashCount(value) {
    this._dashCount = value;
    this._dashArray = 1 / value;
    this.setFloat("grlDashArray", this._dashArray);
  }
  /**
   * False means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
   */
  get sizeAttenuation() {
    return this._sizeAttenuation;
  }
  /**
   * Turn on/off attenuation of the width option and widths array.
   * @param value false means 1 unit in width = 1 unit on scene, true means 1 unit in width is reduced on the screen to make better looking lines
   */
  set sizeAttenuation(value) {
    this._sizeAttenuation = value;
    this.setFloat("grlSizeAttenuation", GreasedLineTools.BooleanToNumber(value));
  }
  /**
   * Gets the color of the line
   */
  get color() {
    return this._color;
  }
  /**
   * Sets the color of the line
   * @param value Color3
   */
  set color(value) {
    this.setColor(value);
  }
  /**
   * Sets the color of the line. If set the whole line will be mixed with this color according to the colorMode option.
   * The simple material always needs a color to be set. If you set it to null it will set the color to the default color (GreasedLineSimpleMaterial.DEFAULT_COLOR).
   * @param value color
   */
  setColor(value) {
    value = value ?? GreasedLineMaterialDefaults.DEFAULT_COLOR;
    this._color = value;
    this.setColor3("grlColor", value);
  }
  /**
   * Gets the color distributiopn type
   */
  get colorsDistributionType() {
    return this._colorsDistributionType;
  }
  /**
   * Sets the color distribution type
   * @see GreasedLineMeshColorDistributionType
   * @param value color distribution type
   */
  set colorsDistributionType(value) {
    this._colorsDistributionType = value;
    this._setColorModeAndColorDistributionType();
  }
  /**
   * Gets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
   * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
   * @see GreasedLineMeshColorMode
   */
  get colorMode() {
    return this._colorMode;
  }
  /**
   * Sets the mixing mode of the color and colors paramaters. Default value is GreasedLineMeshColorMode.SET.
   * MATERIAL_TYPE_SIMPLE mixes the color and colors of the greased line material.
   * @see GreasedLineMeshColorMode
   */
  set colorMode(value) {
    this._colorMode = value;
    this._setColorModeAndColorDistributionType();
  }
  /**
   * Gets the resolution
   */
  get resolution() {
    return this._resolution;
  }
  /**
   * Sets the resolution
   * @param value resolution of the screen for GreasedLine
   */
  set resolution(value) {
    this._resolution = value;
    this.setVector2("grlResolution", value);
    this.setFloat("grlAspect", value.x / value.y);
  }
  /**
   * Serializes this plugin material
   * @returns serializationObjec
   */
  serialize() {
    const serializationObject = super.serialize();
    const greasedLineMaterialOptions = {
      colorDistributionType: this._colorsDistributionType,
      colorsSampling: this._colorsSampling,
      colorMode: this._colorMode,
      color: this._color,
      dashCount: this._dashCount,
      dashOffset: this._dashOffset,
      dashRatio: this._dashRatio,
      resolution: this._resolution,
      sizeAttenuation: this._sizeAttenuation,
      useColors: this._useColors,
      useDash: this._useDash,
      visibility: this._visibility,
      width: this._width,
      cameraFacing: this._cameraFacing
    };
    if (this._colors) {
      greasedLineMaterialOptions.colors = this._colors;
    }
    serializationObject.greasedLineMaterialOptions = greasedLineMaterialOptions;
    return serializationObject;
  }
  /**
   * Parses a serialized objects
   * @param source serialized object
   * @param scene scene
   * @param _rootUrl root url for textures
   */
  parse(source, scene, _rootUrl) {
    const greasedLineMaterialOptions = source.greasedLineMaterialOptions;
    this._colorsTexture?.dispose();
    if (greasedLineMaterialOptions.color) {
      this.color = greasedLineMaterialOptions.color;
    }
    if (greasedLineMaterialOptions.colorDistributionType) {
      this.colorsDistributionType = greasedLineMaterialOptions.colorDistributionType;
    }
    if (greasedLineMaterialOptions.colorsSampling) {
      this.colorsSampling = greasedLineMaterialOptions.colorsSampling;
    }
    if (greasedLineMaterialOptions.colorMode) {
      this.colorMode = greasedLineMaterialOptions.colorMode;
    }
    if (greasedLineMaterialOptions.useColors) {
      this.useColors = greasedLineMaterialOptions.useColors;
    }
    if (greasedLineMaterialOptions.visibility) {
      this.visibility = greasedLineMaterialOptions.visibility;
    }
    if (greasedLineMaterialOptions.useDash) {
      this.useDash = greasedLineMaterialOptions.useDash;
    }
    if (greasedLineMaterialOptions.dashCount) {
      this.dashCount = greasedLineMaterialOptions.dashCount;
    }
    if (greasedLineMaterialOptions.dashRatio) {
      this.dashRatio = greasedLineMaterialOptions.dashRatio;
    }
    if (greasedLineMaterialOptions.dashOffset) {
      this.dashOffset = greasedLineMaterialOptions.dashOffset;
    }
    if (greasedLineMaterialOptions.width) {
      this.width = greasedLineMaterialOptions.width;
    }
    if (greasedLineMaterialOptions.sizeAttenuation) {
      this.sizeAttenuation = greasedLineMaterialOptions.sizeAttenuation;
    }
    if (greasedLineMaterialOptions.resolution) {
      this.resolution = greasedLineMaterialOptions.resolution;
    }
    if (greasedLineMaterialOptions.colors) {
      this.colorsTexture = GreasedLineTools.CreateColorsTexture(`${this.name}-colors-texture`, greasedLineMaterialOptions.colors, this.colorsSampling, this.getScene());
    } else {
      this.colorsTexture = GreasedLineTools.PrepareEmptyColorsTexture(scene);
    }
    this._cameraFacing = greasedLineMaterialOptions.cameraFacing ?? true;
    this.setDefine("GREASED_LINE_CAMERA_FACING", this._cameraFacing);
  }
};
GreasedLineSimpleMaterial.ForceGLSL = false;

// node_modules/@babylonjs/core/Meshes/Compression/dracoEncoder.js
function GetDracoAttributeName(kind) {
  if (kind === VertexBuffer.PositionKind) {
    return "POSITION";
  } else if (kind === VertexBuffer.NormalKind) {
    return "NORMAL";
  } else if (kind === VertexBuffer.ColorKind) {
    return "COLOR";
  } else if (kind.startsWith(VertexBuffer.UVKind)) {
    return "TEX_COORD";
  }
  return "GENERIC";
}
function PrepareIndicesForDraco(input) {
  let indices = input.getIndices(void 0, true);
  if (indices && !(indices instanceof Uint32Array) && !(indices instanceof Uint16Array)) {
    indices = (AreIndices32Bits(indices, indices.length) ? Uint32Array : Uint16Array).from(indices);
  }
  return indices;
}
function PrepareAttributesForDraco(input, excludedAttributes) {
  const attributes = [];
  for (const kind of input.getVerticesDataKinds()) {
    if (excludedAttributes?.includes(kind)) {
      if (kind === VertexBuffer.PositionKind) {
        throw new Error("Cannot exclude position attribute from Draco encoding.");
      }
      continue;
    }
    const vertexBuffer = input.getVertexBuffer(kind);
    const size = vertexBuffer.getSize();
    const data = GetTypedArrayData(vertexBuffer.getData(), size, vertexBuffer.type, vertexBuffer.byteOffset, vertexBuffer.byteStride, input.getTotalVertices(), true);
    attributes.push({ kind, dracoName: GetDracoAttributeName(kind), size, data });
  }
  return attributes;
}
var DefaultEncoderOptions = {
  decodeSpeed: 5,
  encodeSpeed: 5,
  method: "MESH_EDGEBREAKER_ENCODING",
  quantizationBits: {
    POSITION: 14,
    NORMAL: 10,
    COLOR: 8,
    TEX_COORD: 12,
    GENERIC: 12
  }
};
var DracoEncoder = class _DracoEncoder extends DracoCodec {
  /**
   * Returns true if the encoder's `DefaultConfiguration` is available.
   */
  static get DefaultAvailable() {
    return _IsConfigurationAvailable(_DracoEncoder.DefaultConfiguration);
  }
  /**
   * Default instance for the DracoEncoder.
   */
  static get Default() {
    _DracoEncoder._Default ?? (_DracoEncoder._Default = new _DracoEncoder());
    return _DracoEncoder._Default;
  }
  /**
   * Reset the default DracoEncoder object to null and disposing the removed default instance.
   * Note that if the workerPool is a member of the static DefaultConfiguration object it is recommended not to run dispose,
   * unless the static worker pool is no longer needed.
   * @param skipDispose set to true to not dispose the removed default instance
   */
  static ResetDefault(skipDispose) {
    if (_DracoEncoder._Default) {
      if (!skipDispose) {
        _DracoEncoder._Default.dispose();
      }
      _DracoEncoder._Default = null;
    }
  }
  _isModuleAvailable() {
    return typeof DracoEncoderModule !== "undefined";
  }
  async _createModuleAsync(wasmBinary, jsModule) {
    const module = await (jsModule || DracoEncoderModule)({ wasmBinary });
    return { module };
  }
  _getWorkerContent() {
    return `${EncodeMesh}(${EncoderWorkerFunction})()`;
  }
  /**
   * Creates a new Draco encoder.
   * @param configuration Optional override of the configuration for the DracoEncoder. If not provided, defaults to {@link DracoEncoder.DefaultConfiguration}.
   */
  constructor(configuration = _DracoEncoder.DefaultConfiguration) {
    super(configuration);
  }
  /**
   * @internal
   */
  async _encodeAsync(attributes, indices, options) {
    const mergedOptions = options ? deepMerge(DefaultEncoderOptions, options) : DefaultEncoderOptions;
    if (this._workerPoolPromise) {
      const workerPool = await this._workerPoolPromise;
      return await new Promise((resolve, reject) => {
        workerPool.push((worker, onComplete) => {
          const onError = (error) => {
            worker.removeEventListener("error", onError);
            worker.removeEventListener("message", onMessage);
            reject(error);
            onComplete();
          };
          const onMessage = (message) => {
            if (message.data.id === "encodeMeshDone") {
              worker.removeEventListener("error", onError);
              worker.removeEventListener("message", onMessage);
              resolve(message.data.encodedMeshData);
              onComplete();
            }
          };
          worker.addEventListener("error", onError);
          worker.addEventListener("message", onMessage);
          const transferList = [];
          for (const attribute of attributes) {
            transferList.push(attribute.data.buffer);
          }
          if (indices) {
            transferList.push(indices.buffer);
          }
          worker.postMessage({ id: "encodeMesh", attributes, indices, options: mergedOptions }, transferList);
        });
      });
    }
    if (this._modulePromise) {
      const encoder = await this._modulePromise;
      return EncodeMesh(encoder.module, attributes, indices, mergedOptions);
    }
    throw new Error("Draco encoder module is not available");
  }
  /**
   * Encodes a mesh or geometry into a Draco-encoded mesh data.
   * @param input the mesh or geometry to encode
   * @param options options for the encoding
   * @returns a promise that resolves to the newly-encoded data
   */
  async encodeMeshAsync(input, options) {
    const verticesCount = input.getTotalVertices();
    if (verticesCount == 0) {
      throw new Error("Cannot compress geometry with Draco. There are no vertices.");
    }
    if (input instanceof Mesh && input.morphTargetManager && options?.method === "MESH_EDGEBREAKER_ENCODING") {
      Logger.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method.");
      options.method = "MESH_SEQUENTIAL_ENCODING";
    }
    const indices = PrepareIndicesForDraco(input);
    const attributes = PrepareAttributesForDraco(input, options?.excludedAttributes);
    return await this._encodeAsync(attributes, indices, options);
  }
};
DracoEncoder.DefaultConfiguration = {
  wasmUrl: `${Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,
  wasmBinaryUrl: `${Tools._DefaultCdnUrl}/draco_encoder.wasm`,
  fallbackUrl: `${Tools._DefaultCdnUrl}/draco_encoder.js`
};
DracoEncoder._Default = null;

// node_modules/@babylonjs/core/Meshes/GreasedLine/greasedLineBaseMesh.js
var GreasedLineRibbonPointsMode;
(function(GreasedLineRibbonPointsMode2) {
  GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_POINTS"] = 0] = "POINTS_MODE_POINTS";
  GreasedLineRibbonPointsMode2[GreasedLineRibbonPointsMode2["POINTS_MODE_PATHS"] = 1] = "POINTS_MODE_PATHS";
})(GreasedLineRibbonPointsMode || (GreasedLineRibbonPointsMode = {}));
var GreasedLineRibbonFacesMode;
(function(GreasedLineRibbonFacesMode2) {
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED"] = 0] = "FACES_MODE_SINGLE_SIDED";
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING"] = 1] = "FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING";
  GreasedLineRibbonFacesMode2[GreasedLineRibbonFacesMode2["FACES_MODE_DOUBLE_SIDED"] = 2] = "FACES_MODE_DOUBLE_SIDED";
})(GreasedLineRibbonFacesMode || (GreasedLineRibbonFacesMode = {}));
var GreasedLineRibbonAutoDirectionMode;
(function(GreasedLineRibbonAutoDirectionMode2) {
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_FIRST_SEGMENT"] = 0] = "AUTO_DIRECTIONS_FROM_FIRST_SEGMENT";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FROM_ALL_SEGMENTS"] = 1] = "AUTO_DIRECTIONS_FROM_ALL_SEGMENTS";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_ENHANCED"] = 2] = "AUTO_DIRECTIONS_ENHANCED";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_FACE_TO"] = 3] = "AUTO_DIRECTIONS_FACE_TO";
  GreasedLineRibbonAutoDirectionMode2[GreasedLineRibbonAutoDirectionMode2["AUTO_DIRECTIONS_NONE"] = 99] = "AUTO_DIRECTIONS_NONE";
})(GreasedLineRibbonAutoDirectionMode || (GreasedLineRibbonAutoDirectionMode = {}));
var GreasedLineBaseMesh = class extends Mesh {
  constructor(name, scene, _options) {
    super(name, scene, null, null, false, false);
    this.name = name;
    this._options = _options;
    this._lazy = false;
    this._updatable = false;
    this._engine = scene.getEngine();
    this._lazy = _options.lazy ?? false;
    this._updatable = _options.updatable ?? false;
    this._vertexPositions = [];
    this._indices = [];
    this._uvs = [];
    this._points = [];
    this._colorPointers = _options.colorPointers ?? [];
    this._widths = _options.widths ?? new Array(_options.points.length).fill(1);
  }
  /**
   * "GreasedLineMesh"
   * @returns "GreasedLineMesh"
   */
  getClassName() {
    return "GreasedLineMesh";
  }
  _updateWidthsWithValue(defaulValue) {
    let pointCount = 0;
    for (const points of this._points) {
      pointCount += points.length;
    }
    const countDiff = pointCount / 3 * 2 - this._widths.length;
    for (let i = 0; i < countDiff; i++) {
      this._widths.push(defaulValue);
    }
  }
  /**
   * Updated a lazy line. Rerenders the line and updates boundinfo as well.
   */
  updateLazy() {
    this._setPoints(this._points);
    if (!this._options.colorPointers) {
      this._updateColorPointers();
    }
    this._createVertexBuffers(this._options.ribbonOptions?.smoothShading);
    !this.doNotSyncBoundingInfo && this.refreshBoundingInfo();
    this.greasedLineMaterial?.updateLazy();
  }
  /**
   * Adds new points to the line. It doesn't rerenders the line if in lazy mode.
   * @param points points table
   * @param options optional options
   */
  addPoints(points, options) {
    for (const p of points) {
      this._points.push(p);
    }
    if (!this._lazy) {
      this.setPoints(this._points, options);
    }
  }
  /**
   * Dispose the line and it's resources
   * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)
   * @param disposeMaterialAndTextures Set to true to also dispose referenced materials and textures (false by default)
   */
  dispose(doNotRecurse, disposeMaterialAndTextures = false) {
    super.dispose(doNotRecurse, disposeMaterialAndTextures);
  }
  /**
   * @returns true if the mesh was created in lazy mode
   */
  isLazy() {
    return this._lazy;
  }
  /**
   * Returns the UVs
   */
  get uvs() {
    return this._uvs;
  }
  /**
   * Sets the UVs
   * @param uvs the UVs
   */
  set uvs(uvs) {
    this._uvs = uvs instanceof Float32Array ? uvs : new Float32Array(uvs);
    this._createVertexBuffers();
  }
  /**
   * Returns the points offsets
   * Return the points offsets
   */
  get offsets() {
    return this._offsets;
  }
  /**
   * Sets point offests
   * @param offsets offset table [x,y,z, x,y,z, ....]
   */
  set offsets(offsets) {
    if (this.material instanceof GreasedLineSimpleMaterial) {
      this.material.setDefine(GreasedLineUseOffsetsSimpleMaterialDefine, offsets?.length > 0);
    }
    this._offsets = offsets;
    if (!this._offsetsBuffer) {
      this._createOffsetsBuffer(offsets);
    } else {
      this._offsetsBuffer.update(offsets);
    }
  }
  /**
   * Gets widths at each line point like [widthLower, widthUpper, widthLower, widthUpper, ...]
   */
  get widths() {
    return this._widths;
  }
  /**
   * Sets widths at each line point
   * @param widths width table [widthLower, widthUpper, widthLower, widthUpper ...]
   */
  set widths(widths) {
    this._widths = widths;
    if (!this._lazy) {
      this._widthsBuffer && this._widthsBuffer.update(widths);
    }
  }
  /**
   * Gets the color pointer. Each vertex need a color pointer. These color pointers points to the colors in the color table @see colors
   */
  get colorPointers() {
    return this._colorPointers;
  }
  /**
   * Sets the color pointer
   * @param colorPointers array of color pointer in the colors array. One pointer for every vertex is needed.
   */
  set colorPointers(colorPointers) {
    this._colorPointers = colorPointers;
    if (!this._lazy) {
      this._colorPointersBuffer && this._colorPointersBuffer.update(colorPointers);
    }
  }
  /**
   * Gets the pluginMaterial associated with line
   */
  get greasedLineMaterial() {
    if (this.material && this.material instanceof GreasedLineSimpleMaterial) {
      return this.material;
    }
    const materialPlugin = this.material?.pluginManager?.getPlugin(GreasedLinePluginMaterial.GREASED_LINE_MATERIAL_NAME);
    if (materialPlugin) {
      return materialPlugin;
    }
    return;
  }
  /**
   * Return copy the points.
   */
  get points() {
    const pointsCopy = [];
    DeepCopier.DeepCopy(this._points, pointsCopy);
    return pointsCopy;
  }
  /**
   * Sets line points and rerenders the line.
   * @param points points table
   * @param options optional options
   */
  setPoints(points, options) {
    this._points = GreasedLineTools.ConvertPoints(points, options?.pointsOptions ?? this._options.pointsOptions);
    this._updateWidths();
    if (!options?.colorPointers) {
      this._updateColorPointers();
    }
    this._setPoints(this._points, options);
  }
  _initGreasedLine() {
    this._vertexPositions = [];
    this._indices = [];
    this._uvs = [];
  }
  _createLineOptions() {
    const lineOptions = {
      points: this._points,
      colorPointers: this._colorPointers,
      lazy: this._lazy,
      updatable: this._updatable,
      uvs: this._uvs,
      widths: this._widths,
      ribbonOptions: this._options.ribbonOptions
    };
    return lineOptions;
  }
  /**
   * Serializes this GreasedLineMesh
   * @param serializationObject object to write serialization to
   */
  serialize(serializationObject) {
    super.serialize(serializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.lineOptions = this._createLineOptions();
  }
  _createVertexBuffers(computeNormals = false) {
    const vertexData = new VertexData();
    vertexData.positions = this._vertexPositions;
    vertexData.indices = this._indices;
    vertexData.uvs = this._uvs;
    if (computeNormals) {
      vertexData.normals = [];
      VertexData.ComputeNormals(this._vertexPositions, this._indices, vertexData.normals);
    }
    vertexData.applyToMesh(this, this._options.updatable);
    return vertexData;
  }
  _createOffsetsBuffer(offsets) {
    const engine = this._scene.getEngine();
    const offsetBuffer = new Buffer(engine, offsets, this._updatable, 3);
    this.setVerticesBuffer(offsetBuffer.createVertexBuffer("grl_offsets", 0, 3));
    this._offsetsBuffer = offsetBuffer;
  }
};

export {
  LinesMesh,
  InstancedLinesMesh,
  Polygon,
  PolygonMeshBuilder,
  CreatePolygonVertexData,
  CreatePolygon,
  ExtrudePolygon,
  PolygonBuilder,
  CreateTextShapePaths,
  CreateText,
  ProceduralTextureSceneComponent,
  ProceduralTexture,
  SpecularPowerToRoughness,
  GreasedLineMaterialDefaults,
  GreasedLineTools,
  MaterialGreasedLineDefines,
  GreasedLinePluginMaterial,
  GreasedLineUseOffsetsSimpleMaterialDefine,
  GreasedLineSimpleMaterial,
  DracoEncoder,
  GreasedLineRibbonPointsMode,
  GreasedLineRibbonFacesMode,
  GreasedLineRibbonAutoDirectionMode,
  GreasedLineBaseMesh
};
//# sourceMappingURL=chunk-IQTA53RS.js.map
