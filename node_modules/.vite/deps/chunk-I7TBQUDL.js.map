{
  "version": 3,
  "sources": ["../../../dev/core/src/Misc/environmentTextureTools.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { ILog2 } from \"../Maths/math.scalar.functions\";\r\nimport { SphericalPolynomial } from \"../Maths/sphericalPolynomial\";\r\nimport { InternalTexture, InternalTextureSource } from \"../Materials/Textures/internalTexture\";\r\nimport { BaseTexture } from \"../Materials/Textures/baseTexture\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { Scene } from \"../scene\";\r\nimport { PostProcess } from \"../PostProcesses/postProcess\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { RGBDTextureTools } from \"./rgbdTextureTools\";\r\nimport { DumpDataAsync } from \"../Misc/dumpTools\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\n\r\nimport type { RenderTargetWrapper } from \"../Engines/renderTargetWrapper\";\r\nimport type { Engine, WebGPUEngine } from \"core/Engines\";\r\n\r\nimport \"../Materials/Textures/baseTexture.polynomial\";\r\n\r\nconst DefaultEnvironmentTextureImageType = \"image/png\";\r\nconst CurrentVersion = 2;\r\n\r\n/**\r\n * Raw texture data and descriptor sufficient for WebGL texture upload\r\n */\r\nexport type EnvironmentTextureInfo = EnvironmentTextureInfoV1 | EnvironmentTextureInfoV2;\r\n\r\n/**\r\n * v1 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV1 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 1;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: Nullable<EnvironmentTextureIrradianceInfoV1>;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: EnvironmentTextureSpecularInfoV1;\r\n}\r\n\r\n/**\r\n * v2 of EnvironmentTextureInfo\r\n */\r\ninterface EnvironmentTextureInfoV2 {\r\n    /**\r\n     * Version of the environment map\r\n     */\r\n    version: 2;\r\n\r\n    /**\r\n     * Width of image\r\n     */\r\n    width: number;\r\n\r\n    /**\r\n     * Irradiance information stored in the file.\r\n     */\r\n    irradiance: Nullable<EnvironmentTextureIrradianceInfoV1>;\r\n\r\n    /**\r\n     * Specular information stored in the file.\r\n     */\r\n    specular: EnvironmentTextureSpecularInfoV1;\r\n\r\n    /**\r\n     * The mime type used to encode the image data.\r\n     */\r\n    imageType: string;\r\n\r\n    /**\r\n     * Defines where the specular Payload is located. It is a runtime value only not stored in the file.\r\n     */\r\n    binaryDataPosition?: number;\r\n}\r\n\r\n/**\r\n * Defines One Image in the file. It requires only the position in the file\r\n * as well as the length.\r\n */\r\ninterface BufferImageData {\r\n    /**\r\n     * Length of the image data.\r\n     */\r\n    length: number;\r\n    /**\r\n     * Position of the data from the null terminator delimiting the end of the JSON.\r\n     */\r\n    position: number;\r\n}\r\n\r\n/**\r\n * Defines the diffuse data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureIrradianceTextureInfoV1 {\r\n    /**\r\n     * Size of the texture faces.\r\n     */\r\n    size: number;\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    faces: Array<BufferImageData>;\r\n\r\n    /**\r\n     * The dominant direction of light in the environment texture.\r\n     */\r\n    dominantDirection?: Array<number>;\r\n}\r\n\r\n/**\r\n * Defines the specular data enclosed in the file.\r\n * This corresponds to the version 1 of the data.\r\n */\r\nexport interface EnvironmentTextureSpecularInfoV1 {\r\n    /**\r\n     * This contains all the images data needed to reconstruct the cubemap.\r\n     */\r\n    mipmaps: Array<BufferImageData>;\r\n\r\n    /**\r\n     * Defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness.\r\n     */\r\n    lodGenerationScale: number;\r\n}\r\n\r\n/**\r\n * Defines the required storage to save the environment irradiance information.\r\n */\r\ninterface EnvironmentTextureIrradianceInfoV1 {\r\n    x: Array<number>;\r\n    y: Array<number>;\r\n    z: Array<number>;\r\n\r\n    xx: Array<number>;\r\n    yy: Array<number>;\r\n    zz: Array<number>;\r\n\r\n    yz: Array<number>;\r\n    zx: Array<number>;\r\n    xy: Array<number>;\r\n\r\n    irradianceTexture?: EnvironmentTextureIrradianceTextureInfoV1 | undefined;\r\n}\r\n\r\n/**\r\n * Options for creating environment textures\r\n */\r\nexport interface CreateEnvTextureOptions {\r\n    /**\r\n     * The mime type of encoded images.\r\n     */\r\n    imageType?: string;\r\n\r\n    /**\r\n     * the image quality of encoded WebP images.\r\n     */\r\n    imageQuality?: number;\r\n\r\n    /**\r\n     * Disables the generation of irradiance texture even if present on the source.\r\n     */\r\n    disableIrradianceTexture?: boolean;\r\n}\r\n\r\n/**\r\n * Magic number identifying the env file.\r\n */\r\nconst MagicBytes = [0x86, 0x16, 0x87, 0x96, 0xf6, 0xd6, 0x96, 0x36];\r\n\r\n/**\r\n * Gets the environment info from an env file.\r\n * @param data The array buffer containing the .env bytes.\r\n * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n */\r\nexport function GetEnvInfo(data: ArrayBufferView): Nullable<EnvironmentTextureInfoV2> {\r\n    const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n    let pos = 0;\r\n\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        if (dataView.getUint8(pos++) !== MagicBytes[i]) {\r\n            Logger.Error(\"Not a babylon environment map\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Read json manifest - collect characters up to null terminator\r\n    let manifestString = \"\";\r\n    let charCode = 0x00;\r\n    while ((charCode = dataView.getUint8(pos++))) {\r\n        manifestString += String.fromCharCode(charCode);\r\n    }\r\n\r\n    let manifest: EnvironmentTextureInfo = JSON.parse(manifestString);\r\n    manifest = normalizeEnvInfo(manifest);\r\n    // Extend the header with the position of the payload.\r\n    manifest.binaryDataPosition = pos;\r\n\r\n    if (manifest.specular) {\r\n        // Fallback to 0.8 exactly if lodGenerationScale is not defined for backward compatibility.\r\n        manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;\r\n    }\r\n\r\n    return manifest;\r\n}\r\n\r\n/**\r\n * Normalizes any supported version of the environment file info to the latest version\r\n * @param info environment file info on any supported version\r\n * @returns environment file info in the latest supported version\r\n * @private\r\n */\r\nexport function normalizeEnvInfo(info: EnvironmentTextureInfo): EnvironmentTextureInfoV2 {\r\n    if (info.version > CurrentVersion) {\r\n        throw new Error(`Unsupported babylon environment map version \"${info.version}\". Latest supported version is \"${CurrentVersion}\".`);\r\n    }\r\n\r\n    if (info.version === 2) {\r\n        return info;\r\n    }\r\n\r\n    // Migrate a v1 info to v2\r\n    info = { ...info, version: 2, imageType: DefaultEnvironmentTextureImageType };\r\n\r\n    return info;\r\n}\r\n\r\n/**\r\n * Creates an environment texture from a loaded cube texture.\r\n * @param texture defines the cube texture to convert in env file\r\n * @param options options for the conversion process\r\n * @returns a promise containing the environment data if successful.\r\n */\r\nexport async function CreateEnvTextureAsync(texture: BaseTexture, options: CreateEnvTextureOptions = {}): Promise<ArrayBuffer> {\r\n    const internalTexture = texture.getInternalTexture();\r\n    if (!internalTexture) {\r\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n        return await Promise.reject(\"The cube texture is invalid.\");\r\n    }\r\n\r\n    const engine = internalTexture.getEngine();\r\n\r\n    if (\r\n        texture.textureType !== Constants.TEXTURETYPE_HALF_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_FLOAT &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_BYTE &&\r\n        texture.textureType !== Constants.TEXTURETYPE_UNSIGNED_INTEGER &&\r\n        texture.textureType !== -1\r\n    ) {\r\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n        return await Promise.reject(\"The cube texture should allow HDR (Full Float or Half Float).\");\r\n    }\r\n\r\n    let textureType = Constants.TEXTURETYPE_FLOAT;\r\n    if (!engine.getCaps().textureFloatRender) {\r\n        textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n        if (!engine.getCaps().textureHalfFloatRender) {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            return await Promise.reject(\"Env texture can only be created when the browser supports half float or full float rendering.\");\r\n        }\r\n    }\r\n\r\n    // sphericalPolynomial is lazy loaded so simply accessing it should trigger the computation.\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-expressions\r\n    texture.sphericalPolynomial;\r\n\r\n    // Lets keep track of the polynomial promise so we can wait for it to be ready before generating the pixels.\r\n    const sphericalPolynomialPromise = texture.getInternalTexture()?._sphericalPolynomialPromise;\r\n\r\n    const cubeWidth = internalTexture.width;\r\n    const hostingScene = new Scene(engine);\r\n    const specularTextures: { [key: number]: ArrayBuffer } = {};\r\n    const diffuseTextures: { [key: number]: ArrayBuffer } = {};\r\n\r\n    // As we are going to readPixels the faces of the cube, make sure the drawing/update commands for the cube texture are fully sent to the GPU in case it is drawn for the first time in this very frame!\r\n    engine.flushFramebuffer();\r\n\r\n    const imageType = options.imageType ?? DefaultEnvironmentTextureImageType;\r\n\r\n    // Read and collect all mipmaps data from the cube.\r\n    const mipmapsCount = ILog2(internalTexture.width);\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        const faceWidth = Math.pow(2, mipmapsCount - i);\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            specularTextures[i * 6 + face] = await _GetTextureEncodedDataAsync(hostingScene, texture, textureType, face, i, faceWidth, imageType, options.imageQuality);\r\n        }\r\n    }\r\n\r\n    // Read and collect all irradiance data from the cube.\r\n    const irradianceTexture = options.disableIrradianceTexture ? null : texture.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        const faceWidth = irradianceTexture.getSize().width;\r\n\r\n        // All faces of the cube.\r\n        for (let face = 0; face < 6; face++) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            diffuseTextures[face] = await _GetTextureEncodedDataAsync(hostingScene, irradianceTexture, textureType, face, 0, faceWidth, imageType, options.imageQuality);\r\n        }\r\n    }\r\n\r\n    // We can delete the hosting scene keeping track of all the creation objects\r\n    hostingScene.dispose();\r\n\r\n    // Ensure completion of the polynomial creation promise.\r\n    if (sphericalPolynomialPromise) {\r\n        await sphericalPolynomialPromise;\r\n    }\r\n\r\n    // Creates the json header for the env texture\r\n    const info: EnvironmentTextureInfo = {\r\n        version: CurrentVersion,\r\n        width: cubeWidth,\r\n        imageType,\r\n        irradiance: CreateEnvTextureIrradiance(texture),\r\n        specular: {\r\n            mipmaps: [],\r\n            lodGenerationScale: texture.lodGenerationScale,\r\n        },\r\n    };\r\n\r\n    // Sets the specular image data information\r\n    let position = 0;\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = specularTextures[i * 6 + face].byteLength;\r\n            info.specular.mipmaps.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Sets the irradiance image data information\r\n    if (irradianceTexture) {\r\n        info.irradiance = info.irradiance || {\r\n            x: [0, 0, 0],\r\n            xx: [0, 0, 0],\r\n            y: [0, 0, 0],\r\n            yy: [0, 0, 0],\r\n            z: [0, 0, 0],\r\n            zz: [0, 0, 0],\r\n            yz: [0, 0, 0],\r\n            zx: [0, 0, 0],\r\n            xy: [0, 0, 0],\r\n        };\r\n        info.irradiance.irradianceTexture = {\r\n            size: irradianceTexture.getSize().width,\r\n            faces: [],\r\n            dominantDirection: irradianceTexture._dominantDirection?.asArray(),\r\n        };\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            const byteLength = diffuseTextures[face].byteLength;\r\n            info.irradiance.irradianceTexture.faces.push({\r\n                length: byteLength,\r\n                position: position,\r\n            });\r\n            position += byteLength;\r\n        }\r\n    }\r\n\r\n    // Encode the JSON as an array buffer\r\n    const infoString = JSON.stringify(info);\r\n    const infoBuffer = new ArrayBuffer(infoString.length + 1);\r\n    const infoView = new Uint8Array(infoBuffer); // Limited to ascii subset matching unicode.\r\n    for (let i = 0, strLen = infoString.length; i < strLen; i++) {\r\n        infoView[i] = infoString.charCodeAt(i);\r\n    }\r\n    // Ends up with a null terminator for easier parsing\r\n    infoView[infoString.length] = 0x00;\r\n\r\n    // Computes the final required size and creates the storage\r\n    const totalSize = MagicBytes.length + position + infoBuffer.byteLength;\r\n    const finalBuffer = new ArrayBuffer(totalSize);\r\n    const finalBufferView = new Uint8Array(finalBuffer);\r\n    const dataView = new DataView(finalBuffer);\r\n\r\n    // Copy the magic bytes identifying the file in\r\n    let pos = 0;\r\n    for (let i = 0; i < MagicBytes.length; i++) {\r\n        dataView.setUint8(pos++, MagicBytes[i]);\r\n    }\r\n\r\n    // Add the json info\r\n    finalBufferView.set(new Uint8Array(infoBuffer), pos);\r\n    pos += infoBuffer.byteLength;\r\n\r\n    // Finally inserts the radiance texture data\r\n    for (let i = 0; i <= mipmapsCount; i++) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = specularTextures[i * 6 + face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Finally inserts the irradiance texture data\r\n    if (irradianceTexture) {\r\n        for (let face = 0; face < 6; face++) {\r\n            const dataBuffer = diffuseTextures[face];\r\n            finalBufferView.set(new Uint8Array(dataBuffer), pos);\r\n            pos += dataBuffer.byteLength;\r\n        }\r\n    }\r\n\r\n    // Voila\r\n    return finalBuffer;\r\n}\r\n\r\n/**\r\n * Get the texture encoded data from the current texture\r\n * @internal\r\n */\r\nasync function _GetTextureEncodedDataAsync(\r\n    hostingScene: Scene,\r\n    texture: BaseTexture,\r\n    textureType: number,\r\n    face: number,\r\n    i: number,\r\n    size: number,\r\n    imageType: string,\r\n    imageQuality?: number\r\n) {\r\n    let faceData = await texture.readPixels(face, i, undefined, false);\r\n    if (faceData && faceData.byteLength === (faceData as Uint8Array).length) {\r\n        const faceDataFloat = new Float32Array(faceData.byteLength * 4);\r\n        for (let i = 0; i < faceData.byteLength; i++) {\r\n            faceDataFloat[i] = (faceData as Uint8Array)[i] / 255;\r\n            // Gamma to linear\r\n            faceDataFloat[i] = Math.pow(faceDataFloat[i], 2.2);\r\n        }\r\n        faceData = faceDataFloat;\r\n    } else if (faceData && texture.gammaSpace) {\r\n        const floatData = faceData as Float32Array;\r\n        for (let i = 0; i < floatData.length; i++) {\r\n            // Gamma to linear\r\n            floatData[i] = Math.pow(floatData[i], 2.2);\r\n        }\r\n    }\r\n\r\n    const engine = hostingScene.getEngine();\r\n    const tempTexture = engine.createRawTexture(faceData, size, size, Constants.TEXTUREFORMAT_RGBA, false, true, Constants.TEXTURE_NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n    await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);\r\n\r\n    const rgbdEncodedData = await engine._readTexturePixels(tempTexture, size, size);\r\n\r\n    const imageEncodedData = await DumpDataAsync(size, size, rgbdEncodedData, imageType, undefined, false, true, imageQuality);\r\n\r\n    tempTexture.dispose();\r\n\r\n    return imageEncodedData as ArrayBuffer;\r\n}\r\n\r\n/**\r\n * Creates a JSON representation of the spherical data.\r\n * @param texture defines the texture containing the polynomials\r\n * @returns the JSON representation of the spherical info\r\n */\r\nfunction CreateEnvTextureIrradiance(texture: BaseTexture): Nullable<EnvironmentTextureIrradianceInfoV1> {\r\n    const polynmials = texture.sphericalPolynomial;\r\n    if (polynmials == null) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],\r\n        y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],\r\n        z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],\r\n\r\n        xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],\r\n        yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],\r\n        zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],\r\n\r\n        yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],\r\n        zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],\r\n        xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z],\r\n    };\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateRadianceImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<Array<ArrayBufferView>> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular;\r\n\r\n    // Double checks the enclosed info\r\n    let mipmapsCount = Math.log2(info.width);\r\n    mipmapsCount = Math.round(mipmapsCount) + 1;\r\n    if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {\r\n        throw new Error(`Unsupported specular mipmaps number \"${specularInfo.mipmaps.length}\"`);\r\n    }\r\n\r\n    const imageData = new Array<Array<ArrayBufferView>>(mipmapsCount);\r\n    for (let i = 0; i < mipmapsCount; i++) {\r\n        imageData[i] = new Array<ArrayBufferView>(6);\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = specularInfo.mipmaps[i * 6 + face];\r\n            imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n * @param data the image data\r\n * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n * @returns the views described by info providing access to the underlying buffer\r\n */\r\nexport function CreateIrradianceImageDataArrayBufferViews(data: ArrayBufferView, info: EnvironmentTextureInfo): Array<ArrayBufferView> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const imageData = new Array<ArrayBufferView>(6);\r\n\r\n    const irradianceTexture = info.irradiance?.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        if (irradianceTexture.faces.length !== 6) {\r\n            throw new Error(`Incorrect irradiance texture faces number \"${irradianceTexture.faces.length}\"`);\r\n        }\r\n\r\n        for (let face = 0; face < 6; face++) {\r\n            const imageInfo = irradianceTexture.faces[face];\r\n            imageData[face] = new Uint8Array(data.buffer, data.byteOffset + info.binaryDataPosition! + imageInfo.position, imageInfo.length);\r\n        }\r\n    }\r\n\r\n    return imageData;\r\n}\r\n\r\n/**\r\n * Uploads the texture info contained in the env file to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param data defines the data to load\r\n * @param info defines the texture info retrieved through the GetEnvInfo method\r\n * @returns a promise\r\n */\r\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\nexport function UploadEnvLevelsAsync(texture: InternalTexture, data: ArrayBufferView, info: EnvironmentTextureInfo): Promise<void[]> {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const specularInfo = info.specular;\r\n    if (!specularInfo) {\r\n        // Nothing else parsed so far\r\n        return Promise.resolve([]);\r\n    }\r\n\r\n    texture._lodGenerationScale = specularInfo.lodGenerationScale;\r\n\r\n    const promises: Promise<void>[] = [];\r\n\r\n    const radianceImageData = CreateRadianceImageDataArrayBufferViews(data, info);\r\n    promises.push(UploadRadianceLevelsAsync(texture, radianceImageData, info.imageType));\r\n\r\n    const irradianceTexture = info.irradiance?.irradianceTexture;\r\n    if (irradianceTexture) {\r\n        const irradianceImageData = CreateIrradianceImageDataArrayBufferViews(data, info);\r\n        let dominantDirection = null;\r\n        if (info.irradiance?.irradianceTexture?.dominantDirection) {\r\n            dominantDirection = Vector3.FromArray(info.irradiance.irradianceTexture.dominantDirection);\r\n        }\r\n        promises.push(UploadIrradianceLevelsAsync(texture, irradianceImageData, irradianceTexture.size, info.imageType, dominantDirection));\r\n    }\r\n\r\n    return Promise.all(promises);\r\n}\r\n\r\nasync function _OnImageReadyAsync(\r\n    image: HTMLImageElement | ImageBitmap,\r\n    engine: Engine | WebGPUEngine,\r\n    expandTexture: boolean,\r\n    rgbdPostProcess: Nullable<PostProcess>,\r\n    url: string,\r\n    face: number,\r\n    i: number,\r\n    generateNonLODTextures: boolean,\r\n    lodTextures: Nullable<{ [lod: number]: BaseTexture }>,\r\n    cubeRtt: Nullable<RenderTargetWrapper>,\r\n    texture: InternalTexture\r\n): Promise<void> {\r\n    return await new Promise((resolve, reject) => {\r\n        if (expandTexture) {\r\n            const tempTexture = engine.createTexture(\r\n                null,\r\n                true,\r\n                true,\r\n                null,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                null,\r\n                (message) => {\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(message);\r\n                },\r\n                image\r\n            );\r\n\r\n            rgbdPostProcess?.onEffectCreatedObservable.addOnce((effect) => {\r\n                effect.executeWhenCompiled(() => {\r\n                    // Uncompress the data to a RTT\r\n                    rgbdPostProcess.externalTextureSamplerBinding = true;\r\n                    rgbdPostProcess.onApply = (effect) => {\r\n                        effect._bindTexture(\"textureSampler\", tempTexture);\r\n                        effect.setFloat2(\"scale\", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);\r\n                    };\r\n\r\n                    if (!engine.scenes.length) {\r\n                        return;\r\n                    }\r\n\r\n                    engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);\r\n\r\n                    // Cleanup\r\n                    engine.restoreDefaultFramebuffer();\r\n                    tempTexture.dispose();\r\n                    URL.revokeObjectURL(url);\r\n                    resolve();\r\n                });\r\n            });\r\n        } else {\r\n            engine._uploadImageToTexture(texture, image, face, i);\r\n\r\n            // Upload the face to the non lod texture support\r\n            if (generateNonLODTextures) {\r\n                const lodTexture = lodTextures![i];\r\n                if (lodTexture) {\r\n                    engine._uploadImageToTexture(lodTexture._texture!, image, face, 0);\r\n                }\r\n            }\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nexport async function UploadRadianceLevelsAsync(texture: InternalTexture, imageData: ArrayBufferView[][], imageType: string = DefaultEnvironmentTextureImageType): Promise<void> {\r\n    const engine = texture.getEngine() as Engine;\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    await _UploadLevelsAsync(texture, imageData, true, imageType);\r\n\r\n    // Flag internal texture as ready in case they are in use.\r\n    texture.isReady = true;\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param mainTexture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param size defines the size of the texture faces\r\n * @param imageType the mime type of the image data\r\n * @param dominantDirection the dominant direction of light in the environment texture, if available\r\n * @returns a promise\r\n */\r\nexport async function UploadIrradianceLevelsAsync(\r\n    mainTexture: InternalTexture,\r\n    imageData: ArrayBufferView[],\r\n    size: number,\r\n    imageType: string = DefaultEnvironmentTextureImageType,\r\n    dominantDirection: Nullable<Vector3> = null\r\n): Promise<void> {\r\n    // Gets everything ready.\r\n    const engine = mainTexture.getEngine() as Engine;\r\n    const texture = new InternalTexture(engine, InternalTextureSource.RenderTarget);\r\n    const baseTexture = new BaseTexture(engine, texture);\r\n    mainTexture._irradianceTexture = baseTexture;\r\n    baseTexture._dominantDirection = dominantDirection;\r\n    texture.isCube = true;\r\n    texture.format = Constants.TEXTUREFORMAT_RGBA;\r\n    texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n    texture.generateMipMaps = true;\r\n    texture._cachedAnisotropicFilteringLevel = null;\r\n    texture.generateMipMaps = true;\r\n    texture.width = size;\r\n    texture.height = size;\r\n    engine.updateTextureSamplingMode(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, texture);\r\n\r\n    await _UploadLevelsAsync(texture, [imageData], false, imageType);\r\n\r\n    engine.generateMipMapsForCubemap(texture);\r\n\r\n    // Flag internal texture as ready in case they are in use.\r\n    texture.isReady = true;\r\n}\r\n\r\n/**\r\n * Uploads the levels of image data to the GPU.\r\n * @param texture defines the internal texture to upload to\r\n * @param imageData defines the array buffer views of image data [mipmap][face]\r\n * @param canGenerateNonLODTextures defines whether or not to generate non lod textures\r\n * @param imageType the mime type of the image data\r\n * @returns a promise\r\n */\r\nasync function _UploadLevelsAsync(\r\n    texture: InternalTexture,\r\n    imageData: ArrayBufferView[][],\r\n    canGenerateNonLODTextures: boolean,\r\n    imageType: string = DefaultEnvironmentTextureImageType\r\n) {\r\n    if (!Tools.IsExponentOfTwo(texture.width)) {\r\n        throw new Error(\"Texture size must be a power of two\");\r\n    }\r\n\r\n    const mipmapsCount = ILog2(texture.width) + 1;\r\n\r\n    // Gets everything ready.\r\n    const engine = texture.getEngine() as Engine;\r\n    let expandTexture = false;\r\n    let generateNonLODTextures = false;\r\n    let rgbdPostProcess: Nullable<PostProcess> = null;\r\n    let cubeRtt: Nullable<RenderTargetWrapper> = null;\r\n    let lodTextures: Nullable<{ [lod: number]: BaseTexture }> = null;\r\n    const caps = engine.getCaps();\r\n\r\n    if (!caps.textureLOD) {\r\n        expandTexture = false;\r\n        generateNonLODTextures = canGenerateNonLODTextures;\r\n    } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {\r\n        expandTexture = false;\r\n    }\r\n    // If half float available we can uncompress the texture\r\n    else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_HALF_FLOAT;\r\n    }\r\n    // If full float available we can uncompress the texture\r\n    else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {\r\n        expandTexture = true;\r\n        texture.type = Constants.TEXTURETYPE_FLOAT;\r\n    }\r\n\r\n    // Expand the texture if possible\r\n    let shaderLanguage = ShaderLanguage.GLSL;\r\n    if (expandTexture) {\r\n        if (engine.isWebGPU) {\r\n            shaderLanguage = ShaderLanguage.WGSL;\r\n            await import(\"../ShadersWGSL/rgbdDecode.fragment\");\r\n        } else {\r\n            await import(\"../Shaders/rgbdDecode.fragment\");\r\n        }\r\n\r\n        // Simply run through the decode PP\r\n        rgbdPostProcess = new PostProcess(\r\n            \"rgbdDecode\",\r\n            \"rgbdDecode\",\r\n            null,\r\n            null,\r\n            1,\r\n            null,\r\n            Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            engine,\r\n            false,\r\n            undefined,\r\n            texture.type,\r\n            undefined,\r\n            null,\r\n            false,\r\n            undefined,\r\n            shaderLanguage\r\n        );\r\n\r\n        texture._isRGBD = false;\r\n        texture.invertY = false;\r\n        cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {\r\n            generateDepthBuffer: false,\r\n            generateMipMaps: true,\r\n            generateStencilBuffer: false,\r\n            samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n            type: texture.type,\r\n            format: Constants.TEXTUREFORMAT_RGBA,\r\n        });\r\n    } else {\r\n        texture._isRGBD = true;\r\n        texture.invertY = true;\r\n\r\n        // In case of missing support, applies the same patch than DDS files.\r\n        if (generateNonLODTextures) {\r\n            const mipSlices = 3;\r\n            lodTextures = {};\r\n            const scale = texture._lodGenerationScale;\r\n            const offset = texture._lodGenerationOffset;\r\n\r\n            for (let i = 0; i < mipSlices; i++) {\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const smoothness = i / (mipSlices - 1);\r\n                const roughness = 1 - smoothness;\r\n\r\n                const minLODIndex = offset; // roughness = 0\r\n                const maxLODIndex = (mipmapsCount - 1) * scale + offset; // roughness = 1 (mipmaps start from 0)\r\n\r\n                const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;\r\n                const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));\r\n\r\n                //compute LOD from even spacing in smoothness (matching shader calculation)\r\n                const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);\r\n                glTextureFromLod.isCube = true;\r\n                glTextureFromLod.invertY = true;\r\n                glTextureFromLod.generateMipMaps = false;\r\n                engine.updateTextureSamplingMode(Constants.TEXTURE_LINEAR_LINEAR, glTextureFromLod);\r\n\r\n                // Wrap in a base texture for easy binding.\r\n                const lodTexture = new BaseTexture(null);\r\n                lodTexture._isCube = true;\r\n                lodTexture._texture = glTextureFromLod;\r\n                lodTextures[mipmapIndex] = lodTexture;\r\n\r\n                switch (i) {\r\n                    case 0:\r\n                        texture._lodTextureLow = lodTexture;\r\n                        break;\r\n                    case 1:\r\n                        texture._lodTextureMid = lodTexture;\r\n                        break;\r\n                    case 2:\r\n                        texture._lodTextureHigh = lodTexture;\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const promises: Promise<void>[] = [];\r\n    // All mipmaps up to provided number of images\r\n    for (let i = 0; i < imageData.length; i++) {\r\n        // All faces\r\n        for (let face = 0; face < 6; face++) {\r\n            // Constructs an image element from image data\r\n            const bytes = imageData[i][face];\r\n            const blob = new Blob([bytes], { type: imageType });\r\n            const url = URL.createObjectURL(blob);\r\n            let promise: Promise<void>;\r\n\r\n            if (engine._features.forceBitmapOverHTMLImageElement) {\r\n                // eslint-disable-next-line github/no-then\r\n                promise = engine.createImageBitmap(blob, { premultiplyAlpha: \"none\" }).then(async (img) => {\r\n                    return await _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);\r\n                });\r\n            } else {\r\n                const image = new Image();\r\n                image.src = url;\r\n\r\n                // Enqueue promise to upload to the texture.\r\n                promise = new Promise<void>((resolve, reject) => {\r\n                    image.onload = () => {\r\n                        _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture)\r\n                            // eslint-disable-next-line github/no-then\r\n                            .then(() => resolve())\r\n                            // eslint-disable-next-line github/no-then\r\n                            .catch((reason) => {\r\n                                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                                reject(reason);\r\n                            });\r\n                    };\r\n                    image.onerror = (error) => {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(error);\r\n                    };\r\n                });\r\n            }\r\n            promises.push(promise);\r\n        }\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    // Fill remaining mipmaps with black textures.\r\n    if (imageData.length < mipmapsCount) {\r\n        let data: ArrayBufferView;\r\n        const size = Math.pow(2, mipmapsCount - 1 - imageData.length);\r\n        const dataLength = size * size * 4;\r\n        switch (texture.type) {\r\n            case Constants.TEXTURETYPE_UNSIGNED_BYTE: {\r\n                data = new Uint8Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_HALF_FLOAT: {\r\n                data = new Uint16Array(dataLength);\r\n                break;\r\n            }\r\n            case Constants.TEXTURETYPE_FLOAT: {\r\n                data = new Float32Array(dataLength);\r\n                break;\r\n            }\r\n        }\r\n        for (let i = imageData.length; i < mipmapsCount; i++) {\r\n            for (let face = 0; face < 6; face++) {\r\n                engine._uploadArrayBufferViewToTexture(cubeRtt?.texture || texture, data!, face, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Release temp RTT.\r\n    if (cubeRtt) {\r\n        const irradiance = texture._irradianceTexture;\r\n        texture._irradianceTexture = null;\r\n        engine._releaseTexture(texture);\r\n        cubeRtt._swapAndDie(texture);\r\n        texture._irradianceTexture = irradiance;\r\n    }\r\n    // Release temp Post Process.\r\n    if (rgbdPostProcess) {\r\n        rgbdPostProcess.dispose();\r\n    }\r\n    // Flag internal texture as ready in case they are in use.\r\n    if (generateNonLODTextures) {\r\n        if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {\r\n            texture._lodTextureHigh._texture.isReady = true;\r\n        }\r\n        if (texture._lodTextureMid && texture._lodTextureMid._texture) {\r\n            texture._lodTextureMid._texture.isReady = true;\r\n        }\r\n        if (texture._lodTextureLow && texture._lodTextureLow._texture) {\r\n            texture._lodTextureLow._texture.isReady = true;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Uploads spherical polynomials information to the texture.\r\n * @param texture defines the texture we are trying to upload the information to\r\n * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n */\r\nexport function UploadEnvSpherical(texture: InternalTexture, info: EnvironmentTextureInfo): void {\r\n    info = normalizeEnvInfo(info);\r\n\r\n    const irradianceInfo = info.irradiance as EnvironmentTextureIrradianceInfoV1;\r\n    if (!irradianceInfo) {\r\n        return;\r\n    }\r\n\r\n    const sp = new SphericalPolynomial();\r\n    Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);\r\n    Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);\r\n    Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);\r\n    Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);\r\n    Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);\r\n    Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);\r\n    Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);\r\n    Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);\r\n    Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);\r\n    texture._sphericalPolynomial = sp;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\nexport function _UpdateRGBDAsync(\r\n    internalTexture: InternalTexture,\r\n    data: ArrayBufferView[][],\r\n    sphericalPolynomial: Nullable<SphericalPolynomial>,\r\n    lodScale: number,\r\n    lodOffset: number\r\n): Promise<InternalTexture> {\r\n    const proxy = internalTexture\r\n        .getEngine()\r\n        .createRawCubeTexture(\r\n            null,\r\n            internalTexture.width,\r\n            internalTexture.format,\r\n            internalTexture.type,\r\n            internalTexture.generateMipMaps,\r\n            internalTexture.invertY,\r\n            internalTexture.samplingMode,\r\n            internalTexture._compression\r\n        );\r\n    // eslint-disable-next-line github/no-then\r\n    const proxyPromise = UploadRadianceLevelsAsync(proxy, data).then(() => internalTexture);\r\n    internalTexture.onRebuildCallback = (_internalTexture) => {\r\n        return {\r\n            proxy: proxyPromise,\r\n            isReady: true,\r\n            isAsync: true,\r\n        };\r\n    };\r\n    internalTexture._source = InternalTextureSource.CubeRawRGBD;\r\n    internalTexture._bufferViewArrayArray = data;\r\n    internalTexture._lodGenerationScale = lodScale;\r\n    internalTexture._lodGenerationOffset = lodOffset;\r\n    internalTexture._sphericalPolynomial = sphericalPolynomial;\r\n\r\n    // eslint-disable-next-line github/no-then\r\n    return UploadRadianceLevelsAsync(internalTexture, data).then(() => {\r\n        internalTexture.isReady = true;\r\n        return internalTexture;\r\n    });\r\n}\r\n\r\n/**\r\n * Sets of helpers addressing the serialization and deserialization of environment texture\r\n * stored in a BabylonJS env file.\r\n * Those files are usually stored as .env files.\r\n */\r\nexport const EnvironmentTextureTools = {\r\n    /**\r\n     * Gets the environment info from an env file.\r\n     * @param data The array buffer containing the .env bytes.\r\n     * @returns the environment file info (the json header) if successfully parsed, normalized to the latest supported version.\r\n     */\r\n    GetEnvInfo,\r\n\r\n    /**\r\n     * Creates an environment texture from a loaded cube texture.\r\n     * @param texture defines the cube texture to convert in env file\r\n     * @param options options for the conversion process\r\n     * @param options.imageType the mime type for the encoded images, with support for \"image/png\" (default) and \"image/webp\"\r\n     * @param options.imageQuality the image quality of encoded WebP images.\r\n     * @returns a promise containing the environment data if successful.\r\n     */\r\n    CreateEnvTextureAsync,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateRadianceImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Creates the ArrayBufferViews used for initializing environment texture image data.\r\n     * @param data the image data\r\n     * @param info parameters that determine what views will be created for accessing the underlying buffer\r\n     * @returns the views described by info providing access to the underlying buffer\r\n     */\r\n    CreateIrradianceImageDataArrayBufferViews,\r\n\r\n    /**\r\n     * Uploads the texture info contained in the env file to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param data defines the data to load\r\n     * @param info defines the texture info retrieved through the GetEnvInfo method\r\n     * @returns a promise\r\n     */\r\n    UploadEnvLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @returns a promise\r\n     */\r\n    UploadRadianceLevelsAsync,\r\n\r\n    /**\r\n     * Uploads the levels of image data to the GPU.\r\n     * @param texture defines the internal texture to upload to\r\n     * @param imageData defines the array buffer views of image data [mipmap][face]\r\n     * @param imageType the mime type of the image data\r\n     * @param dominantDirection the dominant direction of light in the environment texture, if available\r\n     * @returns a promise\r\n     */\r\n    UploadIrradianceLevelsAsync,\r\n\r\n    /**\r\n     * Uploads spherical polynomials information to the texture.\r\n     * @param texture defines the texture we are trying to upload the information to\r\n     * @param info defines the environment texture info retrieved through the GetEnvInfo method\r\n     */\r\n    UploadEnvSpherical,\r\n};\r\n"],
  "mappings": "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",
  "names": ["i", "effect"]
}
