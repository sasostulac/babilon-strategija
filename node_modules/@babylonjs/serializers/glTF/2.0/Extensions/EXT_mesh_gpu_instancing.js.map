{"version":3,"file":"EXT_mesh_gpu_instancing.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts"],"names":[],"mappings":"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","sourcesContent":["import type { INode, IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport type { BufferManager } from \"../bufferManager\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport { TmpVectors, Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport { ConvertToRightHandedPosition, ConvertToRightHandedRotation } from \"../glTFUtilities\";\r\n\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\nfunction ColorBufferToRGBAToRGB(colorBuffer: Float32Array, instanceCount: number) {\r\n    const colorBufferRgb = new Float32Array(instanceCount * 3);\r\n\r\n    for (let i = 0; i < instanceCount; i++) {\r\n        colorBufferRgb[i * 3 + 0] = colorBuffer[i * 4 + 0];\r\n        colorBufferRgb[i * 3 + 1] = colorBuffer[i * 4 + 1];\r\n        colorBufferRgb[i * 3 + 2] = colorBuffer[i * 4 + 2];\r\n    }\r\n    return colorBufferRgb;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /**\r\n     * Internal state to emit warning about instance color alpha once\r\n     */\r\n    private _instanceColorWarned = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After node is exported\r\n     * @param context the GLTF context when loading the asset\r\n     * @param node the node exported\r\n     * @param babylonNode the corresponding babylon node\r\n     * @param nodeMap map from babylon node id to node index\r\n     * @param convertToRightHanded true if we need to convert data from left hand to right hand system.\r\n     * @param bufferManager buffer manager\r\n     * @returns nullable promise, resolves with the node\r\n     */\r\n    public async postExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: Map<Node, number>,\r\n        convertToRightHanded: boolean,\r\n        bufferManager: BufferManager\r\n    ): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (node && babylonNode instanceof Mesh) {\r\n                if (babylonNode.hasThinInstances && this._exporter) {\r\n                    this._wasUsed = true;\r\n\r\n                    const noTranslation = Vector3.Zero();\r\n                    const noRotation = Quaternion.Identity();\r\n                    const noScale = Vector3.One();\r\n\r\n                    // retrieve all the instance world matrix\r\n                    const matrix = babylonNode.thinInstanceGetWorldMatrices();\r\n\r\n                    const iwt = TmpVectors.Vector3[2];\r\n                    const iwr = TmpVectors.Quaternion[1];\r\n                    const iws = TmpVectors.Vector3[3];\r\n\r\n                    let hasAnyInstanceWorldTranslation = false;\r\n                    let hasAnyInstanceWorldRotation = false;\r\n                    let hasAnyInstanceWorldScale = false;\r\n\r\n                    // prepare temp buffers\r\n                    const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n                    const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);\r\n                    const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n\r\n                    let i = 0;\r\n                    for (const m of matrix) {\r\n                        m.decompose(iws, iwr, iwt);\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedPosition(iwt);\r\n                            ConvertToRightHandedRotation(iwr);\r\n                        }\r\n\r\n                        // fill the temp buffer\r\n                        translationBuffer.set(iwt.asArray(), i * 3);\r\n                        rotationBuffer.set(iwr.normalize().asArray(), i * 4); // ensure the quaternion is normalized\r\n                        scaleBuffer.set(iws.asArray(), i * 3);\r\n\r\n                        // this is where we decide if there is any transformation\r\n                        hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);\r\n                        hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);\r\n                        hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);\r\n\r\n                        i++;\r\n                    }\r\n\r\n                    const extension: IEXTMeshGpuInstancing = {\r\n                        attributes: {},\r\n                    };\r\n\r\n                    // do we need to write TRANSLATION ?\r\n                    if (hasAnyInstanceWorldTranslation) {\r\n                        extension.attributes[\"TRANSLATION\"] = this._buildAccessor(translationBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write ROTATION ?\r\n                    if (hasAnyInstanceWorldRotation) {\r\n                        // we decided to stay on FLOAT for now see https://github.com/BabylonJS/Babylon.js/pull/12495\r\n                        extension.attributes[\"ROTATION\"] = this._buildAccessor(rotationBuffer, AccessorType.VEC4, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write SCALE ?\r\n                    if (hasAnyInstanceWorldScale) {\r\n                        extension.attributes[\"SCALE\"] = this._buildAccessor(scaleBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    let colorBuffer = babylonNode._userThinInstanceBuffersStorage?.data?.instanceColor;\r\n                    if (colorBuffer) {\r\n                        const instanceCount = babylonNode.thinInstanceCount;\r\n                        const accessorType = AccessorType.VEC3;\r\n                        if (babylonNode.hasVertexAlpha && colorBuffer.length === instanceCount * 4) {\r\n                            if (!this._instanceColorWarned) {\r\n                                Logger.Warn(\"EXT_mesh_gpu_instancing: Exporting instance colors as RGB, alpha channel of instance color is not exported\");\r\n                                this._instanceColorWarned = true;\r\n                            }\r\n                            colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);\r\n                        } else if (colorBuffer.length === instanceCount * 4) {\r\n                            colorBuffer = ColorBufferToRGBAToRGB(colorBuffer, instanceCount);\r\n                        }\r\n                        if (colorBuffer.length === instanceCount * 3) {\r\n                            extension.attributes[\"_COLOR_0\"] = this._buildAccessor(colorBuffer, accessorType, instanceCount, bufferManager);\r\n                        }\r\n                    }\r\n\r\n                    /* eslint-enable @typescript-eslint/naming-convention*/\r\n                    node.extensions = node.extensions || {};\r\n                    node.extensions[NAME] = extension;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n\r\n    private _buildAccessor(buffer: Float32Array, type: AccessorType, count: number, bufferManager: BufferManager): number {\r\n        // build the buffer view\r\n        const bv = bufferManager.createBufferView(buffer);\r\n\r\n        // finally build the accessor\r\n        const accessor = bufferManager.createAccessor(bv, type, AccessorComponentType.FLOAT, count);\r\n        this._exporter._accessors.push(accessor);\r\n        return this._exporter._accessors.length - 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));\r\n"]}