{"version":3,"file":"KHR_materials_clearcoat_anisotropy.js","sourceRoot":"","sources":["../../../../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat_anisotropy.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IMaterial, IKHRMaterialsClearcoatAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Effect } from \"core/Materials/effect\";\r\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat_anisotropy\";\r\n\r\n// Convert OpenPBR anisotropy values to glTF-compatible values\r\nfunction OpenpbrAnisotropyStrengthToGltf(baseRoughness: number, anisotropy: number) {\r\n    const baseAlpha = baseRoughness * baseRoughness;\r\n    const roughnessT = baseAlpha * Math.sqrt(2.0 / (1.0 + (1 - anisotropy) * (1 - anisotropy)));\r\n    const roughnessB = (1 - anisotropy) * roughnessT;\r\n    const newBaseRoughness = Math.sqrt(roughnessB);\r\n    const newAnisotropyStrength = Math.min(Math.sqrt((roughnessT - baseAlpha) / Math.max(1.0 - baseAlpha, 0.0001)), 1.0);\r\n\r\n    return { newBaseRoughness, newAnisotropyStrength };\r\n}\r\n\r\nfunction CopyTextureTransform(source: Texture, destination: Texture) {\r\n    destination.uOffset = source.uOffset;\r\n    destination.vOffset = source.vOffset;\r\n    destination.uScale = source.uScale;\r\n    destination.vScale = source.vScale;\r\n    destination.uAng = source.uAng;\r\n    destination.vAng = source.vAng;\r\n    destination.wAng = source.wAng;\r\n    destination.uRotationCenter = source.uRotationCenter;\r\n    destination.vRotationCenter = source.vRotationCenter;\r\n}\r\n\r\n// Custom shader for merging anisotropy into tangent texture\r\nconst AnisotropyMergeFragment = `\r\n    precision highp float;\r\n#ifdef HAS_TANGENT_TEXTURE\r\n    uniform sampler2D tangentTexture;\r\n#endif\r\n#ifdef HAS_ANISOTROPY_TEXTURE\r\n    uniform sampler2D anisotropyTexture;\r\n#endif\r\n    uniform int useRoughnessFromMetallicGreen;\r\n    uniform int useAnisotropyFromTangentBlue;\r\n\r\n    varying vec2 vUV;\r\n\r\n    void main() {\r\n        vec2 tangent = vec2(1.0, 0.0);\r\n        float anisotropy = 1.0;\r\n        #ifdef HAS_TANGENT_TEXTURE\r\n            // Tangent texture is present\r\n            vec4 tangentSample = texture2D(tangentTexture, vUV);\r\n            tangent = tangentSample.rg;\r\n\r\n            if (useAnisotropyFromTangentBlue > 0) {\r\n                anisotropy = tangentSample.b;\r\n            }\r\n        #endif\r\n        #ifdef HAS_ANISOTROPY_TEXTURE\r\n            // Anisotropy texture is present\r\n            vec4 anisotropySample = texture2D(anisotropyTexture, vUV);\r\n            anisotropy = anisotropySample.r;\r\n        #endif\r\n        \r\n        // Output: RG = tangent XY, B = anisotropy strength\r\n        vec4 anisotropyData = vec4(tangent.x, tangent.y, anisotropy, 1.0);\r\n        gl_FragColor = anisotropyData;\r\n    }\r\n`;\r\n\r\n// In your postExportMaterialAsync method:\r\nasync function CreateMergedAnisotropyTexture(babylonMaterial: OpenPBRMaterial): Promise<Nullable<ProceduralTexture>> {\r\n    const scene = babylonMaterial.getScene();\r\n\r\n    // Register the custom shader if not already done\r\n    if (!Effect.ShadersStore[\"anisotropyMergeFragmentShader\"]) {\r\n        Effect.ShadersStore[\"anisotropyMergeFragmentShader\"] = AnisotropyMergeFragment;\r\n    }\r\n\r\n    const anisoStrengthTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessAnisotropyTexture;\r\n    const tangentTexture = babylonMaterial.geometryCoatTangentTexture;\r\n\r\n    // If we don't have any textures, we don't need to generate anything.\r\n    if (!(anisoStrengthTexture || tangentTexture)) {\r\n        return null;\r\n    }\r\n\r\n    const width = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().width : 1, tangentTexture ? tangentTexture.getSize().width : 1);\r\n    const height = Math.max(anisoStrengthTexture ? anisoStrengthTexture.getSize().height : 1, tangentTexture ? tangentTexture.getSize().height : 1);\r\n    const textureOptions: IProceduralTextureCreationOptions = {\r\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\r\n        format: Constants.TEXTUREFORMAT_RGBA,\r\n        samplingMode: Constants.TEXTURE_BILINEAR_SAMPLINGMODE,\r\n        generateDepthBuffer: false,\r\n        generateStencilBuffer: false,\r\n        generateMipMaps: false,\r\n    };\r\n    const rtTexture = new ProceduralTexture(\r\n        babylonMaterial.name + \"_anisotropy\",\r\n        {\r\n            width,\r\n            height,\r\n        },\r\n        \"anisotropyMerge\",\r\n        scene,\r\n        textureOptions\r\n    );\r\n    rtTexture.refreshRate = -1;\r\n\r\n    // Set uniforms and defines\r\n    let defines = \"\";\r\n    if (tangentTexture) {\r\n        defines += \"#define HAS_TANGENT_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"tangentTexture\", tangentTexture);\r\n        CopyTextureTransform(tangentTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setVector2(\"tangentVector\", babylonMaterial.geometryTangent);\r\n    if (anisoStrengthTexture) {\r\n        defines += \"#define HAS_ANISOTROPY_TEXTURE\\n\";\r\n        rtTexture.setTexture(\"anisotropyTexture\", anisoStrengthTexture);\r\n        CopyTextureTransform(anisoStrengthTexture as Texture, rtTexture);\r\n    }\r\n    rtTexture.setInt(\"useAnisotropyFromTangentBlue\", babylonMaterial._useCoatRoughnessAnisotropyFromTangentTexture ? 1 : 0);\r\n    rtTexture.defines = defines;\r\n\r\n    return await new Promise<ProceduralTexture>((resolve, reject) => {\r\n        // Compile and render\r\n        rtTexture.executeWhenReady(() => {\r\n            try {\r\n                rtTexture.render();\r\n                resolve(rtTexture);\r\n            } catch (error) {\r\n                reject(error instanceof Error ? error : new Error(String(error)));\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _anisoTexturesMap: Record<string, ProceduralTexture> = {};\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public async postExportMaterialAdditionalTexturesAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof OpenPBRMaterial) {\r\n            if (babylonMaterial.coatRoughnessAnisotropy > 0) {\r\n                const anisoTexture = await CreateMergedAnisotropyTexture(babylonMaterial);\r\n                if (anisoTexture) {\r\n                    additionalTextures.push(anisoTexture);\r\n                    this._anisoTexturesMap[babylonMaterial.id] = anisoTexture;\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                if (babylonMaterial.coatRoughnessAnisotropy > 0) {\r\n                    // This material must have the clearcoat extension already before\r\n                    // we can add the clearcoat anisotropy sub-extension\r\n                    node.extensions = node.extensions || {};\r\n                    const parentExt = node.extensions ? node.extensions[\"KHR_materials_clearcoat\"] : null;\r\n                    if (!parentExt) {\r\n                        return resolve(node);\r\n                    }\r\n                    this._wasUsed = true;\r\n\r\n                    // Check if we can convert from OpenPBR anisotropy to glTF anisotropy\r\n                    // Conversion involves both specular roughness and anisotropic roughness changes so,\r\n                    // if there are textures for either, we can't reliably convert due to there potentially\r\n                    // being different mappings between the textures.\r\n                    const roughnessTexture: Nullable<BaseTexture> = babylonMaterial.coatRoughnessTexture;\r\n                    const mergedAnisoTexture = this._anisoTexturesMap[babylonMaterial.id];\r\n\r\n                    // If no textures are being used, we'll always output glTF-style anisotropy.\r\n                    // If using OpenPBR anisotropy, convert the constants. Otherwise, just export what we have.\r\n                    if (!roughnessTexture && !mergedAnisoTexture) {\r\n                        // Convert constants\r\n                        let newBaseRoughness = babylonMaterial.coatRoughness;\r\n                        let newAnisotropyStrength = babylonMaterial.coatRoughnessAnisotropy;\r\n                        if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                            const newParams = OpenpbrAnisotropyStrengthToGltf(babylonMaterial.coatRoughness, babylonMaterial.coatRoughnessAnisotropy);\r\n                            newBaseRoughness = newParams.newBaseRoughness;\r\n                            newAnisotropyStrength = newParams.newAnisotropyStrength;\r\n                        }\r\n                        if (node.pbrMetallicRoughness) {\r\n                            node.pbrMetallicRoughness.roughnessFactor = newBaseRoughness;\r\n                        }\r\n                        const anisotropyInfo: IKHRMaterialsClearcoatAnisotropy = {\r\n                            clearcoatAnisotropyStrength: newAnisotropyStrength,\r\n                            clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle + Math.PI * 0.5,\r\n                            clearcoatAnisotropyTexture: undefined,\r\n                        };\r\n                        parentExt.extensions = parentExt.extensions || {};\r\n                        parentExt.extensions[NAME] = anisotropyInfo;\r\n                        return resolve(node);\r\n                    }\r\n\r\n                    const mergedAnisoTextureInfo = mergedAnisoTexture ? this._exporter._materialExporter.getTextureInfo(mergedAnisoTexture) : null;\r\n\r\n                    const anisotropyInfo: IKHRMaterialsClearcoatAnisotropy = {\r\n                        clearcoatAnisotropyStrength: babylonMaterial.coatRoughnessAnisotropy,\r\n                        clearcoatAnisotropyRotation: babylonMaterial.geometryCoatTangentAngle,\r\n                        clearcoatAnisotropyTexture: mergedAnisoTextureInfo ? mergedAnisoTextureInfo : undefined,\r\n                        extensions: {},\r\n                    };\r\n\r\n                    if (!babylonMaterial._useGltfStyleAnisotropy) {\r\n                        anisotropyInfo.extensions![\"EXT_materials_anisotropy_openpbr\"] = {\r\n                            openPbrAnisotropyEnabled: true,\r\n                        };\r\n                        this._exporter._glTF.extensionsUsed ||= [];\r\n                        if (this._exporter._glTF.extensionsUsed.indexOf(\"EXT_materials_anisotropy_openpbr\") === -1) {\r\n                            this._exporter._glTF.extensionsUsed.push(\"EXT_materials_anisotropy_openpbr\");\r\n                        }\r\n                    }\r\n\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n\r\n                    parentExt.extensions = parentExt.extensions || {};\r\n                    parentExt.extensions[NAME] = anisotropyInfo;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat_anisotropy(exporter), 105);\r\n"]}