{"version":3,"file":"glTFExporter.js","sourceRoot":"","sources":["../../../../../dev/serializers/src/glTF/2.0/glTFExporter.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n    ImageMimeType,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType, CameraType } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport { TmpVectors, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Buffer } from \"core/Buffers/buffer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport {\r\n    ConvertToRightHandedPosition,\r\n    ConvertToRightHandedRotation,\r\n    DataArrayToUint8Array,\r\n    GetAccessorType,\r\n    GetAttributeType,\r\n    GetMinMax,\r\n    GetPrimitiveMode,\r\n    IsTriangleFillMode,\r\n    IsChildCollapsible,\r\n    FloatsNeed16BitInteger,\r\n    IsStandardVertexAttribute,\r\n    IndicesArrayToTypedSubarray,\r\n    GetVertexBufferInfo,\r\n    CollapseChildIntoParent,\r\n    Rotate180Y,\r\n    DefaultTranslation,\r\n    DefaultScale,\r\n    DefaultRotation,\r\n    ConvertToRightHandedTransformMatrix,\r\n} from \"./glTFUtilities\";\r\nimport { IsNoopNode } from \"../../exportUtils\";\r\nimport { BufferManager } from \"./bufferManager\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { EnumerateFloatValues, AreIndices32Bits } from \"core/Buffers/bufferUtils\";\r\nimport type { Bone, Skeleton } from \"core/Bones\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport type { MorphTarget } from \"core/Morph\";\r\nimport { BuildMorphTargetBuffers } from \"./glTFMorphTargetsUtilities\";\r\nimport type { IMorphTargetData } from \"./glTFMorphTargetsUtilities\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { GreasedLineBaseMesh } from \"core/Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\nimport { DataWriter } from \"./dataWriter\";\r\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\r\n\r\nclass ExporterState {\r\n    // Babylon indices array, start, count, offset, flip -> glTF accessor index\r\n    private _indicesAccessorMap = new Map<Nullable<IndicesArray>, Map<number, Map<number, Map<number, Map<boolean, number>>>>>();\r\n\r\n    // Babylon buffer -> glTF buffer view\r\n    private _vertexBufferViewMap = new Map<Buffer, IBufferView>();\r\n\r\n    // Babylon vertex buffer, start, count -> glTF accessor index\r\n    private _vertexAccessorMap = new Map<VertexBuffer, Map<number, Map<number, number>>>();\r\n\r\n    private _remappedBufferView = new Map<Buffer, Map<VertexBuffer, IBufferView>>();\r\n\r\n    private _meshMorphTargetMap = new Map<AbstractMesh, IMorphTargetData[]>();\r\n\r\n    private _vertexMapColorAlpha = new Map<VertexBuffer, boolean>();\r\n\r\n    private _exportedNodes = new Set<Node>();\r\n\r\n    // Babylon mesh -> glTF mesh index\r\n    private _meshMap = new Map<AbstractMesh, number>();\r\n\r\n    public constructor(convertToRightHanded: boolean, wasAddedByNoopNode: boolean) {\r\n        this.convertToRightHanded = convertToRightHanded;\r\n        this.wasAddedByNoopNode = wasAddedByNoopNode;\r\n    }\r\n\r\n    public readonly convertToRightHanded: boolean;\r\n\r\n    public readonly wasAddedByNoopNode: boolean;\r\n\r\n    // Only used when convertToRightHanded is true.\r\n    public readonly convertedToRightHandedBuffers = new Map<Buffer, Uint8Array>();\r\n\r\n    public getIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean): number | undefined {\r\n        return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);\r\n    }\r\n\r\n    public setIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean, accessorIndex: number): void {\r\n        let map1 = this._indicesAccessorMap.get(indices);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, Map<number, Map<boolean, number>>>>();\r\n            this._indicesAccessorMap.set(indices, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, Map<number, Map<boolean, number>>>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        let map3 = map2.get(count);\r\n        if (!map3) {\r\n            map3 = new Map<number, Map<boolean, number>>();\r\n            map2.set(count, map3);\r\n        }\r\n\r\n        let map4 = map3.get(offset);\r\n        if (!map4) {\r\n            map4 = new Map<boolean, number>();\r\n            map3.set(offset, map4);\r\n        }\r\n\r\n        map4.set(flip, accessorIndex);\r\n    }\r\n\r\n    public pushExportedNode(node: Node) {\r\n        if (!this._exportedNodes.has(node)) {\r\n            this._exportedNodes.add(node);\r\n        }\r\n    }\r\n\r\n    public getNodesSet(): Set<Node> {\r\n        return this._exportedNodes;\r\n    }\r\n\r\n    public getVertexBufferView(buffer: Buffer): IBufferView | undefined {\r\n        return this._vertexBufferViewMap.get(buffer);\r\n    }\r\n\r\n    public setVertexBufferView(buffer: Buffer, bufferView: IBufferView): void {\r\n        this._vertexBufferViewMap.set(buffer, bufferView);\r\n    }\r\n\r\n    public setRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer, bufferView: IBufferView) {\r\n        this._remappedBufferView.set(buffer, new Map<VertexBuffer, IBufferView>());\r\n        this._remappedBufferView.get(buffer)!.set(vertexBuffer, bufferView);\r\n    }\r\n\r\n    public getRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer): IBufferView | undefined {\r\n        return this._remappedBufferView.get(buffer)?.get(vertexBuffer);\r\n    }\r\n\r\n    public getVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number): number | undefined {\r\n        return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);\r\n    }\r\n\r\n    public setVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number, accessorIndex: number): void {\r\n        let map1 = this._vertexAccessorMap.get(vertexBuffer);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, number>>();\r\n            this._vertexAccessorMap.set(vertexBuffer, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, number>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        map2.set(count, accessorIndex);\r\n    }\r\n\r\n    public hasVertexColorAlpha(vertexBuffer: VertexBuffer): boolean {\r\n        return this._vertexMapColorAlpha.get(vertexBuffer) || false;\r\n    }\r\n\r\n    public setHasVertexColorAlpha(vertexBuffer: VertexBuffer, hasAlpha: boolean) {\r\n        return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);\r\n    }\r\n\r\n    public getMesh(mesh: AbstractMesh): number | undefined {\r\n        return this._meshMap.get(mesh);\r\n    }\r\n\r\n    public setMesh(mesh: AbstractMesh, meshIndex: number): void {\r\n        this._meshMap.set(mesh, meshIndex);\r\n    }\r\n\r\n    public bindMorphDataToMesh(mesh: AbstractMesh, morphData: IMorphTargetData) {\r\n        const morphTargets = this._meshMorphTargetMap.get(mesh) || [];\r\n        this._meshMorphTargetMap.set(mesh, morphTargets);\r\n        if (morphTargets.indexOf(morphData) === -1) {\r\n            morphTargets.push(morphData);\r\n        }\r\n    }\r\n\r\n    public getMorphTargetsFromMesh(mesh: AbstractMesh): IMorphTargetData[] | undefined {\r\n        return this._meshMorphTargetMap.get(mesh);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class GLTFExporter {\r\n    public readonly _glTF: IGLTF = {\r\n        asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n    };\r\n\r\n    public readonly _animations: IAnimation[] = [];\r\n    public readonly _accessors: IAccessor[] = [];\r\n    public readonly _bufferViews: IBufferView[] = [];\r\n    public readonly _cameras: ICamera[] = [];\r\n    public readonly _images: IImage[] = [];\r\n    public readonly _materials: IMaterial[] = [];\r\n    public readonly _meshes: IMesh[] = [];\r\n    public readonly _nodes: INode[] = [];\r\n    public readonly _samplers: ISampler[] = [];\r\n    public readonly _scenes: IScene[] = [];\r\n    public readonly _skins: ISkin[] = [];\r\n    public readonly _textures: ITexture[] = [];\r\n\r\n    public readonly _babylonScene: Scene;\r\n    public readonly _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } } = {};\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private readonly _options: Required<IExportOptions>;\r\n\r\n    public _shouldUseGlb: boolean = false;\r\n\r\n    public readonly _materialExporter = new GLTFMaterialExporter(this);\r\n\r\n    private readonly _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    public readonly _bufferManager = new BufferManager();\r\n\r\n    private readonly _shouldExportNodeMap = new Map<Node, boolean>();\r\n\r\n    // Babylon node -> glTF node index\r\n    private readonly _nodeMap = new Map<Node, number>();\r\n\r\n    // Babylon material -> glTF material index\r\n    public readonly _materialMap = new Map<Material, number>();\r\n    private readonly _camerasMap = new Map<Camera, ICamera>();\r\n    private readonly _nodesCameraMap = new Map<ICamera, INode[]>();\r\n    private readonly _skinMap = new Map<Skeleton, ISkin>();\r\n    private readonly _nodesSkinMap = new Map<ISkin, INode[]>();\r\n\r\n    // A material in this set requires UVs\r\n    public readonly _materialNeedsUVsSet = new Set<Material>();\r\n\r\n    private static readonly _ExtensionNames = new Array<string>();\r\n    private static readonly _ExtensionFactories: { [name: string]: (exporter: GLTFExporter) => IGLTFExporterExtensionV2 } = {};\r\n    private static readonly _ExtensionOrders: { [name: string]: number } = {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtension<T>(\r\n        node: T,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._ApplyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return currentPromise.then(async (newNode) => (newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null));\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtensions<T>(node: T, actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._ApplyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return this._ApplyExtensions(\r\n            node,\r\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n            (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportMaterialAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n        return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    /**\r\n     * Get additional textures for a material\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material\r\n     * @param babylonMaterial The Babylon.js material\r\n     * @returns List of additional textures\r\n     */\r\n    public async _extensionsPostExportMaterialAdditionalTexturesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<BaseTexture[]> {\r\n        const output: BaseTexture[] = [];\r\n\r\n        await Promise.all(\r\n            GLTFExporter._ExtensionNames.map(async (name) => {\r\n                const extension = this._extensions[name];\r\n\r\n                if (extension.postExportMaterialAdditionalTexturesAsync) {\r\n                    const textures = await extension.postExportMaterialAdditionalTexturesAsync(context, material, babylonMaterial);\r\n                    output.push(...textures);\r\n                }\r\n            })\r\n        );\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitive(primitive: IMeshPrimitive): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMeshPrimitive) {\r\n                extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async _extensionsPreGenerateBinaryAsync(): Promise<void> {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.preGenerateBinaryAsync) {\r\n                // eslint-disable-next-line no-await-in-loop\r\n                await extension.preGenerateBinaryAsync(this._bufferManager);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                this._glTF.extensionsUsed ||= [];\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    this._glTF.extensionsRequired ||= [];\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                this._glTF.extensions ||= {};\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = GLTFExporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    public constructor(babylonScene: Nullable<Scene> = EngineStore.LastCreatedScene, options?: IExportOptions) {\r\n        if (!babylonScene) {\r\n            throw new Error(\"No scene available to export\");\r\n        }\r\n\r\n        this._babylonScene = babylonScene;\r\n\r\n        this._options = {\r\n            shouldExportNode: () => true,\r\n            shouldExportAnimation: () => true,\r\n            metadataSelector: (metadata) => metadata?.gltf?.extras,\r\n            animationSampleRate: 1 / 60,\r\n            exportWithoutWaitingForScene: false,\r\n            exportUnusedUVs: false,\r\n            removeNoopRootNodes: true,\r\n            includeCoordinateSystemConversionNodes: false,\r\n            meshCompressionMethod: \"None\",\r\n            ...options,\r\n        };\r\n\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const key in this._extensions) {\r\n            const extension = this._extensions[key];\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public static RegisterExtension(name: string, factory: (exporter: GLTFExporter) => IGLTFExporterExtensionV2, order: number = 100): void {\r\n        if (GLTFExporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        GLTFExporter._ExtensionFactories[name] = factory;\r\n        const extensionOrder = order ?? 0; // Use provided order or default to 0\r\n        GLTFExporter._ExtensionOrders[name] = extensionOrder;\r\n\r\n        // Find the correct position to insert the extension based on order\r\n        let insertIndex = GLTFExporter._ExtensionNames.length;\r\n        for (let i = 0; i < GLTFExporter._ExtensionNames.length; i++) {\r\n            const existingName = GLTFExporter._ExtensionNames[i];\r\n            const existingOrder = GLTFExporter._ExtensionOrders[existingName];\r\n\r\n            // If the order is less, insert before.\r\n            if (extensionOrder < existingOrder) {\r\n                insertIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        GLTFExporter._ExtensionNames.splice(insertIndex, 0, name);\r\n    }\r\n\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFExporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete GLTFExporter._ExtensionFactories[name];\r\n        delete GLTFExporter._ExtensionOrders[name];\r\n\r\n        const index = GLTFExporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFExporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _generateJSON(bufferByteLength: number, fileName?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: bufferByteLength };\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            this._glTF.images = this._images;\r\n        }\r\n\r\n        if (!this._shouldUseGlb) {\r\n            buffer.uri = fileName + \".bin\";\r\n        }\r\n\r\n        return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n    }\r\n\r\n    public async generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);\r\n\r\n        const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n        const glTFFileName = glTFPrefix + \".gltf\";\r\n        const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n        const container = new GLTFData();\r\n\r\n        container.files[glTFFileName] = jsonText;\r\n        container.files[glTFBinFile] = bin;\r\n\r\n        if (this._imageData) {\r\n            for (const image in this._imageData) {\r\n                container.files[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n            }\r\n        }\r\n\r\n        return container;\r\n    }\r\n\r\n    private async _generateBinaryAsync(): Promise<Uint8Array> {\r\n        await this._exportSceneAsync();\r\n        await this._extensionsPreGenerateBinaryAsync();\r\n        return this._bufferManager.generateBinary(this._bufferViews);\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    public async generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        this._shouldUseGlb = true;\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength);\r\n\r\n        const glbFileName = glTFPrefix + \".glb\";\r\n        const headerLength = 12;\r\n        const chunkLengthPrefix = 8;\r\n        let jsonLength = jsonText.length;\r\n        let encodedJsonText;\r\n        // Make use of TextEncoder when available\r\n        if (typeof TextEncoder !== \"undefined\") {\r\n            const encoder = new TextEncoder();\r\n            encodedJsonText = encoder.encode(jsonText);\r\n            jsonLength = encodedJsonText.length;\r\n        }\r\n        const jsonPadding = this._getPadding(jsonLength);\r\n        const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n\r\n        const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;\r\n\r\n        const dataWriter = new DataWriter(byteLength);\r\n\r\n        // Header\r\n        dataWriter.writeUInt32(0x46546c67); // \"glTF\"\r\n        dataWriter.writeUInt32(2); // Version\r\n        dataWriter.writeUInt32(byteLength); // Total bytes in file\r\n\r\n        // JSON chunk length prefix\r\n        dataWriter.writeUInt32(jsonLength + jsonPadding);\r\n        dataWriter.writeUInt32(0x4e4f534a); // \"JSON\"\r\n\r\n        // JSON chunk bytes\r\n        if (encodedJsonText) {\r\n            // If TextEncoder was available, we can simply copy the encoded array\r\n            dataWriter.writeTypedArray(encodedJsonText);\r\n        } else {\r\n            const blankCharCode = \"_\".charCodeAt(0);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                const charCode = jsonText.charCodeAt(i);\r\n                // If the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                if (charCode != jsonText.codePointAt(i)) {\r\n                    dataWriter.writeUInt8(blankCharCode);\r\n                } else {\r\n                    dataWriter.writeUInt8(charCode);\r\n                }\r\n            }\r\n        }\r\n\r\n        // JSON padding\r\n        for (let i = 0; i < jsonPadding; ++i) {\r\n            dataWriter.writeUInt8(0x20);\r\n        }\r\n\r\n        // Binary chunk length prefix\r\n        dataWriter.writeUInt32(binaryBuffer.byteLength + binPadding);\r\n        dataWriter.writeUInt32(0x004e4942); // \"BIN\"\r\n\r\n        // Binary chunk bytes\r\n        dataWriter.writeTypedArray(binaryBuffer);\r\n\r\n        // Binary padding\r\n        for (let i = 0; i < binPadding; ++i) {\r\n            dataWriter.writeUInt8(0);\r\n        }\r\n\r\n        const container = new GLTFData();\r\n        container.files[glbFileName] = new Blob([dataWriter.getOutputData()], { type: \"application/octet-stream\" });\r\n\r\n        return container;\r\n    }\r\n\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHanded: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n\r\n        if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion =\r\n            babylonTransformNode.rotationQuaternion?.clone() ||\r\n            Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedRotation(rotationQuaternion);\r\n            }\r\n\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: TargetCamera, convertToRightHanded: boolean): void {\r\n        // Camera types store rotation differently (e.g., ArcRotateCamera uses alpha/beta, others use rotationQuaternion).\r\n        // Extract the transform from the world matrix instead of handling each case separately.\r\n        const translation = TmpVectors.Vector3[0];\r\n        const rotationQuaternion = TmpVectors.Quaternion[0];\r\n        const cameraWorldMatrix = babylonCamera.getWorldMatrix();\r\n\r\n        if (babylonCamera.parent) {\r\n            // Camera.getWorldMatrix returns global coordinates. GLTF node must use local coordinates. If camera has parent we need to use local translation/rotation.\r\n            const parentInvWorldMatrix = babylonCamera.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);\r\n            const cameraLocal = cameraWorldMatrix.multiplyToRef(parentInvWorldMatrix, TmpVectors.Matrix[1]);\r\n            cameraLocal.decompose(undefined, rotationQuaternion, translation);\r\n        } else {\r\n            cameraWorldMatrix.decompose(undefined, rotationQuaternion, translation);\r\n        }\r\n\r\n        if (!translation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (convertToRightHanded) {\r\n            ConvertToRightHandedRotation(rotationQuaternion);\r\n        }\r\n\r\n        // Left-handed scenes have cameras that always face Z+ (opposite of glTF's Z-).\r\n        // Use scene coordinate system rather than convertToRightHanded, since some\r\n        // cameras may not need convertToRightHanded but still need correction to face Z-.\r\n        if (!this._babylonScene.useRightHandedSystem) {\r\n            Rotate180Y(rotationQuaternion);\r\n        }\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            node.rotation = rotationQuaternion.asArray();\r\n        }\r\n    }\r\n\r\n    // Export babylon cameras to glTF cameras\r\n    private _listAvailableCameras(): void {\r\n        for (const camera of this._babylonScene.cameras) {\r\n            const glTFCamera: ICamera = {\r\n                type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n            };\r\n\r\n            if (camera.name) {\r\n                glTFCamera.name = camera.name;\r\n            }\r\n\r\n            if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                glTFCamera.perspective = {\r\n                    aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                    yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                glTFCamera.orthographic = {\r\n                    xmag: halfWidth,\r\n                    ymag: halfHeight,\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            }\r\n            this._camerasMap.set(camera, glTFCamera);\r\n        }\r\n    }\r\n\r\n    // Cleanup unused cameras and assign index to nodes.\r\n    private _exportAndAssignCameras(): void {\r\n        const gltfCameras = Array.from(this._camerasMap.values());\r\n        for (const gltfCamera of gltfCameras) {\r\n            const usedNodes = this._nodesCameraMap.get(gltfCamera);\r\n            if (usedNodes !== undefined) {\r\n                this._cameras.push(gltfCamera);\r\n                for (const node of usedNodes) {\r\n                    node.camera = this._cameras.length - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Collects all skins in a skins map so nodes can reference it during node parsing.\r\n    private _listAvailableSkeletons(): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin: ISkin = { joints: [] };\r\n            this._skinMap.set(skeleton, skin);\r\n        }\r\n    }\r\n\r\n    private _exportAndAssignSkeletons(leftHandNodes: Set<Node>): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin = this._skinMap.get(skeleton);\r\n            if (skin == undefined) {\r\n                continue;\r\n            }\r\n\r\n            // The bones (joints) of a skeleton (skin) must be exported in the same order as they appear in vertex attributes,\r\n            // which is indicated by getIndex and may not match a bone's index in skeleton.bones\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set joints indices to scene nodes.\r\n            const inverseBindMatrices: Matrix[] = [];\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex]; // Assumes no gaps in bone indices\r\n                const transformNode = bone.getTransformNode();\r\n                const nodeIndex = transformNode ? this._nodeMap.get(transformNode) : undefined;\r\n                if (nodeIndex === undefined) {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported.\");\r\n                    continue; // The indices may be out-of-sync after this and break the skinning.\r\n                }\r\n                skin.joints.push(nodeIndex);\r\n\r\n                const boneMatrix = bone.getAbsoluteInverseBindMatrix().clone();\r\n                if (leftHandNodes.has(transformNode!)) {\r\n                    ConvertToRightHandedTransformMatrix(boneMatrix);\r\n                }\r\n                inverseBindMatrices.push(boneMatrix);\r\n            }\r\n\r\n            // Nodes that use this skin.\r\n            const skinnedNodes = this._nodesSkinMap.get(skin);\r\n\r\n            // Only export the skin if it has at least one joint and is used by a mesh.\r\n            if (skin.joints.length > 0 && skinnedNodes !== undefined) {\r\n                const inverseBindMatricesData = new Float32Array(inverseBindMatrices.length * 16); // Always a 4 x 4 matrix of 32 bit float\r\n                inverseBindMatrices.forEach((mat: Matrix, index: number) => {\r\n                    inverseBindMatricesData.set(mat.m, index * 16);\r\n                });\r\n\r\n                const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.MAT4, AccessorComponentType.FLOAT, inverseBindMatrices.length));\r\n                skin.inverseBindMatrices = this._accessors.length - 1;\r\n\r\n                this._skins.push(skin);\r\n                const skinIndex = this._skins.length - 1;\r\n                for (const skinnedNode of skinnedNodes) {\r\n                    skinnedNode.skin = skinIndex;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _exportSceneAsync(): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n\r\n        // Scene metadata\r\n        if (this._babylonScene.metadata) {\r\n            const extras = this._options.metadataSelector(this._babylonScene.metadata);\r\n            if (extras) {\r\n                scene.extras = extras;\r\n            }\r\n        }\r\n\r\n        //  TODO:\r\n        //  deal with this from the loader:\r\n        //  babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n        //  babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n\r\n        const rootNodesRH = new Array<Node>();\r\n        const rootNodesLH = new Array<Node>();\r\n        const rootNoopNodesRH = new Array<Node>();\r\n\r\n        for (const rootNode of this._babylonScene.rootNodes) {\r\n            if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {\r\n                rootNoopNodesRH.push(...rootNode.getChildren());\r\n            } else if (this._babylonScene.useRightHandedSystem) {\r\n                rootNodesRH.push(rootNode);\r\n            } else {\r\n                rootNodesLH.push(rootNode);\r\n            }\r\n        }\r\n\r\n        this._listAvailableCameras();\r\n        this._listAvailableSkeletons();\r\n\r\n        const stateLH = new ExporterState(true, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesLH, stateLH)));\r\n        const stateRH = new ExporterState(false, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesRH, stateRH)));\r\n        const noopRH = new ExporterState(false, true);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNoopNodesRH, noopRH)));\r\n\r\n        if (scene.nodes.length) {\r\n            this._scenes.push(scene);\r\n        }\r\n\r\n        this._exportAndAssignCameras();\r\n        this._exportAndAssignSkeletons(stateLH.getNodesSet());\r\n\r\n        if (this._babylonScene.animationGroups.length) {\r\n            _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                this._babylonScene,\r\n                this._animations,\r\n                this._nodeMap,\r\n                this._bufferManager,\r\n                this._bufferViews,\r\n                this._accessors,\r\n                this._animationSampleRate,\r\n                stateLH.getNodesSet(),\r\n                this._options.shouldExportAnimation\r\n            );\r\n        }\r\n    }\r\n\r\n    private _shouldExportNode(babylonNode: Node): boolean {\r\n        let result = this._shouldExportNodeMap.get(babylonNode);\r\n\r\n        if (result === undefined) {\r\n            result = this._options.shouldExportNode(babylonNode);\r\n            this._shouldExportNodeMap.set(babylonNode, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private async _exportNodesAsync(babylonRootNodes: Node[], state: ExporterState): Promise<number[]> {\r\n        const nodes = new Array<number>();\r\n\r\n        this._exportBuffers(babylonRootNodes, state);\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonNode, nodes, state);\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    private _collectBuffers(\r\n        babylonNode: Node,\r\n        bufferToVertexBuffersMap: Map<Buffer, VertexBuffer[]>,\r\n        vertexBufferToMeshesMap: Map<VertexBuffer, AbstractMesh[]>,\r\n        morphTargetsToMeshesMap: Map<MorphTarget, AbstractMesh[]>,\r\n        state: ExporterState\r\n    ): void {\r\n        if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {\r\n            const vertexBuffers = babylonNode.geometry.getVertexBuffers();\r\n            if (vertexBuffers) {\r\n                for (const kind in vertexBuffers) {\r\n                    if (!IsStandardVertexAttribute(kind)) {\r\n                        continue;\r\n                    }\r\n                    const vertexBuffer = vertexBuffers[kind];\r\n                    state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);\r\n                    const buffer = vertexBuffer._buffer;\r\n                    const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];\r\n                    bufferToVertexBuffersMap.set(buffer, vertexBufferArray);\r\n                    if (vertexBufferArray.indexOf(vertexBuffer) === -1) {\r\n                        vertexBufferArray.push(vertexBuffer);\r\n                    }\r\n\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];\r\n                    vertexBufferToMeshesMap.set(vertexBuffer, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n\r\n            if (morphTargetManager) {\r\n                for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {\r\n                    const morphTarget = morphTargetManager.getTarget(morphIndex);\r\n\r\n                    const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];\r\n                    morphTargetsToMeshesMap.set(morphTarget, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);\r\n        }\r\n    }\r\n\r\n    private _exportBuffers(babylonRootNodes: Node[], state: ExporterState): void {\r\n        const bufferToVertexBuffersMap = new Map<Buffer, VertexBuffer[]>();\r\n        const vertexBufferToMeshesMap = new Map<VertexBuffer, AbstractMesh[]>();\r\n        const morphTargetsMeshesMap = new Map<MorphTarget, AbstractMesh[]>();\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);\r\n        }\r\n\r\n        const buffers = Array.from(bufferToVertexBuffersMap.keys());\r\n\r\n        for (const buffer of buffers) {\r\n            const data = buffer.getData();\r\n            if (!data) {\r\n                throw new Error(\"Buffer data is not available\");\r\n            }\r\n\r\n            const vertexBuffers = bufferToVertexBuffersMap.get(buffer);\r\n\r\n            if (!vertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const byteStride = vertexBuffers[0].byteStride;\r\n            if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {\r\n                throw new Error(\"Vertex buffers pointing to the same buffer must have the same byte stride\");\r\n            }\r\n\r\n            const bytes = DataArrayToUint8Array(data).slice();\r\n\r\n            // Apply normalizations and color corrections to buffer data in-place.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                switch (kind) {\r\n                    // Normalize normals and tangents.\r\n                    case VertexBuffer.NormalKind:\r\n                    case VertexBuffer.TangentKind: {\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);\r\n                            if (length > 0) {\r\n                                const invLength = 1 / length;\r\n                                values[0] *= invLength;\r\n                                values[1] *= invLength;\r\n                                values[2] *= invLength;\r\n                            }\r\n                        });\r\n                        break;\r\n                    }\r\n                    // Convert StandardMaterial vertex colors from gamma to linear space.\r\n                    case VertexBuffer.ColorKind: {\r\n                        const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;\r\n                        if (stdMaterialCount == 0) {\r\n                            break; // Buffer not used by StandardMaterials, so no conversion needed.\r\n                        }\r\n                        // TODO: Implement this case.\r\n                        if (stdMaterialCount != meshes.length) {\r\n                            Logger.Warn(\"Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.\");\r\n                            break;\r\n                        }\r\n                        if (type == VertexBuffer.UNSIGNED_BYTE) {\r\n                            Logger.Warn(\"Converting uint8 vertex colors to linear space. Results may look incorrect.\");\r\n                        }\r\n\r\n                        const vertexData3 = new Color3();\r\n                        const vertexData4 = new Color4();\r\n                        const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            // Using separate Color3 and Color4 objects to ensure the right functions are called.\r\n                            if (values.length === 3) {\r\n                                vertexData3.fromArray(values, 0);\r\n                                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);\r\n                                vertexData3.toArray(values, 0);\r\n                            } else {\r\n                                vertexData4.fromArray(values, 0);\r\n                                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);\r\n                                vertexData4.toArray(values, 0);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Perform coordinate conversions, if needed, to buffer data in-place (only for positions, normals and tangents).\r\n            if (state.convertToRightHanded) {\r\n                for (const vertexBuffer of vertexBuffers) {\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                    const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                    switch (kind) {\r\n                        case VertexBuffer.PositionKind:\r\n                        case VertexBuffer.NormalKind:\r\n                        case VertexBuffer.TangentKind: {\r\n                            EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                                values[0] = -values[0];\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Save converted bytes for min/max computation.\r\n                state.convertedToRightHandedBuffers.set(buffer, bytes);\r\n            }\r\n\r\n            // Create buffer view, but defer accessor creation for later. Instead, track it via ExporterState.\r\n            const bufferView = this._bufferManager.createBufferView(bytes, byteStride);\r\n            state.setVertexBufferView(buffer, bufferView);\r\n\r\n            const floatMatricesIndices = new Map<VertexBuffer, FloatArray>();\r\n\r\n            // If buffers are of type MatricesIndicesKind and have float values, we need to create a new buffer instead.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n                switch (kind) {\r\n                    case VertexBuffer.MatricesIndicesKind:\r\n                    case VertexBuffer.MatricesIndicesExtraKind: {\r\n                        if (vertexBuffer.type == VertexBuffer.FLOAT) {\r\n                            const floatData = vertexBuffer.getFloatData(totalVertices);\r\n                            if (floatData !== null) {\r\n                                floatMatricesIndices.set(vertexBuffer, floatData);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (floatMatricesIndices.size !== 0) {\r\n                Logger.Warn(\r\n                    `Joint indices conversion needed: some joint indices are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`\r\n                );\r\n            }\r\n\r\n            const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());\r\n\r\n            for (const vertexBuffer of floatArrayVertexBuffers) {\r\n                const array = floatMatricesIndices.get(vertexBuffer);\r\n\r\n                if (!array) {\r\n                    continue;\r\n                }\r\n\r\n                const is16Bit = FloatsNeed16BitInteger(array);\r\n                const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);\r\n                for (let index = 0; index < array.length; index++) {\r\n                    newArray[index] = array[index];\r\n                }\r\n                const bufferView = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));\r\n                state.setRemappedBufferView(buffer, vertexBuffer, bufferView);\r\n            }\r\n        }\r\n\r\n        // Build morph targets buffers\r\n        const morphTargets = Array.from(morphTargetsMeshesMap.keys());\r\n\r\n        for (const morphTarget of morphTargets) {\r\n            const meshes = morphTargetsMeshesMap.get(morphTarget);\r\n\r\n            if (!meshes) {\r\n                continue;\r\n            }\r\n\r\n            const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);\r\n\r\n            for (const mesh of meshes) {\r\n                state.bindMorphDataToMesh(mesh, glTFMorphTarget);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a node to be exported to the glTF file\r\n     * @returns A promise that resolves once the node has been exported\r\n     * @internal\r\n     */\r\n    private async _exportNodeAsync(babylonNode: Node, parentNodeChildren: Array<number>, state: ExporterState): Promise<void> {\r\n        let nodeIndex = this._nodeMap.get(babylonNode);\r\n        if (nodeIndex !== undefined) {\r\n            if (!parentNodeChildren.includes(nodeIndex)) {\r\n                parentNodeChildren.push(nodeIndex);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const node = await this._createNodeAsync(babylonNode, state);\r\n\r\n        if (node) {\r\n            nodeIndex = this._nodes.length;\r\n            this._nodes.push(node);\r\n            this._nodeMap.set(babylonNode, nodeIndex);\r\n            state.pushExportedNode(babylonNode);\r\n            parentNodeChildren.push(nodeIndex);\r\n\r\n            // Process node's animations once the node has been added to nodeMap (TODO: This should be refactored)\r\n            const runtimeGLTFAnimation: IAnimation = {\r\n                name: \"runtime animations\",\r\n                channels: [],\r\n                samplers: [],\r\n            };\r\n            const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n            if (!this._babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                    babylonNode,\r\n                    runtimeGLTFAnimation,\r\n                    idleGLTFAnimations,\r\n                    this._nodeMap,\r\n                    this._nodes,\r\n                    this._bufferManager,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._animationSampleRate,\r\n                    state.convertToRightHanded,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n                if (babylonNode.animations.length) {\r\n                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                        babylonNode,\r\n                        runtimeGLTFAnimation,\r\n                        idleGLTFAnimations,\r\n                        this._nodeMap,\r\n                        this._nodes,\r\n                        this._bufferManager,\r\n                        this._bufferViews,\r\n                        this._accessors,\r\n                        this._animationSampleRate,\r\n                        state.convertToRightHanded,\r\n                        this._options.shouldExportAnimation\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Begin processing child nodes once parent has been added to the node list\r\n        const children = node ? [] : parentNodeChildren;\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonChildNode, children, state);\r\n        }\r\n\r\n        if (node && children.length) {\r\n            node.children = children;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon.js node. If skipped, returns null.\r\n     * @internal\r\n     */\r\n    private async _createNodeAsync(babylonNode: Node, state: ExporterState): Promise<Nullable<INode>> {\r\n        if (!this._shouldExportNode(babylonNode)) {\r\n            return null;\r\n        }\r\n\r\n        const node: INode = {};\r\n\r\n        if (babylonNode.name) {\r\n            node.name = babylonNode.name;\r\n        }\r\n\r\n        // Node metadata\r\n        if (babylonNode.metadata) {\r\n            const extras = this._options.metadataSelector(babylonNode.metadata);\r\n            if (extras) {\r\n                node.extras = extras;\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TransformNode) {\r\n            this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n            if (babylonNode instanceof AbstractMesh) {\r\n                const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : (babylonNode as Mesh);\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    node.mesh = await this._exportMeshAsync(babylonMesh, state);\r\n                }\r\n\r\n                if (babylonNode.skeleton) {\r\n                    const skin = this._skinMap.get(babylonNode.skeleton);\r\n\r\n                    if (skin !== undefined) {\r\n                        if (this._nodesSkinMap.get(skin) === undefined) {\r\n                            this._nodesSkinMap.set(skin, []);\r\n                        }\r\n\r\n                        this._nodesSkinMap.get(skin)?.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TargetCamera) {\r\n            const gltfCamera = this._camerasMap.get(babylonNode);\r\n\r\n            if (gltfCamera) {\r\n                if (this._nodesCameraMap.get(gltfCamera) === undefined) {\r\n                    this._nodesCameraMap.set(gltfCamera, []);\r\n                }\r\n\r\n                this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n                // If a parent node exists and can be collapsed, merge their transformations and mark the parent as the camera-containing node.\r\n                const parentBabylonNode = babylonNode.parent;\r\n                if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                    const parentNodeIndex = this._nodeMap.get(parentBabylonNode);\r\n                    if (parentNodeIndex !== undefined) {\r\n                        const parentNode = this._nodes[parentNodeIndex];\r\n                        CollapseChildIntoParent(node, parentNode);\r\n                        this._nodesCameraMap.get(gltfCamera)?.push(parentNode);\r\n                        return null; // Skip exporting the original child node\r\n                    }\r\n                }\r\n\r\n                this._nodesCameraMap.get(gltfCamera)?.push(node);\r\n            }\r\n        }\r\n\r\n        // Apply extensions to the node. If this resolves to null, it means we should skip exporting this node\r\n        const processedNode = await this._extensionsPostExportNodeAsync(\"exportNodeAsync\", node, babylonNode, this._nodeMap, state.convertToRightHanded);\r\n        if (!processedNode) {\r\n            Logger.Warn(`Not exporting node ${babylonNode.name}`);\r\n            return null;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private _exportIndices(\r\n        indices: Nullable<IndicesArray>,\r\n        is32Bits: boolean,\r\n        start: number,\r\n        count: number,\r\n        offset: number,\r\n        fillMode: number,\r\n        sideOrientation: number,\r\n        state: ExporterState,\r\n        primitive: IMeshPrimitive\r\n    ): void {\r\n        let indicesToExport = indices;\r\n\r\n        primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n        // Flip indices if triangle winding order is not CCW, as glTF is always CCW.\r\n        const flip = sideOrientation !== Material.CounterClockWiseSideOrientation && IsTriangleFillMode(fillMode);\r\n        if (flip) {\r\n            if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {\r\n                throw new Error(\"Triangle strip/fan fill mode is not implemented\");\r\n            }\r\n\r\n            primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n\r\n            if (indices) {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = indices[start + i] + offset;\r\n                    newIndices[i + 1] = indices[start + i + 2] + offset;\r\n                    newIndices[i + 2] = indices[start + i + 1] + offset;\r\n                }\r\n            } else {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = i;\r\n                    newIndices[i + 1] = i + 2;\r\n                    newIndices[i + 2] = i + 1;\r\n                }\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        } else if (indices && offset !== 0) {\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n            for (let i = 0; i < count; i++) {\r\n                newIndices[i] = indices[start + i] + offset;\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        }\r\n\r\n        if (indicesToExport) {\r\n            let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);\r\n            if (accessorIndex === undefined) {\r\n                const bytes = IndicesArrayToTypedSubarray(indicesToExport, start, count, is32Bits);\r\n                const bufferView = this._bufferManager.createBufferView(bytes);\r\n\r\n                const componentType = is32Bits ? AccessorComponentType.UNSIGNED_INT : AccessorComponentType.UNSIGNED_SHORT;\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.SCALAR, componentType, count, 0));\r\n                accessorIndex = this._accessors.length - 1;\r\n                state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);\r\n            }\r\n\r\n            primitive.indices = accessorIndex;\r\n        }\r\n    }\r\n\r\n    private _exportVertexBuffer(vertexBuffer: VertexBuffer, babylonMaterial: Material, start: number, count: number, state: ExporterState, primitive: IMeshPrimitive): void {\r\n        const kind = vertexBuffer.getKind();\r\n\r\n        if (!IsStandardVertexAttribute(kind)) {\r\n            return;\r\n        }\r\n\r\n        if (kind.startsWith(\"uv\") && !this._options.exportUnusedUVs) {\r\n            if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);\r\n\r\n        if (accessorIndex === undefined) {\r\n            // Get min/max from converted or original data.\r\n            const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData()!;\r\n            const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : undefined;\r\n\r\n            // For the remapped buffer views we created for float matrices indices, make sure to use their updated information.\r\n            const isFloatMatricesIndices =\r\n                (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;\r\n\r\n            const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;\r\n            const vertexBufferNormalized = isFloatMatricesIndices ? undefined : vertexBuffer.normalized;\r\n            const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer)! : state.getVertexBufferView(vertexBuffer._buffer)!;\r\n\r\n            const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;\r\n            this._accessors.push(\r\n                this._bufferManager.createAccessor(\r\n                    bufferView,\r\n                    GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),\r\n                    vertexBufferType,\r\n                    count,\r\n                    byteOffset,\r\n                    minMax,\r\n                    vertexBufferNormalized // TODO: Find other places where this is needed.\r\n                )\r\n            );\r\n            accessorIndex = this._accessors.length - 1;\r\n            state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);\r\n        }\r\n\r\n        primitive.attributes[GetAttributeType(kind)] = accessorIndex;\r\n    }\r\n\r\n    private async _exportMaterialAsync(babylonMaterial: Material, vertexBuffers: { [kind: string]: VertexBuffer }, subMesh: SubMesh, primitive: IMeshPrimitive): Promise<void> {\r\n        let materialIndex = this._materialMap.get(babylonMaterial);\r\n        if (materialIndex === undefined) {\r\n            const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith(\"uv\"));\r\n            babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex]! : babylonMaterial;\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, hasUVs);\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, hasUVs);\r\n            } else if (babylonMaterial instanceof OpenPBRMaterial) {\r\n                materialIndex = await this._materialExporter.exportOpenPBRMaterialAsync(babylonMaterial, hasUVs);\r\n            } else {\r\n                Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);\r\n                return;\r\n            }\r\n\r\n            this._materialMap.set(babylonMaterial, materialIndex);\r\n        }\r\n\r\n        primitive.material = materialIndex;\r\n    }\r\n\r\n    private async _exportMeshAsync(babylonMesh: Mesh, state: ExporterState): Promise<number> {\r\n        let meshIndex = state.getMesh(babylonMesh);\r\n        if (meshIndex !== undefined) {\r\n            return meshIndex;\r\n        }\r\n\r\n        const mesh: IMesh = { primitives: [] };\r\n        meshIndex = this._meshes.length;\r\n        this._meshes.push(mesh);\r\n        state.setMesh(babylonMesh, meshIndex);\r\n\r\n        const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();\r\n        const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();\r\n        const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);\r\n\r\n        const isLinesMesh = babylonMesh instanceof LinesMesh;\r\n        const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;\r\n\r\n        const subMeshes = babylonMesh.subMeshes;\r\n        if (vertexBuffers && subMeshes && subMeshes.length > 0) {\r\n            for (const subMesh of subMeshes) {\r\n                const primitive: IMeshPrimitive = { attributes: {} };\r\n\r\n                const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;\r\n\r\n                if (isGreasedLineMesh) {\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    const colorWhite = Color3.White();\r\n                    const alpha = babylonLinesMesh.material?.alpha ?? 1;\r\n                    const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;\r\n                    if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...color.asArray(), alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else if (isLinesMesh) {\r\n                    // Special case for LinesMesh\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else {\r\n                    // Material\r\n                    // eslint-disable-next-line no-await-in-loop\r\n                    await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);\r\n                }\r\n\r\n                // Index buffer\r\n                const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : (babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode);\r\n\r\n                let sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);\r\n                if (state.wasAddedByNoopNode && !babylonMesh.getScene().useRightHandedSystem) {\r\n                    // To properly remove a conversion node, we must also cancel out the implicit flip in its children's side orientations.\r\n                    sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n                }\r\n\r\n                this._exportIndices(\r\n                    indices,\r\n                    indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535,\r\n                    indices ? subMesh.indexStart : subMesh.verticesStart,\r\n                    indices ? subMesh.indexCount : subMesh.verticesCount,\r\n                    -subMesh.verticesStart,\r\n                    fillMode,\r\n                    sideOrientation,\r\n                    state,\r\n                    primitive\r\n                );\r\n\r\n                // Vertex buffers\r\n                for (const vertexBuffer of Object.values(vertexBuffers)) {\r\n                    this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);\r\n                }\r\n\r\n                if (morphTargets) {\r\n                    primitive.targets = [];\r\n                    for (const gltfMorphTarget of morphTargets) {\r\n                        primitive.targets.push(gltfMorphTarget.attributes);\r\n                    }\r\n                }\r\n\r\n                mesh.primitives.push(primitive);\r\n                this._extensionsPostExportMeshPrimitive(primitive);\r\n            }\r\n        }\r\n\r\n        if (morphTargets) {\r\n            mesh.weights = [];\r\n\r\n            if (!mesh.extras) {\r\n                mesh.extras = {};\r\n            }\r\n            mesh.extras.targetNames = [];\r\n\r\n            for (const gltfMorphTarget of morphTargets) {\r\n                mesh.weights.push(gltfMorphTarget.influence);\r\n                mesh.extras.targetNames.push(gltfMorphTarget.name);\r\n            }\r\n        }\r\n\r\n        return meshIndex;\r\n    }\r\n}\r\n"]}