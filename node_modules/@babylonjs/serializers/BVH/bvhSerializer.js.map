{"version":3,"file":"bvhSerializer.js","sourceRoot":"","sources":["../../../../dev/serializers/src/BVH/bvhSerializer.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,cAAc,EAAE,qDAAuC;AAChE,OAAO,EAAE,OAAO,EAAE,UAAU,EAAE,MAAM,EAAE,6CAA+B;AACrE,OAAO,EAAE,KAAK,EAAE,sCAAwB;AACxC,OAAO,EAAE,OAAO,EAAE,gDAAkC;AAYpD,MAAM,OAAO,WAAW;IACb,MAAM,CAAC,MAAM,CAAC,QAAkB,EAAE,iBAA2B,EAAE,EAAE,SAAkB;QACtF,oBAAoB;QACpB,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC3C,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;QAC1D,CAAC;QAED,+DAA+D;QAC/D,IAAI,kBAAkB,GAAG,cAAc,CAAC;QACxC,IAAI,CAAC,cAAc,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACjD,kBAAkB,GAAG,QAAQ,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtE,CAAC;QAED,kEAAkE;QAClE,IAAI,YAAY,GAA6B,IAAI,CAAC;QAClD,KAAK,MAAM,QAAQ,IAAI,kBAAkB,EAAE,CAAC;YACxC,MAAM,KAAK,GAAG,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,CAAC;YACnD,IAAI,KAAK,EAAE,CAAC;gBACR,YAAY,GAAG,YAAY,CAAC,CAAC,CAAC,IAAI,cAAc,CAAC,iBAAiB,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YAC9J,CAAC;QACL,CAAC;QAED,IAAI,CAAC,YAAY,EAAE,CAAC;YAChB,6DAA6D;YAC7D,IAAI,QAAQ,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACjC,YAAY,GAAG,QAAQ,CAAC,iBAAiB,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC;YAC3E,CAAC;YAED,IAAI,CAAC,YAAY,EAAE,CAAC;gBAChB,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;YAC5D,CAAC;QACL,CAAC;QAED,2DAA2D;QAC3D,MAAM,eAAe,GAAG,SAAS,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,cAAc,IAAI,EAAE,CAAC,CAAC;QAExF,kDAAkD;QAClD,MAAM,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,kBAAkB,CAAC,CAAC;QAE7E,wDAAwD;QACxD,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,KAAK,MAAM,QAAQ,IAAI,aAAa,EAAE,CAAC;YACnC,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACnC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YACpE,CAAC;YACD,IAAI,QAAQ,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACnC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,QAAQ,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;YACpE,CAAC;QACL,CAAC;QAED,6DAA6D;QAC7D,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC;YACnB,UAAU,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,YAAY,CAAC,EAAE,GAAG,YAAY,CAAC,IAAI,CAAC,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC;QACzF,CAAC;QAED,IAAI,YAAY,GAAG,EAAE,CAAC;QACtB,YAAY,IAAI,aAAa,CAAC;QAE9B,+BAA+B;QAC/B,YAAY,IAAI,IAAI,CAAC,gBAAgB,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QAExD,qBAAqB;QACrB,YAAY,IAAI,UAAU,CAAC;QAC3B,YAAY,IAAI,WAAW,UAAU,IAAI,CAAC;QAC1C,YAAY,IAAI,eAAe,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC;QAE9D,oBAAoB;QACpB,YAAY,IAAI,IAAI,CAAC,iBAAiB,CAAC,aAAa,EAAE,UAAU,EAAE,CAAC,EAAE,kBAAkB,CAAC,CAAC;QAEzF,OAAO,YAAY,CAAC;IACxB,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,QAAkB,EAAE,cAAwB;QAC3E,MAAM,OAAO,GAAG,IAAI,GAAG,EAAsB,CAAC;QAC9C,MAAM,SAAS,GAAmB,EAAE,CAAC;QAErC,uCAAuC;QACvC,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE,CAAC;YAChC,MAAM,QAAQ,GAAiB;gBAC3B,IAAI;gBACJ,QAAQ,EAAE,EAAE;gBACZ,mBAAmB,EAAE,KAAK;gBAC1B,mBAAmB,EAAE,KAAK;gBAC1B,YAAY,EAAE,EAAE;gBAChB,YAAY,EAAE,EAAE;aACnB,CAAC;YACF,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;QAChC,CAAC;QAED,0DAA0D;QAC1D,KAAK,MAAM,IAAI,IAAI,QAAQ,CAAC,KAAK,EAAE,CAAC;YAChC,MAAM,QAAQ,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAE,CAAC;YAEpC,kEAAkE;YAClE,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC7B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;oBACtC,oEAAoE;oBACpE,IAAI,cAAc,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC;wBAC1C,IAAI,SAAS,CAAC,cAAc,KAAK,UAAU,EAAE,CAAC;4BAC1C,QAAQ,CAAC,mBAAmB,GAAG,IAAI,CAAC;4BACpC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;wBACvD,CAAC;6BAAM,IAAI,SAAS,CAAC,cAAc,KAAK,oBAAoB,EAAE,CAAC;4BAC3D,QAAQ,CAAC,mBAAmB,GAAG,IAAI,CAAC;4BACpC,QAAQ,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,SAAS,CAAC,OAAO,EAAE,CAAC,CAAC;wBACvD,CAAC;oBACL,CAAC;gBACL,CAAC;YACL,CAAC;YAED,kBAAkB;YAClB,IAAI,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;gBACnB,MAAM,UAAU,GAAG,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAG,CAAC,CAAC;gBAClD,IAAI,UAAU,EAAE,CAAC;oBACb,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACvC,CAAC;YACL,CAAC;iBAAM,CAAC;gBACJ,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC7B,CAAC;QACL,CAAC;QAED,OAAO,SAAS,CAAC;IACrB,CAAC;IAEO,MAAM,CAAC,gBAAgB,CAAC,QAAwB,EAAE,WAAmB;QACzE,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAE1C,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;YAC1B,MAAM,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YACvB,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;YAExC,IAAI,SAAS,EAAE,CAAC;gBACZ,MAAM,IAAI,GAAG,MAAM,YAAY,CAAC;gBAChC,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC;gBACzB,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBACzC,MAAM,IAAI,GAAG,MAAM,cAAc,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC;gBACvG,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC;YAC7B,CAAC;iBAAM,CAAC;gBACJ,MAAM,IAAI,GAAG,WAAW,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,OAAO,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;gBAC5E,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC;gBACzB,MAAM,MAAM,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;gBACzC,MAAM,IAAI,GAAG,MAAM,cAAc,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC;gBAEvG,qBAAqB;gBACrB,MAAM,QAAQ,GAAa,EAAE,CAAC;gBAC9B,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC3B,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;gBACzD,CAAC;gBACD,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC3B,wCAAwC;oBACxC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,WAAW,EAAE,WAAW,CAAC,CAAC;gBACzD,CAAC;gBAED,IAAI,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBACtB,MAAM,IAAI,GAAG,MAAM,gBAAgB,QAAQ,CAAC,MAAM,IAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;gBACjF,CAAC;gBAED,8BAA8B;gBAC9B,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;oBAC3B,MAAM,IAAI,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC;gBACpE,CAAC;gBAED,MAAM,IAAI,GAAG,MAAM,KAAK,CAAC;YAC7B,CAAC;QACL,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,MAAM,CAAC,UAAU,CAAC,IAAkB;QACxC,4EAA4E;QAC5E,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC;IACtC,CAAC;IAEO,MAAM,CAAC,cAAc,CAAC,IAAU;QACpC,gEAAgE;QAChE,IAAI,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,EAAE,CAAC;gBACpB,0CAA0C;gBAC1C,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC,cAAc,EAAE,CAAC;YACjD,CAAC;YAED,gDAAgD;YAChD,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;YAC1C,OAAO,WAAW,CAAC,cAAc,EAAE,CAAC;QACxC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACb,oDAAoD;YACpD,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;IACL,CAAC;IAEO,MAAM,CAAC,iBAAiB,CAAC,QAAwB,EAAE,UAAkB,EAAE,UAAkB,EAAE,cAAwB;QACvH,IAAI,MAAM,GAAG,EAAE,CAAC;QAEhB,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,UAAU,EAAE,KAAK,EAAE,EAAE,CAAC;YAC9C,MAAM,WAAW,GAAa,EAAE,CAAC;YAEjC,kDAAkD;YAClD,IAAI,CAAC,mBAAmB,CAAC,QAAQ,EAAE,KAAK,GAAG,UAAU,EAAE,WAAW,EAAE,cAAc,CAAC,CAAC;YAEpF,MAAM,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC;QACpE,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAEO,MAAM,CAAC,mBAAmB,CAAC,QAAwB,EAAE,UAAkB,EAAE,MAAgB,EAAE,cAAwB;QACvH,KAAK,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;YAC1B,iBAAiB;YACjB,IAAI,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC;gBACxB,SAAS;YACb,CAAC;YAED,mCAAmC;YACnC,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;gBAC9E,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpD,CAAC;YAED,mCAAmC;YACnC,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC3B,MAAM,QAAQ,GAAG,IAAI,CAAC,wBAAwB,CAAC,IAAI,CAAC,YAAY,EAAE,UAAU,CAAC,CAAC;gBAC9E,uCAAuC;gBACvC,MAAM,KAAK,GAAG,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC;gBAChD,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;YAC3C,CAAC;YAED,+BAA+B;YAC/B,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBAC3B,IAAI,CAAC,mBAAmB,CAAC,IAAI,CAAC,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,cAAc,CAAC,CAAC;YAChF,CAAC;QACL,CAAC;IACL,CAAC;IAEO,MAAM,CAAC,wBAAwB,CAAC,IAAqB,EAAE,UAAkB;QAC7E,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACpB,OAAO,OAAO,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;QAED,mCAAmC;QACnC,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACxE,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IAC5C,CAAC;IAEO,MAAM,CAAC,wBAAwB,CAAC,IAAqB,EAAE,UAAkB;QAC7E,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACpB,OAAO,UAAU,CAAC,QAAQ,EAAE,CAAC;QACjC,CAAC;QAED,mCAAmC;QACnC,MAAM,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QACxE,OAAO,IAAI,CAAC,YAAY,CAAC,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IAC5C,CAAC;IAEO,MAAM,CAAC,kBAAkB,CAAC,UAAsB;QACpD,0DAA0D;QAC1D,MAAM,MAAM,GAAG,IAAI,MAAM,EAAE,CAAC;QAC5B,UAAU,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAEpC,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC;QACnB,IAAI,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QAEZ,gCAAgC;QAChC,MAAM,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEhD,IAAI,EAAE,GAAG,OAAO,EAAE,CAAC;YACf,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC5B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAC1B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/B,CAAC;aAAM,CAAC;YACJ,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YAC5B,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAC1B,CAAC,GAAG,CAAC,CAAC;QACV,CAAC;QAED,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IACnF,CAAC;CACJ","sourcesContent":["import type { Skeleton } from \"core/Bones/skeleton\";\nimport type { Bone } from \"core/Bones/bone\";\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\nimport { AnimationRange } from \"core/Animations/animationRange\";\nimport { Vector3, Quaternion, Matrix } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { Epsilon } from \"core/Maths/math.constants\";\nimport type { Nullable } from \"core/types\";\n\ninterface IBVHBoneData {\n    bone: Bone;\n    children: IBVHBoneData[];\n    hasPositionChannels: boolean;\n    hasRotationChannels: boolean;\n    positionKeys: IAnimationKey[];\n    rotationKeys: IAnimationKey[];\n}\n\nexport class BVHExporter {\n    public static Export(skeleton: Skeleton, animationNames: string[] = [], frameRate?: number): string {\n        // Validate skeleton\n        if (!skeleton || skeleton.bones.length === 0) {\n            throw new Error(\"Invalid or empty skeleton provided\");\n        }\n\n        // If no animation names provided, use all available animations\n        let animationsToExport = animationNames;\n        if (!animationNames || animationNames.length === 0) {\n            animationsToExport = skeleton.animations.map((anim) => anim.name);\n        }\n\n        // Calculate overall animation range from all specified animations\n        let overallRange: Nullable<AnimationRange> = null;\n        for (const animName of animationsToExport) {\n            const range = skeleton.getAnimationRange(animName);\n            if (range) {\n                overallRange = overallRange ? new AnimationRange(\"animation-range\", Math.min(overallRange.from, range.from), Math.max(overallRange.to, range.to)) : range;\n            }\n        }\n\n        if (!overallRange) {\n            // If no animation range found, try to get from any animation\n            if (skeleton.animations.length > 0) {\n                overallRange = skeleton.getAnimationRange(skeleton.animations[0].name);\n            }\n\n            if (!overallRange) {\n                throw new Error(\"No animation range found in skeleton\");\n            }\n        }\n\n        // Calculate frame rate from animation data if not provided\n        const actualFrameRate = frameRate || 1 / (skeleton.animations[0]?.framePerSecond || 30);\n\n        // Build bone hierarchy and collect animation data\n        const boneHierarchy = this._BuildBoneHierarchy(skeleton, animationsToExport);\n\n        // Calculate frame count from actual animation keyframes\n        let frameCount = 0;\n        for (const boneData of boneHierarchy) {\n            if (boneData.positionKeys.length > 0) {\n                frameCount = Math.max(frameCount, boneData.positionKeys.length);\n            }\n            if (boneData.rotationKeys.length > 0) {\n                frameCount = Math.max(frameCount, boneData.rotationKeys.length);\n            }\n        }\n\n        // Fallback: if no keyframes found, calculate from time range\n        if (frameCount === 0) {\n            frameCount = Math.floor((overallRange.to - overallRange.from) / actualFrameRate) + 1;\n        }\n\n        let exportString = \"\";\n        exportString += `HIERARCHY\\n`;\n\n        // Export hierarchy recursively\n        exportString += this._ExportHierarchy(boneHierarchy, 0);\n\n        // Export motion data\n        exportString += `MOTION\\n`;\n        exportString += `Frames: ${frameCount}\\n`;\n        exportString += `Frame Time: ${actualFrameRate.toFixed(6)}\\n`;\n\n        // Export frame data\n        exportString += this._ExportMotionData(boneHierarchy, frameCount, 0, animationsToExport);\n\n        return exportString;\n    }\n\n    private static _BuildBoneHierarchy(skeleton: Skeleton, animationNames: string[]): IBVHBoneData[] {\n        const boneMap = new Map<Bone, IBVHBoneData>();\n        const rootBones: IBVHBoneData[] = [];\n\n        // First pass: create bone data objects\n        for (const bone of skeleton.bones) {\n            const boneData: IBVHBoneData = {\n                bone,\n                children: [],\n                hasPositionChannels: false,\n                hasRotationChannels: false,\n                positionKeys: [],\n                rotationKeys: [],\n            };\n            boneMap.set(bone, boneData);\n        }\n\n        // Second pass: build hierarchy and collect animation data\n        for (const bone of skeleton.bones) {\n            const boneData = boneMap.get(bone)!;\n\n            // Check if bone has animations from the specified animation names\n            if (bone.animations.length > 0) {\n                for (const animation of bone.animations) {\n                    // Only include animations that are in the specified animation names\n                    if (animationNames.includes(animation.name)) {\n                        if (animation.targetProperty === \"position\") {\n                            boneData.hasPositionChannels = true;\n                            boneData.positionKeys.push(...animation.getKeys());\n                        } else if (animation.targetProperty === \"rotationQuaternion\") {\n                            boneData.hasRotationChannels = true;\n                            boneData.rotationKeys.push(...animation.getKeys());\n                        }\n                    }\n                }\n            }\n\n            // Build hierarchy\n            if (bone.getParent()) {\n                const parentData = boneMap.get(bone.getParent()!);\n                if (parentData) {\n                    parentData.children.push(boneData);\n                }\n            } else {\n                rootBones.push(boneData);\n            }\n        }\n\n        return rootBones;\n    }\n\n    private static _ExportHierarchy(boneData: IBVHBoneData[], indentLevel: number): string {\n        let result = \"\";\n        const indent = \"    \".repeat(indentLevel);\n\n        for (const data of boneData) {\n            const bone = data.bone;\n            const isEndSite = this._IsEndSite(data);\n\n            if (isEndSite) {\n                result += `${indent}End Site\\n`;\n                result += `${indent}{\\n`;\n                const offset = this._GetBoneOffset(bone);\n                result += `${indent}    OFFSET ${offset.x.toFixed(6)} ${offset.y.toFixed(6)} ${offset.z.toFixed(6)}\\n`;\n                result += `${indent}}\\n`;\n            } else {\n                result += `${indentLevel === 0 ? \"ROOT\" : `${indent}JOINT`} ${bone.name}\\n`;\n                result += `${indent}{\\n`;\n                const offset = this._GetBoneOffset(bone);\n                result += `${indent}    OFFSET ${offset.x.toFixed(6)} ${offset.y.toFixed(6)} ${offset.z.toFixed(6)}\\n`;\n\n                // Determine channels\n                const channels: string[] = [];\n                if (data.hasPositionChannels) {\n                    channels.push(\"Xposition\", \"Yposition\", \"Zposition\");\n                }\n                if (data.hasRotationChannels) {\n                    // BVH typically uses ZXY rotation order\n                    channels.push(\"Zrotation\", \"Xrotation\", \"Yrotation\");\n                }\n\n                if (channels.length > 0) {\n                    result += `${indent}    CHANNELS ${channels.length} ${channels.join(\" \")}\\n`;\n                }\n\n                // Export children recursively\n                if (data.children.length > 0) {\n                    result += this._ExportHierarchy(data.children, indentLevel + 1);\n                }\n\n                result += `${indent}}\\n`;\n            }\n        }\n\n        return result;\n    }\n\n    private static _IsEndSite(data: IBVHBoneData): boolean {\n        // An end site is a bone with no children (regardless of animation channels)\n        return data.children.length === 0;\n    }\n\n    private static _GetBoneOffset(bone: Bone): Vector3 {\n        // Use the bone's rest matrix or local matrix for correct offset\n        try {\n            if (!bone.getParent()) {\n                // Root bone - use rest matrix translation\n                return bone.getRestMatrix().getTranslation();\n            }\n\n            // For child bones, use local matrix translation\n            const localMatrix = bone.getLocalMatrix();\n            return localMatrix.getTranslation();\n        } catch (error) {\n            // Fallback to zero offset if matrix operations fail\n            return Vector3.Zero();\n        }\n    }\n\n    private static _ExportMotionData(boneData: IBVHBoneData[], frameCount: number, startFrame: number, animationNames: string[]): string {\n        let result = \"\";\n\n        for (let frame = 0; frame < frameCount; frame++) {\n            const frameValues: number[] = [];\n\n            // Collect values for all bones in hierarchy order\n            this._CollectFrameValues(boneData, frame + startFrame, frameValues, animationNames);\n\n            result += frameValues.map((v) => v.toFixed(6)).join(\" \") + \"\\n\";\n        }\n\n        return result;\n    }\n\n    private static _CollectFrameValues(boneData: IBVHBoneData[], frameIndex: number, values: number[], animationNames: string[]): void {\n        for (const data of boneData) {\n            // Skip end sites\n            if (this._IsEndSite(data)) {\n                continue;\n            }\n\n            // Add position values if available\n            if (data.hasPositionChannels) {\n                const position = this._GetPositionAtFrameIndex(data.positionKeys, frameIndex);\n                values.push(position.x, position.y, position.z);\n            }\n\n            // Add rotation values if available\n            if (data.hasRotationChannels) {\n                const rotation = this._GetRotationAtFrameIndex(data.rotationKeys, frameIndex);\n                // Convert to Euler angles in ZXY order\n                const euler = this._QuaternionToEuler(rotation);\n                values.push(euler.z, euler.x, euler.y);\n            }\n\n            // Process children recursively\n            if (data.children.length > 0) {\n                this._CollectFrameValues(data.children, frameIndex, values, animationNames);\n            }\n        }\n    }\n\n    private static _GetPositionAtFrameIndex(keys: IAnimationKey[], frameIndex: number): Vector3 {\n        if (keys.length === 0) {\n            return Vector3.Zero();\n        }\n\n        // Clamp frame index to valid range\n        const clampedIndex = Math.max(0, Math.min(frameIndex, keys.length - 1));\n        return keys[clampedIndex].value.clone();\n    }\n\n    private static _GetRotationAtFrameIndex(keys: IAnimationKey[], frameIndex: number): Quaternion {\n        if (keys.length === 0) {\n            return Quaternion.Identity();\n        }\n\n        // Clamp frame index to valid range\n        const clampedIndex = Math.max(0, Math.min(frameIndex, keys.length - 1));\n        return keys[clampedIndex].value.clone();\n    }\n\n    private static _QuaternionToEuler(quaternion: Quaternion): Vector3 {\n        // Convert quaternion to Euler angles in ZXY order for BVH\n        const matrix = new Matrix();\n        quaternion.toRotationMatrix(matrix);\n\n        const m = matrix.m;\n        let x, y, z;\n\n        // ZXY rotation order extraction\n        const sy = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n\n        if (sy > Epsilon) {\n            x = Math.atan2(m[6], m[10]);\n            y = Math.atan2(-m[2], sy);\n            z = Math.atan2(m[1], m[0]);\n        } else {\n            x = Math.atan2(-m[9], m[5]);\n            y = Math.atan2(-m[2], sy);\n            z = 0;\n        }\n\n        return new Vector3(Tools.ToDegrees(x), Tools.ToDegrees(y), Tools.ToDegrees(z));\n    }\n}\n"]}