{"version":3,"file":"geospatialCamera.js","sourceRoot":"","sources":["../../../../dev/core/src/Cameras/geospatialCamera.ts"],"names":[],"mappings":"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","sourcesContent":["import { GeospatialCameraInputsManager } from \"./geospatialCameraInputsManager\";\r\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport { Scalar } from \"../Maths/math.scalar\";\r\nimport { Camera } from \"./camera\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { MeshPredicate } from \"../Culling/ray.core\";\r\nimport type { Nullable } from \"../types\";\r\n\r\ntype CameraOptions = {\r\n    planetRadius: number; // Radius of the planet\r\n    minAltitude?: number; // Minimum altitude of the camera above the planet surface\r\n    maxAltitude?: number; // Maximum altitude of the camera above the planet surface\r\n    restingAltitude?: number; // The altitude the camera will return to when not being actively zoomed in or out\r\n};\r\n\r\n/**\r\n * @experimental\r\n * This camera's movements are limited to a camera orbiting a globe, and as the API evolves it will introduce conversions between cartesian coordinates and true lat/long/alt\r\n *\r\n * Please note this is marked as experimental and the API (including the constructor!) will change until we remove that flag\r\n *\r\n * Still TODO:\r\n * - Pitch/yaw limits, input speeds\r\n * - ZoomToPoint\r\n * - Conversion between lat/long/alt and cartesian coordinates\r\n */\r\nexport class GeospatialCamera extends Camera {\r\n    override inputs: GeospatialCameraInputsManager;\r\n\r\n    // Changed by the inputs, reset on every frame\r\n    /** @internal */\r\n    public _perFrameGeocentricTranslation: Vector3; // Translation that keeps camera at the same radius from the center of the globe\r\n    /** @internal */\r\n    public _perFrameGeocentricRotation: Vector3; // Rotation around center (distinct from rotation around camera that can cause looking off into space)\r\n    /** @internal */\r\n    public _perFrameZoom: number;\r\n\r\n    /** If supplied, will be used when picking the globe */\r\n    public pickPredicate?: MeshPredicate;\r\n\r\n    /**\r\n     * Enables rotation around a specific point, instead of default rotation around center\r\n     * @internal\r\n     */\r\n    public _alternateRotationPt: Nullable<Vector3>;\r\n\r\n    /** The point on the globe that we are anchoring around. If no alternate rotation point is supplied, this will represent the center of screen*/\r\n    public get center(): Vector3 {\r\n        // NOTE that for now we are falling back to target if no pick on globe (because that shouldn't happen with current implemented inputs)\r\n        // but eventually we want to return a point on the globe even if the camera is looking off into space\r\n        return this._pickAlongLook?.pickedPoint ?? this._target;\r\n    }\r\n\r\n    // Temp vars\r\n    private _tempGeocentricNormal: Vector3;\r\n    private _tempRotationAxis: Vector3;\r\n    private _tempRotationMatrix: Matrix;\r\n    private _tempPickingRay: Ray;\r\n    private _tempPosition: Vector3;\r\n\r\n    private _viewMatrix: Matrix;\r\n    private _isViewMatrixDirty: boolean;\r\n    private _lookAtVector: Vector3;\r\n\r\n    // Camera configuration vars\r\n    private _planetRadius: number;\r\n    private _minAltitude: number;\r\n    private _maxAltitude?: number;\r\n    private _maxCameraRadius?: number;\r\n    private _restingAltitude: number;\r\n\r\n    /** Target of camera when looking along lookAtVector from current position. This does not necessarily represent a point on the globe */\r\n    private get _target(): Vector3 {\r\n        return this.position.addToRef(this._lookAtVector, this._tempPosition);\r\n    }\r\n\r\n    /** The point around which the camera will geocentrically rotate. Uses center (pt we are anchored to) if no alternateRotationPt is defined */\r\n    private get _geocentricRotationPt(): Vector3 {\r\n        return this._alternateRotationPt ?? this.center;\r\n    }\r\n\r\n    constructor(name: string, scene: Scene, options: CameraOptions, pickPredicate?: MeshPredicate) {\r\n        super(name, Vector3.Zero(), scene);\r\n        this._resetToDefault(options);\r\n        this.pickPredicate = pickPredicate;\r\n        this.inputs = new GeospatialCameraInputsManager(this);\r\n        this.inputs.addMouse().addMouseWheel();\r\n    }\r\n\r\n    private _resetToDefault(options: CameraOptions): void {\r\n        // Camera configuration vars\r\n        this._minAltitude = options.minAltitude ?? 5;\r\n        this._maxAltitude = options.maxAltitude;\r\n        this._planetRadius = options.planetRadius;\r\n        this._maxCameraRadius = this._maxAltitude ? this._planetRadius + this._maxAltitude : undefined;\r\n        this._restingAltitude = options.restingAltitude ?? this._maxCameraRadius ?? this._planetRadius * 4;\r\n        this.position.copyFromFloats(0, 0, -this._restingAltitude);\r\n\r\n        // Input vars\r\n        this._perFrameGeocentricRotation = Vector3.Zero();\r\n        this._perFrameGeocentricTranslation = Vector3.Zero();\r\n        this._perFrameZoom = 0;\r\n\r\n        // Temp vars\r\n        this._tempPosition = Vector3.Zero();\r\n        this._tempRotationAxis = Vector3.Right(); // starting axis used to calculate pitch rotation matrix\r\n        this._tempRotationMatrix = Matrix.Identity();\r\n        this._tempGeocentricNormal = Vector3.Zero();\r\n        this._tempPickingRay = new Ray(this.position, this._lookAtVector);\r\n        this._tempPickingRay.direction = Vector3.Zero();\r\n\r\n        // View matrix calculation vars\r\n        this.upVector = Vector3.Up(); // Up vector of the camera\r\n        this._lookAtVector = this.position.negate().normalize(); // Lookat vector of the camera\r\n        this._viewMatrix = Matrix.Identity();\r\n        this._isViewMatrixDirty = true;\r\n    }\r\n\r\n    /** @internal */\r\n    override _getViewMatrix() {\r\n        if (!this._isViewMatrixDirty) {\r\n            return this._viewMatrix;\r\n        }\r\n        this._isViewMatrixDirty = false;\r\n\r\n        // Ensure vectors are normalized\r\n        this.upVector.normalize();\r\n        this._lookAtVector.normalize();\r\n\r\n        // Calculate view matrix with camera position and target\r\n        if (this.getScene().useRightHandedSystem) {\r\n            Matrix.LookAtRHToRef(this.position, this._target, this.upVector, this._viewMatrix);\r\n        } else {\r\n            Matrix.LookAtLHToRef(this.position, this._target, this.upVector, this._viewMatrix);\r\n        }\r\n\r\n        return this._viewMatrix;\r\n    }\r\n\r\n    /** @internal */\r\n    override _isSynchronizedViewMatrix(): boolean {\r\n        if (!super._isSynchronizedViewMatrix() || this._isViewMatrixDirty) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Applies rotation correction to the camera by calculating a changeOfBasis matrix from the camera's current position to the new position\r\n     * and transforming the lookAt and up vectors by that matrix before updating the camera position and marking the view matrix as dirty\r\n     * @param newPos The camera's desired position, before correction is applied\r\n     */\r\n    private _applyRotationCorrectionAndSetPos(newPos: Vector3): void {\r\n        // Compute changeOfBasis between current camera position and new position\r\n        ComputeChangeOfBasisToRef(this.position, newPos, this._tempRotationMatrix);\r\n\r\n        // Apply rotation correction to lookat/up vectors\r\n        Vector3.TransformNormalToRef(this._lookAtVector, this._tempRotationMatrix, this._lookAtVector);\r\n        Vector3.TransformNormalToRef(this.upVector, this._tempRotationMatrix, this.upVector);\r\n\r\n        // Apply position change and mark viewMatrix as dirty\r\n        this.position.copyFrom(newPos);\r\n        this._isViewMatrixDirty = true;\r\n    }\r\n\r\n    /**\r\n     * When the geocentric normal has any translation change (due to dragging), we must ensure the camera remains orbiting around the world origin\r\n     * We thus need to perform 2 correction steps\r\n     * 1. Translation correction that keeps the camera at the same radius as before the drag\r\n     * 2. Rotation correction that keeps the camera facing the globe (so that as we pan, the globe stays centered on screen)\r\n     */\r\n    private _applyGeocentricTranslation() {\r\n        // Store pending position (without any corrections applied)\r\n        this.position.addToRef(this._perFrameGeocentricTranslation, this._tempPosition);\r\n\r\n        // 1. Calculate the altitude correction to keep camera at the same radius when applying translation\r\n        const tempPositionScaled = TmpVectors.Vector3[2];\r\n        const offset = TmpVectors.Vector3[3];\r\n        this._tempPosition.normalizeToRef(tempPositionScaled).scaleInPlace(this.position.length()); // what would tempPosition be if it were scaled to same radius as before\r\n        this._tempPosition.subtractToRef(tempPositionScaled, offset); // find offset between tempPosition and the tempScaledPosition\r\n        this._tempPosition.subtractInPlace(offset); // reduce tempPosition by that offset\r\n\r\n        // 2. Calculate the rotation correction to keep camera facing globe\r\n        this._applyRotationCorrectionAndSetPos(this._tempPosition);\r\n    }\r\n\r\n    /**\r\n     * This rotation keeps the camera oriented towards the globe as it orbits around it. This is different from cameraCentricRotation which is when the camera rotates around its own axis\r\n     */\r\n    private _applyGeocentricRotation(): void {\r\n        // Normalize key vectors\r\n        this._geocentricRotationPt.normalizeToRef(this._tempGeocentricNormal);\r\n        this.upVector.normalize();\r\n        this._lookAtVector.normalize();\r\n\r\n        const pitchRotationMatrix = Matrix.Identity();\r\n        const yawRotationMatrix = Matrix.Identity();\r\n        // First apply pitch\r\n        if (this._perFrameGeocentricRotation.x !== 0) {\r\n            // Compute a rotation axis that is perpendicular to both the upVector and the geocentricNormalOfPitchPoint\r\n            Vector3.CrossToRef(this.upVector, this._tempGeocentricNormal, this._tempRotationAxis);\r\n\r\n            // If upVector and geocentricNormalOfPitchPoint are parallel, fall back to cross(lookAtDirection, geocentricNormalOfPitchPoint)\r\n            if (this._tempRotationAxis.lengthSquared() <= Epsilon) {\r\n                Vector3.CrossToRef(this._lookAtVector, this._tempGeocentricNormal, this._tempRotationAxis);\r\n            }\r\n\r\n            const pitchSign = Math.sign(Vector3.Dot(this._tempGeocentricNormal, this.upVector)); // If negative, camera is upside down\r\n            // Since these are pointed in opposite directions, we must negate the dot product to get the proper angle\r\n            const currentPitch = pitchSign * Math.acos(Scalar.Clamp(-Vector3.Dot(this._lookAtVector, this._tempGeocentricNormal), -1, 1));\r\n            const newPitch = Scalar.Clamp(currentPitch + this._perFrameGeocentricRotation.x, 0, 0.5 * Math.PI - Epsilon);\r\n            // Build rotation matrix around normalized axis\r\n            Matrix.RotationAxisToRef(this._tempRotationAxis.normalize(), newPitch - currentPitch, pitchRotationMatrix);\r\n        }\r\n\r\n        // Then apply yaw\r\n        if (this._perFrameGeocentricRotation.y !== 0) {\r\n            Matrix.RotationAxisToRef(this._tempGeocentricNormal, this._perFrameGeocentricRotation.y, yawRotationMatrix); // this axis changes if we aren't using center of screen for tilt\r\n        }\r\n        pitchRotationMatrix.multiplyToRef(yawRotationMatrix, this._tempRotationMatrix);\r\n\r\n        // Offset camera to be (position-pitchPoint) distance from geocentricOrigin, apply rotation to position/up/lookat vectors, then add back the pitchPoint offset\r\n        this.position.subtractInPlace(this._geocentricRotationPt);\r\n\r\n        Vector3.TransformCoordinatesToRef(this.position, this._tempRotationMatrix, this.position);\r\n        Vector3.TransformNormalToRef(this.upVector, this._tempRotationMatrix, this.upVector);\r\n        Vector3.TransformNormalToRef(this._lookAtVector, this._tempRotationMatrix, this._lookAtVector);\r\n\r\n        this.position.addInPlace(this._geocentricRotationPt);\r\n    }\r\n\r\n    private _clampZoomDistance(requestedDistance: number, pickResultDistance: number | undefined): number {\r\n        // If pickResult is defined\r\n        if (requestedDistance > 0) {\r\n            if (pickResultDistance !== undefined) {\r\n                // If there is a pick, allow movement up to pick - minAltitude\r\n                if (pickResultDistance - this._minAltitude < 0) {\r\n                    return 0;\r\n                }\r\n                return Math.min(requestedDistance, pickResultDistance - this._minAltitude);\r\n            } else {\r\n                return requestedDistance;\r\n            }\r\n        }\r\n\r\n        if (requestedDistance < 0) {\r\n            const maxZoomOut = this._maxCameraRadius ? this._maxCameraRadius - this.position.length() : Number.POSITIVE_INFINITY;\r\n            return Math.max(requestedDistance, -maxZoomOut);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private _applyZoom(distance: number) {\r\n        const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, this.pickPredicate);\r\n        if (pickResult.hit && pickResult.ray) {\r\n            // Zoom to cursor\r\n            this._moveCameraAlongVectorByDistance(pickResult.ray.direction, this._clampZoomDistance(distance, pickResult.distance));\r\n        } else {\r\n            // If no hit under cursor, zoom along lookVector instead\r\n            this._moveCameraAlongVectorByDistance(this._lookAtVector, this._clampZoomDistance(distance, this._pickAlongLook?.distance));\r\n        }\r\n    }\r\n\r\n    private _moveCameraAlongVectorByDistance(vector: Vector3, distance: number) {\r\n        if (distance) {\r\n            vector.scaleAndAddToRef(distance, this._tempPosition);\r\n            this._applyRotationCorrectionAndSetPos(this._tempPosition);\r\n        }\r\n    }\r\n\r\n    private get _pickAlongLook() {\r\n        this._tempPickingRay.origin.copyFrom(this.position);\r\n        this._tempPickingRay.direction.copyFrom(this._lookAtVector);\r\n        return this._scene.pickWithRay(this._tempPickingRay, this.pickPredicate);\r\n    }\r\n\r\n    override _checkInputs(): void {\r\n        this.inputs.checkInputs();\r\n        if (this._perFrameGeocentricTranslation.lengthSquared() > 0) {\r\n            this._applyGeocentricTranslation();\r\n            this._perFrameGeocentricTranslation.setAll(0);\r\n            this._isViewMatrixDirty = true;\r\n        }\r\n        if (this._perFrameGeocentricRotation.lengthSquared() > 0) {\r\n            this._applyGeocentricRotation();\r\n            this._perFrameGeocentricRotation.setAll(0);\r\n            this._isViewMatrixDirty = true;\r\n        }\r\n        if (this._perFrameZoom !== 0) {\r\n            this._applyZoom(this._perFrameZoom);\r\n            this._perFrameZoom = 0;\r\n            this._isViewMatrixDirty = true;\r\n        }\r\n        super._checkInputs();\r\n    }\r\n\r\n    override attachControl(noPreventDefault?: boolean): void {\r\n        this.inputs.attachElement(noPreventDefault);\r\n    }\r\n\r\n    override detachControl(): void {\r\n        this.inputs.detachElement();\r\n    }\r\n}\r\n\r\n// Helper to build east/north/up basis vectors at a world position\r\nfunction ComputeLocalBasisToRefs(worldPos: Vector3, refEast: Vector3, refNorth: Vector3, refUp: Vector3) {\r\n    // up = normalized position (geocentric normal)\r\n    refUp.copyFrom(worldPos).normalize();\r\n\r\n    // east = normalize(up × worldUp)\r\n    // (cross product of up with world Y gives east except at poles)\r\n    const worldUp = Vector3.Up(); // (0,1,0)\r\n    Vector3.CrossToRef(refUp, worldUp, refEast);\r\n\r\n    // at poles, cross with worldForward instead\r\n    if (refEast.lengthSquared() < Epsilon) {\r\n        Vector3.CrossToRef(refUp, Vector3.Forward(), refEast);\r\n    }\r\n    refEast.normalize();\r\n\r\n    // north = up × east (completes right-handed basis)\r\n    Vector3.CrossToRef(refUp, refEast, refNorth);\r\n    refNorth.normalize();\r\n}\r\n\r\n/**\r\n * Calculates changeOfBasis matrix from currentPos to newPos and stores it in ref\r\n * @param currentPos\r\n * @param newPos\r\n * @param ref\r\n * @returns The changeOfBasis matrix from currentPos to newPos\r\n */\r\nfunction ComputeChangeOfBasisToRef(currentPos: Vector3, newPos: Vector3, ref: Matrix): Matrix {\r\n    const currentBasis = TmpVectors.Matrix[5];\r\n    const newBasis = TmpVectors.Matrix[6];\r\n    const inverse = TmpVectors.Matrix[7];\r\n    const east = TmpVectors.Vector3[3];\r\n    const north = TmpVectors.Vector3[4];\r\n    const up = TmpVectors.Vector3[5];\r\n\r\n    ComputeLocalBasisToRefs(currentPos, east, north, up);\r\n    Matrix.FromXYZAxesToRef(east, north, up, currentBasis);\r\n\r\n    ComputeLocalBasisToRefs(newPos, east, north, up);\r\n    Matrix.FromXYZAxesToRef(east, north, up, newBasis);\r\n\r\n    // Change of basis matrix = basis2 * basis1.inverse()\r\n    // (since orthonormal, inverse = transpose)\r\n    currentBasis.transposeToRef(inverse).multiplyToRef(newBasis, ref);\r\n\r\n    return ref;\r\n}\r\n"]}