{"version":3,"file":"geospatialCameraPointersInput.js","sourceRoot":"","sources":["../../../../../dev/core/src/Cameras/Inputs/geospatialCameraPointersInput.ts"],"names":[],"mappings":"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","sourcesContent":["import type { GeospatialCamera } from \"../../Cameras/geospatialCamera\";\r\nimport type { PickingInfo } from \"../../Collisions/pickingInfo\";\r\nimport type { Ray } from \"../../Culling/ray\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport { Plane } from \"../../Maths/math.plane\";\r\nimport { TmpVectors, Vector3 } from \"../../Maths/math.vector\";\r\nimport type { Nullable } from \"../../types\";\r\nimport { BaseCameraPointersInput } from \"./BaseCameraPointersInput\";\r\n\r\n/**\r\n * @experimental\r\n * Geospatial camera inputs can simulate dragging the globe around or tilting the camera around some point on the globe\r\n * The input will update the camera's localTranslation or localRotation values, and the camera is responsible for using these updates to calculate viewMatrix appropriately\r\n *\r\n * As of right now, the camera correction logic (to keep the camera geospatially oriented around the globe) is happening within the camera class when calculating viewmatrix\r\n * As this is experimental, it is possible we move that correction step to live within the input class (to enable non-corrected translations in the future), say if we want to allow the camera to move outside of the globe's orbit\r\n *\r\n * Left mouse button: drag globe\r\n * Middle mouse button: tilt globe around cursor location\r\n * Right mouse button: tilt globe around center of screen\r\n *\r\n */\r\nexport class GeospatialCameraPointersInput extends BaseCameraPointersInput {\r\n    public camera: GeospatialCamera;\r\n\r\n    /**\r\n     * Mouse sensitivity for rotation (lower = more sensitive)\r\n     */\r\n    public angularSensibility = 200.0;\r\n\r\n    private _dragPlane: Plane = new Plane(0, 0, 0, 0);\r\n    private _dragPlaneNormal: Vector3 = Vector3.Zero();\r\n    private _dragPlaneOriginPoint: Vector3 = Vector3.Zero();\r\n    private _dragPlaneHitPoint: Vector3 = Vector3.Zero();\r\n    private _dragPlaneOffsetVector: Vector3 = Vector3.Zero();\r\n\r\n    private _hitPointRadius?: number; // Distance between world origin (center of globe) and the hitPoint (where initial drag started)\r\n\r\n    public override getClassName(): string {\r\n        return \"GeospatialCameraPointersInput\";\r\n    }\r\n\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        const scene = this.camera.getScene();\r\n        let pickResult: Nullable<PickingInfo>;\r\n        switch (evt.button) {\r\n            case 0: // Left button - drag/pan globe under cursor\r\n                pickResult = scene.pick(scene.pointerX, scene.pointerY, this.camera.pickPredicate);\r\n                if (pickResult.pickedPoint && pickResult.ray) {\r\n                    // Store radius from earth center to pickedPoint, used when calculating drag plane\r\n                    this._hitPointRadius = pickResult.pickedPoint.length();\r\n\r\n                    // The dragPlaneOffsetVector will later be recalculated when drag occurs, and the delta between the offset vectors will be applied to localTranslation\r\n                    this._recalculateDragPlaneOffsetVectorToRef(this._hitPointRadius, pickResult.ray, this._dragPlaneOffsetVector);\r\n                } else {\r\n                    this._hitPointRadius = undefined; // can't drag without a hit on the globe\r\n                }\r\n                break;\r\n            case 1: // Middle button - tilt camera around cursor\r\n                pickResult = scene.pick(scene.pointerX, scene.pointerY, this.camera.pickPredicate);\r\n                pickResult.pickedPoint && (this.camera._alternateRotationPt = pickResult.pickedPoint);\r\n                break;\r\n            case 2: // Right button - tilt camera around center of screen, already the default\r\n                this.camera._alternateRotationPt = this.camera.center;\r\n                break;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        switch (point?.button) {\r\n            case 0: // Left button - drag/pan globe under cursor\r\n                this._hitPointRadius !== undefined && this._handleDrag(this._hitPointRadius);\r\n                break;\r\n            case 1: // Middle button - tilt camera around cursor\r\n            case 2: // Right button - tilt camera\r\n                this._handleTilt(offsetX, offsetY);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._hitPointRadius = undefined;\r\n        this.camera._alternateRotationPt = null;\r\n    }\r\n\r\n    /**\r\n     * The DragPlaneOffsetVector represents the vector between the dragPlane hit point and the dragPlane origin point.\r\n     * As the drag movement occurs, we will continuously recalculate this vector. The delta between the offsetVectors is the delta we will apply to the camera's localtranslation\r\n     * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point\r\n     * @param ray The ray from the camera to the new cursor location\r\n     * @param ref The offset vector between the drag plane's hitPoint and originPoint\r\n     */\r\n    private _recalculateDragPlaneOffsetVectorToRef(hitPointRadius: number, ray: Ray, ref: Vector3) {\r\n        // Use the camera's geocentric normal to find the dragPlaneOriginPoint which lives at hitPointRadius along the camera's geocentric normal\r\n        this.camera.position.normalizeToRef(this._dragPlaneNormal);\r\n        this._dragPlaneNormal.scaleToRef(hitPointRadius, this._dragPlaneOriginPoint);\r\n\r\n        // Now create a plane at that point, perpendicular to the camera's geocentric normal\r\n        Plane.FromPositionAndNormalToRef(this._dragPlaneOriginPoint, this._dragPlaneNormal, this._dragPlane);\r\n\r\n        // Lastly, find the _dragPlaneHitPoint where the ray intersects the _dragPlane\r\n        IntersectRayWithPlaneToRef(ray, this._dragPlane, this._dragPlaneHitPoint);\r\n\r\n        // Store the new offset between the drag plane's hitPoint and originPoint\r\n        this._dragPlaneHitPoint.subtractToRef(this._dragPlaneOriginPoint, ref);\r\n    }\r\n\r\n    private _handleDrag(hitPointRadius: number): void {\r\n        const scene = this.camera.getScene();\r\n        const pickResult = scene.pick(scene.pointerX, scene.pointerY);\r\n        if (pickResult.ray) {\r\n            const newDragPlaneOffsetVector = TmpVectors.Vector3[5];\r\n            this._recalculateDragPlaneOffsetVectorToRef(hitPointRadius, pickResult.ray, newDragPlaneOffsetVector);\r\n            const delta = TmpVectors.Vector3[6];\r\n            newDragPlaneOffsetVector.subtractToRef(this._dragPlaneOffsetVector, delta);\r\n\r\n            this._dragPlaneOffsetVector.copyFrom(newDragPlaneOffsetVector);\r\n\r\n            this.camera._perFrameGeocentricTranslation.subtractInPlace(delta); // ???\r\n        }\r\n    }\r\n\r\n    private _handleTilt(deltaX: number, deltaY: number): void {\r\n        this.camera._perFrameGeocentricRotation.y += -deltaX / this.angularSensibility; // yaw - looking side to side\r\n        this.camera._perFrameGeocentricRotation.x += -deltaY / this.angularSensibility; // pitch - look up towards sky / down towards ground\r\n    }\r\n}\r\n\r\nfunction IntersectRayWithPlaneToRef(ray: Ray, plane: Plane, ref: Vector3): boolean {\r\n    // Distance along the ray to the plane; null if no hit\r\n    const dist = ray.intersectsPlane(plane);\r\n\r\n    if (dist !== null && dist >= 0) {\r\n        ray.origin.addToRef(ray.direction.scaleToRef(dist, TmpVectors.Vector3[0]), ref);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n"]}