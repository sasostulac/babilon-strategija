{"version":3,"file":"smartFilterTextureBlock.js","sourceRoot":"","sources":["../../../../../../../dev/core/src/Materials/Node/Blocks/Dual/smartFilterTextureBlock.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,wBAAwB,EAAE,MAAM,sCAAsC,CAAC;AAChF,OAAO,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAC1D,OAAO,EAAE,aAAa,EAAE,sCAA4B;AACpD,OAAO,EAAE,UAAU,EAAE,MAAM,qBAAqB,CAAC;AAIjD,OAAO,EAAE,aAAa,EAAE,MAAM,4CAA4C,CAAC;AAC3E,OAAO,EAAE,qCAAqC,EAAE,MAAM,mDAAmD,CAAC;AAK1G,OAAO,EAAE,uCAAuC,EAAE,MAAM,+CAA+C,CAAC;AACxG,OAAO,EAAE,gBAAgB,EAAE,MAAM,oBAAoB,CAAC;AAEtD;;;;GAIG;AACH,MAAM,OAAO,uBAAwB,SAAQ,kBAAkB;IAS3D;;OAEG;IACH,IAAoB,WAAW;QAC3B,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;YAC7B,OAAQ,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAA+B,CAAC,WAAW,CAAC;QACnF,CAAC;QACD,OAAO,IAAI,CAAC,YAAY,CAAC;IAC7B,CAAC;IAED;;OAEG;IACH,IAAoB,OAAO;QACvB,IAAI,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC;YAC7B,OAAQ,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,UAA+B,CAAC,OAAO,CAAC;QAC/E,CAAC;QACD,OAAO,IAAI,CAAC,QAAQ,CAAC;IACzB,CAAC;IACD,IAAoB,OAAO,CAAC,KAA4B;QACpD,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;IAC1B,CAAC;IAED;;;OAGG;IACH,YAAmB,IAAY;QAC3B,KAAK,CAAC,IAAI,CAAC,CAAC;QApCR,eAAU,GAAY,IAAI,CAAC;QAEnC;;;WAGG;QACI,gBAAW,GAAY,KAAK,CAAC;QAgChC,IAAI,CAAC,aAAa,CACd,QAAQ,EACR,qCAAqC,CAAC,MAAM,EAC5C,IAAI,EACJ,wBAAwB,CAAC,iBAAiB,EAC1C,IAAI,uCAAuC,CAAC,QAAQ,EAAE,IAAI,sDAA8C,gBAAgB,EAAE,kBAAkB,CAAC,CAChJ,CAAC;IACN,CAAC;IAED;;OAEG;IACH,IAAW,MAAM;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,IAAW,cAAc;QACrB,OAAO,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;IACnC,CAAC;IAED;;;OAGG;IACa,YAAY;QACxB,OAAO,yBAAyB,CAAC;IACrC,CAAC;IAED;;;OAGG;IACa,UAAU,CAAC,KAA6B;QACpD,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YAClB,IAAI,CAAC,YAAY,GAAG,KAAK,CAAC,oBAAoB,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC1D,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;QAC5B,CAAC;IACL,CAAC;IAEkB,cAAc,CAAC,KAA6B;QAC3D,6EAA6E;QAC7E,iHAAiH;QACjH,MAAM,QAAQ,GAAG,KAAK,CAAC,UAAU,CAAC,YAAY,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC,IAAI,KAAK,gBAAgB,CAAC,CAAC;QAC7H,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,CAAC;YAC9C,KAAK,CAAC,UAAU,CAAC,eAAe,CAAC,qFAAqF,CAAC,CAAC;YACxH,OAAO,EAAE,CAAC;QACd,CAAC;QACD,OAAO,QAAQ,CAAC,sBAAsB,CAAC;IAC3C,CAAC;IAEkB,iBAAiB,CAAC,KAA6B;QAC9D,IAAI,KAAK,CAAC,MAAM,KAAK,wBAAwB,CAAC,QAAQ,EAAE,CAAC;YACrD,8DAA8D;YAC9D,KAAK,CAAC,sBAAsB,CAAC,IAAI,CAAC,WAAW,EAAE,qCAAqC,CAAC,OAAO,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;YAEnH,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,CAAC;gBACvB,yEAAyE;gBACzE,MAAM,UAAU,GAAG,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC;gBAC5D,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,YAAY,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC,CAAC;YAC9E,CAAC;QACL,CAAC;IACL,CAAC;IAEe,aAAa,CAAC,QAAsB,EAAE,0BAAgE,GAAG,EAAE,CAAC,IAAI;QAC5H,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC;YACvB,IAAI,OAAO,GAAG,QAAQ,CAAC,wBAAwB,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC,IAAI,KAAK,gBAAgB,IAAI,uBAAuB,CAAC,CAAC,CAAC,CAAC,CAAC;YAEnI,IAAI,CAAC,OAAO,EAAE,CAAC;gBACX,OAAO,GAAG,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC;gBAC/B,OAAO,CAAC,cAAc,CAAC,gBAAgB,CAAC,CAAC;YAC7C,CAAC;YACD,OAAO,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QACtC,CAAC;IACL,CAAC;IAEe,eAAe;QAC3B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IAC3B,CAAC;IAEe,SAAS;QACrB,MAAM,mBAAmB,GAAG,KAAK,CAAC,SAAS,EAAE,CAAC;QAC9C,mBAAmB,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC;QACnD,OAAO,mBAAmB,CAAC;IAC/B,CAAC;IAEe,YAAY,CAAC,mBAAwB,EAAE,KAAY,EAAE,OAAe;QAChF,KAAK,CAAC,YAAY,CAAC,mBAAmB,EAAE,KAAK,EAAE,OAAO,CAAC,CAAC;QACxD,IAAI,CAAC,WAAW,GAAG,mBAAmB,CAAC,WAAW,CAAC;IACvD,CAAC;CACJ;AAED,aAAa,CAAC,iCAAiC,EAAE,uBAAuB,CAAC,CAAC","sourcesContent":["import type { NodeMaterialBuildState } from \"../../nodeMaterialBuildState\";\nimport { NodeMaterialBlockTargets } from \"../../Enums/nodeMaterialBlockTargets\";\nimport { CurrentScreenBlock } from \"./currentScreenBlock\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { InputBlock } from \"../Input/inputBlock\";\nimport type { NodeMaterialBlock } from \"../../nodeMaterialBlock\";\nimport type { NodeMaterial } from \"../../nodeMaterial\";\nimport type { Scene } from \"core/scene\";\nimport { SfeModeDefine } from \"../Fragment/smartFilterFragmentOutputBlock\";\nimport { NodeMaterialBlockConnectionPointTypes } from \"../../Enums/nodeMaterialBlockConnectionPointTypes\";\nimport type { Nullable } from \"../../../../types\";\nimport type { BaseTexture } from \"../../../Textures/baseTexture\";\nimport type { NodeMaterialConnectionPoint } from \"../../nodeMaterialBlockConnectionPoint\";\nimport { NodeMaterialConnectionPointDirection } from \"../../nodeMaterialBlockConnectionPoint\";\nimport { NodeMaterialConnectionPointCustomObject } from \"../../nodeMaterialConnectionPointCustomObject\";\nimport { ImageSourceBlock } from \"./imageSourceBlock\";\n\n/**\n * Base block used for creating Smart Filter shader blocks for the SFE framework.\n * This block extends the functionality of CurrentScreenBlock, as both are used\n * to represent arbitrary 2D textures to compose, and work similarly.\n */\nexport class SmartFilterTextureBlock extends CurrentScreenBlock {\n    private _firstInit: boolean = true;\n\n    /**\n     * A boolean indicating whether this block should be the main input for the SFE pipeline.\n     * If true, it can be used in SFE for auto-disabling.\n     */\n    public isMainInput: boolean = false;\n\n    /**\n     * Gets the sampler name associated with this texture\n     */\n    public override get samplerName(): string {\n        if (this.source.connectedPoint) {\n            return (this.source.connectedPoint.ownerBlock as ImageSourceBlock).samplerName;\n        }\n        return this._samplerName;\n    }\n\n    /**\n     * Gets or sets the texture associated with this block\n     */\n    public override get texture(): Nullable<BaseTexture> {\n        if (this.source.connectedPoint) {\n            return (this.source.connectedPoint.ownerBlock as ImageSourceBlock).texture;\n        }\n        return this._texture;\n    }\n    public override set texture(value: Nullable<BaseTexture>) {\n        this._texture = value;\n    }\n\n    /**\n     * Create a new SmartFilterTextureBlock\n     * @param name defines the block name\n     */\n    public constructor(name: string) {\n        super(name);\n\n        this.registerInput(\n            \"source\",\n            NodeMaterialBlockConnectionPointTypes.Object,\n            true,\n            NodeMaterialBlockTargets.VertexAndFragment,\n            new NodeMaterialConnectionPointCustomObject(\"source\", this, NodeMaterialConnectionPointDirection.Input, ImageSourceBlock, \"ImageSourceBlock\")\n        );\n    }\n\n    /**\n     * Gets the source input component\n     */\n    public get source(): NodeMaterialConnectionPoint {\n        return this._inputs[1];\n    }\n\n    /**\n     * Gets a boolean indicating that this block is linked to an ImageSourceBlock\n     */\n    public get hasImageSource(): boolean {\n        return this.source.isConnected;\n    }\n\n    /**\n     * Gets the current class name\n     * @returns the class name\n     */\n    public override getClassName() {\n        return \"SmartFilterTextureBlock\";\n    }\n\n    /**\n     * Initialize the block and prepare the context for build\n     * @param state defines the state that will be used for the build\n     */\n    public override initialize(state: NodeMaterialBuildState) {\n        if (this._firstInit) {\n            this._samplerName = state._getFreeVariableName(this.name);\n            this._firstInit = false;\n        }\n    }\n\n    protected override _getMainUvName(state: NodeMaterialBuildState): string {\n        // Get the ScreenUVBlock's name, which is required for SFE and should be vUV.\n        // NOTE: In the future, when we move to vertex shaders, update this to check for the nearest vec2 varying output.\n        const screenUv = state.sharedData.nodeMaterial.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\");\n        if (!screenUv || !screenUv.isAnAncestorOf(this)) {\n            state.sharedData.raiseBuildError(\"SmartFilterTextureBlock: 'postprocess_uv' attribute from ScreenUVBlock is required.\");\n            return \"\";\n        }\n        return screenUv.associatedVariableName;\n    }\n\n    protected override _emitUvAndSampler(state: NodeMaterialBuildState): void {\n        if (state.target === NodeMaterialBlockTargets.Fragment) {\n            // Wrap the varying in a define, as it won't be needed in SFE.\n            state._emitVaryingFromString(this._mainUVName, NodeMaterialBlockConnectionPointTypes.Vector2, SfeModeDefine, true);\n\n            if (!this.hasImageSource) {\n                // Append `// main` to denote this as the main input texture to composite\n                const annotation = this.isMainInput ? \"// main\" : undefined;\n                state._emit2DSampler(this._samplerName, undefined, undefined, annotation);\n            }\n        }\n    }\n\n    public override autoConfigure(material: NodeMaterial, additionalFilteringInfo: (node: NodeMaterialBlock) => boolean = () => true) {\n        if (!this.uv.isConnected) {\n            let uvInput = material.getInputBlockByPredicate((b) => b.isAttribute && b.name === \"postprocess_uv\" && additionalFilteringInfo(b));\n\n            if (!uvInput) {\n                uvInput = new InputBlock(\"uv\");\n                uvInput.setAsAttribute(\"postprocess_uv\");\n            }\n            uvInput.output.connectTo(this.uv);\n        }\n    }\n\n    public override _postBuildBlock(): void {\n        this._firstInit = true;\n    }\n\n    public override serialize(): any {\n        const serializationObject = super.serialize();\n        serializationObject.isMainInput = this.isMainInput;\n        return serializationObject;\n    }\n\n    public override _deserialize(serializationObject: any, scene: Scene, rootUrl: string) {\n        super._deserialize(serializationObject, scene, rootUrl);\n        this.isMainInput = serializationObject.isMainInput;\n    }\n}\n\nRegisterClass(\"BABYLON.SmartFilterTextureBlock\", SmartFilterTextureBlock);\n"]}