import type { Nullable } from "../../types.js";
import { Scene } from "../../scene.js";
import { Color3 } from "../../Maths/math.color.js";
import { ImageProcessingConfiguration } from "../imageProcessingConfiguration.js";
import type { BaseTexture } from "../../Materials/Textures/baseTexture.js";
import { Material } from "../material.js";
import type { AbstractMesh } from "../../Meshes/abstractMesh.js";
import { MaterialDefines } from "../materialDefines.js";
import { PrePassConfiguration } from "../prePassConfiguration.js";
import type { IMaterialCompilationOptions } from "../../Materials/material.js";
import type { SubMesh } from "../../Meshes/subMesh.js";
import { Vector2 } from "../../Maths/math.vector.js";
import type { Matrix } from "../../Maths/math.vector.js";
import type { Mesh } from "../../Meshes/mesh.js";
import { PushMaterial } from "../pushMaterial.js";
import type { IAnimatable } from "../../Animations/animatable.interface.js";
declare const OpenPBRMaterialDefinesBase_base: {
    new (...args: any[]): {
        MAINUV1: boolean;
        MAINUV2: boolean;
        MAINUV3: boolean;
        MAINUV4: boolean;
        MAINUV5: boolean;
        MAINUV6: boolean;
        UV1: boolean;
        UV2: boolean;
        UV3: boolean;
        UV4: boolean;
        UV5: boolean;
        UV6: boolean;
    };
} & typeof MaterialDefines;
declare class OpenPBRMaterialDefinesBase extends OpenPBRMaterialDefinesBase_base {
}
declare const OpenPBRMaterialDefines_base: {
    new (...args: any[]): {
        IMAGEPROCESSING: boolean;
        VIGNETTE: boolean;
        VIGNETTEBLENDMODEMULTIPLY: boolean;
        VIGNETTEBLENDMODEOPAQUE: boolean;
        TONEMAPPING: number;
        CONTRAST: boolean;
        COLORCURVES: boolean;
        COLORGRADING: boolean;
        COLORGRADING3D: boolean;
        SAMPLER3DGREENDEPTH: boolean;
        SAMPLER3DBGRMAP: boolean;
        DITHER: boolean;
        IMAGEPROCESSINGPOSTPROCESS: boolean;
        SKIPFINALCOLORCLAMP: boolean;
        EXPOSURE: boolean;
    };
} & typeof OpenPBRMaterialDefinesBase;
/**
 * Manages the defines for the PBR Material.
 * @internal
 */
export declare class OpenPBRMaterialDefines extends OpenPBRMaterialDefines_base {
    NUM_SAMPLES: string;
    REALTIME_FILTERING: boolean;
    IBL_CDF_FILTERING: boolean;
    VERTEXCOLOR: boolean;
    BAKED_VERTEX_ANIMATION_TEXTURE: boolean;
    VERTEXALPHA: boolean;
    ALPHATEST: boolean;
    DEPTHPREPASS: boolean;
    ALPHABLEND: boolean;
    ALPHA_FROM_BASE_COLOR_TEXTURE: boolean;
    ALPHATESTVALUE: string;
    PREMULTIPLYALPHA: boolean;
    REFLECTIVITY_GAMMA: boolean;
    REFLECTIVITYDIRECTUV: number;
    SPECULARTERM: boolean;
    LODBASEDMICROSFURACE: boolean;
    METALLICWORKFLOW: boolean;
    ROUGHNESSSTOREINMETALMAPALPHA: boolean;
    ROUGHNESSSTOREINMETALMAPGREEN: boolean;
    METALLNESSSTOREINMETALMAPBLUE: boolean;
    AOSTOREINMETALMAPRED: boolean;
    SPECULAR_WEIGHT_IN_ALPHA: boolean;
    SPECULAR_WEIGHT_FROM_SPECULAR_COLOR_TEXTURE: boolean;
    SPECULAR_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE: boolean;
    COAT_ROUGHNESS_ANISOTROPY_FROM_TANGENT_TEXTURE: boolean;
    USE_GLTF_STYLE_ANISOTROPY: boolean;
    THIN_FILM_THICKNESS_FROM_THIN_FILM_TEXTURE: boolean;
    ENVIRONMENTBRDF: boolean;
    ENVIRONMENTBRDF_RGBD: boolean;
    NORMAL: boolean;
    TANGENT: boolean;
    OBJECTSPACE_NORMALMAP: boolean;
    PARALLAX: boolean;
    PARALLAX_RHS: boolean;
    PARALLAXOCCLUSION: boolean;
    NORMALXYSCALE: boolean;
    ANISOTROPIC: boolean;
    ANISOTROPIC_OPENPBR: boolean;
    ANISOTROPIC_BASE: boolean;
    ANISOTROPIC_COAT: boolean;
    THIN_FILM: boolean;
    IRIDESCENCE: boolean;
    REFLECTION: boolean;
    REFLECTIONMAP_3D: boolean;
    REFLECTIONMAP_SPHERICAL: boolean;
    REFLECTIONMAP_PLANAR: boolean;
    REFLECTIONMAP_CUBIC: boolean;
    USE_LOCAL_REFLECTIONMAP_CUBIC: boolean;
    REFLECTIONMAP_PROJECTION: boolean;
    REFLECTIONMAP_SKYBOX: boolean;
    REFLECTIONMAP_EXPLICIT: boolean;
    REFLECTIONMAP_EQUIRECTANGULAR: boolean;
    REFLECTIONMAP_EQUIRECTANGULAR_FIXED: boolean;
    REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: boolean;
    INVERTCUBICMAP: boolean;
    USESPHERICALFROMREFLECTIONMAP: boolean;
    USEIRRADIANCEMAP: boolean;
    USE_IRRADIANCE_DOMINANT_DIRECTION: boolean;
    USESPHERICALINVERTEX: boolean;
    REFLECTIONMAP_OPPOSITEZ: boolean;
    LODINREFLECTIONALPHA: boolean;
    GAMMAREFLECTION: boolean;
    RGBDREFLECTION: boolean;
    RADIANCEOCCLUSION: boolean;
    HORIZONOCCLUSION: boolean;
    INSTANCES: boolean;
    THIN_INSTANCES: boolean;
    INSTANCESCOLOR: boolean;
    PREPASS: boolean;
    PREPASS_COLOR: boolean;
    PREPASS_COLOR_INDEX: number;
    PREPASS_IRRADIANCE: boolean;
    PREPASS_IRRADIANCE_INDEX: number;
    PREPASS_ALBEDO: boolean;
    PREPASS_ALBEDO_INDEX: number;
    PREPASS_ALBEDO_SQRT: boolean;
    PREPASS_ALBEDO_SQRT_INDEX: number;
    PREPASS_DEPTH: boolean;
    PREPASS_DEPTH_INDEX: number;
    PREPASS_SCREENSPACE_DEPTH: boolean;
    PREPASS_SCREENSPACE_DEPTH_INDEX: number;
    PREPASS_NORMALIZED_VIEW_DEPTH: boolean;
    PREPASS_NORMALIZED_VIEW_DEPTH_INDEX: number;
    PREPASS_NORMAL: boolean;
    PREPASS_NORMAL_INDEX: number;
    PREPASS_NORMAL_WORLDSPACE: boolean;
    PREPASS_WORLD_NORMAL: boolean;
    PREPASS_WORLD_NORMAL_INDEX: number;
    PREPASS_POSITION: boolean;
    PREPASS_POSITION_INDEX: number;
    PREPASS_LOCAL_POSITION: boolean;
    PREPASS_LOCAL_POSITION_INDEX: number;
    PREPASS_VELOCITY: boolean;
    PREPASS_VELOCITY_INDEX: number;
    PREPASS_VELOCITY_LINEAR: boolean;
    PREPASS_VELOCITY_LINEAR_INDEX: number;
    PREPASS_REFLECTIVITY: boolean;
    PREPASS_REFLECTIVITY_INDEX: number;
    SCENE_MRT_COUNT: number;
    NUM_BONE_INFLUENCERS: number;
    BonesPerMesh: number;
    BONETEXTURE: boolean;
    BONES_VELOCITY_ENABLED: boolean;
    NONUNIFORMSCALING: boolean;
    MORPHTARGETS: boolean;
    MORPHTARGETS_POSITION: boolean;
    MORPHTARGETS_NORMAL: boolean;
    MORPHTARGETS_TANGENT: boolean;
    MORPHTARGETS_UV: boolean;
    MORPHTARGETS_UV2: boolean;
    MORPHTARGETS_COLOR: boolean;
    MORPHTARGETTEXTURE_HASPOSITIONS: boolean;
    MORPHTARGETTEXTURE_HASNORMALS: boolean;
    MORPHTARGETTEXTURE_HASTANGENTS: boolean;
    MORPHTARGETTEXTURE_HASUVS: boolean;
    MORPHTARGETTEXTURE_HASUV2S: boolean;
    MORPHTARGETTEXTURE_HASCOLORS: boolean;
    NUM_MORPH_INFLUENCERS: number;
    MORPHTARGETS_TEXTURE: boolean;
    USEPHYSICALLIGHTFALLOFF: boolean;
    USEGLTFLIGHTFALLOFF: boolean;
    TWOSIDEDLIGHTING: boolean;
    MIRRORED: boolean;
    SHADOWFLOAT: boolean;
    CLIPPLANE: boolean;
    CLIPPLANE2: boolean;
    CLIPPLANE3: boolean;
    CLIPPLANE4: boolean;
    CLIPPLANE5: boolean;
    CLIPPLANE6: boolean;
    POINTSIZE: boolean;
    FOG: boolean;
    LOGARITHMICDEPTH: boolean;
    CAMERA_ORTHOGRAPHIC: boolean;
    CAMERA_PERSPECTIVE: boolean;
    AREALIGHTSUPPORTED: boolean;
    FORCENORMALFORWARD: boolean;
    SPECULARAA: boolean;
    UNLIT: boolean;
    DECAL_AFTER_DETAIL: boolean;
    DEBUGMODE: number;
    CLUSTLIGHT_SLICES: number;
    CLUSTLIGHT_BATCH: number;
    BRDF_V_HEIGHT_CORRELATED: boolean;
    MS_BRDF_ENERGY_CONSERVATION: boolean;
    SPHERICAL_HARMONICS: boolean;
    SPECULAR_GLOSSINESS_ENERGY_CONSERVATION: boolean;
    MIX_IBL_RADIANCE_WITH_IRRADIANCE: boolean;
    LEGACY_SPECULAR_ENERGY_CONSERVATION: boolean;
    BASE_DIFFUSE_MODEL: number;
    DIELECTRIC_SPECULAR_MODEL: number;
    CONDUCTOR_SPECULAR_MODEL: number;
    /**
     * Initializes the PBR Material defines.
     * @param externalProperties The external properties
     */
    constructor(externalProperties?: {
        [name: string]: {
            type: string;
            default: any;
        };
    });
    /**
     * Resets the PBR Material defines.
     */
    reset(): void;
}
declare const OpenPBRMaterialBase_base: {
    new (...args: any[]): {
        _imageProcessingConfiguration: ImageProcessingConfiguration;
        imageProcessingConfiguration: ImageProcessingConfiguration;
        _imageProcessingObserver: Nullable<import("../../index.js").Observer<ImageProcessingConfiguration>>;
        _attachImageProcessingConfiguration(configuration: Nullable<ImageProcessingConfiguration>): void;
        cameraColorCurvesEnabled: boolean;
        cameraColorGradingEnabled: boolean;
        cameraToneMappingEnabled: boolean;
        cameraExposure: number;
        cameraContrast: number;
        cameraColorGradingTexture: Nullable<BaseTexture>;
        cameraColorCurves: Nullable<import("../index.js").ColorCurves>;
    };
} & typeof PushMaterial;
declare class OpenPBRMaterialBase extends OpenPBRMaterialBase_base {
}
/**
 * A Physically based material that follows the specification of OpenPBR.
 *
 * For more information, please refer to the documentation :
 * https://academysoftwarefoundation.github.io/OpenPBR/index.html
 */
export declare class OpenPBRMaterial extends OpenPBRMaterialBase {
    /**
     * Base Weight is a multiplier on the diffuse and metal lobes.
     * See OpenPBR's specs for base_weight
     */
    baseWeight: number;
    private _baseWeight;
    /**
     * Base Weight is a multiplier on the diffuse and metal lobes.
     * See OpenPBR's specs for base_weight
     */
    baseWeightTexture: Nullable<BaseTexture>;
    private _baseWeightTexture;
    /**
     * Color of the base diffuse lobe.
     * See OpenPBR's specs for base_color
     */
    baseColor: Color3;
    private _baseColor;
    /**
     * Base Color Texture property.
     * See OpenPBR's specs for base_color
     */
    baseColorTexture: Nullable<BaseTexture>;
    private _baseColorTexture;
    /**
     * Roughness of the diffuse lobe.
     * See OpenPBR's specs for base_diffuse_roughness
     */
    baseDiffuseRoughness: number;
    private _baseDiffuseRoughness;
    /**
     * Roughness texture of the diffuse lobe.
     * See OpenPBR's specs for base_diffuse_roughness
     */
    baseDiffuseRoughnessTexture: Nullable<BaseTexture>;
    private _baseDiffuseRoughnessTexture;
    /**
     * Metalness of the base lobe.
     * See OpenPBR's specs for base_metalness
     */
    baseMetalness: number;
    private _baseMetalness;
    /**
     * Metalness texture.
     * See OpenPBR's specs for base_metalness
     */
    baseMetalnessTexture: Nullable<BaseTexture>;
    private _baseMetalnessTexture;
    /**
     * Weight of the specular lobe.
     * See OpenPBR's specs for specular_weight
     */
    specularWeight: number;
    private _specularWeight;
    /**
     * Weight texture of the specular lobe.
     * See OpenPBR's specs for specular_weight
     */
    specularWeightTexture: Nullable<BaseTexture>;
    private _specularWeightTexture;
    /**
     * Color of the specular lobe.
     * See OpenPBR's specs for specular_color
     */
    specularColor: Color3;
    private _specularColor;
    /**
     * Specular Color Texture property.
     * See OpenPBR's specs for specular_color
     */
    specularColorTexture: Nullable<BaseTexture>;
    private _specularColorTexture;
    /**
     * Roughness of the specular lobe.
     * See OpenPBR's specs for specular_roughness
     */
    specularRoughness: number;
    private _specularRoughness;
    /**
     * Roughness texture of the specular lobe.
     * See OpenPBR's specs for specular_roughness
     */
    specularRoughnessTexture: Nullable<BaseTexture>;
    private _specularRoughnessTexture;
    /**
     * Anisotropic roughness of the specular lobe.
     * See OpenPBR's specs for specular_roughness_anisotropy
     */
    specularRoughnessAnisotropy: number;
    private _specularRoughnessAnisotropy;
    /**
     * Anisotropic Roughness texture.
     * See OpenPBR's specs for specular_roughness
     */
    specularRoughnessAnisotropyTexture: Nullable<BaseTexture>;
    private _specularRoughnessAnisotropyTexture;
    /**
     * IOR of the specular lobe.
     * See OpenPBR's specs for specular_ior
     */
    specularIor: number;
    private _specularIor;
    /**
     * Defines the amount of clear coat on the surface.
     * See OpenPBR's specs for coat_weight
     */
    coatWeight: number;
    private _coatWeight;
    /**
     * Coat weight texture.
     * See OpenPBR's specs for coat_weight
     */
    coatWeightTexture: Nullable<BaseTexture>;
    private _coatWeightTexture;
    /**
     * Defines the color of the clear coat on the surface.
     * See OpenPBR's specs for coat_color
     */
    coatColor: Color3;
    private _coatColor;
    /**
     * Color texture of the clear coat.
     * See OpenPBR's specs for coat_color
     */
    coatColorTexture: Nullable<BaseTexture>;
    private _coatColorTexture;
    /**
     * Defines the roughness of the clear coat on the surface.
     * See OpenPBR's specs for coat_roughness
     */
    coatRoughness: number;
    private _coatRoughness;
    /**
     * Roughness texture of the clear coat.
     * See OpenPBR's specs for coat_roughness
     */
    coatRoughnessTexture: Nullable<BaseTexture>;
    private _coatRoughnessTexture;
    /**
     * Defines the anisotropy of the clear coat on the surface.
     * See OpenPBR's specs for coat_roughness_anisotropy
     */
    coatRoughnessAnisotropy: number;
    private _coatRoughnessAnisotropy;
    /**
     * Anisotropic Roughness texture of the clear coat.
     * See OpenPBR's specs for coat_roughness_anisotropy
     */
    coatRoughnessAnisotropyTexture: Nullable<BaseTexture>;
    private _coatRoughnessAnisotropyTexture;
    /**
     * Defines the IOR of the clear coat on the surface.
     * See OpenPBR's specs for coat_ior
     */
    coatIor: number;
    private _coatIor;
    /**
     * Defines the amount that interreflections within the coat allow the underlying surface
     * to be darkened. A value of 1.0 means that the physically correct amount of darkening
     * is applied, while a value of 0.0 means that no darkening is applied.
     * See OpenPBR's specs for coat_darkening
     */
    coatDarkening: number;
    private _coatDarkening;
    /**
     * Defines the amount that interreflections within the coat allow the underlying surface
     * to be darkened. A value of 1.0 means that the physically correct amount of darkening
     * is applied, while a value of 0.0 means that no darkening is applied.
     * See OpenPBR's specs for coat_darkening
     */
    coatDarkeningTexture: Nullable<BaseTexture>;
    private _coatDarkeningTexture;
    /**
     * Specifies whether the coat roughness is taken from the
     * same texture as the coat_weight.
     */
    useCoatRoughnessFromWeightTexture: boolean;
    /**
     * Defines the normal of the material's geometry.
     * See OpenPBR's specs for geometry_normal
     */
    geometryNormalTexture: Nullable<BaseTexture>;
    private _geometryNormalTexture;
    /**
     * Defines the tangent of the material's geometry. Used only for anisotropic reflections.
     * See OpenPBR's specs for geometry_tangent
     */
    geometryTangent: Vector2;
    private _geometryTangent;
    /**
     * Defines the angle of the tangent of the material's geometry. Used only for anisotropic reflections.
     * See OpenPBR's specs for geometry_tangent
     */
    get geometryTangentAngle(): number;
    set geometryTangentAngle(value: number);
    /**
     * Defines the tangent of the material's geometry. Used only for anisotropic reflections.
     * See OpenPBR's specs for geometry_tangent
     */
    geometryTangentTexture: Nullable<BaseTexture>;
    private _geometryTangentTexture;
    /**
     * Defines the normal of the material's coat layer.
     * See OpenPBR's specs for geometry_coat_normal
     */
    geometryCoatNormalTexture: Nullable<BaseTexture>;
    private _geometryCoatNormalTexture;
    /**
     * Defines the tangent of the material's coat layer. Used only for anisotropic reflections.
     * See OpenPBR's specs for geometry_coat_tangent
     */
    geometryCoatTangent: Vector2;
    private _geometryCoatTangent;
    /**
     * Defines the angle of the tangent of the material's coat layer.
     */
    get geometryCoatTangentAngle(): number;
    /**
     * Defines the angle of the tangent of the material's coat layer.
     */
    set geometryCoatTangentAngle(value: number);
    /**
     * Defines the tangent of the material's coat layer. Used only for anisotropic reflections.
     * See OpenPBR's specs for geometry_coat_tangent
     */
    geometryCoatTangentTexture: Nullable<BaseTexture>;
    private _geometryCoatTangentTexture;
    /**
     * Defines the opacity of the material's geometry.
     * See OpenPBR's specs for geometry_opacity
     */
    geometryOpacity: number;
    private _geometryOpacity;
    /**
     * Defines the opacity texture of the material's geometry.
     * See OpenPBR's specs for geometry_opacity
     */
    geometryOpacityTexture: Nullable<BaseTexture>;
    private _geometryOpacityTexture;
    /**
     * Defines the luminance of the material's emission.
     * See OpenPBR's specs for emission_luminance
     */
    emissionLuminance: number;
    private _emissionLuminance;
    /**
     * Defines the color of the material's emission.
     * See OpenPBR's specs for emission_color
     */
    emissionColor: Color3;
    private _emissionColor;
    /**
     * Defines the texture of the material's emission color.
     * See OpenPBR's specs for emission_color
     */
    emissionColorTexture: Nullable<BaseTexture>;
    private _emissionColorTexture;
    /**
     * Defines the weight of the thin film layer on top of the base layer for iridescent effects.
     */
    thinFilmWeight: number;
    private _thinFilmWeight;
    /**
     * Thin film weight texture.
     */
    thinFilmWeightTexture: Nullable<BaseTexture>;
    private _thinFilmWeightTexture;
    /**
     * Defines the thickness of the thin film layer in μm. If a texture is provided for thinFilmWeightTexture,
     * this value will act as a multiplier to the texture values.
     * See OpenPBR's specs for thin_film_thickness
     */
    thinFilmThickness: number;
    private _thinFilmThickness;
    /**
     * Defines the minimum thickness of the thin film layer in μm.
     */
    thinFilmThicknessMin: number;
    private _thinFilmThicknessMin;
    /**
     * Defines the maximum thickness of the thin film layer in μm.
     */
    thinFilmThicknessTexture: Nullable<BaseTexture>;
    private _thinFilmThicknessTexture;
    /**
     * Defines the index of refraction of the thin film layer.
     */
    thinFilmIor: number;
    private _thinFilmIor;
    /**
     * Defines the ambient occlusion texture.
     */
    ambientOcclusionTexture: Nullable<BaseTexture>;
    private _ambientOcclusionTexture;
    private _propertyList;
    private _uniformsList;
    private _samplersList;
    private _samplerDefines;
    private static _noiseTextures;
    /**
     * Intensity of the direct lights e.g. the four lights available in your scene.
     * This impacts both the direct diffuse and specular highlights.
     */
    directIntensity: number;
    /**
     * Intensity of the environment e.g. how much the environment will light the object
     * either through harmonics for rough material or through the reflection for shiny ones.
     */
    environmentIntensity: number;
    /**
     * Specifies that the specular weight is stored in the alpha channel of the specular weight texture.
     */
    useSpecularWeightFromTextureAlpha: boolean;
    /**
     * Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
     */
    forceAlphaTest: boolean;
    /**
     * Defines the alpha limits in alpha test mode.
     */
    alphaCutOff: number;
    /**
     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
     */
    useAmbientOcclusionFromMetallicTextureRed: boolean;
    /**
     * Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
     */
    useAmbientInGrayScale: boolean;
    /**
     * BJS is using an hardcoded light falloff based on a manually sets up range.
     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
     */
    get usePhysicalLightFalloff(): boolean;
    /**
     * BJS is using an hardcoded light falloff based on a manually sets up range.
     * In PBR, one way to represents the falloff is to use the inverse squared root algorithm.
     * This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
     */
    set usePhysicalLightFalloff(value: boolean);
    /**
     * In order to support the falloff compatibility with gltf, a special mode has been added
     * to reproduce the gltf light falloff.
     */
    get useGLTFLightFalloff(): boolean;
    /**
     * In order to support the falloff compatibility with gltf, a special mode has been added
     * to reproduce the gltf light falloff.
     */
    set useGLTFLightFalloff(value: boolean);
    /**
     * Allows using an object space normal map (instead of tangent space).
     */
    useObjectSpaceNormalMap: boolean;
    /**
     * Allows using the normal map in parallax mode.
     */
    useParallax: boolean;
    /**
     * Allows using the normal map in parallax occlusion mode.
     */
    useParallaxOcclusion: boolean;
    /**
     * Controls the scale bias of the parallax mode.
     */
    parallaxScaleBias: number;
    /**
     * If sets to true, disables all the lights affecting the material.
     */
    disableLighting: boolean;
    /**
     * Force the shader to compute irradiance in the fragment shader in order to take normal mapping into account.
     */
    forceIrradianceInFragment: boolean;
    /**
     * Number of Simultaneous lights allowed on the material.
     */
    maxSimultaneousLights: number;
    /**
     * If sets to true, x component of normal map value will invert (x = 1.0 - x).
     */
    invertNormalMapX: boolean;
    /**
     * If sets to true, y component of normal map value will invert (y = 1.0 - y).
     */
    invertNormalMapY: boolean;
    /**
     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
     */
    twoSidedLighting: boolean;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
     */
    useAlphaFresnel: boolean;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
     */
    useLinearAlphaFresnel: boolean;
    /**
     * Let user defines the brdf lookup texture used for IBL.
     * A default 8bit version is embedded but you could point at :
     * * Default texture: https://assets.babylonjs.com/environments/correlatedMSBRDF_RGBD.png
     * * Default 16bit pixel depth texture: https://assets.babylonjs.com/environments/correlatedMSBRDF.dds
     * * LEGACY Default None correlated https://assets.babylonjs.com/environments/uncorrelatedBRDF_RGBD.png
     * * LEGACY Default None correlated 16bit pixel depth https://assets.babylonjs.com/environments/uncorrelatedBRDF.dds
     */
    environmentBRDFTexture: Nullable<BaseTexture>;
    /**
     * Force normal to face away from face.
     */
    forceNormalForward: boolean;
    /**
     * Enables specular anti aliasing in the PBR shader.
     * It will both interacts on the Geometry for analytical and IBL lighting.
     * It also prefilter the roughness map based on the normalmap values.
     */
    enableSpecularAntiAliasing: boolean;
    /**
     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
     * makes the reflect vector face the model (under horizon).
     */
    useHorizonOcclusion: boolean;
    /**
     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
     * too much the area relying on ambient texture to define their ambient occlusion.
     */
    useRadianceOcclusion: boolean;
    /**
     * If set to true, no lighting calculations will be applied.
     */
    unlit: boolean;
    /**
     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)
     */
    applyDecalMapAfterDetailMap: boolean;
    /**
     * Force all the PBR materials to compile to glsl even on WebGPU engines.
     * False by default. This is mostly meant for backward compatibility.
     */
    static ForceGLSL: boolean;
    /**
     * This stores the direct, emissive, environment, and specular light intensities into a Vector4.
     */
    private _lightingInfos;
    /**
     * Stores the radiance (and, possibly, irradiance) values in a texture.
     * @internal
     */
    _radianceTexture: Nullable<BaseTexture>;
    /**
     * Specifies that the specular weight will be read from the alpha channel.
     * This is for compatibility with glTF's KHR_materials_specular extension.
     * @internal
     */
    _useSpecularWeightFromAlpha: boolean;
    /**
     * Specifies that the specular weight will be read from the alpha channel of the specular color texture.
     * This is for compatibility with glTF's KHR_materials_specular extension.
     * @internal
     */
    _useSpecularWeightFromSpecularColorTexture: boolean;
    /**
     * Specifies if the material uses anisotropy weight read from the geometry tangent texture's blue channel.
     * This is for compatibility with glTF's anisotropy extension.
     * @internal
     */
    _useSpecularRoughnessAnisotropyFromTangentTexture: boolean;
    /**
     * Specifies if the material uses coat anisotropy weight read from the coat's geometry tangent texture's blue channel.
     * This is for compatibility with glTF's clearcoat_anisotropy extension.
     * @internal
     */
    _useCoatRoughnessAnisotropyFromTangentTexture: boolean;
    /**
     * Assume the anisotropy data is stored in the format specified by
     * KHR_materials_anisotropy.
     * @internal
     */
    _useGltfStyleAnisotropy: boolean;
    /**
     * This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
     * makes the reflect vector face the model (under horizon).
     * @internal
     */
    _useHorizonOcclusion: boolean;
    /**
     * This parameters will enable/disable radiance occlusion by preventing the radiance to lit
     * too much the area relying on ambient texture to define their ambient occlusion.
     * @internal
     */
    _useRadianceOcclusion: boolean;
    /**
     * Specifies that the alpha is coming from the base color texture's alpha channel.
     * This is for compatibility with glTF.
     * @internal
     */
    _useAlphaFromBaseColorTexture: boolean;
    /**
     * Specifies if the metallic texture contains the ambient occlusion information in its red channel.
     * This is for compatibility with glTF.
     * @internal
     */
    _useAmbientOcclusionFromMetallicTextureRed: boolean;
    /**
     * Specifies if the metallic texture contains the roughness information in its green channel.
     * This is for compatibility with glTF.
     * @internal
     */
    _useRoughnessFromMetallicTextureGreen: boolean;
    /**
     * Specifies if the metallic texture contains the metallic information in its blue channel.
     * This is for compatibility with glTF.
     * @internal
     */
    _useMetallicFromMetallicTextureBlue: boolean;
    /**
     * Specifies if the thin film thickness is stored in the green channel of the thin film thickness texture.
     */
    _useThinFilmThicknessFromTextureGreen: boolean;
    /**
     * Defines the  falloff type used in this material.
     * It by default is Physical.
     * @internal
     */
    _lightFalloff: number;
    /**
     * Allows using an object space normal map (instead of tangent space).
     * @internal
     */
    _useObjectSpaceNormalMap: boolean;
    /**
     * Allows using the normal map in parallax mode.
     * @internal
     */
    _useParallax: boolean;
    /**
     * Allows using the normal map in parallax occlusion mode.
     * @internal
     */
    _useParallaxOcclusion: boolean;
    /**
     * Controls the scale bias of the parallax mode.
     * @internal
     */
    _parallaxScaleBias: number;
    /**
     * If sets to true, disables all the lights affecting the material.
     * @internal
     */
    _disableLighting: boolean;
    /**
     * Number of Simultaneous lights allowed on the material.
     * @internal
     */
    _maxSimultaneousLights: number;
    /**
     * If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
     * @internal
     */
    _invertNormalMapX: boolean;
    /**
     * If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
     * @internal
     */
    _invertNormalMapY: boolean;
    /**
     * If sets to true and backfaceCulling is false, normals will be flipped on the backside.
     * @internal
     */
    _twoSidedLighting: boolean;
    /**
     * Defines the alpha limits in alpha test mode.
     * @internal
     */
    _alphaCutOff: number;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
     * @internal
     */
    _useAlphaFresnel: boolean;
    /**
     * A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
     * And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
     * @internal
     */
    _useLinearAlphaFresnel: boolean;
    /**
     * Specifies the environment BRDF texture used to compute the scale and offset roughness values
     * from cos theta and roughness:
     * http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
     * @internal
     */
    _environmentBRDFTexture: Nullable<BaseTexture>;
    /**
     * Force the shader to compute irradiance in the fragment shader in order to take normal mapping into account.
     * @internal
     */
    _forceIrradianceInFragment: boolean;
    private _realTimeFiltering;
    /**
     * Enables realtime filtering on the texture.
     */
    get realTimeFiltering(): boolean;
    set realTimeFiltering(b: boolean);
    private _realTimeFilteringQuality;
    /**
     * Quality switch for realtime filtering
     */
    get realTimeFilteringQuality(): number;
    set realTimeFilteringQuality(n: number);
    /**
     * Can this material render to several textures at once
     */
    get canRenderToMRT(): boolean;
    /**
     * Force normal to face away from face.
     * @internal
     */
    _forceNormalForward: boolean;
    /**
     * Enables specular anti aliasing in the PBR shader.
     * It will both interacts on the Geometry for analytical and IBL lighting.
     * It also prefilter the roughness map based on the normalmap values.
     * @internal
     */
    _enableSpecularAntiAliasing: boolean;
    /**
     * Stores the available render targets.
     */
    private _renderTargets;
    /**
     * If set to true, no lighting calculations will be applied.
     */
    private _unlit;
    /**
     * If sets to true, the decal map will be applied after the detail map. Else, it is applied before (default: false)
     */
    private _applyDecalMapAfterDetailMap;
    private _debugMode;
    private _shadersLoaded;
    private _breakShaderLoadedCheck;
    /**
     * @internal
     * This is reserved for the inspector.
     * Defines the material debug mode.
     * It helps seeing only some components of the material while troubleshooting.
     */
    debugMode: number;
    /**
     * @internal
     * This is reserved for the inspector.
     * Specify from where on screen the debug mode should start.
     * The value goes from -1 (full screen) to 1 (not visible)
     * It helps with side by side comparison against the final render
     * This defaults to -1
     */
    debugLimit: number;
    /**
     * @internal
     * This is reserved for the inspector.
     * As the default viewing range might not be enough (if the ambient is really small for instance)
     * You can use the factor to better multiply the final value.
     */
    debugFactor: number;
    /**
     * Defines additional PrePass parameters for the material.
     */
    readonly prePassConfiguration: PrePassConfiguration;
    protected _cacheHasRenderTargetTextures: boolean;
    /**
     * Instantiates a new OpenPBRMaterial instance.
     *
     * @param name The material name
     * @param scene The scene the material will be use in.
     * @param forceGLSL Use the GLSL code generation for the shader (even on WebGPU). Default is false
     */
    constructor(name: string, scene?: Scene, forceGLSL?: boolean);
    /**
     * Gets a boolean indicating that current material needs to register RTT
     */
    get hasRenderTargetTextures(): boolean;
    /**
     * Can this material render to prepass
     */
    get isPrePassCapable(): boolean;
    /**
     * @returns the name of the material class.
     */
    getClassName(): string;
    protected _transparencyMode: number;
    get transparencyMode(): number;
    set transparencyMode(value: number);
    /**
     * @returns whether or not the alpha value of the albedo texture should be used for alpha blending.
     */
    protected _shouldUseAlphaFromBaseColorTexture(): boolean;
    /**
     * @returns whether or not there is a usable alpha channel for transparency.
     */
    protected _hasAlphaChannel(): boolean;
    /**
     * Makes a duplicate of the current material.
     * @param name - name to use for the new material.
     * @param cloneTexturesOnlyOnce - if a texture is used in more than one channel (e.g baseColor and opacity), only clone it once and reuse it on the other channels. Default false.
     * @param rootUrl defines the root URL to use to load textures
     * @returns cloned material instance
     */
    clone(name: string, cloneTexturesOnlyOnce?: boolean, rootUrl?: string): OpenPBRMaterial;
    /**
     * Serializes this PBR Material.
     * @returns - An object with the serialized material.
     */
    serialize(): any;
    /**
     * Parses a PBR Material from a serialized object.
     * @param source - Serialized object.
     * @param scene - BJS scene instance.
     * @param rootUrl - url for the scene object
     * @returns - OpenPBRMaterial
     */
    static Parse(source: any, scene: Scene, rootUrl: string): OpenPBRMaterial;
    /**
     * Force shader compilation
     * @param mesh - Define the mesh we want to force the compilation for
     * @param onCompiled - Define a callback triggered when the compilation completes
     * @param options - Define the options used to create the compilation
     */
    forceCompilation(mesh: AbstractMesh, onCompiled?: (material: Material) => void, options?: Partial<IMaterialCompilationOptions>): void;
    /**
     * Specifies that the submesh is ready to be used.
     * @param mesh - BJS mesh.
     * @param subMesh - A submesh of the BJS mesh.  Used to check if it is ready.
     * @param useInstances - Specifies that instances should be used.
     * @returns - boolean indicating that the submesh is ready or not.
     */
    isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
    /**
     * Initializes the uniform buffer layout for the shader.
     */
    buildUniformLayout(): void;
    /**
     * Binds the submesh data.
     * @param world - The world matrix.
     * @param mesh - The BJS mesh.
     * @param subMesh - A submesh of the BJS mesh.
     */
    bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
    /**
     * Returns the animatable textures.
     * If material have animatable metallic texture, then reflectivity texture will not be returned, even if it has animations.
     * @returns - Array of animatable textures.
     */
    getAnimatables(): IAnimatable[];
    /**
     * Returns an array of the actively used textures.
     * @returns - Array of BaseTextures
     */
    getActiveTextures(): BaseTexture[];
    /**
     * Checks to see if a texture is used in the material.
     * @param texture - Base texture to use.
     * @returns - Boolean specifying if a texture is used in the material.
     */
    hasTexture(texture: BaseTexture): boolean;
    /**
     * Sets the required values to the prepass renderer.
     * It can't be sets when subsurface scattering of this material is disabled.
     * When scene have ability to enable subsurface prepass effect, it will enable.
     * @returns - If prepass is enabled or not.
     */
    setPrePassRenderer(): boolean;
    /**
     * Disposes the resources of the material.
     * @param forceDisposeEffect - Forces the disposal of effects.
     * @param forceDisposeTextures - Forces the disposal of all textures.
     */
    dispose(forceDisposeEffect?: boolean, forceDisposeTextures?: boolean): void;
    /**
     * Returns the texture used for reflections.
     * @returns - Reflection texture if present.  Otherwise, returns the environment texture.
     */
    private _getRadianceTexture;
    private _prepareEffect;
    private _prepareDefines;
}
export {};
